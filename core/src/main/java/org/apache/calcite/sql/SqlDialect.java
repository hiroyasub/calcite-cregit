begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|Casing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|Quoting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|NullCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Experimental
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeSystemImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|dialect
operator|.
name|JethroDataSqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|BasicSqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlConformance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlConformanceEnum
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Suppliers
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DatabaseMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|DateTimeStringUtils
operator|.
name|getDateFormatter
import|;
end_import

begin_comment
comment|/**  *<code>SqlDialect</code> encapsulates the differences between dialects of SQL.  *  *<p>It is used by classes such as {@link SqlWriter} and  * {@link org.apache.calcite.sql.util.SqlBuilder}.  *  *<p>To add a new {@link SqlDialect} sub-class, extends this class to hold 2 public final  * static member:  *<ul>  *<li>DEFAULT_CONTEXT: a default {@link Context} instance, which can be used to customize  *   or extending the dialect if the DEFAULT instance does not meet the requests</li>  *<li>DEFAULT: the default {@link SqlDialect} instance with context properties defined with  *<code>DEFAULT_CONTEXT</code></li>  *</ul>  */
end_comment

begin_class
specifier|public
class|class
name|SqlDialect
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|protected
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SqlDialect
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Empty context. */
specifier|public
specifier|static
specifier|final
name|Context
name|EMPTY_CONTEXT
init|=
name|emptyContext
argument_list|()
decl_stmt|;
comment|/** Built-in scalar functions and operators common for every dialect. */
specifier|protected
specifier|static
specifier|final
name|Set
argument_list|<
name|SqlOperator
argument_list|>
name|BUILT_IN_OPERATORS_LIST
init|=
name|ImmutableSet
operator|.
expr|<
name|SqlOperator
operator|>
name|builder
argument_list|()
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ABS
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ACOS
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ASIN
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|BETWEEN
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CEIL
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CHAR_LENGTH
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CHARACTER_LENGTH
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COALESCE
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CONCAT
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CBRT
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COS
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COT
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DIVIDE
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|FLOOR
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IN
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LIKE
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LN
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LOG10
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MOD
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_BETWEEN
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_IN
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_LIKE
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PI
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|POWER
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|RAND
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ROUND
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ROW
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SIN
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SQRT
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUBSTRING
argument_list|)
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|TAN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|protected
specifier|final
name|String
name|identifierQuoteString
decl_stmt|;
specifier|protected
specifier|final
name|String
name|identifierEndQuoteString
decl_stmt|;
specifier|protected
specifier|final
name|String
name|identifierEscapedQuote
decl_stmt|;
specifier|protected
specifier|final
name|String
name|literalQuoteString
decl_stmt|;
specifier|protected
specifier|final
name|String
name|literalEndQuoteString
decl_stmt|;
specifier|protected
specifier|final
name|String
name|literalEscapedQuote
decl_stmt|;
specifier|private
specifier|final
name|DatabaseProduct
name|databaseProduct
decl_stmt|;
specifier|protected
specifier|final
name|NullCollation
name|nullCollation
decl_stmt|;
specifier|private
specifier|final
name|RelDataTypeSystem
name|dataTypeSystem
decl_stmt|;
specifier|private
specifier|final
name|Casing
name|unquotedCasing
decl_stmt|;
specifier|private
specifier|final
name|Casing
name|quotedCasing
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|caseSensitive
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a<code>SqlDialect</code> from a DatabaseMetaData.    *    *<p>Does not maintain a reference to the DatabaseMetaData -- or, more    * importantly, to its {@link java.sql.Connection} -- after this call has    * returned.    *    * @param databaseMetaData used to determine which dialect of SQL to generate    *    * @deprecated Replaced by {@link SqlDialectFactory}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|SqlDialect
name|create
parameter_list|(
name|DatabaseMetaData
name|databaseMetaData
parameter_list|)
block|{
return|return
operator|new
name|SqlDialectFactoryImpl
argument_list|()
operator|.
name|create
argument_list|(
name|databaseMetaData
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|SqlDialect
parameter_list|(
name|DatabaseProduct
name|databaseProduct
parameter_list|,
name|String
name|databaseProductName
parameter_list|,
name|String
name|identifierQuoteString
parameter_list|)
block|{
name|this
argument_list|(
name|EMPTY_CONTEXT
operator|.
name|withDatabaseProduct
argument_list|(
name|databaseProduct
argument_list|)
operator|.
name|withDatabaseProductName
argument_list|(
name|databaseProductName
argument_list|)
operator|.
name|withIdentifierQuoteString
argument_list|(
name|identifierQuoteString
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a SqlDialect.    *    * @param databaseProduct       Database product; may be UNKNOWN, never null    * @param databaseProductName   Database product name from JDBC driver    * @param identifierQuoteString String to quote identifiers. Null if quoting    *                              is not supported. If "[", close quote is    *                              deemed to be "]".    * @param nullCollation         Whether NULL values appear first or last    *    * @deprecated Use {@link #SqlDialect(Context)}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|SqlDialect
parameter_list|(
name|DatabaseProduct
name|databaseProduct
parameter_list|,
name|String
name|databaseProductName
parameter_list|,
name|String
name|identifierQuoteString
parameter_list|,
name|NullCollation
name|nullCollation
parameter_list|)
block|{
name|this
argument_list|(
name|EMPTY_CONTEXT
operator|.
name|withDatabaseProduct
argument_list|(
name|databaseProduct
argument_list|)
operator|.
name|withDatabaseProductName
argument_list|(
name|databaseProductName
argument_list|)
operator|.
name|withIdentifierQuoteString
argument_list|(
name|identifierQuoteString
argument_list|)
operator|.
name|withNullCollation
argument_list|(
name|nullCollation
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a SqlDialect.    *    * @param context All the information necessary to create a dialect    */
specifier|public
name|SqlDialect
parameter_list|(
name|Context
name|context
parameter_list|)
block|{
name|this
operator|.
name|nullCollation
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|context
operator|.
name|nullCollation
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|dataTypeSystem
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|context
operator|.
name|dataTypeSystem
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|databaseProduct
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|context
operator|.
name|databaseProduct
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|literalQuoteString
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|context
operator|.
name|literalQuoteString
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|literalEndQuoteString
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|context
operator|.
name|literalQuoteString
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|literalEscapedQuote
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|context
operator|.
name|literalEscapedQuoteString
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|identifierQuoteString
init|=
name|context
operator|.
name|identifierQuoteString
argument_list|()
decl_stmt|;
if|if
condition|(
name|identifierQuoteString
operator|!=
literal|null
condition|)
block|{
name|identifierQuoteString
operator|=
name|identifierQuoteString
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|identifierQuoteString
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|identifierQuoteString
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|this
operator|.
name|identifierQuoteString
operator|=
name|identifierQuoteString
expr_stmt|;
name|this
operator|.
name|identifierEndQuoteString
operator|=
name|identifierQuoteString
operator|==
literal|null
condition|?
literal|null
else|:
name|identifierQuoteString
operator|.
name|equals
argument_list|(
literal|"["
argument_list|)
condition|?
literal|"]"
else|:
name|identifierQuoteString
expr_stmt|;
name|this
operator|.
name|identifierEscapedQuote
operator|=
name|identifierQuoteString
operator|==
literal|null
condition|?
literal|null
else|:
name|this
operator|.
name|identifierEndQuoteString
operator|+
name|this
operator|.
name|identifierEndQuoteString
expr_stmt|;
name|this
operator|.
name|unquotedCasing
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|context
operator|.
name|unquotedCasing
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|quotedCasing
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|context
operator|.
name|quotedCasing
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|caseSensitive
operator|=
name|context
operator|.
name|caseSensitive
argument_list|()
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/** Creates an empty context. Use {@link #EMPTY_CONTEXT} to reference the instance. */
specifier|private
specifier|static
name|Context
name|emptyContext
parameter_list|()
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|DatabaseProduct
operator|.
name|UNKNOWN
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|"'"
argument_list|,
literal|"''"
argument_list|,
literal|null
argument_list|,
name|Casing
operator|.
name|UNCHANGED
argument_list|,
name|Casing
operator|.
name|TO_UPPER
argument_list|,
literal|true
argument_list|,
name|SqlConformanceEnum
operator|.
name|DEFAULT
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|,
name|RelDataTypeSystemImpl
operator|.
name|DEFAULT
argument_list|,
name|JethroDataSqlDialect
operator|.
name|JethroInfo
operator|.
name|EMPTY
argument_list|)
return|;
block|}
comment|/**    * Converts a product name and version (per the JDBC driver) into a product    * enumeration.    *    * @param productName    Product name    * @param productVersion Product version    * @return database product    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|DatabaseProduct
name|getProduct
parameter_list|(
name|String
name|productName
parameter_list|,
name|String
name|productVersion
parameter_list|)
block|{
specifier|final
name|String
name|upperProductName
init|=
name|productName
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|upperProductName
condition|)
block|{
case|case
literal|"ACCESS"
case|:
return|return
name|DatabaseProduct
operator|.
name|ACCESS
return|;
case|case
literal|"APACHE DERBY"
case|:
return|return
name|DatabaseProduct
operator|.
name|DERBY
return|;
case|case
literal|"CLICKHOUSE"
case|:
return|return
name|DatabaseProduct
operator|.
name|CLICKHOUSE
return|;
case|case
literal|"DBMS:CLOUDSCAPE"
case|:
return|return
name|DatabaseProduct
operator|.
name|DERBY
return|;
case|case
literal|"HIVE"
case|:
return|return
name|DatabaseProduct
operator|.
name|HIVE
return|;
case|case
literal|"INGRES"
case|:
return|return
name|DatabaseProduct
operator|.
name|INGRES
return|;
case|case
literal|"INTERBASE"
case|:
return|return
name|DatabaseProduct
operator|.
name|INTERBASE
return|;
case|case
literal|"LUCIDDB"
case|:
return|return
name|DatabaseProduct
operator|.
name|LUCIDDB
return|;
case|case
literal|"ORACLE"
case|:
return|return
name|DatabaseProduct
operator|.
name|ORACLE
return|;
case|case
literal|"PHOENIX"
case|:
return|return
name|DatabaseProduct
operator|.
name|PHOENIX
return|;
case|case
literal|"PRESTO"
case|:
return|return
name|DatabaseProduct
operator|.
name|PRESTO
return|;
case|case
literal|"MYSQL (INFOBRIGHT)"
case|:
return|return
name|DatabaseProduct
operator|.
name|INFOBRIGHT
return|;
case|case
literal|"MYSQL"
case|:
return|return
name|DatabaseProduct
operator|.
name|MYSQL
return|;
case|case
literal|"REDSHIFT"
case|:
return|return
name|DatabaseProduct
operator|.
name|REDSHIFT
return|;
block|}
comment|// Now the fuzzy matches.
if|if
condition|(
name|productName
operator|.
name|startsWith
argument_list|(
literal|"DB2"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|DB2
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"FIREBIRD"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|FIREBIRD
return|;
block|}
if|else if
condition|(
name|productName
operator|.
name|startsWith
argument_list|(
literal|"Informix"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|INFORMIX
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"NETEZZA"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|NETEZZA
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"PARACCEL"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|PARACCEL
return|;
block|}
if|else if
condition|(
name|productName
operator|.
name|startsWith
argument_list|(
literal|"HP Neoview"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|NEOVIEW
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"POSTGRE"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|POSTGRESQL
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"SQL SERVER"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|MSSQL
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"SYBASE"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|SYBASE
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"TERADATA"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|TERADATA
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"HSQL"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|HSQLDB
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"H2"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|H2
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"VERTICA"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|VERTICA
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"GOOGLE BIGQUERY"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|BIG_QUERY
return|;
block|}
else|else
block|{
return|return
name|DatabaseProduct
operator|.
name|UNKNOWN
return|;
block|}
block|}
comment|/** Returns the type system implementation for this dialect. */
specifier|public
name|RelDataTypeSystem
name|getTypeSystem
parameter_list|()
block|{
return|return
name|dataTypeSystem
return|;
block|}
comment|/**    * Encloses an identifier in quotation marks appropriate for the current SQL    * dialect.    *    *<p>For example,<code>quoteIdentifier("emp")</code> yields a string    * containing<code>"emp"</code> in Oracle, and a string containing<code>    * [emp]</code> in Access.    *    * @param val Identifier to quote    * @return Quoted identifier    */
specifier|public
name|String
name|quoteIdentifier
parameter_list|(
name|String
name|val
parameter_list|)
block|{
return|return
name|quoteIdentifier
argument_list|(
operator|new
name|StringBuilder
argument_list|()
argument_list|,
name|val
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Encloses an identifier in quotation marks appropriate for the current SQL    * dialect, writing the result to a {@link StringBuilder}.    *    *<p>For example,<code>quoteIdentifier("emp")</code> yields a string    * containing<code>"emp"</code> in Oracle, and a string containing<code>    * [emp]</code> in Access.    *    * @param buf Buffer    * @param val Identifier to quote    * @return The buffer    */
specifier|public
name|StringBuilder
name|quoteIdentifier
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|String
name|val
parameter_list|)
block|{
if|if
condition|(
name|identifierQuoteString
operator|==
literal|null
comment|// quoting is not supported
operator|||
operator|!
name|identifierNeedsQuote
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
name|identifierQuoteString
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|val
operator|.
name|replace
argument_list|(
name|identifierEndQuoteString
argument_list|,
name|identifierEscapedQuote
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|identifierEndQuoteString
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
comment|/**    * Quotes a multi-part identifier.    *    * @param buf         Buffer    * @param identifiers List of parts of the identifier to quote    * @return The buffer    */
specifier|public
name|StringBuilder
name|quoteIdentifier
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|identifiers
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|identifier
range|:
name|identifiers
control|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
comment|/** Returns whether to quote an identifier.    * By default, all identifiers are quoted. */
specifier|protected
name|boolean
name|identifierNeedsQuote
parameter_list|(
name|String
name|val
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Converts a string into a string literal.    *    *<p>For example, {@code "can't run"} becomes {@code "'can''t run'"}.    */
specifier|public
specifier|final
name|String
name|quoteStringLiteral
parameter_list|(
name|String
name|val
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|quoteStringLiteral
argument_list|(
name|buf
argument_list|,
literal|null
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Appends a string literal to a buffer.    *    * @param buf Buffer    * @param charsetName Character set name, e.g. "utf16", or null    * @param val String value    */
specifier|public
name|void
name|quoteStringLiteral
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|String
name|charsetName
parameter_list|,
name|String
name|val
parameter_list|)
block|{
if|if
condition|(
name|containsNonAscii
argument_list|(
name|val
argument_list|)
operator|&&
name|charsetName
operator|==
literal|null
condition|)
block|{
name|quoteStringLiteralUnicode
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|charsetName
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|charsetName
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|literalQuoteString
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|val
operator|.
name|replace
argument_list|(
name|literalEndQuoteString
argument_list|,
name|literalEscapedQuote
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|literalEndQuoteString
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|unparseCall
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|ROW
case|:
comment|// Remove the ROW keyword if the dialect does not allow that.
if|if
condition|(
operator|!
name|getConformance
argument_list|()
operator|.
name|allowExplicitRowValueConstructor
argument_list|()
condition|)
block|{
comment|// Fix the syntax when there is no parentheses after VALUES keyword.
if|if
condition|(
operator|!
name|writer
operator|.
name|isAlwaysUseParentheses
argument_list|()
condition|)
block|{
name|writer
operator|.
name|print
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlWriter
operator|.
name|Frame
name|frame
init|=
name|writer
operator|.
name|isAlwaysUseParentheses
argument_list|()
condition|?
name|writer
operator|.
name|startList
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|FUN_CALL
argument_list|)
else|:
name|writer
operator|.
name|startList
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|FUN_CALL
argument_list|,
literal|"("
argument_list|,
literal|")"
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|writer
operator|.
name|sep
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|operand
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
name|leftPrec
argument_list|,
name|rightPrec
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|endList
argument_list|(
name|frame
argument_list|)
expr_stmt|;
break|break;
block|}
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
name|call
argument_list|,
name|leftPrec
argument_list|,
name|rightPrec
argument_list|)
expr_stmt|;
break|break;
default|default:
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
name|call
argument_list|,
name|leftPrec
argument_list|,
name|rightPrec
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|unparseDateTimeLiteral
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlAbstractDateTimeLiteral
name|literal
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
name|writer
operator|.
name|literal
argument_list|(
name|literal
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|unparseSqlDatetimeArithmetic
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|SqlKind
name|sqlKind
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
specifier|final
name|SqlWriter
operator|.
name|Frame
name|frame
init|=
name|writer
operator|.
name|startList
argument_list|(
literal|"("
argument_list|,
literal|")"
argument_list|)
decl_stmt|;
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
name|leftPrec
argument_list|,
name|rightPrec
argument_list|)
expr_stmt|;
name|writer
operator|.
name|sep
argument_list|(
operator|(
name|SqlKind
operator|.
name|PLUS
operator|==
name|sqlKind
operator|)
condition|?
literal|"+"
else|:
literal|"-"
argument_list|)
expr_stmt|;
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
name|leftPrec
argument_list|,
name|rightPrec
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|frame
argument_list|)
expr_stmt|;
comment|//Only two parameters are present normally
comment|//Checking parameter count to prevent errors
if|if
condition|(
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
name|call
operator|.
name|operand
argument_list|(
literal|2
argument_list|)
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
name|leftPrec
argument_list|,
name|rightPrec
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Converts an interval qualifier to a SQL string. The default implementation    * returns strings such as    *<code>INTERVAL '1 2:3:4' DAY(4) TO SECOND(4)</code>. */
specifier|public
name|void
name|unparseSqlIntervalQualifier
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlIntervalQualifier
name|qualifier
parameter_list|,
name|RelDataTypeSystem
name|typeSystem
parameter_list|)
block|{
specifier|final
name|String
name|start
init|=
name|qualifier
operator|.
name|timeUnitRange
operator|.
name|startUnit
operator|.
name|name
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fractionalSecondPrecision
init|=
name|qualifier
operator|.
name|getFractionalSecondPrecision
argument_list|(
name|typeSystem
argument_list|)
decl_stmt|;
specifier|final
name|int
name|startPrecision
init|=
name|qualifier
operator|.
name|getStartPrecision
argument_list|(
name|typeSystem
argument_list|)
decl_stmt|;
if|if
condition|(
name|qualifier
operator|.
name|timeUnitRange
operator|.
name|startUnit
operator|==
name|TimeUnit
operator|.
name|SECOND
condition|)
block|{
if|if
condition|(
operator|!
name|qualifier
operator|.
name|useDefaultFractionalSecondPrecision
argument_list|()
condition|)
block|{
specifier|final
name|SqlWriter
operator|.
name|Frame
name|frame
init|=
name|writer
operator|.
name|startFunCall
argument_list|(
name|start
argument_list|)
decl_stmt|;
name|writer
operator|.
name|print
argument_list|(
name|startPrecision
argument_list|)
expr_stmt|;
name|writer
operator|.
name|sep
argument_list|(
literal|","
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|writer
operator|.
name|print
argument_list|(
name|qualifier
operator|.
name|getFractionalSecondPrecision
argument_list|(
name|typeSystem
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|!
name|qualifier
operator|.
name|useDefaultStartPrecision
argument_list|()
condition|)
block|{
specifier|final
name|SqlWriter
operator|.
name|Frame
name|frame
init|=
name|writer
operator|.
name|startFunCall
argument_list|(
name|start
argument_list|)
decl_stmt|;
name|writer
operator|.
name|print
argument_list|(
name|startPrecision
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|keyword
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|qualifier
operator|.
name|useDefaultStartPrecision
argument_list|()
condition|)
block|{
specifier|final
name|SqlWriter
operator|.
name|Frame
name|frame
init|=
name|writer
operator|.
name|startFunCall
argument_list|(
name|start
argument_list|)
decl_stmt|;
name|writer
operator|.
name|print
argument_list|(
name|startPrecision
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|keyword
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|qualifier
operator|.
name|timeUnitRange
operator|.
name|endUnit
condition|)
block|{
name|writer
operator|.
name|keyword
argument_list|(
literal|"TO"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|end
init|=
name|qualifier
operator|.
name|timeUnitRange
operator|.
name|endUnit
operator|.
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|TimeUnit
operator|.
name|SECOND
operator|==
name|qualifier
operator|.
name|timeUnitRange
operator|.
name|endUnit
operator|)
operator|&&
operator|(
operator|!
name|qualifier
operator|.
name|useDefaultFractionalSecondPrecision
argument_list|()
operator|)
condition|)
block|{
specifier|final
name|SqlWriter
operator|.
name|Frame
name|frame
init|=
name|writer
operator|.
name|startFunCall
argument_list|(
name|end
argument_list|)
decl_stmt|;
name|writer
operator|.
name|print
argument_list|(
name|fractionalSecondPrecision
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|keyword
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Converts an interval literal to a SQL string. The default implementation    * returns strings such as    *<code>INTERVAL '1 2:3:4' DAY(4) TO SECOND(4)</code>. */
specifier|public
name|void
name|unparseSqlIntervalLiteral
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlIntervalLiteral
name|literal
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
name|SqlIntervalLiteral
operator|.
name|IntervalValue
name|interval
init|=
name|literal
operator|.
name|getValueAs
argument_list|(
name|SqlIntervalLiteral
operator|.
name|IntervalValue
operator|.
name|class
argument_list|)
decl_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"INTERVAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interval
operator|.
name|getSign
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|writer
operator|.
name|print
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|literal
argument_list|(
literal|"'"
operator|+
name|literal
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|unparseSqlIntervalQualifier
argument_list|(
name|writer
argument_list|,
name|interval
operator|.
name|getIntervalQualifier
argument_list|()
argument_list|,
name|RelDataTypeSystem
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns whether the string contains any characters outside the    * comfortable 7-bit ASCII range (32 through 127, plus linefeed (10) and    * carriage return (13)).    *    *<p>Such characters can be used unquoted in SQL character literals.    *    * @param s String    * @return Whether string contains any non-7-bit-ASCII characters    */
specifier|protected
specifier|static
name|boolean
name|containsNonAscii
parameter_list|(
name|String
name|s
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|32
operator|&&
name|c
operator|!=
literal|10
operator|&&
name|c
operator|!=
literal|13
operator|||
name|c
operator|>=
literal|128
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Converts a string into a unicode string literal. For example,    *<code>can't{tab}run\</code> becomes<code>u'can''t\0009run\\'</code>.    */
specifier|public
name|void
name|quoteStringLiteralUnicode
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|String
name|val
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"u&'"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|val
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|val
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|32
operator|||
name|c
operator|>=
literal|128
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|HEXITS
index|[
operator|(
name|c
operator|>>
literal|12
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|HEXITS
index|[
operator|(
name|c
operator|>>
literal|8
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|HEXITS
index|[
operator|(
name|c
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|HEXITS
index|[
name|c
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'\\'
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|HEXITS
init|=
block|{
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,   }
decl_stmt|;
comment|/**    * Converts a string literal back into a string. For example,<code>'can''t    * run'</code> becomes<code>can't run</code>.    */
specifier|public
name|String
name|unquoteStringLiteral
parameter_list|(
name|String
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|!=
literal|null
operator|&&
name|val
operator|.
name|startsWith
argument_list|(
name|literalQuoteString
argument_list|)
operator|&&
name|val
operator|.
name|endsWith
argument_list|(
name|literalEndQuoteString
argument_list|)
condition|)
block|{
specifier|final
name|String
name|stripped
init|=
name|val
operator|.
name|substring
argument_list|(
name|literalQuoteString
operator|.
name|length
argument_list|()
argument_list|,
name|val
operator|.
name|length
argument_list|()
operator|-
name|literalEndQuoteString
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|stripped
operator|.
name|replace
argument_list|(
name|literalEscapedQuote
argument_list|,
name|literalEndQuoteString
argument_list|)
return|;
block|}
return|return
name|val
return|;
block|}
specifier|protected
name|boolean
name|allowsAs
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|// -- behaviors --
comment|/** Whether a sub-query in the FROM clause must have an alias.    *    *<p>For example, in PostgreSQL, this query is legal:    *    *<blockquote>{@code SELECT * FROM (SELECT * FROM Emp) As e}</blockquote>    *    *<p>but remove the alias {@code e} and it is not:    *    *<blockquote>{@code SELECT * FROM (SELECT * FROM Emp)}</blockquote>    *    *<p>In Oracle, both queries are legal.    */
specifier|public
name|boolean
name|requiresAliasForFromItems
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/** Returns whether a qualified table in the FROM clause has an implicit alias    * which consists of just the table name.    *    *<p>For example, in {@link DatabaseProduct#ORACLE}    *    *<blockquote>SELECT * FROM sales.emp</blockquote>    *    *<p>is equivalent to    *    *<blockquote>SELECT * FROM sales.emp AS emp</blockquote>    *    *<p>and therefore    *    *<blockquote>SELECT emp.empno FROM sales.emp</blockquote>    *    *<p>is valid. But {@link DatabaseProduct#DB2} does not have an implicit    * alias, so the previous query it not valid; you need to write    *    *<blockquote>SELECT sales.emp.empno FROM sales.emp</blockquote>    *    *<p>Returns true for all databases except DB2.    */
specifier|public
name|boolean
name|hasImplicitTableAlias
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Converts a timestamp to a SQL timestamp literal, e.g.    * {@code TIMESTAMP '2009-12-17 12:34:56'}.    *    *<p>Timestamp values do not have a time zone. We therefore interpret them    * as the number of milliseconds after the UTC epoch, and the formatted    * value is that time in UTC.    *    *<p>In particular,    *    *<blockquote><code>quoteTimestampLiteral(new Timestamp(0));</code>    *</blockquote>    *    *<p>returns {@code TIMESTAMP '1970-01-01 00:00:00'}, regardless of the JVM's    * time zone.    *    * @param timestamp Timestamp    * @return SQL timestamp literal    */
specifier|public
name|String
name|quoteTimestampLiteral
parameter_list|(
name|Timestamp
name|timestamp
parameter_list|)
block|{
specifier|final
name|SimpleDateFormat
name|format
init|=
name|getDateFormatter
argument_list|(
literal|"'TIMESTAMP' ''yyyy-MM-DD HH:mm:SS''"
argument_list|)
decl_stmt|;
return|return
name|format
operator|.
name|format
argument_list|(
name|timestamp
argument_list|)
return|;
block|}
comment|/**    * Returns the database this dialect belongs to,    * {@link SqlDialect.DatabaseProduct#UNKNOWN} if not known, never null.    *    *<p>Please be judicious in how you use this method. If you wish to determine    * whether a dialect has a particular capability or behavior, it is usually    * better to add a method to SqlDialect and override that method in particular    * sub-classes of SqlDialect.    *    * @return Database product    * @deprecated To be removed without replacement    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|DatabaseProduct
name|getDatabaseProduct
parameter_list|()
block|{
return|return
name|databaseProduct
return|;
block|}
comment|/**    * Returns whether the dialect supports character set names as part of a    * data type, for instance {@code VARCHAR(30) CHARACTER SET `ISO-8859-1`}.    */
specifier|public
name|boolean
name|supportsCharSet
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|supportsAggregateFunction
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|COUNT
case|:
case|case
name|SUM
case|:
case|case
name|SUM0
case|:
case|case
name|MIN
case|:
case|case
name|MAX
case|:
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Returns whether this dialect supports window functions (OVER clause). */
specifier|public
name|boolean
name|supportsWindowFunctions
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/** Returns whether this dialect supports a given function or operator.    * It only applies to built-in scalar functions and operators, since    * user-defined functions and procedures should be read by JdbcSchema. */
specifier|public
name|boolean
name|supportsFunction
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|paramTypes
parameter_list|)
block|{
switch|switch
condition|(
name|operator
operator|.
name|kind
condition|)
block|{
case|case
name|AND
case|:
case|case
name|BETWEEN
case|:
case|case
name|CASE
case|:
case|case
name|CAST
case|:
case|case
name|CEIL
case|:
case|case
name|COALESCE
case|:
case|case
name|DIVIDE
case|:
case|case
name|EQUALS
case|:
case|case
name|FLOOR
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|IN
case|:
case|case
name|IS_NULL
case|:
case|case
name|IS_NOT_NULL
case|:
case|case
name|LESS_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
case|case
name|MINUS
case|:
case|case
name|MOD
case|:
case|case
name|NOT
case|:
case|case
name|NOT_IN
case|:
case|case
name|NOT_EQUALS
case|:
case|case
name|NVL
case|:
case|case
name|OR
case|:
case|case
name|PLUS
case|:
case|case
name|ROW
case|:
case|case
name|TIMES
case|:
return|return
literal|true
return|;
default|default:
return|return
name|BUILT_IN_OPERATORS_LIST
operator|.
name|contains
argument_list|(
name|operator
argument_list|)
return|;
block|}
block|}
specifier|public
name|CalendarPolicy
name|getCalendarPolicy
parameter_list|()
block|{
return|return
name|CalendarPolicy
operator|.
name|NULL
return|;
block|}
comment|/** Returns whether this dialect supports a given type. */
specifier|public
name|boolean
name|supportsDataType
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
comment|/** Returns SqlNode for type in "cast(column as type)", which might be   * different between databases by type name, precision etc.   *   *<p>If this method returns null, the cast will be omitted. In the default   * implementation, this is the case for the NULL type, and therefore   * {@code CAST(NULL AS<nulltype>)} is rendered as {@code NULL}. */
specifier|public
name|SqlNode
name|getCastSpec
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|BasicSqlType
condition|)
block|{
name|int
name|maxPrecision
init|=
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|NULL
case|:
return|return
literal|null
return|;
case|case
name|VARCHAR
case|:
comment|// if needed, adjust varchar length to max length supported by the system
name|maxPrecision
operator|=
name|getTypeSystem
argument_list|()
operator|.
name|getMaxPrecision
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|charSet
init|=
name|type
operator|.
name|getCharset
argument_list|()
operator|!=
literal|null
operator|&&
name|supportsCharSet
argument_list|()
condition|?
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|name
argument_list|()
else|:
literal|null
decl_stmt|;
return|return
name|SqlTypeUtil
operator|.
name|convertTypeToSpec
argument_list|(
name|type
argument_list|,
name|charSet
argument_list|,
name|maxPrecision
argument_list|)
return|;
block|}
return|return
name|SqlTypeUtil
operator|.
name|convertTypeToSpec
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/** Rewrite SINGLE_VALUE into expression based on database variants    *  E.g. HSQLDB, MYSQL, ORACLE, etc    */
specifier|public
name|SqlNode
name|rewriteSingleValueExpr
parameter_list|(
name|SqlNode
name|aggCall
parameter_list|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"SINGLE_VALUE rewrite not supported for {}"
argument_list|,
name|databaseProduct
argument_list|)
expr_stmt|;
return|return
name|aggCall
return|;
block|}
comment|/**    * Returns the SqlNode for emulating the null direction for the given field    * or<code>null</code> if no emulation needs to be done.    *    * @param node The SqlNode representing the expression    * @param nullsFirst Whether nulls should come first    * @param desc Whether the sort direction is    * {@link org.apache.calcite.rel.RelFieldCollation.Direction#DESCENDING} or    * {@link org.apache.calcite.rel.RelFieldCollation.Direction#STRICTLY_DESCENDING}    * @return A SqlNode for null direction emulation or<code>null</code> if not required    */
specifier|public
name|SqlNode
name|emulateNullDirection
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|boolean
name|nullsFirst
parameter_list|,
name|boolean
name|desc
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|JoinType
name|emulateJoinTypeForCrossJoin
parameter_list|()
block|{
return|return
name|JoinType
operator|.
name|COMMA
return|;
block|}
specifier|protected
name|SqlNode
name|emulateNullDirectionWithIsNull
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|boolean
name|nullsFirst
parameter_list|,
name|boolean
name|desc
parameter_list|)
block|{
comment|// No need for emulation if the nulls will anyways come out the way we want
comment|// them based on "nullsFirst" and "desc".
if|if
condition|(
name|nullCollation
operator|.
name|isDefaultOrder
argument_list|(
name|nullsFirst
argument_list|,
name|desc
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|IS_NULL
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|nullsFirst
condition|)
block|{
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|DESC
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
comment|/**    * Returns whether the dialect supports OFFSET/FETCH clauses    * introduced by SQL:2008, for instance    * {@code OFFSET 10 ROWS FETCH NEXT 20 ROWS ONLY}.    * If false, we assume that the dialect supports the alternative syntax    * {@code LIMIT 20 OFFSET 10}.    *    * @deprecated This method is no longer used. To change how the dialect    * unparses offset/fetch, override the {@link #unparseOffsetFetch} method.    */
annotation|@
name|Deprecated
specifier|public
name|boolean
name|supportsOffsetFetch
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Converts an offset and fetch into SQL.    *    *<p>At least one of {@code offset} and {@code fetch} must be provided.    *    *<p>Common options:    *<ul>    *<li>{@code OFFSET offset ROWS FETCH NEXT fetch ROWS ONLY}    *   (ANSI standard SQL, Oracle, PostgreSQL, and the default)    *<li>{@code LIMIT fetch OFFSET offset} (Apache Hive, MySQL, Redshift)    *</ul>    *    * @param writer Writer    * @param offset Number of rows to skip before emitting, or null    * @param fetch Number of rows to fetch, or null    *    * @see #unparseFetchUsingAnsi(SqlWriter, SqlNode, SqlNode)    * @see #unparseFetchUsingLimit(SqlWriter, SqlNode, SqlNode)    */
specifier|public
name|void
name|unparseOffsetFetch
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlNode
name|offset
parameter_list|,
name|SqlNode
name|fetch
parameter_list|)
block|{
name|unparseFetchUsingAnsi
argument_list|(
name|writer
argument_list|,
name|offset
argument_list|,
name|fetch
argument_list|)
expr_stmt|;
block|}
comment|/**    * Converts a fetch into a "SELECT TOP(fetch)".    *    *<p>A dialect that uses "TOP" syntax should override this method to print    * "TOP(fetch)", and override {@link #unparseOffsetFetch} to no-op.    *    *<p>The default implementation of this method is no-op.    *    * @param writer Writer    * @param offset Number of rows to skip before emitting, or null    * @param fetch Number of rows to fetch, or null    */
specifier|public
name|void
name|unparseTopN
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlNode
name|offset
parameter_list|,
name|SqlNode
name|fetch
parameter_list|)
block|{
block|}
comment|/** Unparses offset/fetch using ANSI standard "OFFSET offset ROWS FETCH NEXT    * fetch ROWS ONLY" syntax. */
specifier|protected
specifier|final
name|void
name|unparseFetchUsingAnsi
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlNode
name|offset
parameter_list|,
name|SqlNode
name|fetch
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|fetch
operator|!=
literal|null
operator|||
name|offset
operator|!=
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|newlineAndIndent
argument_list|()
expr_stmt|;
specifier|final
name|SqlWriter
operator|.
name|Frame
name|offsetFrame
init|=
name|writer
operator|.
name|startList
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|OFFSET
argument_list|)
decl_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"OFFSET"
argument_list|)
expr_stmt|;
name|offset
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"ROWS"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|offsetFrame
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fetch
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|newlineAndIndent
argument_list|()
expr_stmt|;
specifier|final
name|SqlWriter
operator|.
name|Frame
name|fetchFrame
init|=
name|writer
operator|.
name|startList
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|FETCH
argument_list|)
decl_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"FETCH"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"NEXT"
argument_list|)
expr_stmt|;
name|fetch
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"ROWS"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"ONLY"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|fetchFrame
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Unparses offset/fetch using "LIMIT fetch OFFSET offset" syntax. */
specifier|protected
specifier|final
name|void
name|unparseFetchUsingLimit
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlNode
name|offset
parameter_list|,
name|SqlNode
name|fetch
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|fetch
operator|!=
literal|null
operator|||
name|offset
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|unparseLimit
argument_list|(
name|writer
argument_list|,
name|fetch
argument_list|)
expr_stmt|;
name|unparseOffset
argument_list|(
name|writer
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|final
name|void
name|unparseLimit
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlNode
name|fetch
parameter_list|)
block|{
if|if
condition|(
name|fetch
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|newlineAndIndent
argument_list|()
expr_stmt|;
specifier|final
name|SqlWriter
operator|.
name|Frame
name|fetchFrame
init|=
name|writer
operator|.
name|startList
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|FETCH
argument_list|)
decl_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"LIMIT"
argument_list|)
expr_stmt|;
name|fetch
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|fetchFrame
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
specifier|final
name|void
name|unparseOffset
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlNode
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|newlineAndIndent
argument_list|()
expr_stmt|;
specifier|final
name|SqlWriter
operator|.
name|Frame
name|offsetFrame
init|=
name|writer
operator|.
name|startList
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|OFFSET
argument_list|)
decl_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"OFFSET"
argument_list|)
expr_stmt|;
name|offset
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|offsetFrame
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns whether the dialect supports nested aggregations, for instance    * {@code SELECT SUM(SUM(1)) }.    */
specifier|public
name|boolean
name|supportsNestedAggregations
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether this dialect supports "WITH ROLLUP" in the "GROUP BY"    * clause.    *    *<p>For instance, in MySQL version 5,    *    *<blockquote>    *<code>    *     SELECT deptno, job, COUNT(*) AS c    *     FROM emp    *     GROUP BY deptno, job WITH ROLLUP    *</code>    *</blockquote>    *    *<p>is equivalent to standard SQL    *    *<blockquote>    *<code>    *     SELECT deptno, job, COUNT(*) AS c    *     FROM emp    *     GROUP BY ROLLUP(deptno, job)    *     ORDER BY deptno, job    *</code>    *</blockquote>    *    *<p>The "WITH ROLLUP" clause was introduced in MySQL and is not standard    * SQL.    *    *<p>See also {@link #supportsAggregateFunction(SqlKind)} applied to    * {@link SqlKind#ROLLUP}, which returns true in MySQL 8 and higher.    */
specifier|public
name|boolean
name|supportsGroupByWithRollup
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether this dialect supports "WITH CUBE" in "GROUP BY" clause.    */
specifier|public
name|boolean
name|supportsGroupByWithCube
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/** Returns how NULL values are sorted if an ORDER BY item does not contain    * NULLS ASCENDING or NULLS DESCENDING. */
specifier|public
name|NullCollation
name|getNullCollation
parameter_list|()
block|{
return|return
name|nullCollation
return|;
block|}
comment|/** Returns whether NULL values are sorted first or last, in this dialect,    * in an ORDER BY item of a given direction. */
specifier|public
annotation|@
name|Nonnull
name|RelFieldCollation
operator|.
name|NullDirection
name|defaultNullDirection
parameter_list|(
name|RelFieldCollation
operator|.
name|Direction
name|direction
parameter_list|)
block|{
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|ASCENDING
case|:
case|case
name|STRICTLY_ASCENDING
case|:
return|return
name|getNullCollation
argument_list|()
operator|.
name|last
argument_list|(
literal|false
argument_list|)
condition|?
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
else|:
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
return|;
case|case
name|DESCENDING
case|:
case|case
name|STRICTLY_DESCENDING
case|:
return|return
name|getNullCollation
argument_list|()
operator|.
name|last
argument_list|(
literal|true
argument_list|)
condition|?
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
else|:
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
return|;
default|default:
return|return
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
return|;
block|}
block|}
comment|/**    * Returns whether the dialect supports VALUES in a sub-query with    * and an "AS t(column, ...)" values to define column names.    *    *<p>Currently, only Oracle does not. For this, we generate "SELECT v0 AS c0,    * v1 AS c1 ... UNION ALL ...". We may need to refactor this method when we    * support VALUES for other dialects. */
annotation|@
name|Experimental
specifier|public
name|boolean
name|supportsAliasedValues
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether the dialect supports implicit type coercion.    *    *<p>Most of the sql dialects support implicit type coercion, so we make this method    * default return true. For instance, "cast('10' as integer)&gt; 5"    * can be simplified to "'10'&gt; 5" if the dialect supports implicit type coercion    * for VARCHAR and INTEGER comparison.    *    *<p>For sql dialect that does not support implicit type coercion, such as the BigQuery,    * we can not convert '10' into INT64 implicitly.    *    *<p>Now this method is used for some auxiliary decision when translating some {@link RexCall}s,    * see SqlImplementor#stripCastFromString for details.    *    * @param call the call to make decision    */
specifier|public
name|boolean
name|supportsImplicitTypeCoercion
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
specifier|final
name|RexNode
name|operand0
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|operand0
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
comment|/** Returns the name of the system table that has precisely one row.    * If there is no such table, returns null, and we will generate SELECT with    * no FROM clause.    *    *<p>For {@code VALUES 1},    * Oracle returns ["DUAL"] and we generate "SELECT 1 FROM DUAL";    * MySQL returns null and we generate "SELECT 1".    */
annotation|@
name|Experimental
specifier|public
annotation|@
name|Nullable
name|List
argument_list|<
name|String
argument_list|>
name|getSingleRowTableName
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Copies settings from this dialect into a parser configuration.    *    *<p>{@code SqlDialect}, {@link SqlParser.Config} and {@link SqlConformance}    * cover different aspects of the same thing - the dialect of SQL spoken by a    * database - and this method helps to bridge between them. (The aspects are,    * respectively, generating SQL to send to a source database, parsing SQL    * sent to Calcite, and validating queries sent to Calcite. It makes sense to    * keep them as separate interfaces because they are used by different    * modules.)    *    *<p>The settings copied may differ among dialects, and may change over time,    * but currently include the following:    *    *<ul>    *<li>{@link #getQuoting()}    *<li>{@link #getQuotedCasing()}    *<li>{@link #getUnquotedCasing()}    *<li>{@link #isCaseSensitive()}    *<li>{@link #getConformance()}    *</ul>    *    * @param config Parser configuration builder    *    * @return The configuration builder    */
specifier|public
annotation|@
name|Nonnull
name|SqlParser
operator|.
name|Config
name|configureParser
parameter_list|(
name|SqlParser
operator|.
name|Config
name|config
parameter_list|)
block|{
specifier|final
name|Quoting
name|quoting
init|=
name|getQuoting
argument_list|()
decl_stmt|;
if|if
condition|(
name|quoting
operator|!=
literal|null
condition|)
block|{
name|config
operator|=
name|config
operator|.
name|withQuoting
argument_list|(
name|quoting
argument_list|)
expr_stmt|;
block|}
return|return
name|config
operator|.
name|withQuotedCasing
argument_list|(
name|getQuotedCasing
argument_list|()
argument_list|)
operator|.
name|withUnquotedCasing
argument_list|(
name|getUnquotedCasing
argument_list|()
argument_list|)
operator|.
name|withCaseSensitive
argument_list|(
name|isCaseSensitive
argument_list|()
argument_list|)
operator|.
name|withConformance
argument_list|(
name|getConformance
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
annotation|@
name|Nonnull
name|SqlParser
operator|.
name|ConfigBuilder
name|configureParser
parameter_list|(
name|SqlParser
operator|.
name|ConfigBuilder
name|configBuilder
parameter_list|)
block|{
return|return
name|SqlParser
operator|.
name|configBuilder
argument_list|(
name|configureParser
argument_list|(
name|configBuilder
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns the {@link SqlConformance} that matches this dialect.    *    *<p>The base implementation returns its best guess, based upon    * {@link #databaseProduct}; sub-classes may override. */
annotation|@
name|Nonnull
specifier|public
name|SqlConformance
name|getConformance
parameter_list|()
block|{
switch|switch
condition|(
name|databaseProduct
condition|)
block|{
case|case
name|UNKNOWN
case|:
case|case
name|CALCITE
case|:
return|return
name|SqlConformanceEnum
operator|.
name|DEFAULT
return|;
case|case
name|BIG_QUERY
case|:
return|return
name|SqlConformanceEnum
operator|.
name|BIG_QUERY
return|;
case|case
name|MYSQL
case|:
return|return
name|SqlConformanceEnum
operator|.
name|MYSQL_5
return|;
case|case
name|ORACLE
case|:
return|return
name|SqlConformanceEnum
operator|.
name|ORACLE_10
return|;
case|case
name|MSSQL
case|:
return|return
name|SqlConformanceEnum
operator|.
name|SQL_SERVER_2008
return|;
default|default:
return|return
name|SqlConformanceEnum
operator|.
name|PRAGMATIC_2003
return|;
block|}
block|}
comment|/** Returns the quoting scheme, or null if the combination of    * {@link #identifierQuoteString} and {@link #identifierEndQuoteString}    * does not correspond to any known quoting scheme. */
specifier|protected
name|Quoting
name|getQuoting
parameter_list|()
block|{
if|if
condition|(
literal|"\""
operator|.
name|equals
argument_list|(
name|identifierQuoteString
argument_list|)
operator|&&
literal|"\""
operator|.
name|equals
argument_list|(
name|identifierEndQuoteString
argument_list|)
condition|)
block|{
return|return
name|Quoting
operator|.
name|DOUBLE_QUOTE
return|;
block|}
if|else if
condition|(
literal|"`"
operator|.
name|equals
argument_list|(
name|identifierQuoteString
argument_list|)
operator|&&
literal|"`"
operator|.
name|equals
argument_list|(
name|identifierEndQuoteString
argument_list|)
condition|)
block|{
return|return
name|Quoting
operator|.
name|BACK_TICK
return|;
block|}
if|else if
condition|(
literal|"["
operator|.
name|equals
argument_list|(
name|identifierQuoteString
argument_list|)
operator|&&
literal|"]"
operator|.
name|equals
argument_list|(
name|identifierEndQuoteString
argument_list|)
condition|)
block|{
return|return
name|Quoting
operator|.
name|BRACKET
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** Returns how unquoted identifiers are stored. */
specifier|public
name|Casing
name|getUnquotedCasing
parameter_list|()
block|{
return|return
name|unquotedCasing
return|;
block|}
comment|/** Returns how quoted identifiers are stored. */
specifier|public
name|Casing
name|getQuotedCasing
parameter_list|()
block|{
return|return
name|quotedCasing
return|;
block|}
comment|/** Returns whether matching of identifiers is case-sensitive. */
specifier|public
name|boolean
name|isCaseSensitive
parameter_list|()
block|{
return|return
name|caseSensitive
return|;
block|}
comment|/**    * A few utility functions copied from org.apache.calcite.util.Util. We have    * copied them because we wish to keep SqlDialect's dependencies to a    * minimum.    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
class|class
name|FakeUtil
block|{
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|(
name|Throwable
name|e
parameter_list|,
name|String
name|s
parameter_list|)
block|{
name|String
name|message
init|=
literal|"Internal error: \u0000"
operator|+
name|s
decl_stmt|;
name|AssertionError
name|ae
init|=
operator|new
name|AssertionError
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|ae
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|ae
return|;
block|}
comment|/**      * Replaces every occurrence of<code>find</code> in<code>s</code> with      *<code>replace</code>.      */
specifier|public
specifier|static
name|String
name|replace
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|find
parameter_list|,
name|String
name|replace
parameter_list|)
block|{
comment|// let's be optimistic
name|int
name|found
init|=
name|s
operator|.
name|indexOf
argument_list|(
name|find
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|s
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|s
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
name|start
operator|<
name|found
condition|;
name|start
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
name|replace
argument_list|)
expr_stmt|;
name|start
operator|+=
name|find
operator|.
name|length
argument_list|()
expr_stmt|;
name|found
operator|=
name|s
operator|.
name|indexOf
argument_list|(
name|find
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
operator|-
literal|1
condition|)
block|{
name|found
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Whether this JDBC driver needs you to pass a Calendar object to methods    * such as {@link ResultSet#getTimestamp(int, java.util.Calendar)}. */
specifier|public
enum|enum
name|CalendarPolicy
block|{
name|NONE
block|,
name|NULL
block|,
name|LOCAL
block|,
name|DIRECT
block|,
name|SHIFT
block|;   }
comment|/**    * Rough list of flavors of database.    *    *<p>These values cannot help you distinguish between features that exist    * in different versions or ports of a database, but they are sufficient    * to drive a {@code switch} statement if behavior is broadly different    * between say, MySQL and Oracle.    *    *<p>If possible, you should not refer to particular database at all; write    * extend the dialect to describe the particular capability, for example,    * whether the database allows expressions to appear in the GROUP BY clause.    */
specifier|public
enum|enum
name|DatabaseProduct
block|{
name|ACCESS
argument_list|(
literal|"Access"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|BIG_QUERY
argument_list|(
literal|"Google BigQuery"
argument_list|,
literal|"`"
argument_list|,
name|NullCollation
operator|.
name|LOW
argument_list|)
block|,
name|CALCITE
argument_list|(
literal|"Apache Calcite"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|CLICKHOUSE
argument_list|(
literal|"ClickHouse"
argument_list|,
literal|"`"
argument_list|,
name|NullCollation
operator|.
name|LOW
argument_list|)
block|,
name|MSSQL
argument_list|(
literal|"Microsoft SQL Server"
argument_list|,
literal|"["
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|MYSQL
argument_list|(
literal|"MySQL"
argument_list|,
literal|"`"
argument_list|,
name|NullCollation
operator|.
name|LOW
argument_list|)
block|,
name|ORACLE
argument_list|(
literal|"Oracle"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|DERBY
argument_list|(
literal|"Apache Derby"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|DB2
argument_list|(
literal|"IBM DB2"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|FIREBIRD
argument_list|(
literal|"Firebird"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|H2
argument_list|(
literal|"H2"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|HIVE
argument_list|(
literal|"Apache Hive"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|LOW
argument_list|)
block|,
name|INFORMIX
argument_list|(
literal|"Informix"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|INGRES
argument_list|(
literal|"Ingres"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|JETHRO
argument_list|(
literal|"JethroData"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|LOW
argument_list|)
block|,
name|LUCIDDB
argument_list|(
literal|"LucidDB"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|INTERBASE
argument_list|(
literal|"Interbase"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|PHOENIX
argument_list|(
literal|"Phoenix"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|POSTGRESQL
argument_list|(
literal|"PostgreSQL"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|PRESTO
argument_list|(
literal|"Presto"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|LOW
argument_list|)
block|,
name|NETEZZA
argument_list|(
literal|"Netezza"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|INFOBRIGHT
argument_list|(
literal|"Infobright"
argument_list|,
literal|"`"
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|NEOVIEW
argument_list|(
literal|"Neoview"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|SYBASE
argument_list|(
literal|"Sybase"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|TERADATA
argument_list|(
literal|"Teradata"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|HSQLDB
argument_list|(
literal|"Hsqldb"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|VERTICA
argument_list|(
literal|"Vertica"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|SQLSTREAM
argument_list|(
literal|"SQLstream"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|SPARK
argument_list|(
literal|"Spark"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|LOW
argument_list|)
block|,
comment|/** Paraccel, now called Actian Matrix. Redshift is based on this, so      * presumably the dialect capabilities are similar. */
name|PARACCEL
argument_list|(
literal|"Paraccel"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|REDSHIFT
argument_list|(
literal|"Redshift"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|SNOWFLAKE
argument_list|(
literal|"Snowflake"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
comment|/**      * Placeholder for the unknown database.      *      *<p>Its dialect is useful for generating generic SQL. If you need to      * do something database-specific like quoting identifiers, don't rely      * on this dialect to do what you want.      */
name|UNKNOWN
argument_list|(
literal|"Unknown"
argument_list|,
literal|"`"
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|;
specifier|private
specifier|final
name|Supplier
argument_list|<
name|SqlDialect
argument_list|>
name|dialect
decl_stmt|;
name|DatabaseProduct
parameter_list|(
name|String
name|databaseProductName
parameter_list|,
name|String
name|quoteString
parameter_list|,
name|NullCollation
name|nullCollation
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|databaseProductName
argument_list|)
expr_stmt|;
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|nullCollation
argument_list|)
expr_stmt|;
name|dialect
operator|=
name|Suppliers
operator|.
name|memoize
argument_list|(
parameter_list|()
lambda|->
block|{
specifier|final
name|SqlDialect
name|dialect
init|=
name|SqlDialectFactoryImpl
operator|.
name|simple
argument_list|(
name|DatabaseProduct
operator|.
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|dialect
operator|!=
literal|null
condition|)
block|{
return|return
name|dialect
return|;
block|}
return|return
operator|new
name|SqlDialect
argument_list|(
name|SqlDialect
operator|.
name|EMPTY_CONTEXT
operator|.
name|withDatabaseProduct
argument_list|(
name|DatabaseProduct
operator|.
name|this
argument_list|)
operator|.
name|withDatabaseProductName
argument_list|(
name|databaseProductName
argument_list|)
operator|.
name|withIdentifierQuoteString
argument_list|(
name|quoteString
argument_list|)
operator|.
name|withNullCollation
argument_list|(
name|nullCollation
argument_list|)
argument_list|)
return|;
block|}
argument_list|)
operator|::
name|get
expr_stmt|;
block|}
comment|/**      * Returns a dummy dialect for this database.      *      *<p>Since databases have many versions and flavors, this dummy dialect      * is at best an approximation. If you want exact information, better to      * use a dialect created from an actual connection's metadata      * (see {@link SqlDialectFactory#create(java.sql.DatabaseMetaData)}).      *      * @return Dialect representing lowest-common-denominator behavior for      * all versions of this database      */
specifier|public
name|SqlDialect
name|getDialect
parameter_list|()
block|{
return|return
name|dialect
operator|.
name|get
argument_list|()
return|;
block|}
block|}
comment|/** Information for creating a dialect.    *    *<p>It is immutable; to "set" a property, call one of the "with" methods,    * which returns a new context with the desired property value. */
specifier|public
interface|interface
name|Context
block|{
annotation|@
name|Nonnull
name|DatabaseProduct
name|databaseProduct
parameter_list|()
function_decl|;
name|Context
name|withDatabaseProduct
parameter_list|(
annotation|@
name|Nonnull
name|DatabaseProduct
name|databaseProduct
parameter_list|)
function_decl|;
name|String
name|databaseProductName
parameter_list|()
function_decl|;
name|Context
name|withDatabaseProductName
parameter_list|(
name|String
name|databaseProductName
parameter_list|)
function_decl|;
name|String
name|databaseVersion
parameter_list|()
function_decl|;
name|Context
name|withDatabaseVersion
parameter_list|(
name|String
name|databaseVersion
parameter_list|)
function_decl|;
name|int
name|databaseMajorVersion
parameter_list|()
function_decl|;
name|Context
name|withDatabaseMajorVersion
parameter_list|(
name|int
name|databaseMajorVersion
parameter_list|)
function_decl|;
name|int
name|databaseMinorVersion
parameter_list|()
function_decl|;
name|Context
name|withDatabaseMinorVersion
parameter_list|(
name|int
name|databaseMinorVersion
parameter_list|)
function_decl|;
annotation|@
name|Nonnull
name|String
name|literalQuoteString
parameter_list|()
function_decl|;
annotation|@
name|Nonnull
name|Context
name|withLiteralQuoteString
parameter_list|(
name|String
name|literalQuoteString
parameter_list|)
function_decl|;
annotation|@
name|Nonnull
name|String
name|literalEscapedQuoteString
parameter_list|()
function_decl|;
annotation|@
name|Nonnull
name|Context
name|withLiteralEscapedQuoteString
parameter_list|(
name|String
name|literalEscapedQuoteString
parameter_list|)
function_decl|;
name|String
name|identifierQuoteString
parameter_list|()
function_decl|;
annotation|@
name|Nonnull
name|Context
name|withIdentifierQuoteString
parameter_list|(
name|String
name|identifierQuoteString
parameter_list|)
function_decl|;
annotation|@
name|Nonnull
name|Casing
name|unquotedCasing
parameter_list|()
function_decl|;
annotation|@
name|Nonnull
name|Context
name|withUnquotedCasing
parameter_list|(
name|Casing
name|unquotedCasing
parameter_list|)
function_decl|;
annotation|@
name|Nonnull
name|Casing
name|quotedCasing
parameter_list|()
function_decl|;
annotation|@
name|Nonnull
name|Context
name|withQuotedCasing
parameter_list|(
name|Casing
name|unquotedCasing
parameter_list|)
function_decl|;
name|boolean
name|caseSensitive
parameter_list|()
function_decl|;
annotation|@
name|Nonnull
name|Context
name|withCaseSensitive
parameter_list|(
name|boolean
name|caseSensitive
parameter_list|)
function_decl|;
annotation|@
name|Nonnull
name|SqlConformance
name|conformance
parameter_list|()
function_decl|;
annotation|@
name|Nonnull
name|Context
name|withConformance
parameter_list|(
name|SqlConformance
name|conformance
parameter_list|)
function_decl|;
annotation|@
name|Nonnull
name|NullCollation
name|nullCollation
parameter_list|()
function_decl|;
annotation|@
name|Nonnull
name|Context
name|withNullCollation
parameter_list|(
annotation|@
name|Nonnull
name|NullCollation
name|nullCollation
parameter_list|)
function_decl|;
annotation|@
name|Nonnull
name|RelDataTypeSystem
name|dataTypeSystem
parameter_list|()
function_decl|;
name|Context
name|withDataTypeSystem
parameter_list|(
annotation|@
name|Nonnull
name|RelDataTypeSystem
name|dataTypeSystem
parameter_list|)
function_decl|;
name|JethroDataSqlDialect
operator|.
name|JethroInfo
name|jethroInfo
parameter_list|()
function_decl|;
name|Context
name|withJethroInfo
parameter_list|(
name|JethroDataSqlDialect
operator|.
name|JethroInfo
name|jethroInfo
parameter_list|)
function_decl|;
block|}
comment|/** Implementation of Context. */
specifier|private
specifier|static
class|class
name|ContextImpl
implements|implements
name|Context
block|{
specifier|private
specifier|final
name|DatabaseProduct
name|databaseProduct
decl_stmt|;
specifier|private
specifier|final
name|String
name|databaseProductName
decl_stmt|;
specifier|private
specifier|final
name|String
name|databaseVersion
decl_stmt|;
specifier|private
specifier|final
name|int
name|databaseMajorVersion
decl_stmt|;
specifier|private
specifier|final
name|int
name|databaseMinorVersion
decl_stmt|;
specifier|private
specifier|final
name|String
name|literalQuoteString
decl_stmt|;
specifier|private
specifier|final
name|String
name|literalEscapedQuoteString
decl_stmt|;
specifier|private
specifier|final
name|String
name|identifierQuoteString
decl_stmt|;
specifier|private
specifier|final
name|Casing
name|unquotedCasing
decl_stmt|;
specifier|private
specifier|final
name|Casing
name|quotedCasing
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|caseSensitive
decl_stmt|;
specifier|private
specifier|final
name|SqlConformance
name|conformance
decl_stmt|;
specifier|private
specifier|final
name|NullCollation
name|nullCollation
decl_stmt|;
specifier|private
specifier|final
name|RelDataTypeSystem
name|dataTypeSystem
decl_stmt|;
specifier|private
specifier|final
name|JethroDataSqlDialect
operator|.
name|JethroInfo
name|jethroInfo
decl_stmt|;
specifier|private
name|ContextImpl
parameter_list|(
name|DatabaseProduct
name|databaseProduct
parameter_list|,
name|String
name|databaseProductName
parameter_list|,
name|String
name|databaseVersion
parameter_list|,
name|int
name|databaseMajorVersion
parameter_list|,
name|int
name|databaseMinorVersion
parameter_list|,
name|String
name|literalQuoteString
parameter_list|,
name|String
name|literalEscapedQuoteString
parameter_list|,
name|String
name|identifierQuoteString
parameter_list|,
name|Casing
name|quotedCasing
parameter_list|,
name|Casing
name|unquotedCasing
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|,
name|SqlConformance
name|conformance
parameter_list|,
name|NullCollation
name|nullCollation
parameter_list|,
name|RelDataTypeSystem
name|dataTypeSystem
parameter_list|,
name|JethroDataSqlDialect
operator|.
name|JethroInfo
name|jethroInfo
parameter_list|)
block|{
name|this
operator|.
name|databaseProduct
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|databaseProduct
argument_list|)
expr_stmt|;
name|this
operator|.
name|databaseProductName
operator|=
name|databaseProductName
expr_stmt|;
name|this
operator|.
name|databaseVersion
operator|=
name|databaseVersion
expr_stmt|;
name|this
operator|.
name|databaseMajorVersion
operator|=
name|databaseMajorVersion
expr_stmt|;
name|this
operator|.
name|databaseMinorVersion
operator|=
name|databaseMinorVersion
expr_stmt|;
name|this
operator|.
name|literalQuoteString
operator|=
name|literalQuoteString
expr_stmt|;
name|this
operator|.
name|literalEscapedQuoteString
operator|=
name|literalEscapedQuoteString
expr_stmt|;
name|this
operator|.
name|identifierQuoteString
operator|=
name|identifierQuoteString
expr_stmt|;
name|this
operator|.
name|quotedCasing
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|quotedCasing
argument_list|)
expr_stmt|;
name|this
operator|.
name|unquotedCasing
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|unquotedCasing
argument_list|)
expr_stmt|;
name|this
operator|.
name|caseSensitive
operator|=
name|caseSensitive
expr_stmt|;
name|this
operator|.
name|conformance
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|conformance
argument_list|)
expr_stmt|;
name|this
operator|.
name|nullCollation
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|nullCollation
argument_list|)
expr_stmt|;
name|this
operator|.
name|dataTypeSystem
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|dataTypeSystem
argument_list|)
expr_stmt|;
name|this
operator|.
name|jethroInfo
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|jethroInfo
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|Nonnull
specifier|public
name|DatabaseProduct
name|databaseProduct
parameter_list|()
block|{
return|return
name|databaseProduct
return|;
block|}
annotation|@
name|Override
specifier|public
name|Context
name|withDatabaseProduct
parameter_list|(
annotation|@
name|Nonnull
name|DatabaseProduct
name|databaseProduct
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|databaseProductName
parameter_list|()
block|{
return|return
name|databaseProductName
return|;
block|}
annotation|@
name|Override
specifier|public
name|Context
name|withDatabaseProductName
parameter_list|(
name|String
name|databaseProductName
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|databaseVersion
parameter_list|()
block|{
return|return
name|databaseVersion
return|;
block|}
annotation|@
name|Override
specifier|public
name|Context
name|withDatabaseVersion
parameter_list|(
name|String
name|databaseVersion
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|databaseMajorVersion
parameter_list|()
block|{
return|return
name|databaseMajorVersion
return|;
block|}
annotation|@
name|Override
specifier|public
name|Context
name|withDatabaseMajorVersion
parameter_list|(
name|int
name|databaseMajorVersion
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|databaseMinorVersion
parameter_list|()
block|{
return|return
name|databaseMinorVersion
return|;
block|}
annotation|@
name|Override
specifier|public
name|Context
name|withDatabaseMinorVersion
parameter_list|(
name|int
name|databaseMinorVersion
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|literalQuoteString
parameter_list|()
block|{
return|return
name|literalQuoteString
return|;
block|}
annotation|@
name|Override
specifier|public
name|Context
name|withLiteralQuoteString
parameter_list|(
name|String
name|literalQuoteString
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|literalEscapedQuoteString
parameter_list|()
block|{
return|return
name|literalEscapedQuoteString
return|;
block|}
annotation|@
name|Override
specifier|public
name|Context
name|withLiteralEscapedQuoteString
parameter_list|(
name|String
name|literalEscapedQuoteString
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|identifierQuoteString
parameter_list|()
block|{
return|return
name|identifierQuoteString
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nonnull
specifier|public
name|Context
name|withIdentifierQuoteString
parameter_list|(
name|String
name|identifierQuoteString
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nonnull
specifier|public
name|Casing
name|unquotedCasing
parameter_list|()
block|{
return|return
name|unquotedCasing
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nonnull
specifier|public
name|Context
name|withUnquotedCasing
parameter_list|(
name|Casing
name|unquotedCasing
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nonnull
specifier|public
name|Casing
name|quotedCasing
parameter_list|()
block|{
return|return
name|quotedCasing
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nonnull
specifier|public
name|Context
name|withQuotedCasing
parameter_list|(
name|Casing
name|quotedCasing
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|caseSensitive
parameter_list|()
block|{
return|return
name|caseSensitive
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nonnull
specifier|public
name|Context
name|withCaseSensitive
parameter_list|(
name|boolean
name|caseSensitive
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nonnull
specifier|public
name|SqlConformance
name|conformance
parameter_list|()
block|{
return|return
name|conformance
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nonnull
specifier|public
name|Context
name|withConformance
parameter_list|(
name|SqlConformance
name|conformance
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nonnull
specifier|public
name|NullCollation
name|nullCollation
parameter_list|()
block|{
return|return
name|nullCollation
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nonnull
specifier|public
name|Context
name|withNullCollation
parameter_list|(
annotation|@
name|Nonnull
name|NullCollation
name|nullCollation
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nonnull
specifier|public
name|RelDataTypeSystem
name|dataTypeSystem
parameter_list|()
block|{
return|return
name|dataTypeSystem
return|;
block|}
annotation|@
name|Override
specifier|public
name|Context
name|withDataTypeSystem
parameter_list|(
annotation|@
name|Nonnull
name|RelDataTypeSystem
name|dataTypeSystem
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|Nonnull
specifier|public
name|JethroDataSqlDialect
operator|.
name|JethroInfo
name|jethroInfo
parameter_list|()
block|{
return|return
name|jethroInfo
return|;
block|}
annotation|@
name|Override
specifier|public
name|Context
name|withJethroInfo
parameter_list|(
name|JethroDataSqlDialect
operator|.
name|JethroInfo
name|jethroInfo
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|literalQuoteString
argument_list|,
name|literalEscapedQuoteString
argument_list|,
name|identifierQuoteString
argument_list|,
name|quotedCasing
argument_list|,
name|unquotedCasing
argument_list|,
name|caseSensitive
argument_list|,
name|conformance
argument_list|,
name|nullCollation
argument_list|,
name|dataTypeSystem
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

