begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|DateTimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|NullCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Experimental
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|dialect
operator|.
name|AnsiSqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|dialect
operator|.
name|CalciteSqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|dialect
operator|.
name|JethroDataSqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|BasicSqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Suppliers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DatabaseMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_comment
comment|/**  *<code>SqlDialect</code> encapsulates the differences between dialects of SQL.  *  *<p>It is used by classes such as {@link SqlWriter} and  * {@link org.apache.calcite.sql.util.SqlBuilder}.  */
end_comment

begin_class
specifier|public
class|class
name|SqlDialect
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|protected
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SqlDialect
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Empty context. */
specifier|public
specifier|static
specifier|final
name|Context
name|EMPTY_CONTEXT
init|=
name|emptyContext
argument_list|()
decl_stmt|;
comment|/** @deprecated Use {@link AnsiSqlDialect#DEFAULT} instead. */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
specifier|final
name|SqlDialect
name|DUMMY
init|=
name|AnsiSqlDialect
operator|.
name|DEFAULT
decl_stmt|;
comment|/** @deprecated Use {@link CalciteSqlDialect#DEFAULT} instead. */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
specifier|final
name|SqlDialect
name|CALCITE
init|=
name|CalciteSqlDialect
operator|.
name|DEFAULT
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|private
specifier|final
name|String
name|identifierQuoteString
decl_stmt|;
specifier|private
specifier|final
name|String
name|identifierEndQuoteString
decl_stmt|;
specifier|private
specifier|final
name|String
name|identifierEscapedQuote
decl_stmt|;
specifier|private
specifier|final
name|DatabaseProduct
name|databaseProduct
decl_stmt|;
specifier|protected
specifier|final
name|NullCollation
name|nullCollation
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a<code>SqlDialect</code> from a DatabaseMetaData.    *    *<p>Does not maintain a reference to the DatabaseMetaData -- or, more    * importantly, to its {@link java.sql.Connection} -- after this call has    * returned.    *    * @param databaseMetaData used to determine which dialect of SQL to generate    *    * @deprecated Replaced by {@link SqlDialectFactory}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|SqlDialect
name|create
parameter_list|(
name|DatabaseMetaData
name|databaseMetaData
parameter_list|)
block|{
return|return
operator|new
name|SqlDialectFactoryImpl
argument_list|()
operator|.
name|create
argument_list|(
name|databaseMetaData
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|SqlDialect
parameter_list|(
name|DatabaseProduct
name|databaseProduct
parameter_list|,
name|String
name|databaseProductName
parameter_list|,
name|String
name|identifierQuoteString
parameter_list|)
block|{
name|this
argument_list|(
name|EMPTY_CONTEXT
operator|.
name|withDatabaseProduct
argument_list|(
name|databaseProduct
argument_list|)
operator|.
name|withDatabaseProductName
argument_list|(
name|databaseProductName
argument_list|)
operator|.
name|withIdentifierQuoteString
argument_list|(
name|identifierQuoteString
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a SqlDialect.    *    * @param databaseProduct       Database product; may be UNKNOWN, never null    * @param databaseProductName   Database product name from JDBC driver    * @param identifierQuoteString String to quote identifiers. Null if quoting    *                              is not supported. If "[", close quote is    *                              deemed to be "]".    * @param nullCollation         Whether NULL values appear first or last    *    * @deprecated Use {@link #SqlDialect(Context)}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|SqlDialect
parameter_list|(
name|DatabaseProduct
name|databaseProduct
parameter_list|,
name|String
name|databaseProductName
parameter_list|,
name|String
name|identifierQuoteString
parameter_list|,
name|NullCollation
name|nullCollation
parameter_list|)
block|{
name|this
argument_list|(
name|EMPTY_CONTEXT
operator|.
name|withDatabaseProduct
argument_list|(
name|databaseProduct
argument_list|)
operator|.
name|withDatabaseProductName
argument_list|(
name|databaseProductName
argument_list|)
operator|.
name|withIdentifierQuoteString
argument_list|(
name|identifierQuoteString
argument_list|)
operator|.
name|withNullCollation
argument_list|(
name|nullCollation
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a SqlDialect.    *    * @param context All the information necessary to create a dialect    */
specifier|public
name|SqlDialect
parameter_list|(
name|Context
name|context
parameter_list|)
block|{
name|this
operator|.
name|nullCollation
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|context
operator|.
name|nullCollation
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|databaseProduct
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|context
operator|.
name|databaseProduct
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|identifierQuoteString
init|=
name|context
operator|.
name|identifierQuoteString
argument_list|()
decl_stmt|;
if|if
condition|(
name|identifierQuoteString
operator|!=
literal|null
condition|)
block|{
name|identifierQuoteString
operator|=
name|identifierQuoteString
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|identifierQuoteString
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|identifierQuoteString
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|this
operator|.
name|identifierQuoteString
operator|=
name|identifierQuoteString
expr_stmt|;
name|this
operator|.
name|identifierEndQuoteString
operator|=
name|identifierQuoteString
operator|==
literal|null
condition|?
literal|null
else|:
name|identifierQuoteString
operator|.
name|equals
argument_list|(
literal|"["
argument_list|)
condition|?
literal|"]"
else|:
name|identifierQuoteString
expr_stmt|;
name|this
operator|.
name|identifierEscapedQuote
operator|=
name|identifierQuoteString
operator|==
literal|null
condition|?
literal|null
else|:
name|this
operator|.
name|identifierEndQuoteString
operator|+
name|this
operator|.
name|identifierEndQuoteString
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/** Creates an empty context. Use {@link #EMPTY_CONTEXT} if possible. */
specifier|protected
specifier|static
name|Context
name|emptyContext
parameter_list|()
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|DatabaseProduct
operator|.
name|UNKNOWN
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|,
name|JethroDataSqlDialect
operator|.
name|JethroInfo
operator|.
name|EMPTY
argument_list|)
return|;
block|}
comment|/**    * Converts a product name and version (per the JDBC driver) into a product    * enumeration.    *    * @param productName    Product name    * @param productVersion Product version    * @return database product    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|DatabaseProduct
name|getProduct
parameter_list|(
name|String
name|productName
parameter_list|,
name|String
name|productVersion
parameter_list|)
block|{
specifier|final
name|String
name|upperProductName
init|=
name|productName
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|upperProductName
condition|)
block|{
case|case
literal|"ACCESS"
case|:
return|return
name|DatabaseProduct
operator|.
name|ACCESS
return|;
case|case
literal|"APACHE DERBY"
case|:
return|return
name|DatabaseProduct
operator|.
name|DERBY
return|;
case|case
literal|"DBMS:CLOUDSCAPE"
case|:
return|return
name|DatabaseProduct
operator|.
name|DERBY
return|;
case|case
literal|"HIVE"
case|:
return|return
name|DatabaseProduct
operator|.
name|HIVE
return|;
case|case
literal|"INGRES"
case|:
return|return
name|DatabaseProduct
operator|.
name|INGRES
return|;
case|case
literal|"INTERBASE"
case|:
return|return
name|DatabaseProduct
operator|.
name|INTERBASE
return|;
case|case
literal|"LUCIDDB"
case|:
return|return
name|DatabaseProduct
operator|.
name|LUCIDDB
return|;
case|case
literal|"ORACLE"
case|:
return|return
name|DatabaseProduct
operator|.
name|ORACLE
return|;
case|case
literal|"PHOENIX"
case|:
return|return
name|DatabaseProduct
operator|.
name|PHOENIX
return|;
case|case
literal|"MYSQL (INFOBRIGHT)"
case|:
return|return
name|DatabaseProduct
operator|.
name|INFOBRIGHT
return|;
case|case
literal|"MYSQL"
case|:
return|return
name|DatabaseProduct
operator|.
name|MYSQL
return|;
case|case
literal|"REDSHIFT"
case|:
return|return
name|DatabaseProduct
operator|.
name|REDSHIFT
return|;
block|}
comment|// Now the fuzzy matches.
if|if
condition|(
name|productName
operator|.
name|startsWith
argument_list|(
literal|"DB2"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|DB2
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"FIREBIRD"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|FIREBIRD
return|;
block|}
if|else if
condition|(
name|productName
operator|.
name|startsWith
argument_list|(
literal|"Informix"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|INFORMIX
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"NETEZZA"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|NETEZZA
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"PARACCEL"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|PARACCEL
return|;
block|}
if|else if
condition|(
name|productName
operator|.
name|startsWith
argument_list|(
literal|"HP Neoview"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|NEOVIEW
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"POSTGRE"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|POSTGRESQL
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"SQL SERVER"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|MSSQL
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"SYBASE"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|SYBASE
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"TERADATA"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|TERADATA
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"HSQL"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|HSQLDB
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"H2"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|H2
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"VERTICA"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|VERTICA
return|;
block|}
if|else if
condition|(
name|upperProductName
operator|.
name|contains
argument_list|(
literal|"GOOGLE BIGQUERY"
argument_list|)
condition|)
block|{
return|return
name|DatabaseProduct
operator|.
name|BIG_QUERY
return|;
block|}
else|else
block|{
return|return
name|DatabaseProduct
operator|.
name|UNKNOWN
return|;
block|}
block|}
comment|/**    * Encloses an identifier in quotation marks appropriate for the current SQL    * dialect.    *    *<p>For example,<code>quoteIdentifier("emp")</code> yields a string    * containing<code>"emp"</code> in Oracle, and a string containing<code>    * [emp]</code> in Access.    *    * @param val Identifier to quote    * @return Quoted identifier    */
specifier|public
name|String
name|quoteIdentifier
parameter_list|(
name|String
name|val
parameter_list|)
block|{
if|if
condition|(
name|identifierQuoteString
operator|==
literal|null
condition|)
block|{
return|return
name|val
return|;
comment|// quoting is not supported
block|}
name|String
name|val2
init|=
name|val
operator|.
name|replaceAll
argument_list|(
name|identifierEndQuoteString
argument_list|,
name|identifierEscapedQuote
argument_list|)
decl_stmt|;
return|return
name|identifierQuoteString
operator|+
name|val2
operator|+
name|identifierEndQuoteString
return|;
block|}
comment|/**    * Encloses an identifier in quotation marks appropriate for the current SQL    * dialect, writing the result to a {@link StringBuilder}.    *    *<p>For example,<code>quoteIdentifier("emp")</code> yields a string    * containing<code>"emp"</code> in Oracle, and a string containing<code>    * [emp]</code> in Access.    *    * @param buf Buffer    * @param val Identifier to quote    * @return The buffer    */
specifier|public
name|StringBuilder
name|quoteIdentifier
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|String
name|val
parameter_list|)
block|{
if|if
condition|(
name|identifierQuoteString
operator|==
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|// quoting is not supported
return|return
name|buf
return|;
block|}
name|String
name|val2
init|=
name|val
operator|.
name|replaceAll
argument_list|(
name|identifierEndQuoteString
argument_list|,
name|identifierEscapedQuote
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|identifierQuoteString
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|val2
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|identifierEndQuoteString
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
comment|/**    * Quotes a multi-part identifier.    *    * @param buf         Buffer    * @param identifiers List of parts of the identifier to quote    * @return The buffer    */
specifier|public
name|StringBuilder
name|quoteIdentifier
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|identifiers
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|identifier
range|:
name|identifiers
control|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
comment|/**    * Returns whether a given identifier needs to be quoted.    */
specifier|public
name|boolean
name|identifierNeedsToBeQuoted
parameter_list|(
name|String
name|val
parameter_list|)
block|{
return|return
operator|!
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^[A-Z_$0-9]+"
argument_list|)
operator|.
name|matcher
argument_list|(
name|val
argument_list|)
operator|.
name|matches
argument_list|()
return|;
block|}
comment|/**    * Converts a string into a string literal. For example,<code>can't    * run</code> becomes<code>'can''t run'</code>.    */
specifier|public
name|String
name|quoteStringLiteral
parameter_list|(
name|String
name|val
parameter_list|)
block|{
if|if
condition|(
name|containsNonAscii
argument_list|(
name|val
argument_list|)
condition|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|quoteStringLiteralUnicode
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
name|val
operator|=
name|FakeUtil
operator|.
name|replace
argument_list|(
name|val
argument_list|,
literal|"'"
argument_list|,
literal|"''"
argument_list|)
expr_stmt|;
return|return
literal|"'"
operator|+
name|val
operator|+
literal|"'"
return|;
block|}
block|}
specifier|public
name|void
name|unparseCall
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
name|call
argument_list|,
name|leftPrec
argument_list|,
name|rightPrec
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|unparseDateTimeLiteral
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlAbstractDateTimeLiteral
name|literal
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
name|writer
operator|.
name|literal
argument_list|(
name|literal
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns whether the string contains any characters outside the    * comfortable 7-bit ASCII range (32 through 127).    *    * @param s String    * @return Whether string contains any non-7-bit-ASCII characters    */
specifier|private
specifier|static
name|boolean
name|containsNonAscii
parameter_list|(
name|String
name|s
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|32
operator|||
name|c
operator|>=
literal|128
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Converts a string into a unicode string literal. For example,    *<code>can't{tab}run\</code> becomes<code>u'can''t\0009run\\'</code>.    */
specifier|public
name|void
name|quoteStringLiteralUnicode
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|String
name|val
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"u&'"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|val
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|val
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|32
operator|||
name|c
operator|>=
literal|128
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|HEXITS
index|[
operator|(
name|c
operator|>>
literal|12
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|HEXITS
index|[
operator|(
name|c
operator|>>
literal|8
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|HEXITS
index|[
operator|(
name|c
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|HEXITS
index|[
name|c
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'\\'
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|HEXITS
init|=
block|{
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,   }
decl_stmt|;
comment|/**    * Converts a string literal back into a string. For example,<code>'can''t    * run'</code> becomes<code>can't run</code>.    */
specifier|public
name|String
name|unquoteStringLiteral
parameter_list|(
name|String
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|val
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'\''
operator|)
operator|&&
operator|(
name|val
operator|.
name|charAt
argument_list|(
name|val
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'\''
operator|)
condition|)
block|{
if|if
condition|(
name|val
operator|.
name|length
argument_list|()
operator|>
literal|2
condition|)
block|{
name|val
operator|=
name|FakeUtil
operator|.
name|replace
argument_list|(
name|val
argument_list|,
literal|"''"
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
return|return
name|val
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|val
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
else|else
block|{
comment|// zero length string
return|return
literal|""
return|;
block|}
block|}
return|return
name|val
return|;
block|}
specifier|protected
name|boolean
name|allowsAs
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|// -- behaviors --
specifier|protected
name|boolean
name|requiresAliasForFromItems
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/** Returns whether a qualified table in the FROM clause has an implicit alias    * which consists of just the table name.    *    *<p>For example, in {@link DatabaseProduct#ORACLE}    *    *<blockquote>SELECT * FROM sales.emp</blockquote>    *    *<p>is equivalent to    *    *<blockquote>SELECT * FROM sales.emp AS emp</blockquote>    *    *<p>and therefore    *    *<blockquote>SELECT emp.empno FROM sales.emp</blockquote>    *    *<p>is valid. But {@link DatabaseProduct#DB2} does not have an implicit    * alias, so the previous query it not valid; you need to write    *    *<blockquote>SELECT sales.emp.empno FROM sales.emp</blockquote>    *    *<p>Returns true for all databases except DB2.    */
specifier|public
name|boolean
name|hasImplicitTableAlias
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Converts a timestamp to a SQL timestamp literal, e.g.    * {@code TIMESTAMP '2009-12-17 12:34:56'}.    *    *<p>Timestamp values do not have a time zone. We therefore interpret them    * as the number of milliseconds after the UTC epoch, and the formatted    * value is that time in UTC.    *    *<p>In particular,    *    *<blockquote><code>quoteTimestampLiteral(new Timestamp(0));</code>    *</blockquote>    *    *<p>returns {@code TIMESTAMP '1970-01-01 00:00:00'}, regardless of the JVM's    * time zone.    *    * @param timestamp Timestamp    * @return SQL timestamp literal    */
specifier|public
name|String
name|quoteTimestampLiteral
parameter_list|(
name|Timestamp
name|timestamp
parameter_list|)
block|{
specifier|final
name|SimpleDateFormat
name|format
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"'TIMESTAMP' ''yyyy-MM-DD HH:mm:SS''"
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|format
operator|.
name|setTimeZone
argument_list|(
name|DateTimeUtils
operator|.
name|UTC_ZONE
argument_list|)
expr_stmt|;
return|return
name|format
operator|.
name|format
argument_list|(
name|timestamp
argument_list|)
return|;
block|}
comment|/**    * Returns the database this dialect belongs to,    * {@link SqlDialect.DatabaseProduct#UNKNOWN} if not known, never null.    *    *<p>Please be judicious in how you use this method. If you wish to determine    * whether a dialect has a particular capability or behavior, it is usually    * better to add a method to SqlDialect and override that method in particular    * sub-classes of SqlDialect.    *    * @return Database product    * @deprecated To be removed without replacement    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|DatabaseProduct
name|getDatabaseProduct
parameter_list|()
block|{
return|return
name|databaseProduct
return|;
block|}
comment|/**    * Returns whether the dialect supports character set names as part of a    * data type, for instance {@code VARCHAR(30) CHARACTER SET `ISO-8859-1`}.    */
specifier|public
name|boolean
name|supportsCharSet
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|supportsAggregateFunction
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|COUNT
case|:
case|case
name|SUM
case|:
case|case
name|SUM0
case|:
case|case
name|MIN
case|:
case|case
name|MAX
case|:
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Returns whether this dialect supports a given function or operator. */
specifier|public
name|boolean
name|supportsFunction
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|paramTypes
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|CalendarPolicy
name|getCalendarPolicy
parameter_list|()
block|{
return|return
name|CalendarPolicy
operator|.
name|NULL
return|;
block|}
specifier|public
name|SqlNode
name|getCastSpec
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|BasicSqlType
condition|)
block|{
return|return
operator|new
name|SqlDataTypeSpec
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|type
operator|.
name|getScale
argument_list|()
argument_list|,
name|type
operator|.
name|getCharset
argument_list|()
operator|!=
literal|null
operator|&&
name|supportsCharSet
argument_list|()
condition|?
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|name
argument_list|()
else|:
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
return|return
name|SqlTypeUtil
operator|.
name|convertTypeToSpec
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/** Rewrite SINGLE_VALUE into expression based on database variants    *  E.g. HSQLDB, MYSQL, ORACLE, etc    */
specifier|public
name|SqlNode
name|rewriteSingleValueExpr
parameter_list|(
name|SqlNode
name|aggCall
parameter_list|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"SINGLE_VALUE rewrite not supported for {}"
argument_list|,
name|databaseProduct
argument_list|)
expr_stmt|;
return|return
name|aggCall
return|;
block|}
comment|/**    * Returns the SqlNode for emulating the null direction for the given field    * or<code>null</code> if no emulation needs to be done.    *    * @param node The SqlNode representing the expression    * @param nullsFirst Whether nulls should come first    * @param desc Whether the sort direction is    * {@link org.apache.calcite.rel.RelFieldCollation.Direction#DESCENDING} or    * {@link org.apache.calcite.rel.RelFieldCollation.Direction#STRICTLY_DESCENDING}    * @return A SqlNode for null direction emulation or<code>null</code> if not required    */
specifier|public
name|SqlNode
name|emulateNullDirection
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|boolean
name|nullsFirst
parameter_list|,
name|boolean
name|desc
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
specifier|protected
name|SqlNode
name|emulateNullDirectionWithIsNull
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|boolean
name|nullsFirst
parameter_list|,
name|boolean
name|desc
parameter_list|)
block|{
comment|// No need for emulation if the nulls will anyways come out the way we want
comment|// them based on "nullsFirst" and "desc".
if|if
condition|(
name|nullCollation
operator|.
name|isDefaultOrder
argument_list|(
name|nullsFirst
argument_list|,
name|desc
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|IS_NULL
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|nullsFirst
condition|)
block|{
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|DESC
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
comment|/**    * Returns whether the dialect supports OFFSET/FETCH clauses    * introduced by SQL:2008, for instance    * {@code OFFSET 10 ROWS FETCH NEXT 20 ROWS ONLY}.    * If false, we assume that the dialect supports the alternative syntax    * {@code LIMIT 20 OFFSET 10}.    *    * @deprecated This method is no longer used. To change how the dialect    * unparses offset/fetch, override the {@link #unparseOffsetFetch} method.    */
annotation|@
name|Deprecated
specifier|public
name|boolean
name|supportsOffsetFetch
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Converts an offset and fetch into SQL.    *    *<p>At least one of {@code offset} and {@code fetch} must be provided.    *    *<p>Common options:    *<ul>    *<li>{@code OFFSET offset ROWS FETCH NEXT fetch ROWS ONLY}    *   (ANSI standard SQL, Oracle, PostgreSQL, and the default)    *<li>{@code LIMIT fetch OFFSET offset} (Apache Hive, MySQL, Redshift)    *</ul>    *    * @param writer Writer    * @param offset Number of rows to skip before emitting, or null    * @param fetch Number of rows to fetch, or null    *    * @see #unparseFetchUsingAnsi(SqlWriter, SqlNode, SqlNode)    * @see #unparseFetchUsingLimit(SqlWriter, SqlNode, SqlNode)    */
specifier|public
name|void
name|unparseOffsetFetch
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlNode
name|offset
parameter_list|,
name|SqlNode
name|fetch
parameter_list|)
block|{
name|unparseFetchUsingAnsi
argument_list|(
name|writer
argument_list|,
name|offset
argument_list|,
name|fetch
argument_list|)
expr_stmt|;
block|}
comment|/** Unparses offset/fetch using ANSI standard "OFFSET offset ROWS FETCH NEXT    * fetch ROWS ONLY" syntax. */
specifier|protected
specifier|final
name|void
name|unparseFetchUsingAnsi
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlNode
name|offset
parameter_list|,
name|SqlNode
name|fetch
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|fetch
operator|!=
literal|null
operator|||
name|offset
operator|!=
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|newlineAndIndent
argument_list|()
expr_stmt|;
specifier|final
name|SqlWriter
operator|.
name|Frame
name|offsetFrame
init|=
name|writer
operator|.
name|startList
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|OFFSET
argument_list|)
decl_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"OFFSET"
argument_list|)
expr_stmt|;
name|offset
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"ROWS"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|offsetFrame
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fetch
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|newlineAndIndent
argument_list|()
expr_stmt|;
specifier|final
name|SqlWriter
operator|.
name|Frame
name|fetchFrame
init|=
name|writer
operator|.
name|startList
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|FETCH
argument_list|)
decl_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"FETCH"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"NEXT"
argument_list|)
expr_stmt|;
name|fetch
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"ROWS"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"ONLY"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|fetchFrame
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Unparses offset/fetch using "LIMIT fetch OFFSET offset" syntax. */
specifier|protected
specifier|final
name|void
name|unparseFetchUsingLimit
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlNode
name|offset
parameter_list|,
name|SqlNode
name|fetch
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|fetch
operator|!=
literal|null
operator|||
name|offset
operator|!=
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|newlineAndIndent
argument_list|()
expr_stmt|;
specifier|final
name|SqlWriter
operator|.
name|Frame
name|fetchFrame
init|=
name|writer
operator|.
name|startList
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|FETCH
argument_list|)
decl_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"LIMIT"
argument_list|)
expr_stmt|;
name|fetch
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|fetchFrame
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|newlineAndIndent
argument_list|()
expr_stmt|;
specifier|final
name|SqlWriter
operator|.
name|Frame
name|offsetFrame
init|=
name|writer
operator|.
name|startList
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|OFFSET
argument_list|)
decl_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"OFFSET"
argument_list|)
expr_stmt|;
name|offset
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|offsetFrame
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns whether the dialect supports nested aggregations, for instance    * {@code SELECT SUM(SUM(1)) }.    */
specifier|public
name|boolean
name|supportsNestedAggregations
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/** Returns how NULL values are sorted if an ORDER BY item does not contain    * NULLS ASCENDING or NULLS DESCENDING. */
specifier|public
name|NullCollation
name|getNullCollation
parameter_list|()
block|{
return|return
name|nullCollation
return|;
block|}
comment|/** Returns whether NULL values are sorted first or last, in this dialect,    * in an ORDER BY item of a given direction. */
specifier|public
name|RelFieldCollation
operator|.
name|NullDirection
name|defaultNullDirection
parameter_list|(
name|RelFieldCollation
operator|.
name|Direction
name|direction
parameter_list|)
block|{
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|ASCENDING
case|:
case|case
name|STRICTLY_ASCENDING
case|:
return|return
name|getNullCollation
argument_list|()
operator|.
name|last
argument_list|(
literal|false
argument_list|)
condition|?
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
else|:
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
return|;
case|case
name|DESCENDING
case|:
case|case
name|STRICTLY_DESCENDING
case|:
return|return
name|getNullCollation
argument_list|()
operator|.
name|last
argument_list|(
literal|true
argument_list|)
condition|?
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
else|:
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
return|;
default|default:
return|return
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
return|;
block|}
block|}
comment|/**    * Returns whether the dialect supports VALUES in a sub-query with    * and an "AS t(column, ...)" values to define column names.    *    *<p>Currently, only Oracle does not. For this, we generate "SELECT v0 AS c0,    * v1 AS c1 ... UNION ALL ...". We may need to refactor this method when we    * support VALUES for other dialects. */
annotation|@
name|Experimental
specifier|public
name|boolean
name|supportsAliasedValues
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * A few utility functions copied from org.apache.calcite.util.Util. We have    * copied them because we wish to keep SqlDialect's dependencies to a    * minimum.    */
specifier|public
specifier|static
class|class
name|FakeUtil
block|{
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|(
name|Throwable
name|e
parameter_list|,
name|String
name|s
parameter_list|)
block|{
name|String
name|message
init|=
literal|"Internal error: \u0000"
operator|+
name|s
decl_stmt|;
name|AssertionError
name|ae
init|=
operator|new
name|AssertionError
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|ae
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|ae
return|;
block|}
comment|/**      * Replaces every occurrence of<code>find</code> in<code>s</code> with      *<code>replace</code>.      */
specifier|public
specifier|static
name|String
name|replace
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|find
parameter_list|,
name|String
name|replace
parameter_list|)
block|{
comment|// let's be optimistic
name|int
name|found
init|=
name|s
operator|.
name|indexOf
argument_list|(
name|find
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|s
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|s
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
name|start
operator|<
name|found
condition|;
name|start
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
name|replace
argument_list|)
expr_stmt|;
name|start
operator|+=
name|find
operator|.
name|length
argument_list|()
expr_stmt|;
name|found
operator|=
name|s
operator|.
name|indexOf
argument_list|(
name|find
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
operator|-
literal|1
condition|)
block|{
name|found
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Whether this JDBC driver needs you to pass a Calendar object to methods    * such as {@link ResultSet#getTimestamp(int, java.util.Calendar)}. */
specifier|public
enum|enum
name|CalendarPolicy
block|{
name|NONE
block|,
name|NULL
block|,
name|LOCAL
block|,
name|DIRECT
block|,
name|SHIFT
block|;   }
comment|/**    * Rough list of flavors of database.    *    *<p>These values cannot help you distinguish between features that exist    * in different versions or ports of a database, but they are sufficient    * to drive a {@code switch} statement if behavior is broadly different    * between say, MySQL and Oracle.    *    *<p>If possible, you should not refer to particular database at all; write    * extend the dialect to describe the particular capability, for example,    * whether the database allows expressions to appear in the GROUP BY clause.    */
specifier|public
enum|enum
name|DatabaseProduct
block|{
name|ACCESS
argument_list|(
literal|"Access"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|BIG_QUERY
argument_list|(
literal|"Google BigQuery"
argument_list|,
literal|"`"
argument_list|,
name|NullCollation
operator|.
name|LOW
argument_list|)
block|,
name|CALCITE
argument_list|(
literal|"Apache Calcite"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|MSSQL
argument_list|(
literal|"Microsoft SQL Server"
argument_list|,
literal|"["
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|MYSQL
argument_list|(
literal|"MySQL"
argument_list|,
literal|"`"
argument_list|,
name|NullCollation
operator|.
name|LOW
argument_list|)
block|,
name|ORACLE
argument_list|(
literal|"Oracle"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|DERBY
argument_list|(
literal|"Apache Derby"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|DB2
argument_list|(
literal|"IBM DB2"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|FIREBIRD
argument_list|(
literal|"Firebird"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|H2
argument_list|(
literal|"H2"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|HIVE
argument_list|(
literal|"Apache Hive"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|LOW
argument_list|)
block|,
name|INFORMIX
argument_list|(
literal|"Informix"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|INGRES
argument_list|(
literal|"Ingres"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|JETHRO
argument_list|(
literal|"JethroData"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|LOW
argument_list|)
block|,
name|LUCIDDB
argument_list|(
literal|"LucidDB"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|INTERBASE
argument_list|(
literal|"Interbase"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|PHOENIX
argument_list|(
literal|"Phoenix"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|POSTGRESQL
argument_list|(
literal|"PostgreSQL"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|NETEZZA
argument_list|(
literal|"Netezza"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|INFOBRIGHT
argument_list|(
literal|"Infobright"
argument_list|,
literal|"`"
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|NEOVIEW
argument_list|(
literal|"Neoview"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|SYBASE
argument_list|(
literal|"Sybase"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|TERADATA
argument_list|(
literal|"Teradata"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|HSQLDB
argument_list|(
literal|"Hsqldb"
argument_list|,
literal|null
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|VERTICA
argument_list|(
literal|"Vertica"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|SQLSTREAM
argument_list|(
literal|"SQLstream"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
comment|/** Paraccel, now called Actian Matrix. Redshift is based on this, so      * presumably the dialect capabilities are similar. */
name|PARACCEL
argument_list|(
literal|"Paraccel"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
name|REDSHIFT
argument_list|(
literal|"Redshift"
argument_list|,
literal|"\""
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|,
comment|/**      * Placeholder for the unknown database.      *      *<p>Its dialect is useful for generating generic SQL. If you need to      * do something database-specific like quoting identifiers, don't rely      * on this dialect to do what you want.      */
name|UNKNOWN
argument_list|(
literal|"Unknown"
argument_list|,
literal|"`"
argument_list|,
name|NullCollation
operator|.
name|HIGH
argument_list|)
block|;
specifier|private
specifier|final
name|Supplier
argument_list|<
name|SqlDialect
argument_list|>
name|dialect
init|=
name|Suppliers
operator|.
name|memoize
argument_list|(
operator|new
name|Supplier
argument_list|<
name|SqlDialect
argument_list|>
argument_list|()
block|{
specifier|public
name|SqlDialect
name|get
parameter_list|()
block|{
specifier|final
name|SqlDialect
name|dialect
init|=
name|SqlDialectFactoryImpl
operator|.
name|simple
argument_list|(
name|DatabaseProduct
operator|.
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|dialect
operator|!=
literal|null
condition|)
block|{
return|return
name|dialect
return|;
block|}
return|return
operator|new
name|SqlDialect
argument_list|(
name|SqlDialect
operator|.
name|EMPTY_CONTEXT
operator|.
name|withDatabaseProduct
argument_list|(
name|DatabaseProduct
operator|.
name|this
argument_list|)
operator|.
name|withDatabaseProductName
argument_list|(
name|databaseProductName
argument_list|)
operator|.
name|withIdentifierQuoteString
argument_list|(
name|quoteString
argument_list|)
operator|.
name|withNullCollation
argument_list|(
name|nullCollation
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
specifier|private
name|String
name|databaseProductName
decl_stmt|;
specifier|private
name|String
name|quoteString
decl_stmt|;
specifier|private
specifier|final
name|NullCollation
name|nullCollation
decl_stmt|;
name|DatabaseProduct
parameter_list|(
name|String
name|databaseProductName
parameter_list|,
name|String
name|quoteString
parameter_list|,
name|NullCollation
name|nullCollation
parameter_list|)
block|{
name|this
operator|.
name|databaseProductName
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|databaseProductName
argument_list|)
expr_stmt|;
name|this
operator|.
name|quoteString
operator|=
name|quoteString
expr_stmt|;
name|this
operator|.
name|nullCollation
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|nullCollation
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns a dummy dialect for this database.      *      *<p>Since databases have many versions and flavors, this dummy dialect      * is at best an approximation. If you want exact information, better to      * use a dialect created from an actual connection's metadata      * (see {@link SqlDialectFactory#create(java.sql.DatabaseMetaData)}).      *      * @return Dialect representing lowest-common-denominator behavior for      * all versions of this database      */
specifier|public
name|SqlDialect
name|getDialect
parameter_list|()
block|{
return|return
name|dialect
operator|.
name|get
argument_list|()
return|;
block|}
block|}
comment|/** Information for creating a dialect.    *    *<p>It is immutable; to "set" a property, call one of the "with" methods,    * which returns a new context with the desired property value. */
specifier|public
interface|interface
name|Context
block|{
annotation|@
name|Nonnull
name|DatabaseProduct
name|databaseProduct
parameter_list|()
function_decl|;
name|Context
name|withDatabaseProduct
parameter_list|(
annotation|@
name|Nonnull
name|DatabaseProduct
name|databaseProduct
parameter_list|)
function_decl|;
name|String
name|databaseProductName
parameter_list|()
function_decl|;
name|Context
name|withDatabaseProductName
parameter_list|(
name|String
name|databaseProductName
parameter_list|)
function_decl|;
name|String
name|databaseVersion
parameter_list|()
function_decl|;
name|Context
name|withDatabaseVersion
parameter_list|(
name|String
name|databaseVersion
parameter_list|)
function_decl|;
name|int
name|databaseMajorVersion
parameter_list|()
function_decl|;
name|Context
name|withDatabaseMajorVersion
parameter_list|(
name|int
name|databaseMajorVersion
parameter_list|)
function_decl|;
name|int
name|databaseMinorVersion
parameter_list|()
function_decl|;
name|Context
name|withDatabaseMinorVersion
parameter_list|(
name|int
name|databaseMinorVersion
parameter_list|)
function_decl|;
name|String
name|identifierQuoteString
parameter_list|()
function_decl|;
name|Context
name|withIdentifierQuoteString
parameter_list|(
name|String
name|identifierQuoteString
parameter_list|)
function_decl|;
annotation|@
name|Nonnull
name|NullCollation
name|nullCollation
parameter_list|()
function_decl|;
name|Context
name|withNullCollation
parameter_list|(
annotation|@
name|Nonnull
name|NullCollation
name|nullCollation
parameter_list|)
function_decl|;
name|JethroDataSqlDialect
operator|.
name|JethroInfo
name|jethroInfo
parameter_list|()
function_decl|;
name|Context
name|withJethroInfo
parameter_list|(
name|JethroDataSqlDialect
operator|.
name|JethroInfo
name|jethroInfo
parameter_list|)
function_decl|;
block|}
comment|/** Implementation of Context. */
specifier|private
specifier|static
class|class
name|ContextImpl
implements|implements
name|Context
block|{
specifier|private
specifier|final
name|DatabaseProduct
name|databaseProduct
decl_stmt|;
specifier|private
specifier|final
name|String
name|databaseProductName
decl_stmt|;
specifier|private
specifier|final
name|String
name|databaseVersion
decl_stmt|;
specifier|private
specifier|final
name|int
name|databaseMajorVersion
decl_stmt|;
specifier|private
specifier|final
name|int
name|databaseMinorVersion
decl_stmt|;
specifier|private
specifier|final
name|String
name|identifierQuoteString
decl_stmt|;
specifier|private
specifier|final
name|NullCollation
name|nullCollation
decl_stmt|;
specifier|private
specifier|final
name|JethroDataSqlDialect
operator|.
name|JethroInfo
name|jethroInfo
decl_stmt|;
specifier|private
name|ContextImpl
parameter_list|(
name|DatabaseProduct
name|databaseProduct
parameter_list|,
name|String
name|databaseProductName
parameter_list|,
name|String
name|databaseVersion
parameter_list|,
name|int
name|databaseMajorVersion
parameter_list|,
name|int
name|databaseMinorVersion
parameter_list|,
name|String
name|identifierQuoteString
parameter_list|,
name|NullCollation
name|nullCollation
parameter_list|,
name|JethroDataSqlDialect
operator|.
name|JethroInfo
name|jethroInfo
parameter_list|)
block|{
name|this
operator|.
name|databaseProduct
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|databaseProduct
argument_list|)
expr_stmt|;
name|this
operator|.
name|databaseProductName
operator|=
name|databaseProductName
expr_stmt|;
name|this
operator|.
name|databaseVersion
operator|=
name|databaseVersion
expr_stmt|;
name|this
operator|.
name|databaseMajorVersion
operator|=
name|databaseMajorVersion
expr_stmt|;
name|this
operator|.
name|databaseMinorVersion
operator|=
name|databaseMinorVersion
expr_stmt|;
name|this
operator|.
name|identifierQuoteString
operator|=
name|identifierQuoteString
expr_stmt|;
name|this
operator|.
name|nullCollation
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|nullCollation
argument_list|)
expr_stmt|;
name|this
operator|.
name|jethroInfo
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|jethroInfo
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Nonnull
specifier|public
name|DatabaseProduct
name|databaseProduct
parameter_list|()
block|{
return|return
name|databaseProduct
return|;
block|}
specifier|public
name|Context
name|withDatabaseProduct
parameter_list|(
annotation|@
name|Nonnull
name|DatabaseProduct
name|databaseProduct
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|identifierQuoteString
argument_list|,
name|nullCollation
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
specifier|public
name|String
name|databaseProductName
parameter_list|()
block|{
return|return
name|databaseProductName
return|;
block|}
specifier|public
name|Context
name|withDatabaseProductName
parameter_list|(
name|String
name|databaseProductName
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|identifierQuoteString
argument_list|,
name|nullCollation
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
specifier|public
name|String
name|databaseVersion
parameter_list|()
block|{
return|return
name|databaseVersion
return|;
block|}
specifier|public
name|Context
name|withDatabaseVersion
parameter_list|(
name|String
name|databaseVersion
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|identifierQuoteString
argument_list|,
name|nullCollation
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
specifier|public
name|int
name|databaseMajorVersion
parameter_list|()
block|{
return|return
name|databaseMajorVersion
return|;
block|}
specifier|public
name|Context
name|withDatabaseMajorVersion
parameter_list|(
name|int
name|databaseMajorVersion
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|identifierQuoteString
argument_list|,
name|nullCollation
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
specifier|public
name|int
name|databaseMinorVersion
parameter_list|()
block|{
return|return
name|databaseMinorVersion
return|;
block|}
specifier|public
name|Context
name|withDatabaseMinorVersion
parameter_list|(
name|int
name|databaseMinorVersion
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|identifierQuoteString
argument_list|,
name|nullCollation
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
specifier|public
name|String
name|identifierQuoteString
parameter_list|()
block|{
return|return
name|identifierQuoteString
return|;
block|}
specifier|public
name|Context
name|withIdentifierQuoteString
parameter_list|(
name|String
name|identifierQuoteString
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|identifierQuoteString
argument_list|,
name|nullCollation
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Nonnull
specifier|public
name|NullCollation
name|nullCollation
parameter_list|()
block|{
return|return
name|nullCollation
return|;
block|}
specifier|public
name|Context
name|withNullCollation
parameter_list|(
annotation|@
name|Nonnull
name|NullCollation
name|nullCollation
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|identifierQuoteString
argument_list|,
name|nullCollation
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
annotation|@
name|Nonnull
specifier|public
name|JethroDataSqlDialect
operator|.
name|JethroInfo
name|jethroInfo
parameter_list|()
block|{
return|return
name|jethroInfo
return|;
block|}
specifier|public
name|Context
name|withJethroInfo
parameter_list|(
name|JethroDataSqlDialect
operator|.
name|JethroInfo
name|jethroInfo
parameter_list|)
block|{
return|return
operator|new
name|ContextImpl
argument_list|(
name|databaseProduct
argument_list|,
name|databaseProductName
argument_list|,
name|databaseVersion
argument_list|,
name|databaseMajorVersion
argument_list|,
name|databaseMinorVersion
argument_list|,
name|identifierQuoteString
argument_list|,
name|nullCollation
argument_list|,
name|jethroInfo
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End SqlDialect.java
end_comment

end_unit

