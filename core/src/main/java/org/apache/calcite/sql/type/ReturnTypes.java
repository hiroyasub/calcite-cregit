begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelProtoDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|ExplicitOperatorBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCallBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperatorBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorNamespace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Glossary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|UnaryOperator
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|NonNullableAccessors
operator|.
name|getCharset
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|NonNullableAccessors
operator|.
name|getCollation
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlNonNullableAccessors
operator|.
name|getNamespace
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
operator|.
name|RESOURCE
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * A collection of return-type inference strategies.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|ReturnTypes
block|{
specifier|private
name|ReturnTypes
parameter_list|()
block|{
block|}
comment|/** Creates a return-type inference that applies a rule then a sequence of    * rules, returning the first non-null result.    *    * @see SqlReturnTypeInference#orElse(SqlReturnTypeInference) */
specifier|public
specifier|static
name|SqlReturnTypeInferenceChain
name|chain
parameter_list|(
name|SqlReturnTypeInference
modifier|...
name|rules
parameter_list|)
block|{
return|return
operator|new
name|SqlReturnTypeInferenceChain
argument_list|(
name|rules
argument_list|)
return|;
block|}
comment|/** Creates a return-type inference that applies a rule then a sequence of    * transforms.    *    * @see SqlReturnTypeInference#andThen(SqlTypeTransform) */
specifier|public
specifier|static
name|SqlTypeTransformCascade
name|cascade
parameter_list|(
name|SqlReturnTypeInference
name|rule
parameter_list|,
name|SqlTypeTransform
modifier|...
name|transforms
parameter_list|)
block|{
return|return
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rule
argument_list|,
name|transforms
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|ExplicitReturnTypeInference
name|explicit
parameter_list|(
name|RelProtoDataType
name|protoType
parameter_list|)
block|{
return|return
operator|new
name|ExplicitReturnTypeInference
argument_list|(
name|protoType
argument_list|)
return|;
block|}
comment|/**    * Creates an inference rule which returns a copy of a given data type.    */
specifier|public
specifier|static
name|ExplicitReturnTypeInference
name|explicit
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|explicit
argument_list|(
name|RelDataTypeImpl
operator|.
name|proto
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates an inference rule which returns a type with no precision or scale,    * such as {@code DATE}.    */
specifier|public
specifier|static
name|ExplicitReturnTypeInference
name|explicit
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|)
block|{
return|return
name|explicit
argument_list|(
name|RelDataTypeImpl
operator|.
name|proto
argument_list|(
name|typeName
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates an inference rule which returns a type with precision but no scale,    * such as {@code VARCHAR(100)}.    */
specifier|public
specifier|static
name|ExplicitReturnTypeInference
name|explicit
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
return|return
name|explicit
argument_list|(
name|RelDataTypeImpl
operator|.
name|proto
argument_list|(
name|typeName
argument_list|,
name|precision
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns a return-type inference that first transforms a binding and    * then applies an inference.    *    *<p>{@link #stripOrderBy} is an example of {@code bindingTransform}. */
specifier|public
specifier|static
name|SqlReturnTypeInference
name|andThen
parameter_list|(
name|UnaryOperator
argument_list|<
name|SqlOperatorBinding
argument_list|>
name|bindingTransform
parameter_list|,
name|SqlReturnTypeInference
name|typeInference
parameter_list|)
block|{
return|return
name|opBinding
lambda|->
name|typeInference
operator|.
name|inferReturnType
argument_list|(
name|bindingTransform
operator|.
name|apply
argument_list|(
name|opBinding
argument_list|)
argument_list|)
return|;
block|}
comment|/** Converts a binding of {@code FOO(x, y ORDER BY z)}    * or {@code FOO(x, y ORDER BY z SEPARATOR s)}    * to a binding of {@code FOO(x, y)}.    * Used for {@code STRING_AGG} and {@code GROUP_CONCAT}. */
specifier|public
specifier|static
name|SqlOperatorBinding
name|stripOrderBy
parameter_list|(
name|SqlOperatorBinding
name|operatorBinding
parameter_list|)
block|{
if|if
condition|(
name|operatorBinding
operator|instanceof
name|SqlCallBinding
condition|)
block|{
specifier|final
name|SqlCallBinding
name|callBinding
init|=
operator|(
name|SqlCallBinding
operator|)
name|operatorBinding
decl_stmt|;
specifier|final
name|SqlCall
name|call2
init|=
name|stripSeparator
argument_list|(
name|callBinding
operator|.
name|getCall
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlCall
name|call3
init|=
name|stripOrderBy
argument_list|(
name|call2
argument_list|)
decl_stmt|;
if|if
condition|(
name|call3
operator|!=
name|callBinding
operator|.
name|getCall
argument_list|()
condition|)
block|{
return|return
operator|new
name|SqlCallBinding
argument_list|(
name|callBinding
operator|.
name|getValidator
argument_list|()
argument_list|,
name|callBinding
operator|.
name|getScope
argument_list|()
argument_list|,
name|call3
argument_list|)
return|;
block|}
block|}
return|return
name|operatorBinding
return|;
block|}
specifier|public
specifier|static
name|SqlCall
name|stripOrderBy
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
if|if
condition|(
operator|!
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|Util
operator|.
name|last
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
operator|instanceof
name|SqlNodeList
condition|)
block|{
comment|// Remove the last argument if it is "ORDER BY". The parser stashes the
comment|// ORDER BY clause in the argument list but it does not take part in
comment|// type derivation.
return|return
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getFunctionQuantifier
argument_list|()
argument_list|,
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|Util
operator|.
name|skipLast
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
return|return
name|call
return|;
block|}
specifier|public
specifier|static
name|SqlCall
name|stripSeparator
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
if|if
condition|(
operator|!
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|Util
operator|.
name|last
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|SEPARATOR
condition|)
block|{
comment|// Remove the last argument if it is "SEPARATOR literal".
return|return
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getFunctionQuantifier
argument_list|()
argument_list|,
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|Util
operator|.
name|skipLast
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
return|return
name|call
return|;
block|}
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the operand #0 (0-based).    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0
init|=
operator|new
name|OrdinalReturnTypeInference
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is VARYING the    * type of the first argument. The length returned is the same as length of    * the first argument. If any of the other operands are nullable the    * returned type will also be nullable. First Arg must be of string type.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_NULLABLE_VARYING
init|=
name|ARG0
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_VARYING
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the operand #0 (0-based). If any of the other operands are nullable the    * returned type will also be nullable.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_NULLABLE
init|=
name|ARG0
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the operand #0 (0-based), with nulls always allowed.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_FORCE_NULLABLE
init|=
name|ARG0
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|FORCE_NULLABLE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_INTERVAL
init|=
operator|new
name|MatchReturnTypeInference
argument_list|(
literal|0
argument_list|,
name|SqlTypeFamily
operator|.
name|DATETIME_INTERVAL
operator|.
name|getTypeNames
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_INTERVAL_NULLABLE
init|=
name|ARG0_INTERVAL
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the operand #0 (0-based), and nullable if the call occurs within a    * "GROUP BY ()" query. E.g. in "select sum(1) as s from empty", s may be    * null.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_NULLABLE_IF_EMPTY
init|=
operator|new
name|OrdinalReturnTypeInference
argument_list|(
literal|0
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|super
operator|.
name|inferReturnType
argument_list|(
name|opBinding
argument_list|)
decl_stmt|;
if|if
condition|(
name|opBinding
operator|.
name|getGroupCount
argument_list|()
operator|==
literal|0
operator|||
name|opBinding
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|type
return|;
block|}
block|}
block|}
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the operand #1 (0-based).    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG1
init|=
operator|new
name|OrdinalReturnTypeInference
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the operand #1 (0-based). If any of the other operands are nullable the    * returned type will also be nullable.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG1_NULLABLE
init|=
name|ARG1
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * operand #2 (0-based).    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG2
init|=
operator|new
name|OrdinalReturnTypeInference
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * operand #2 (0-based). If any of the other operands are nullable the    * returned type will also be nullable.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG2_NULLABLE
init|=
name|ARG2
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Boolean.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BOOLEAN
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Boolean,    * with nulls allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BOOLEAN_NULLABLE
init|=
name|BOOLEAN
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy with similar effect to {@link #BOOLEAN_NULLABLE},    * which is more efficient, but can only be used if all arguments are    * BOOLEAN.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BOOLEAN_NULLABLE_OPTIMIZED
init|=
name|opBinding
lambda|->
block|{
comment|// Equivalent to
comment|//   cascade(ARG0, SqlTypeTransforms.TO_NULLABLE);
comment|// but implemented by hand because used in AND, which is a very common
comment|// operator.
specifier|final
name|int
name|n
init|=
name|opBinding
operator|.
name|getOperandCount
argument_list|()
decl_stmt|;
name|RelDataType
name|type1
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|type1
operator|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|.
name|isNullable
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
return|return
name|type1
return|;
block|}
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is a nullable    * Boolean.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BOOLEAN_FORCE_NULLABLE
init|=
name|BOOLEAN
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|FORCE_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is BOOLEAN    * NOT NULL.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BOOLEAN_NOT_NULL
init|=
name|BOOLEAN
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NOT_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is DATE.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DATE
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|DATE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is nullable    * DATE.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DATE_NULLABLE
init|=
name|DATE
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is TIME(0).    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|TIME
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|TIME
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is nullable    * TIME(0).    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|TIME_NULLABLE
init|=
name|TIME
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is TIMESTAMP.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|TIMESTAMP
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is nullable    * TIMESTAMP.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|TIMESTAMP_NULLABLE
init|=
name|TIMESTAMP
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Double.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DOUBLE
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Double with    * nulls allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DOUBLE_NULLABLE
init|=
name|DOUBLE
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is a Char.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|CHAR
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is a nullable    * CHAR(1).    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|CHAR_FORCE_NULLABLE
init|=
name|CHAR
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|FORCE_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is an Integer.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|INTEGER
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is an Integer    * with nulls allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|INTEGER_NULLABLE
init|=
name|INTEGER
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is a BIGINT.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BIGINT
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is a nullable    * BIGINT.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BIGINT_FORCE_NULLABLE
init|=
name|BIGINT
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|FORCE_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is a BIGINT    * with nulls allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BIGINT_NULLABLE
init|=
name|BIGINT
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy that always returns "VARCHAR(4)".    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|VARCHAR_4
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|4
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy that always returns "VARCHAR(4)" with nulls    * allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|VARCHAR_4_NULLABLE
init|=
name|VARCHAR_4
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy that always returns "VARCHAR(2000)".    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|VARCHAR_2000
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|2000
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy that always returns "VARCHAR(2000)" with nulls    * allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|VARCHAR_2000_NULLABLE
init|=
name|VARCHAR_2000
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy for Histogram agg support.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|HISTOGRAM
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|VARBINARY
argument_list|,
literal|8
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy that always returns "CURSOR".    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|CURSOR
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|CURSOR
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy that always returns "COLUMN_LIST".    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|COLUMN_LIST
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|COLUMN_LIST
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is using its    * operands biggest type, using the SQL:1999 rules described in "Data types    * of results of aggregations". These rules are used in union, except,    * intersect, case and other places.    *    * @see Glossary#SQL99 SQL:1999 Part 2 Section 9.3    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|LEAST_RESTRICTIVE
init|=
name|opBinding
lambda|->
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|leastRestrictive
argument_list|(
name|opBinding
operator|.
name|collectOperandTypes
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Returns the same type as the multiset carries. The multiset type returned    * is the least restrictive of the call's multiset operands    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTISET
init|=
name|opBinding
lambda|->
block|{
name|ExplicitOperatorBinding
name|newBinding
init|=
operator|new
name|ExplicitOperatorBinding
argument_list|(
name|opBinding
argument_list|,
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
comment|// CHECKSTYLE: IGNORE 12
annotation|@
name|Override
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
name|index
argument_list|)
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
assert|assert
name|type
operator|!=
literal|null
assert|;
return|return
name|type
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|opBinding
operator|.
name|getOperandCount
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|RelDataType
name|biggestElementType
init|=
name|LEAST_RESTRICTIVE
operator|.
name|inferReturnType
argument_list|(
name|newBinding
argument_list|)
decl_stmt|;
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createMultisetType
argument_list|(
name|requireNonNull
argument_list|(
name|biggestElementType
argument_list|,
parameter_list|()
lambda|->
literal|"can't infer element type for multiset of "
operator|+
name|newBinding
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Returns a MULTISET type.    *    *<p>For example, given<code>INTEGER</code>, returns    *<code>INTEGER MULTISET</code>.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|TO_MULTISET
init|=
name|ARG0
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_MULTISET
argument_list|)
decl_stmt|;
comment|/**    * Returns the element type of a MULTISET.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTISET_ELEMENT_NULLABLE
init|=
name|MULTISET
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_MULTISET_ELEMENT_TYPE
argument_list|)
decl_stmt|;
comment|/**    * Same as {@link #MULTISET} but returns with nullability if any of the    * operands is nullable.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTISET_NULLABLE
init|=
name|MULTISET
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Returns the type of the only column of a multiset.    *    *<p>For example, given<code>RECORD(x INTEGER) MULTISET</code>, returns    *<code>INTEGER MULTISET</code>.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTISET_PROJECT_ONLY
init|=
name|MULTISET
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|ONLY_COLUMN
argument_list|)
decl_stmt|;
comment|/**    * Returns an ARRAY type.    *    *<p>For example, given<code>INTEGER</code>, returns    *<code>INTEGER ARRAY</code>.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|TO_ARRAY
init|=
name|ARG0
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_ARRAY
argument_list|)
decl_stmt|;
comment|/**    * Returns a MAP type.    *    *<p>For example, given {@code Record(f0: INTEGER, f1: DATE)}, returns    * {@code (INTEGER, DATE) MAP}.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|TO_MAP
init|=
name|ARG0
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_MAP
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy that always returns GEOMETRY.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|GEOMETRY
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|GEOMETRY
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is    * {@link #ARG0_INTERVAL_NULLABLE} and {@link #LEAST_RESTRICTIVE}. These rules    * are used for integer division.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|INTEGER_QUOTIENT_NULLABLE
init|=
name|ARG0_INTERVAL_NULLABLE
operator|.
name|orElse
argument_list|(
name|LEAST_RESTRICTIVE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy for a call where the first argument is a decimal.    * The result type of a call is a decimal with a scale of 0, and the same    * precision and nullability as the first argument.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_SCALE0
init|=
name|opBinding
lambda|->
block|{
name|RelDataType
name|type1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|type1
argument_list|)
condition|)
block|{
if|if
condition|(
name|type1
operator|.
name|getScale
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|type1
return|;
block|}
else|else
block|{
name|int
name|p
init|=
name|type1
operator|.
name|getPrecision
argument_list|()
decl_stmt|;
name|RelDataType
name|ret
decl_stmt|;
name|ret
operator|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|ret
operator|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|ret
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is    * {@link #DECIMAL_SCALE0} with a fallback to {@link #ARG0} This rule    * is used for floor, ceiling.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_OR_EXACT_NO_SCALE
init|=
name|DECIMAL_SCALE0
operator|.
name|orElse
argument_list|(
name|ARG0
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the decimal    * product of two exact numeric operands where at least one of the operands    * is a decimal.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_PRODUCT
init|=
name|opBinding
lambda|->
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|RelDataType
name|type1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|type2
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveDecimalMultiplyType
argument_list|(
name|typeFactory
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Same as {@link #DECIMAL_PRODUCT} but returns with nullability if any of    * the operands is nullable by using    * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_NULLABLE}.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_PRODUCT_NULLABLE
init|=
name|DECIMAL_PRODUCT
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is    * {@link #DECIMAL_PRODUCT_NULLABLE} with a fallback to    * {@link #ARG0_INTERVAL_NULLABLE}    * and {@link #LEAST_RESTRICTIVE}.    * These rules are used for multiplication.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|PRODUCT_NULLABLE
init|=
name|DECIMAL_PRODUCT_NULLABLE
operator|.
name|orElse
argument_list|(
name|ARG0_INTERVAL_NULLABLE
argument_list|)
operator|.
name|orElse
argument_list|(
name|LEAST_RESTRICTIVE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the decimal    * quotient of two exact numeric operands where at least one of the operands    * is a decimal.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_QUOTIENT
init|=
name|opBinding
lambda|->
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|RelDataType
name|type1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|type2
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveDecimalDivideType
argument_list|(
name|typeFactory
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Same as {@link #DECIMAL_QUOTIENT} but returns with nullability if any of    * the operands is nullable by using    * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_NULLABLE}.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_QUOTIENT_NULLABLE
init|=
name|DECIMAL_QUOTIENT
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is    * {@link #DECIMAL_QUOTIENT_NULLABLE} with a fallback to    * {@link #ARG0_INTERVAL_NULLABLE} and {@link #LEAST_RESTRICTIVE}. These rules    * are used for division.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|QUOTIENT_NULLABLE
init|=
name|DECIMAL_QUOTIENT_NULLABLE
operator|.
name|orElse
argument_list|(
name|ARG0_INTERVAL_NULLABLE
argument_list|)
operator|.
name|orElse
argument_list|(
name|LEAST_RESTRICTIVE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the decimal    * sum of two exact numeric operands where at least one of the operands is a    * decimal.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_SUM
init|=
name|opBinding
lambda|->
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|RelDataType
name|type1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|type2
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveDecimalPlusType
argument_list|(
name|typeFactory
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Same as {@link #DECIMAL_SUM} but returns with nullability if any    * of the operands is nullable by using    * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_NULLABLE}.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_SUM_NULLABLE
init|=
name|DECIMAL_SUM
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is    * {@link #DECIMAL_SUM_NULLABLE} with a fallback to {@link #LEAST_RESTRICTIVE}    * These rules are used for addition and subtraction.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|NULLABLE_SUM
init|=
operator|new
name|SqlReturnTypeInferenceChain
argument_list|(
name|DECIMAL_SUM_NULLABLE
argument_list|,
name|LEAST_RESTRICTIVE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_MOD
init|=
name|opBinding
lambda|->
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|RelDataType
name|type1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|type2
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveDecimalModType
argument_list|(
name|typeFactory
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the decimal    * modulus of two exact numeric operands where at least one of the operands is a    * decimal.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_MOD_NULLABLE
init|=
name|DECIMAL_MOD
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is    * {@link #DECIMAL_MOD_NULLABLE} with a fallback to {@link #ARG1_NULLABLE}    * These rules are used for modulus.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|NULLABLE_MOD
init|=
name|DECIMAL_MOD_NULLABLE
operator|.
name|orElse
argument_list|(
name|ARG1_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy for concatenating two string arguments. The result    * type of a call is:    *    *<ul>    *<li>the same type as the input types but with the combined length of the    * two first types</li>    *<li>if types are of char type the type with the highest coercibility will    * be used</li>    *<li>result is varying if either input is; otherwise fixed    *</ul>    *    *<p>Pre-requisites:    *    *<ul>    *<li>input types must be of the same string type    *<li>types must be comparable without casting    *</ul>    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DYADIC_STRING_SUM_PRECISION
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataType
name|argType0
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|argType1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|containsAnyType
init|=
operator|(
name|argType0
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
operator|)
operator|||
operator|(
name|argType1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
operator|)
decl_stmt|;
specifier|final
name|boolean
name|containsNullType
init|=
operator|(
name|argType0
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
operator|)
operator|||
operator|(
name|argType1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|containsAnyType
operator|&&
operator|!
name|containsNullType
operator|&&
operator|!
operator|(
name|SqlTypeUtil
operator|.
name|inCharOrBinaryFamilies
argument_list|(
name|argType0
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|inCharOrBinaryFamilies
argument_list|(
name|argType1
argument_list|)
operator|)
condition|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|SqlTypeUtil
operator|.
name|sameNamedType
argument_list|(
name|argType0
argument_list|,
name|argType1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SqlCollation
name|pickedCollation
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|containsAnyType
operator|&&
operator|!
name|containsNullType
operator|&&
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|argType0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|isCharTypeComparable
argument_list|(
name|opBinding
operator|.
name|collectOperandTypes
argument_list|()
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
name|opBinding
operator|.
name|newError
argument_list|(
name|RESOURCE
operator|.
name|typeNotComparable
argument_list|(
name|argType0
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|argType1
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|pickedCollation
operator|=
name|requireNonNull
argument_list|(
name|SqlCollation
operator|.
name|getCoercibilityDyadicOperator
argument_list|(
name|getCollation
argument_list|(
name|argType0
argument_list|)
argument_list|,
name|getCollation
argument_list|(
name|argType1
argument_list|)
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"getCoercibilityDyadicOperator is null for "
operator|+
name|argType0
operator|+
literal|" and "
operator|+
name|argType1
argument_list|)
expr_stmt|;
block|}
comment|// Determine whether result is variable-length
name|SqlTypeName
name|typeName
init|=
name|argType0
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isBoundedVariableWidth
argument_list|(
name|argType1
argument_list|)
condition|)
block|{
name|typeName
operator|=
name|argType1
operator|.
name|getSqlTypeName
argument_list|()
expr_stmt|;
block|}
name|RelDataType
name|ret
decl_stmt|;
name|int
name|typePrecision
decl_stmt|;
specifier|final
name|long
name|x
init|=
operator|(
name|long
operator|)
name|argType0
operator|.
name|getPrecision
argument_list|()
operator|+
operator|(
name|long
operator|)
name|argType1
operator|.
name|getPrecision
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeSystem
name|typeSystem
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
decl_stmt|;
if|if
condition|(
name|argType0
operator|.
name|getPrecision
argument_list|()
operator|==
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
operator|||
name|argType1
operator|.
name|getPrecision
argument_list|()
operator|==
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
operator|||
name|x
operator|>
name|typeSystem
operator|.
name|getMaxPrecision
argument_list|(
name|typeName
argument_list|)
condition|)
block|{
name|typePrecision
operator|=
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
expr_stmt|;
block|}
else|else
block|{
name|typePrecision
operator|=
operator|(
name|int
operator|)
name|x
expr_stmt|;
block|}
name|ret
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|,
name|typePrecision
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|pickedCollation
condition|)
block|{
name|RelDataType
name|pickedType
decl_stmt|;
if|if
condition|(
name|getCollation
argument_list|(
name|argType0
argument_list|)
operator|.
name|equals
argument_list|(
name|pickedCollation
argument_list|)
condition|)
block|{
name|pickedType
operator|=
name|argType0
expr_stmt|;
block|}
if|else if
condition|(
name|getCollation
argument_list|(
name|argType1
argument_list|)
operator|.
name|equals
argument_list|(
name|pickedCollation
argument_list|)
condition|)
block|{
name|pickedType
operator|=
name|argType1
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"should never come here, "
operator|+
literal|"argType0="
operator|+
name|argType0
operator|+
literal|", argType1="
operator|+
name|argType1
argument_list|)
throw|;
block|}
name|ret
operator|=
name|typeFactory
operator|.
name|createTypeWithCharsetAndCollation
argument_list|(
name|ret
argument_list|,
name|getCharset
argument_list|(
name|pickedType
argument_list|)
argument_list|,
name|getCollation
argument_list|(
name|pickedType
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
condition|)
block|{
name|ret
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
decl_stmt|;
comment|/**    * Type-inference strategy for String concatenation.    * Result is varying if either input is; otherwise fixed.    * For example,    *    *<p>concat(cast('a' as varchar(2)), cast('b' as varchar(3)),cast('c' as varchar(2)))    * returns varchar(7).</p>    *    *<p>concat(cast('a' as varchar), cast('b' as varchar(2), cast('c' as varchar(2))))    * returns varchar.</p>    *    *<p>concat(cast('a' as varchar(65535)), cast('b' as varchar(2)), cast('c' as varchar(2)))    * returns varchar.</p>    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTIVALENT_STRING_SUM_PRECISION
init|=
name|opBinding
lambda|->
block|{
name|boolean
name|hasPrecisionNotSpecifiedOperand
init|=
literal|false
decl_stmt|;
name|boolean
name|precisionOverflow
init|=
literal|false
decl_stmt|;
name|int
name|typePrecision
decl_stmt|;
name|long
name|amount
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|RelDataType
argument_list|>
name|operandTypes
init|=
name|opBinding
operator|.
name|collectOperandTypes
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeSystem
name|typeSystem
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataType
name|operandType
range|:
name|operandTypes
control|)
block|{
name|int
name|operandPrecision
init|=
name|operandType
operator|.
name|getPrecision
argument_list|()
decl_stmt|;
name|amount
operator|=
operator|(
name|long
operator|)
name|operandPrecision
operator|+
name|amount
expr_stmt|;
if|if
condition|(
name|operandPrecision
operator|==
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
condition|)
block|{
name|hasPrecisionNotSpecifiedOperand
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|amount
operator|>
name|typeSystem
operator|.
name|getMaxPrecision
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
condition|)
block|{
name|precisionOverflow
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|hasPrecisionNotSpecifiedOperand
operator|||
name|precisionOverflow
condition|)
block|{
name|typePrecision
operator|=
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
expr_stmt|;
block|}
else|else
block|{
name|typePrecision
operator|=
operator|(
name|int
operator|)
name|amount
expr_stmt|;
block|}
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
name|typePrecision
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Same as {@link #MULTIVALENT_STRING_SUM_PRECISION} and using    * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_NULLABLE}.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTIVALENT_STRING_SUM_PRECISION_NULLABLE
init|=
name|MULTIVALENT_STRING_SUM_PRECISION
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Same as {@link #DYADIC_STRING_SUM_PRECISION} and using    * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_NULLABLE},    * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_VARYING}.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DYADIC_STRING_SUM_PRECISION_NULLABLE_VARYING
init|=
name|DYADIC_STRING_SUM_PRECISION
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_VARYING
argument_list|)
decl_stmt|;
comment|/**    * Same as {@link #DYADIC_STRING_SUM_PRECISION} and using    * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_NULLABLE}.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DYADIC_STRING_SUM_PRECISION_NULLABLE
init|=
name|DYADIC_STRING_SUM_PRECISION
operator|.
name|andThen
argument_list|(
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy where the expression is assumed to be registered    * as a {@link org.apache.calcite.sql.validate.SqlValidatorNamespace}, and    * therefore the result type of the call is the type of that namespace.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|SCOPE
init|=
name|opBinding
lambda|->
block|{
name|SqlCallBinding
name|callBinding
init|=
operator|(
name|SqlCallBinding
operator|)
name|opBinding
decl_stmt|;
name|SqlValidatorNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|callBinding
argument_list|)
decl_stmt|;
return|return
name|ns
operator|.
name|getRowType
argument_list|()
return|;
block|}
decl_stmt|;
comment|/**    * Returns a multiset of column #0 of a multiset. For example, given    *<code>RECORD(x INTEGER, y DATE) MULTISET</code>, returns<code>INTEGER    * MULTISET</code>.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTISET_PROJECT0
init|=
name|opBinding
lambda|->
block|{
assert|assert
name|opBinding
operator|.
name|getOperandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|RelDataType
name|recordMultisetType
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|multisetType
init|=
name|recordMultisetType
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
assert|assert
name|multisetType
operator|!=
literal|null
operator|:
literal|"expected a multiset type: "
operator|+
name|recordMultisetType
assert|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|multisetType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|fields
operator|.
name|size
argument_list|()
operator|>
literal|0
assert|;
specifier|final
name|RelDataType
name|firstColType
init|=
name|fields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createMultisetType
argument_list|(
name|firstColType
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Returns a multiset of the first column of a multiset. For example, given    *<code>INTEGER MULTISET</code>, returns<code>RECORD(x INTEGER)    * MULTISET</code>.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTISET_RECORD
init|=
name|opBinding
lambda|->
block|{
assert|assert
name|opBinding
operator|.
name|getOperandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|RelDataType
name|multisetType
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|componentType
init|=
name|multisetType
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
assert|assert
name|componentType
operator|!=
literal|null
operator|:
literal|"expected a multiset type: "
operator|+
name|multisetType
assert|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
name|SqlUtil
operator|.
name|deriveAliasFromOrdinal
argument_list|(
literal|0
argument_list|)
argument_list|,
name|componentType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createMultisetType
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Returns the field type of a structured type which has only one field. For    * example, given {@code RECORD(x INTEGER)} returns {@code INTEGER}.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|RECORD_TO_SCALAR
init|=
name|opBinding
lambda|->
block|{
assert|assert
name|opBinding
operator|.
name|getOperandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|RelDataType
name|recordType
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|boolean
name|isStruct
init|=
name|recordType
operator|.
name|isStruct
argument_list|()
decl_stmt|;
name|int
name|fieldCount
init|=
name|recordType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
name|isStruct
operator|&&
operator|(
name|fieldCount
operator|==
literal|1
operator|)
assert|;
name|RelDataTypeField
name|fieldType
init|=
name|recordType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|fieldType
operator|!=
literal|null
operator|:
literal|"expected a record type with one field: "
operator|+
name|recordType
assert|;
specifier|final
name|RelDataType
name|firstColType
init|=
name|fieldType
operator|.
name|getType
argument_list|()
decl_stmt|;
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|firstColType
argument_list|,
literal|true
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Type-inference strategy for SUM aggregate function inferred from the    * operand type, and nullable if the call occurs within a "GROUP BY ()"    * query. E.g. in "select sum(x) as s from empty", s may be null. Also,    * with the default implementation of RelDataTypeSystem, s has the same    * type name as x.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|AGG_SUM
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveSumType
argument_list|(
name|typeFactory
argument_list|,
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|opBinding
operator|.
name|getGroupCount
argument_list|()
operator|==
literal|0
operator|||
name|opBinding
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|type
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Type-inference strategy for $SUM0 aggregate function inferred from the    * operand type. By default the inferred type is identical to the operand    * type. E.g. in "select $sum0(x) as s from empty", s has the same type as    * x.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|AGG_SUM_EMPTY_IS_ZERO
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|sumType
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveSumType
argument_list|(
name|typeFactory
argument_list|,
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// SUM0 should not return null.
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|sumType
argument_list|,
literal|false
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Type-inference strategy for the {@code CUME_DIST} and {@code PERCENT_RANK}    * aggregate functions.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|FRACTIONAL_RANK
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
return|return
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveFractionalRankType
argument_list|(
name|typeFactory
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Type-inference strategy for the {@code NTILE}, {@code RANK},    * {@code DENSE_RANK}, and {@code ROW_NUMBER} aggregate functions.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|RANK
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
return|return
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveRankType
argument_list|(
name|typeFactory
argument_list|)
return|;
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|AVG_AGG_FUNCTION
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|relDataType
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveAvgAggType
argument_list|(
name|typeFactory
argument_list|,
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|opBinding
operator|.
name|getGroupCount
argument_list|()
operator|==
literal|0
operator|||
name|opBinding
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|relDataType
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|relDataType
return|;
block|}
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|COVAR_REGR_FUNCTION
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|relDataType
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveCovarType
argument_list|(
name|typeFactory
argument_list|,
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
argument_list|,
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|opBinding
operator|.
name|getGroupCount
argument_list|()
operator|==
literal|0
operator|||
name|opBinding
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|relDataType
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|relDataType
return|;
block|}
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|PERCENTILE_DISC
init|=
name|opBinding
lambda|->
name|opBinding
operator|.
name|getCollationType
argument_list|()
decl_stmt|;
block|}
end_class

end_unit

