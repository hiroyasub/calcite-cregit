begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelProtoDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|ExplicitOperatorBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCallBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperatorBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Glossary
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
operator|.
name|RESOURCE
import|;
end_import

begin_comment
comment|/**  * A collection of return-type inference strategies.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|ReturnTypes
block|{
specifier|private
name|ReturnTypes
parameter_list|()
block|{
block|}
specifier|public
specifier|static
name|SqlReturnTypeInferenceChain
name|chain
parameter_list|(
name|SqlReturnTypeInference
modifier|...
name|rules
parameter_list|)
block|{
return|return
operator|new
name|SqlReturnTypeInferenceChain
argument_list|(
name|rules
argument_list|)
return|;
block|}
comment|/** Creates a return-type inference that applies a rule then a sequence of    * transforms. */
specifier|public
specifier|static
name|SqlTypeTransformCascade
name|cascade
parameter_list|(
name|SqlReturnTypeInference
name|rule
parameter_list|,
name|SqlTypeTransform
modifier|...
name|transforms
parameter_list|)
block|{
return|return
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rule
argument_list|,
name|transforms
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|ExplicitReturnTypeInference
name|explicit
parameter_list|(
name|RelProtoDataType
name|protoType
parameter_list|)
block|{
return|return
operator|new
name|ExplicitReturnTypeInference
argument_list|(
name|protoType
argument_list|)
return|;
block|}
comment|/**    * Creates an inference rule which returns a copy of a given data type.    */
specifier|public
specifier|static
name|ExplicitReturnTypeInference
name|explicit
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|explicit
argument_list|(
name|RelDataTypeImpl
operator|.
name|proto
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates an inference rule which returns a type with no precision or scale,    * such as {@code DATE}.    */
specifier|public
specifier|static
name|ExplicitReturnTypeInference
name|explicit
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|)
block|{
return|return
name|explicit
argument_list|(
name|RelDataTypeImpl
operator|.
name|proto
argument_list|(
name|typeName
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates an inference rule which returns a type with precision but no scale,    * such as {@code VARCHAR(100)}.    */
specifier|public
specifier|static
name|ExplicitReturnTypeInference
name|explicit
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
return|return
name|explicit
argument_list|(
name|RelDataTypeImpl
operator|.
name|proto
argument_list|(
name|typeName
argument_list|,
name|precision
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the operand #0 (0-based).    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0
init|=
operator|new
name|OrdinalReturnTypeInference
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is VARYING the    * type of the first argument. The length returned is the same as length of    * the first argument. If any of the other operands are nullable the    * returned type will also be nullable. First Arg must be of string type.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_NULLABLE_VARYING
init|=
name|cascade
argument_list|(
name|ARG0
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_VARYING
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the operand #0 (0-based). If any of the other operands are nullable the    * returned type will also be nullable.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_NULLABLE
init|=
name|cascade
argument_list|(
name|ARG0
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the operand #0 (0-based), with nulls always allowed.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_FORCE_NULLABLE
init|=
name|cascade
argument_list|(
name|ARG0
argument_list|,
name|SqlTypeTransforms
operator|.
name|FORCE_NULLABLE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_INTERVAL
init|=
operator|new
name|MatchReturnTypeInference
argument_list|(
literal|0
argument_list|,
name|SqlTypeFamily
operator|.
name|DATETIME_INTERVAL
operator|.
name|getTypeNames
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_INTERVAL_NULLABLE
init|=
name|cascade
argument_list|(
name|ARG0_INTERVAL
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the operand #0 (0-based), and nullable if the call occurs within a    * "GROUP BY ()" query. E.g. in "select sum(1) as s from empty", s may be    * null.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_NULLABLE_IF_EMPTY
init|=
operator|new
name|OrdinalReturnTypeInference
argument_list|(
literal|0
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|super
operator|.
name|inferReturnType
argument_list|(
name|opBinding
argument_list|)
decl_stmt|;
if|if
condition|(
name|opBinding
operator|.
name|getGroupCount
argument_list|()
operator|==
literal|0
operator|||
name|opBinding
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|type
return|;
block|}
block|}
block|}
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the operand #1 (0-based).    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG1
init|=
operator|new
name|OrdinalReturnTypeInference
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the operand #1 (0-based). If any of the other operands are nullable the    * returned type will also be nullable.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG1_NULLABLE
init|=
name|cascade
argument_list|(
name|ARG1
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * operand #2 (0-based).    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG2
init|=
operator|new
name|OrdinalReturnTypeInference
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * operand #2 (0-based). If any of the other operands are nullable the    * returned type will also be nullable.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG2_NULLABLE
init|=
name|cascade
argument_list|(
name|ARG2
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Boolean.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BOOLEAN
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Boolean,    * with nulls allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BOOLEAN_NULLABLE
init|=
name|cascade
argument_list|(
name|BOOLEAN
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy with similar effect to {@link #BOOLEAN_NULLABLE},    * which is more efficient, but can only be used if all arguments are    * BOOLEAN.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BOOLEAN_NULLABLE_OPTIMIZED
init|=
name|opBinding
lambda|->
block|{
comment|// Equivalent to
comment|//   cascade(ARG0, SqlTypeTransforms.TO_NULLABLE);
comment|// but implemented by hand because used in AND, which is a very common
comment|// operator.
specifier|final
name|int
name|n
init|=
name|opBinding
operator|.
name|getOperandCount
argument_list|()
decl_stmt|;
name|RelDataType
name|type1
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|type1
operator|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|.
name|isNullable
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
return|return
name|type1
return|;
block|}
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is a nullable Boolean.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BOOLEAN_FORCE_NULLABLE
init|=
name|cascade
argument_list|(
name|BOOLEAN
argument_list|,
name|SqlTypeTransforms
operator|.
name|FORCE_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Boolean    * not null.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BOOLEAN_NOT_NULL
init|=
name|cascade
argument_list|(
name|BOOLEAN
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NOT_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Date.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DATE
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|DATE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Time(0).    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|TIME
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|TIME
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is nullable    * Time(0).    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|TIME_NULLABLE
init|=
name|cascade
argument_list|(
name|TIME
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Double.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DOUBLE
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Double with    * nulls allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DOUBLE_NULLABLE
init|=
name|cascade
argument_list|(
name|DOUBLE
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is an Integer.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|INTEGER
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is an Integer    * with nulls allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|INTEGER_NULLABLE
init|=
name|cascade
argument_list|(
name|INTEGER
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is a Bigint    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BIGINT
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is a nullable    * Bigint    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BIGINT_FORCE_NULLABLE
init|=
name|cascade
argument_list|(
name|BIGINT
argument_list|,
name|SqlTypeTransforms
operator|.
name|FORCE_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is an Bigint    * with nulls allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|BIGINT_NULLABLE
init|=
name|cascade
argument_list|(
name|BIGINT
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy that always returns "VARCHAR(2000)".    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|VARCHAR_2000
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|2000
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy for Histogram agg support    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|HISTOGRAM
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|VARBINARY
argument_list|,
literal|8
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy that always returns "CURSOR".    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|CURSOR
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|CURSOR
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy that always returns "COLUMN_LIST".    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|COLUMN_LIST
init|=
name|explicit
argument_list|(
name|SqlTypeName
operator|.
name|COLUMN_LIST
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is using its    * operands biggest type, using the SQL:1999 rules described in "Data types    * of results of aggregations". These rules are used in union, except,    * intersect, case and other places.    *    * @see Glossary#SQL99 SQL:1999 Part 2 Section 9.3    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|LEAST_RESTRICTIVE
init|=
name|opBinding
lambda|->
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|leastRestrictive
argument_list|(
name|opBinding
operator|.
name|collectOperandTypes
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Returns the same type as the multiset carries. The multiset type returned    * is the least restrictive of the call's multiset operands    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTISET
init|=
name|opBinding
lambda|->
block|{
name|ExplicitOperatorBinding
name|newBinding
init|=
operator|new
name|ExplicitOperatorBinding
argument_list|(
name|opBinding
argument_list|,
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
comment|// CHECKSTYLE: IGNORE 12
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
name|index
argument_list|)
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
assert|assert
name|type
operator|!=
literal|null
assert|;
return|return
name|type
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|opBinding
operator|.
name|getOperandCount
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|RelDataType
name|biggestElementType
init|=
name|LEAST_RESTRICTIVE
operator|.
name|inferReturnType
argument_list|(
name|newBinding
argument_list|)
decl_stmt|;
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createMultisetType
argument_list|(
name|biggestElementType
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Returns a multiset type.    *    *<p>For example, given<code>INTEGER</code>, returns    *<code>INTEGER MULTISET</code>.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|TO_MULTISET
init|=
name|cascade
argument_list|(
name|ARG0
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_MULTISET
argument_list|)
decl_stmt|;
comment|/**    * Returns the element type of a multiset    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTISET_ELEMENT_NULLABLE
init|=
name|cascade
argument_list|(
name|MULTISET
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_MULTISET_ELEMENT_TYPE
argument_list|)
decl_stmt|;
comment|/**    * Same as {@link #MULTISET} but returns with nullability if any of the    * operands is nullable.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTISET_NULLABLE
init|=
name|cascade
argument_list|(
name|MULTISET
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Returns the type of the only column of a multiset.    *    *<p>For example, given<code>RECORD(x INTEGER) MULTISET</code>, returns    *<code>INTEGER MULTISET</code>.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTISET_PROJECT_ONLY
init|=
name|cascade
argument_list|(
name|MULTISET
argument_list|,
name|SqlTypeTransforms
operator|.
name|ONLY_COLUMN
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is    * {@link #ARG0_INTERVAL_NULLABLE} and {@link #LEAST_RESTRICTIVE}. These rules    * are used for integer division.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|INTEGER_QUOTIENT_NULLABLE
init|=
name|chain
argument_list|(
name|ARG0_INTERVAL_NULLABLE
argument_list|,
name|LEAST_RESTRICTIVE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy for a call where the first argument is a decimal.    * The result type of a call is a decimal with a scale of 0, and the same    * precision and nullability as the first argument.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_SCALE0
init|=
name|opBinding
lambda|->
block|{
name|RelDataType
name|type1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|type1
argument_list|)
condition|)
block|{
if|if
condition|(
name|type1
operator|.
name|getScale
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|type1
return|;
block|}
else|else
block|{
name|int
name|p
init|=
name|type1
operator|.
name|getPrecision
argument_list|()
decl_stmt|;
name|RelDataType
name|ret
decl_stmt|;
name|ret
operator|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|ret
operator|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|ret
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is    * {@link #DECIMAL_SCALE0} with a fallback to {@link #ARG0} This rule    * is used for floor, ceiling.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|ARG0_OR_EXACT_NO_SCALE
init|=
name|chain
argument_list|(
name|DECIMAL_SCALE0
argument_list|,
name|ARG0
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the decimal    * product of two exact numeric operands where at least one of the operands    * is a decimal.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_PRODUCT
init|=
name|opBinding
lambda|->
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|RelDataType
name|type1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|type2
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createDecimalProduct
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Same as {@link #DECIMAL_PRODUCT} but returns with nullability if any of    * the operands is nullable by using    * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_NULLABLE}    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_PRODUCT_NULLABLE
init|=
name|cascade
argument_list|(
name|DECIMAL_PRODUCT
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is    * {@link #DECIMAL_PRODUCT_NULLABLE} with a fallback to    * {@link #ARG0_INTERVAL_NULLABLE}    * and {@link #LEAST_RESTRICTIVE}.    * These rules are used for multiplication.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|PRODUCT_NULLABLE
init|=
name|chain
argument_list|(
name|DECIMAL_PRODUCT_NULLABLE
argument_list|,
name|ARG0_INTERVAL_NULLABLE
argument_list|,
name|LEAST_RESTRICTIVE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the decimal    * product of two exact numeric operands where at least one of the operands    * is a decimal.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_QUOTIENT
init|=
name|opBinding
lambda|->
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|RelDataType
name|type1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|type2
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createDecimalQuotient
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Same as {@link #DECIMAL_QUOTIENT} but returns with nullability if any of    * the operands is nullable by using    * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_NULLABLE}    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_QUOTIENT_NULLABLE
init|=
name|cascade
argument_list|(
name|DECIMAL_QUOTIENT
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is    * {@link #DECIMAL_QUOTIENT_NULLABLE} with a fallback to    * {@link #ARG0_INTERVAL_NULLABLE} and {@link #LEAST_RESTRICTIVE} These rules    * are used for division.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|QUOTIENT_NULLABLE
init|=
name|chain
argument_list|(
name|DECIMAL_QUOTIENT_NULLABLE
argument_list|,
name|ARG0_INTERVAL_NULLABLE
argument_list|,
name|LEAST_RESTRICTIVE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the decimal    * sum of two exact numeric operands where at least one of the operands is a    * decimal. Let p1, s1 be the precision and scale of the first operand Let    * p2, s2 be the precision and scale of the second operand Let p, s be the    * precision and scale of the result, Then the result type is a decimal    * with:    *    *<ul>    *<li>s = max(s1, s2)</li>    *<li>p = max(p1 - s1, p2 - s2) + s + 1</li>    *</ul>    *    *<p>p and s are capped at their maximum values    *    * @see Glossary#SQL2003 SQL:2003 Part 2 Section 6.26    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_SUM
init|=
name|opBinding
lambda|->
block|{
name|RelDataType
name|type1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|type2
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|type1
argument_list|)
operator|||
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|int
name|p1
init|=
name|type1
operator|.
name|getPrecision
argument_list|()
decl_stmt|;
name|int
name|p2
init|=
name|type2
operator|.
name|getPrecision
argument_list|()
decl_stmt|;
name|int
name|s1
init|=
name|type1
operator|.
name|getScale
argument_list|()
decl_stmt|;
name|int
name|s2
init|=
name|type2
operator|.
name|getScale
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|int
name|scale
init|=
name|Math
operator|.
name|max
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeSystem
name|typeSystem
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
decl_stmt|;
assert|assert
name|scale
operator|<=
name|typeSystem
operator|.
name|getMaxNumericScale
argument_list|()
assert|;
name|int
name|precision
init|=
name|Math
operator|.
name|max
argument_list|(
name|p1
operator|-
name|s1
argument_list|,
name|p2
operator|-
name|s2
argument_list|)
operator|+
name|scale
operator|+
literal|1
decl_stmt|;
name|precision
operator|=
name|Math
operator|.
name|min
argument_list|(
name|precision
argument_list|,
name|typeSystem
operator|.
name|getMaxNumericPrecision
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
name|precision
operator|>
literal|0
assert|;
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
name|precision
argument_list|,
name|scale
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
decl_stmt|;
comment|/**    * Same as {@link #DECIMAL_SUM} but returns with nullability if any    * of the operands is nullable by using    * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_NULLABLE}.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DECIMAL_SUM_NULLABLE
init|=
name|cascade
argument_list|(
name|DECIMAL_SUM
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is    * {@link #DECIMAL_SUM_NULLABLE} with a fallback to {@link #LEAST_RESTRICTIVE}    * These rules are used for addition and subtraction.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|NULLABLE_SUM
init|=
operator|new
name|SqlReturnTypeInferenceChain
argument_list|(
name|DECIMAL_SUM_NULLABLE
argument_list|,
name|LEAST_RESTRICTIVE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is    *    *<ul>    *<li>the same type as the input types but with the combined length of the    * two first types</li>    *<li>if types are of char type the type with the highest coercibility will    * be used</li>    *<li>result is varying if either input is; otherwise fixed    *</ul>    *    *<p>Pre-requisites:    *    *<ul>    *<li>input types must be of the same string type    *<li>types must be comparable without casting    *</ul>    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DYADIC_STRING_SUM_PRECISION
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataType
name|argType0
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|argType1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|containsAnyType
init|=
operator|(
name|argType0
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
operator|)
operator|||
operator|(
name|argType1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|containsAnyType
operator|&&
operator|!
operator|(
name|SqlTypeUtil
operator|.
name|inCharOrBinaryFamilies
argument_list|(
name|argType0
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|inCharOrBinaryFamilies
argument_list|(
name|argType1
argument_list|)
operator|)
condition|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|SqlTypeUtil
operator|.
name|sameNamedType
argument_list|(
name|argType0
argument_list|,
name|argType1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SqlCollation
name|pickedCollation
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|containsAnyType
operator|&&
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|argType0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|isCharTypeComparable
argument_list|(
name|opBinding
operator|.
name|collectOperandTypes
argument_list|()
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
name|opBinding
operator|.
name|newError
argument_list|(
name|RESOURCE
operator|.
name|typeNotComparable
argument_list|(
name|argType0
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|argType1
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|pickedCollation
operator|=
name|SqlCollation
operator|.
name|getCoercibilityDyadicOperator
argument_list|(
name|argType0
operator|.
name|getCollation
argument_list|()
argument_list|,
name|argType1
operator|.
name|getCollation
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
literal|null
operator|!=
name|pickedCollation
assert|;
block|}
comment|// Determine whether result is variable-length
name|SqlTypeName
name|typeName
init|=
name|argType0
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isBoundedVariableWidth
argument_list|(
name|argType1
argument_list|)
condition|)
block|{
name|typeName
operator|=
name|argType1
operator|.
name|getSqlTypeName
argument_list|()
expr_stmt|;
block|}
name|RelDataType
name|ret
decl_stmt|;
name|int
name|typePrecision
decl_stmt|;
specifier|final
name|long
name|x
init|=
operator|(
name|long
operator|)
name|argType0
operator|.
name|getPrecision
argument_list|()
operator|+
operator|(
name|long
operator|)
name|argType1
operator|.
name|getPrecision
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeSystem
name|typeSystem
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
decl_stmt|;
if|if
condition|(
name|argType0
operator|.
name|getPrecision
argument_list|()
operator|==
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
operator|||
name|argType1
operator|.
name|getPrecision
argument_list|()
operator|==
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
operator|||
name|x
operator|>
name|typeSystem
operator|.
name|getMaxPrecision
argument_list|(
name|typeName
argument_list|)
condition|)
block|{
name|typePrecision
operator|=
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
expr_stmt|;
block|}
else|else
block|{
name|typePrecision
operator|=
operator|(
name|int
operator|)
name|x
expr_stmt|;
block|}
name|ret
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|,
name|typePrecision
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|pickedCollation
condition|)
block|{
name|RelDataType
name|pickedType
decl_stmt|;
if|if
condition|(
name|argType0
operator|.
name|getCollation
argument_list|()
operator|.
name|equals
argument_list|(
name|pickedCollation
argument_list|)
condition|)
block|{
name|pickedType
operator|=
name|argType0
expr_stmt|;
block|}
if|else if
condition|(
name|argType1
operator|.
name|getCollation
argument_list|()
operator|.
name|equals
argument_list|(
name|pickedCollation
argument_list|)
condition|)
block|{
name|pickedType
operator|=
name|argType1
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"should never come here"
argument_list|)
throw|;
block|}
name|ret
operator|=
name|typeFactory
operator|.
name|createTypeWithCharsetAndCollation
argument_list|(
name|ret
argument_list|,
name|pickedType
operator|.
name|getCharset
argument_list|()
argument_list|,
name|pickedType
operator|.
name|getCollation
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
decl_stmt|;
comment|/**    * Same as {@link #DYADIC_STRING_SUM_PRECISION} and using    * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_NULLABLE},    * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_VARYING}.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DYADIC_STRING_SUM_PRECISION_NULLABLE_VARYING
init|=
name|cascade
argument_list|(
name|DYADIC_STRING_SUM_PRECISION
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_VARYING
argument_list|)
decl_stmt|;
comment|/**    * Same as {@link #DYADIC_STRING_SUM_PRECISION} and using    * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_NULLABLE}    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|DYADIC_STRING_SUM_PRECISION_NULLABLE
init|=
name|cascade
argument_list|(
name|DYADIC_STRING_SUM_PRECISION
argument_list|,
name|SqlTypeTransforms
operator|.
name|TO_NULLABLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy where the expression is assumed to be registered    * as a {@link org.apache.calcite.sql.validate.SqlValidatorNamespace}, and    * therefore the result type of the call is the type of that namespace.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|SCOPE
init|=
name|opBinding
lambda|->
block|{
name|SqlCallBinding
name|callBinding
init|=
operator|(
name|SqlCallBinding
operator|)
name|opBinding
decl_stmt|;
return|return
name|callBinding
operator|.
name|getValidator
argument_list|()
operator|.
name|getNamespace
argument_list|(
name|callBinding
operator|.
name|getCall
argument_list|()
argument_list|)
operator|.
name|getRowType
argument_list|()
return|;
block|}
decl_stmt|;
comment|/**    * Returns a multiset of column #0 of a multiset. For example, given    *<code>RECORD(x INTEGER, y DATE) MULTISET</code>, returns<code>INTEGER    * MULTISET</code>.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTISET_PROJECT0
init|=
name|opBinding
lambda|->
block|{
assert|assert
name|opBinding
operator|.
name|getOperandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|RelDataType
name|recordMultisetType
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|multisetType
init|=
name|recordMultisetType
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
assert|assert
name|multisetType
operator|!=
literal|null
operator|:
literal|"expected a multiset type: "
operator|+
name|recordMultisetType
assert|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|multisetType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|fields
operator|.
name|size
argument_list|()
operator|>
literal|0
assert|;
specifier|final
name|RelDataType
name|firstColType
init|=
name|fields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createMultisetType
argument_list|(
name|firstColType
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Returns a multiset of the first column of a multiset. For example, given    *<code>INTEGER MULTISET</code>, returns<code>RECORD(x INTEGER)    * MULTISET</code>.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|MULTISET_RECORD
init|=
name|opBinding
lambda|->
block|{
assert|assert
name|opBinding
operator|.
name|getOperandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|RelDataType
name|multisetType
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|componentType
init|=
name|multisetType
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
assert|assert
name|componentType
operator|!=
literal|null
operator|:
literal|"expected a multiset type: "
operator|+
name|multisetType
assert|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
name|SqlUtil
operator|.
name|deriveAliasFromOrdinal
argument_list|(
literal|0
argument_list|)
argument_list|,
name|componentType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createMultisetType
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Returns the field type of a structured type which has only one field. For    * example, given {@code RECORD(x INTEGER)} returns {@code INTEGER}.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|RECORD_TO_SCALAR
init|=
name|opBinding
lambda|->
block|{
assert|assert
name|opBinding
operator|.
name|getOperandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|RelDataType
name|recordType
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|boolean
name|isStruct
init|=
name|recordType
operator|.
name|isStruct
argument_list|()
decl_stmt|;
name|int
name|fieldCount
init|=
name|recordType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
name|isStruct
operator|&&
operator|(
name|fieldCount
operator|==
literal|1
operator|)
assert|;
name|RelDataTypeField
name|fieldType
init|=
name|recordType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|fieldType
operator|!=
literal|null
operator|:
literal|"expected a record type with one field: "
operator|+
name|recordType
assert|;
specifier|final
name|RelDataType
name|firstColType
init|=
name|fieldType
operator|.
name|getType
argument_list|()
decl_stmt|;
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|firstColType
argument_list|,
literal|true
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Type-inference strategy for SUM aggregate function inferred from the    * operand type, and nullable if the call occurs within a "GROUP BY ()"    * query. E.g. in "select sum(x) as s from empty", s may be null. Also,    * with the default implementation of RelDataTypeSystem, s has the same    * type name as x.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|AGG_SUM
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveSumType
argument_list|(
name|typeFactory
argument_list|,
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|opBinding
operator|.
name|getGroupCount
argument_list|()
operator|==
literal|0
operator|||
name|opBinding
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|type
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Type-inference strategy for $SUM0 aggregate function inferred from the    * operand type. By default the inferred type is identical to the operand    * type. E.g. in "select $sum0(x) as s from empty", s has the same type as    * x.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|AGG_SUM_EMPTY_IS_ZERO
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|sumType
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveSumType
argument_list|(
name|typeFactory
argument_list|,
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// SUM0 should not return null.
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|sumType
argument_list|,
literal|false
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Type-inference strategy for the {@code CUME_DIST} and {@code PERCENT_RANK}    * aggregate functions.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|FRACTIONAL_RANK
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
return|return
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveFractionalRankType
argument_list|(
name|typeFactory
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Type-inference strategy for the {@code NTILE}, {@code RANK},    * {@code DENSE_RANK}, and {@code ROW_NUMBER} aggregate functions.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|RANK
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
return|return
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveRankType
argument_list|(
name|typeFactory
argument_list|)
return|;
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|AVG_AGG_FUNCTION
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|relDataType
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveAvgAggType
argument_list|(
name|typeFactory
argument_list|,
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|opBinding
operator|.
name|getGroupCount
argument_list|()
operator|==
literal|0
operator|||
name|opBinding
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|relDataType
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|relDataType
return|;
block|}
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|COVAR_REGR_FUNCTION
init|=
name|opBinding
lambda|->
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|relDataType
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|deriveCovarType
argument_list|(
name|typeFactory
argument_list|,
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
argument_list|,
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|opBinding
operator|.
name|getGroupCount
argument_list|()
operator|==
literal|0
operator|||
name|opBinding
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|relDataType
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|relDataType
return|;
block|}
block|}
decl_stmt|;
block|}
end_class

begin_comment
comment|// End ReturnTypes.java
end_comment

end_unit

