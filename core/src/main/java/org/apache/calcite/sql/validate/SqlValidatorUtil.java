begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionConfigImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalciteSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Linq4j
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptSchemaWithSampling
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|prepare
operator|.
name|CalciteCatalogReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|prepare
operator|.
name|Prepare
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFieldImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|CustomColumnResolvingTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|ExtensibleTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|AbstractSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|AbstractTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDataTypeSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunctionCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIntervalQualifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSyntax
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
operator|.
name|RESOURCE
import|;
end_import

begin_comment
comment|/**  * Utility methods related to validation.  */
end_comment

begin_class
specifier|public
class|class
name|SqlValidatorUtil
block|{
specifier|private
name|SqlValidatorUtil
parameter_list|()
block|{
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Converts a {@link SqlValidatorScope} into a {@link RelOptTable}. This is    * only possible if the scope represents an identifier, such as "sales.emp".    * Otherwise, returns null.    *    * @param namespace     Namespace    * @param catalogReader Schema    * @param datasetName   Name of sample dataset to substitute, or null to use    *                      the regular table    * @param usedDataset   Output parameter which is set to true if a sample    *                      dataset is found; may be null    */
specifier|public
specifier|static
name|RelOptTable
name|getRelOptTable
parameter_list|(
name|SqlValidatorNamespace
name|namespace
parameter_list|,
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
parameter_list|,
name|String
name|datasetName
parameter_list|,
name|boolean
index|[]
name|usedDataset
parameter_list|)
block|{
if|if
condition|(
name|namespace
operator|.
name|isWrapperFor
argument_list|(
name|TableNamespace
operator|.
name|class
argument_list|)
condition|)
block|{
specifier|final
name|TableNamespace
name|tableNamespace
init|=
name|namespace
operator|.
name|unwrap
argument_list|(
name|TableNamespace
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|getRelOptTable
argument_list|(
name|tableNamespace
argument_list|,
name|catalogReader
argument_list|,
name|datasetName
argument_list|,
name|usedDataset
argument_list|,
name|tableNamespace
operator|.
name|extendedFields
argument_list|)
return|;
block|}
if|else if
condition|(
name|namespace
operator|.
name|isWrapperFor
argument_list|(
name|SqlValidatorImpl
operator|.
name|DmlNamespace
operator|.
name|class
argument_list|)
condition|)
block|{
specifier|final
name|SqlValidatorImpl
operator|.
name|DmlNamespace
name|dmlNamespace
init|=
name|namespace
operator|.
name|unwrap
argument_list|(
name|SqlValidatorImpl
operator|.
name|DmlNamespace
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|resolvedNamespace
init|=
name|dmlNamespace
operator|.
name|resolve
argument_list|()
decl_stmt|;
if|if
condition|(
name|resolvedNamespace
operator|.
name|isWrapperFor
argument_list|(
name|TableNamespace
operator|.
name|class
argument_list|)
condition|)
block|{
specifier|final
name|TableNamespace
name|tableNamespace
init|=
name|resolvedNamespace
operator|.
name|unwrap
argument_list|(
name|TableNamespace
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorTable
name|validatorTable
init|=
name|tableNamespace
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|extendedFields
init|=
name|dmlNamespace
operator|.
name|extendList
operator|==
literal|null
condition|?
name|ImmutableList
operator|.
name|of
argument_list|()
else|:
name|getExtendedColumns
argument_list|(
name|namespace
operator|.
name|getValidator
argument_list|()
argument_list|,
name|validatorTable
argument_list|,
name|dmlNamespace
operator|.
name|extendList
argument_list|)
decl_stmt|;
return|return
name|getRelOptTable
argument_list|(
name|tableNamespace
argument_list|,
name|catalogReader
argument_list|,
name|datasetName
argument_list|,
name|usedDataset
argument_list|,
name|extendedFields
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|static
name|RelOptTable
name|getRelOptTable
parameter_list|(
name|TableNamespace
name|tableNamespace
parameter_list|,
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
parameter_list|,
name|String
name|datasetName
parameter_list|,
name|boolean
index|[]
name|usedDataset
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|extendedFields
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|tableNamespace
operator|.
name|getTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
decl_stmt|;
name|RelOptTable
name|table
decl_stmt|;
if|if
condition|(
name|datasetName
operator|!=
literal|null
operator|&&
name|catalogReader
operator|instanceof
name|RelOptSchemaWithSampling
condition|)
block|{
specifier|final
name|RelOptSchemaWithSampling
name|reader
init|=
operator|(
name|RelOptSchemaWithSampling
operator|)
name|catalogReader
decl_stmt|;
name|table
operator|=
name|reader
operator|.
name|getTableForMember
argument_list|(
name|names
argument_list|,
name|datasetName
argument_list|,
name|usedDataset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Schema does not support substitution. Ignore the data set, if any.
name|table
operator|=
name|catalogReader
operator|.
name|getTableForMember
argument_list|(
name|names
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|extendedFields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|table
operator|=
name|table
operator|.
name|extend
argument_list|(
name|extendedFields
argument_list|)
expr_stmt|;
block|}
return|return
name|table
return|;
block|}
comment|/**    * Gets a list of extended columns with field indices to the underlying table.    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|getExtendedColumns
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlValidatorTable
name|table
parameter_list|,
name|SqlNodeList
name|extendedColumns
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RelDataTypeField
argument_list|>
name|extendedFields
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|ExtensibleTable
name|extTable
init|=
name|table
operator|.
name|unwrap
argument_list|(
name|ExtensibleTable
operator|.
name|class
argument_list|)
decl_stmt|;
name|int
name|extendedFieldOffset
init|=
name|extTable
operator|==
literal|null
condition|?
name|table
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
else|:
name|extTable
operator|.
name|getExtendedColumnOffset
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Pair
argument_list|<
name|SqlIdentifier
argument_list|,
name|SqlDataTypeSpec
argument_list|>
name|pair
range|:
name|pairs
argument_list|(
name|extendedColumns
argument_list|)
control|)
block|{
specifier|final
name|SqlIdentifier
name|identifier
init|=
name|pair
operator|.
name|left
decl_stmt|;
specifier|final
name|SqlDataTypeSpec
name|type
init|=
name|pair
operator|.
name|right
decl_stmt|;
name|extendedFields
operator|.
name|add
argument_list|(
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|identifier
operator|.
name|toString
argument_list|()
argument_list|,
name|extendedFieldOffset
operator|++
argument_list|,
name|type
operator|.
name|deriveType
argument_list|(
name|validator
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|extendedFields
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Converts a list of extended columns    * (of the form [name0, type0, name1, type1, ...])    * into a list of (name, type) pairs. */
specifier|private
specifier|static
name|List
argument_list|<
name|Pair
argument_list|<
name|SqlIdentifier
argument_list|,
name|SqlDataTypeSpec
argument_list|>
argument_list|>
name|pairs
parameter_list|(
name|SqlNodeList
name|extendedColumns
parameter_list|)
block|{
specifier|final
name|List
name|list
init|=
name|extendedColumns
operator|.
name|getList
argument_list|()
decl_stmt|;
comment|//noinspection unchecked
return|return
name|Util
operator|.
name|pairs
argument_list|(
name|list
argument_list|)
return|;
block|}
comment|/**    * Gets a map of indexes from the source to fields in the target for the    * intersecting set of source and target fields.    *    * @param sourceFields The source of column names that determine indexes    * @param targetFields The target fields to be indexed    */
specifier|public
specifier|static
name|ImmutableMap
argument_list|<
name|Integer
argument_list|,
name|RelDataTypeField
argument_list|>
name|getIndexToFieldMap
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sourceFields
parameter_list|,
name|RelDataType
name|targetFields
parameter_list|)
block|{
specifier|final
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|Integer
argument_list|,
name|RelDataTypeField
argument_list|>
name|output
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|RelDataTypeField
name|source
range|:
name|sourceFields
control|)
block|{
specifier|final
name|RelDataTypeField
name|target
init|=
name|targetFields
operator|.
name|getField
argument_list|(
name|source
operator|.
name|getName
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|!=
literal|null
condition|)
block|{
name|output
operator|.
name|put
argument_list|(
name|source
operator|.
name|getIndex
argument_list|()
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|output
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Gets the bit-set to the column ordinals in the source for columns that intersect in the target.    * @param sourceRowType The source upon which to ordinate the bit set.    * @param targetRowType The target to overlay on the source to create the bit set.    */
specifier|public
specifier|static
name|ImmutableBitSet
name|getOrdinalBitSet
parameter_list|(
name|RelDataType
name|sourceRowType
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|)
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|RelDataTypeField
argument_list|>
name|indexToField
init|=
name|getIndexToFieldMap
argument_list|(
name|sourceRowType
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|targetRowType
argument_list|)
decl_stmt|;
return|return
name|getOrdinalBitSet
argument_list|(
name|sourceRowType
argument_list|,
name|indexToField
argument_list|)
return|;
block|}
comment|/**    * Gets the bit-set to the column ordinals in the source for columns that    * intersect in the target.    *    * @param sourceRowType The source upon which to ordinate the bit set.    * @param indexToField  The map of ordinals to target fields.    */
specifier|public
specifier|static
name|ImmutableBitSet
name|getOrdinalBitSet
parameter_list|(
name|RelDataType
name|sourceRowType
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|RelDataTypeField
argument_list|>
name|indexToField
parameter_list|)
block|{
name|ImmutableBitSet
name|source
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|Util
operator|.
name|transform
argument_list|(
name|sourceRowType
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|RelDataTypeField
operator|::
name|getIndex
argument_list|)
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|target
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|indexToField
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|source
operator|.
name|intersect
argument_list|(
name|target
argument_list|)
return|;
block|}
comment|/** Returns a map from field names to indexes. */
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|mapNameToIndex
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
parameter_list|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|output
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|fields
control|)
block|{
name|output
operator|.
name|put
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|output
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelDataTypeField
name|lookupField
parameter_list|(
name|boolean
name|caseSensitive
parameter_list|,
specifier|final
name|RelDataType
name|rowType
parameter_list|,
name|String
name|columnName
parameter_list|)
block|{
return|return
name|rowType
operator|.
name|getField
argument_list|(
name|columnName
argument_list|,
name|caseSensitive
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|void
name|checkCharsetAndCollateConsistentIfCharType
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
comment|// (every charset must have a default collation)
if|if
condition|(
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|Charset
name|strCharset
init|=
name|type
operator|.
name|getCharset
argument_list|()
decl_stmt|;
name|Charset
name|colCharset
init|=
name|type
operator|.
name|getCollation
argument_list|()
operator|.
name|getCharset
argument_list|()
decl_stmt|;
assert|assert
literal|null
operator|!=
name|strCharset
assert|;
assert|assert
literal|null
operator|!=
name|colCharset
assert|;
if|if
condition|(
operator|!
name|strCharset
operator|.
name|equals
argument_list|(
name|colCharset
argument_list|)
condition|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
comment|// todo: enable this checking when we have a charset to
comment|//   collation mapping
throw|throw
operator|new
name|Error
argument_list|(
name|type
operator|.
name|toString
argument_list|()
operator|+
literal|" was found to have charset '"
operator|+
name|strCharset
operator|.
name|name
argument_list|()
operator|+
literal|"' and a mismatched collation charset '"
operator|+
name|colCharset
operator|.
name|name
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Checks that there are no duplicates in a list of {@link SqlIdentifier}.    */
specifier|static
name|void
name|checkIdentifierListForDuplicates
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|columnList
parameter_list|,
name|SqlValidatorImpl
operator|.
name|ValidationErrorFunction
name|validationErrorFunction
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|names
init|=
name|Util
operator|.
name|transform
argument_list|(
name|columnList
argument_list|,
name|o
lambda|->
operator|(
operator|(
name|SqlIdentifier
operator|)
name|o
operator|)
operator|.
name|names
argument_list|)
decl_stmt|;
specifier|final
name|int
name|i
init|=
name|Util
operator|.
name|firstDuplicate
argument_list|(
name|names
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
throw|throw
name|validationErrorFunction
operator|.
name|apply
argument_list|(
name|columnList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|RESOURCE
operator|.
name|duplicateNameInColumnList
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|names
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * Converts an expression "expr" into "expr AS alias".    */
specifier|public
specifier|static
name|SqlNode
name|addAlias
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
specifier|final
name|SqlParserPos
name|pos
init|=
name|expr
operator|.
name|getParserPosition
argument_list|()
decl_stmt|;
specifier|final
name|SqlIdentifier
name|id
init|=
operator|new
name|SqlIdentifier
argument_list|(
name|alias
argument_list|,
name|pos
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|expr
argument_list|,
name|id
argument_list|)
return|;
block|}
comment|/**    * Derives an alias for a node, and invents a mangled identifier if it    * cannot.    *    *<p>Examples:    *    *<ul>    *<li>Alias: "1 + 2 as foo" yields "foo"    *<li>Identifier: "foo.bar.baz" yields "baz"    *<li>Anything else yields "expr$<i>ordinal</i>"    *</ul>    *    * @return An alias, if one can be derived; or a synthetic alias    * "expr$<i>ordinal</i>" if ordinal&lt; 0; otherwise null    */
specifier|public
specifier|static
name|String
name|getAlias
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
comment|// E.g. "1 + 2 as foo" --> "foo"
return|return
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
return|;
case|case
name|OVER
case|:
comment|// E.g. "bids over w" --> "bids"
return|return
name|getAlias
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|ordinal
argument_list|)
return|;
case|case
name|IDENTIFIER
case|:
comment|// E.g. "foo.bar" --> "bar"
return|return
name|Util
operator|.
name|last
argument_list|(
operator|(
operator|(
name|SqlIdentifier
operator|)
name|node
operator|)
operator|.
name|names
argument_list|)
return|;
default|default:
if|if
condition|(
name|ordinal
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|SqlUtil
operator|.
name|deriveAliasFromOrdinal
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Factory method for {@link SqlValidator}.    */
specifier|public
specifier|static
name|SqlValidatorWithHints
name|newValidator
parameter_list|(
name|SqlOperatorTable
name|opTab
parameter_list|,
name|SqlValidatorCatalogReader
name|catalogReader
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|SqlValidator
operator|.
name|Config
name|config
parameter_list|)
block|{
return|return
operator|new
name|SqlValidatorImpl
argument_list|(
name|opTab
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|config
argument_list|)
return|;
block|}
comment|/**    * Factory method for {@link SqlValidator}, with default conformance.    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|SqlValidatorWithHints
name|newValidator
parameter_list|(
name|SqlOperatorTable
name|opTab
parameter_list|,
name|SqlValidatorCatalogReader
name|catalogReader
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|newValidator
argument_list|(
name|opTab
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|SqlValidator
operator|.
name|Config
operator|.
name|DEFAULT
argument_list|)
return|;
block|}
comment|/**    * Makes a name distinct from other names which have already been used, adds    * it to the list, and returns it.    *    * @param name      Suggested name, may not be unique    * @param usedNames  Collection of names already used    * @param suggester Base for name when input name is null    * @return Unique name    */
specifier|public
specifier|static
name|String
name|uniquify
parameter_list|(
name|String
name|name
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|usedNames
parameter_list|,
name|Suggester
name|suggester
parameter_list|)
block|{
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|usedNames
operator|.
name|add
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|name
return|;
block|}
block|}
specifier|final
name|String
name|originalName
init|=
name|name
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
block|{
name|name
operator|=
name|suggester
operator|.
name|apply
argument_list|(
name|originalName
argument_list|,
name|j
argument_list|,
name|usedNames
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|usedNames
operator|.
name|add
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|name
return|;
block|}
block|}
block|}
comment|/**    * Makes sure that the names in a list are unique.    *    *<p>Does not modify the input list. Returns the input list if the strings    * are unique, otherwise allocates a new list. Deprecated in favor of caseSensitive    * aware version.    *    * @param nameList List of strings    * @return List of unique strings    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|uniquify
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|)
block|{
return|return
name|uniquify
argument_list|(
name|nameList
argument_list|,
name|EXPR_SUGGESTER
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Makes sure that the names in a list are unique.    *    *<p>Does not modify the input list. Returns the input list if the strings    * are unique, otherwise allocates a new list.    *    * @deprecated Use {@link #uniquify(List, Suggester, boolean)}    *    * @param nameList List of strings    * @param suggester How to generate new names if duplicate names are found    * @return List of unique strings    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|uniquify
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|,
name|Suggester
name|suggester
parameter_list|)
block|{
return|return
name|uniquify
argument_list|(
name|nameList
argument_list|,
name|suggester
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Makes sure that the names in a list are unique.    *    *<p>Does not modify the input list. Returns the input list if the strings    * are unique, otherwise allocates a new list.    *    * @param nameList List of strings    * @param caseSensitive Whether upper and lower case names are considered    *     distinct    * @return List of unique strings    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|uniquify
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|)
block|{
return|return
name|uniquify
argument_list|(
name|nameList
argument_list|,
name|EXPR_SUGGESTER
argument_list|,
name|caseSensitive
argument_list|)
return|;
block|}
comment|/**    * Makes sure that the names in a list are unique.    *    *<p>Does not modify the input list. Returns the input list if the strings    * are unique, otherwise allocates a new list.    *    * @param nameList List of strings    * @param suggester How to generate new names if duplicate names are found    * @param caseSensitive Whether upper and lower case names are considered    *     distinct    * @return List of unique strings    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|uniquify
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|,
name|Suggester
name|suggester
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|used
init|=
name|caseSensitive
condition|?
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
else|:
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|String
operator|.
name|CASE_INSENSITIVE_ORDER
argument_list|)
decl_stmt|;
name|int
name|changeCount
init|=
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|newNameList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|nameList
control|)
block|{
name|String
name|uniqueName
init|=
name|uniquify
argument_list|(
name|name
argument_list|,
name|used
argument_list|,
name|suggester
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|uniqueName
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
operator|++
name|changeCount
expr_stmt|;
block|}
name|newNameList
operator|.
name|add
argument_list|(
name|uniqueName
argument_list|)
expr_stmt|;
block|}
return|return
name|changeCount
operator|==
literal|0
condition|?
name|nameList
else|:
name|newNameList
return|;
block|}
comment|/**    * Derives the type of a join relational expression.    *    * @param leftType        Row type of left input to join    * @param rightType       Row type of right input to join    * @param joinType        Type of join    * @param typeFactory     Type factory    * @param fieldNameList   List of names of fields; if null, field names are    *                        inherited and made unique    * @param systemFieldList List of system fields that will be prefixed to    *                        output row type; typically empty but must not be    *                        null    * @return join type    */
specifier|public
specifier|static
name|RelDataType
name|deriveJoinRowType
parameter_list|(
name|RelDataType
name|leftType
parameter_list|,
name|RelDataType
name|rightType
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|systemFieldList
parameter_list|)
block|{
assert|assert
name|systemFieldList
operator|!=
literal|null
assert|;
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|LEFT
case|:
name|rightType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|rightType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|leftType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|leftType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|FULL
case|:
name|leftType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|leftType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|rightType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|rightType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEMI
case|:
case|case
name|ANTI
case|:
name|rightType
operator|=
literal|null
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|createJoinType
argument_list|(
name|typeFactory
argument_list|,
name|leftType
argument_list|,
name|rightType
argument_list|,
name|fieldNameList
argument_list|,
name|systemFieldList
argument_list|)
return|;
block|}
comment|/**    * Returns the type the row which results when two relations are joined.    *    *<p>The resulting row type consists of    * the system fields (if any), followed by    * the fields of the left type, followed by    * the fields of the right type. The field name list, if present, overrides    * the original names of the fields.    *    * @param typeFactory     Type factory    * @param leftType        Type of left input to join    * @param rightType       Type of right input to join, or null for semi-join    * @param fieldNameList   If not null, overrides the original names of the    *                        fields    * @param systemFieldList List of system fields that will be prefixed to    *                        output row type; typically empty but must not be    *                        null    * @return type of row which results when two relations are joined    */
specifier|public
specifier|static
name|RelDataType
name|createJoinType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|leftType
parameter_list|,
name|RelDataType
name|rightType
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|systemFieldList
parameter_list|)
block|{
assert|assert
operator|(
name|fieldNameList
operator|==
literal|null
operator|)
operator|||
operator|(
name|fieldNameList
operator|.
name|size
argument_list|()
operator|==
operator|(
name|systemFieldList
operator|.
name|size
argument_list|()
operator|+
name|leftType
operator|.
name|getFieldCount
argument_list|()
operator|+
name|rightType
operator|.
name|getFieldCount
argument_list|()
operator|)
operator|)
assert|;
name|List
argument_list|<
name|String
argument_list|>
name|nameList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Use a set to keep track of the field names; this is needed
comment|// to ensure that the contains() call to check for name uniqueness
comment|// runs in constant time; otherwise, if the number of fields is large,
comment|// doing a contains() on a list can be expensive.
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|uniqueNameList
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|isSchemaCaseSensitive
argument_list|()
condition|?
operator|new
name|HashSet
argument_list|<>
argument_list|()
else|:
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|String
operator|.
name|CASE_INSENSITIVE_ORDER
argument_list|)
decl_stmt|;
name|addFields
argument_list|(
name|systemFieldList
argument_list|,
name|typeList
argument_list|,
name|nameList
argument_list|,
name|uniqueNameList
argument_list|)
expr_stmt|;
name|addFields
argument_list|(
name|leftType
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|typeList
argument_list|,
name|nameList
argument_list|,
name|uniqueNameList
argument_list|)
expr_stmt|;
if|if
condition|(
name|rightType
operator|!=
literal|null
condition|)
block|{
name|addFields
argument_list|(
name|rightType
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|typeList
argument_list|,
name|nameList
argument_list|,
name|uniqueNameList
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fieldNameList
operator|!=
literal|null
condition|)
block|{
assert|assert
name|fieldNameList
operator|.
name|size
argument_list|()
operator|==
name|nameList
operator|.
name|size
argument_list|()
assert|;
name|nameList
operator|=
name|fieldNameList
expr_stmt|;
block|}
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|typeList
argument_list|,
name|nameList
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|addFields
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fieldList
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|uniqueNames
parameter_list|)
block|{
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|fieldList
control|)
block|{
name|String
name|name
init|=
name|field
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// Ensure that name is unique from all previous field names
if|if
condition|(
name|uniqueNames
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|nameBase
init|=
name|name
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
block|{
name|name
operator|=
name|nameBase
operator|+
name|j
expr_stmt|;
if|if
condition|(
operator|!
name|uniqueNames
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
name|nameList
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|uniqueNames
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|typeList
operator|.
name|add
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Resolve a target column name in the target table.    *    * @return the target field or null if the name cannot be resolved    * @param rowType the target row type    * @param id      the target column identifier    * @param table   the target table or null if it is not a RelOptTable instance    */
specifier|public
specifier|static
name|RelDataTypeField
name|getTargetField
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|SqlIdentifier
name|id
parameter_list|,
name|SqlValidatorCatalogReader
name|catalogReader
parameter_list|,
name|RelOptTable
name|table
parameter_list|)
block|{
specifier|final
name|Table
name|t
init|=
name|table
operator|==
literal|null
condition|?
literal|null
else|:
name|table
operator|.
name|unwrap
argument_list|(
name|Table
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|instanceof
name|CustomColumnResolvingTable
operator|)
condition|)
block|{
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
return|return
name|nameMatcher
operator|.
name|field
argument_list|(
name|rowType
argument_list|,
name|id
operator|.
name|getSimple
argument_list|()
argument_list|)
return|;
block|}
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|entries
init|=
operator|(
operator|(
name|CustomColumnResolvingTable
operator|)
name|t
operator|)
operator|.
name|resolveColumn
argument_list|(
name|rowType
argument_list|,
name|typeFactory
argument_list|,
name|id
operator|.
name|names
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|entries
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|entries
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getValue
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|entries
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getKey
argument_list|()
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Resolves a multi-part identifier such as "SCHEMA.EMP.EMPNO" to a    * namespace. The returned namespace, never null, may represent a    * schema, table, column, etc.    */
specifier|public
specifier|static
name|SqlValidatorNamespace
name|lookup
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
block|{
assert|assert
name|names
operator|.
name|size
argument_list|()
operator|>
literal|0
assert|;
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|scope
operator|.
name|getValidator
argument_list|()
operator|.
name|getCatalogReader
argument_list|()
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
operator|.
name|ResolvedImpl
name|resolved
init|=
operator|new
name|SqlValidatorScope
operator|.
name|ResolvedImpl
argument_list|()
decl_stmt|;
name|scope
operator|.
name|resolve
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|nameMatcher
argument_list|,
literal|false
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
assert|assert
name|resolved
operator|.
name|count
argument_list|()
operator|==
literal|1
assert|;
name|SqlValidatorNamespace
name|namespace
init|=
name|resolved
operator|.
name|only
argument_list|()
operator|.
name|namespace
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|Util
operator|.
name|skip
argument_list|(
name|names
argument_list|)
control|)
block|{
name|namespace
operator|=
name|namespace
operator|.
name|lookupChild
argument_list|(
name|name
argument_list|)
expr_stmt|;
assert|assert
name|namespace
operator|!=
literal|null
assert|;
block|}
return|return
name|namespace
return|;
block|}
specifier|public
specifier|static
name|void
name|getSchemaObjectMonikers
parameter_list|(
name|SqlValidatorCatalogReader
name|catalogReader
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|,
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|hints
parameter_list|)
block|{
comment|// Assume that the last name is 'dummy' or similar.
name|List
argument_list|<
name|String
argument_list|>
name|subNames
init|=
name|Util
operator|.
name|skipLast
argument_list|(
name|names
argument_list|)
decl_stmt|;
comment|// Try successively with catalog.schema, catalog and no prefix
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|x
range|:
name|catalogReader
operator|.
name|getSchemaPaths
argument_list|()
control|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names2
init|=
name|ImmutableList
operator|.
expr|<
name|String
operator|>
name|builder
argument_list|()
operator|.
name|addAll
argument_list|(
name|x
argument_list|)
operator|.
name|addAll
argument_list|(
name|subNames
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|hints
operator|.
name|addAll
argument_list|(
name|catalogReader
operator|.
name|getAllSchemaObjectNames
argument_list|(
name|names2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|SelectScope
name|getEnclosingSelectScope
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
while|while
condition|(
name|scope
operator|instanceof
name|DelegatingScope
condition|)
block|{
if|if
condition|(
name|scope
operator|instanceof
name|SelectScope
condition|)
block|{
return|return
operator|(
name|SelectScope
operator|)
name|scope
return|;
block|}
name|scope
operator|=
operator|(
operator|(
name|DelegatingScope
operator|)
name|scope
operator|)
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
specifier|static
name|AggregatingSelectScope
name|getEnclosingAggregateSelectScope
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
while|while
condition|(
name|scope
operator|instanceof
name|DelegatingScope
condition|)
block|{
if|if
condition|(
name|scope
operator|instanceof
name|AggregatingSelectScope
condition|)
block|{
return|return
operator|(
name|AggregatingSelectScope
operator|)
name|scope
return|;
block|}
name|scope
operator|=
operator|(
operator|(
name|DelegatingScope
operator|)
name|scope
operator|)
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Derives the list of column names suitable for NATURAL JOIN. These are the    * columns that occur exactly once on each side of the join.    *    * @param nameMatcher Whether matches are case-sensitive    * @param leftRowType  Row type of left input to the join    * @param rightRowType Row type of right input to the join    * @return List of columns that occur once on each side    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|deriveNaturalJoinColumnList
parameter_list|(
name|SqlNameMatcher
name|nameMatcher
parameter_list|,
name|RelDataType
name|leftRowType
parameter_list|,
name|RelDataType
name|rightRowType
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|naturalColumnNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|leftNames
init|=
name|leftRowType
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|rightNames
init|=
name|rightRowType
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|leftNames
control|)
block|{
if|if
condition|(
name|nameMatcher
operator|.
name|frequency
argument_list|(
name|leftNames
argument_list|,
name|name
argument_list|)
operator|==
literal|1
operator|&&
name|nameMatcher
operator|.
name|frequency
argument_list|(
name|rightNames
argument_list|,
name|name
argument_list|)
operator|==
literal|1
condition|)
block|{
name|naturalColumnNames
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|naturalColumnNames
return|;
block|}
specifier|public
specifier|static
name|RelDataType
name|createTypeFromProjection
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNameList
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|)
block|{
comment|// If the names in columnNameList and type have case-sensitive differences,
comment|// the resulting type will use those from type. These are presumably more
comment|// canonical.
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|columnNameList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|columnNameList
control|)
block|{
name|RelDataTypeField
name|field
init|=
name|type
operator|.
name|getField
argument_list|(
name|name
argument_list|,
name|caseSensitive
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|type
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|fields
argument_list|)
return|;
block|}
comment|/** Analyzes an expression in a GROUP BY clause.    *    *<p>It may be an expression, an empty list (), or a call to    * {@code GROUPING SETS}, {@code CUBE}, {@code ROLLUP},    * {@code TUMBLE}, {@code HOP} or {@code SESSION}.    *    *<p>Each group item produces a list of group sets, which are written to    * {@code topBuilder}. To find the grouping sets of the query, we will take    * the cartesian product of the group sets. */
specifier|public
specifier|static
name|void
name|analyzeGroupItem
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|GroupAnalyzer
name|groupAnalyzer
parameter_list|,
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
argument_list|>
name|topBuilder
parameter_list|,
name|SqlNode
name|groupExpr
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableBitSet
argument_list|>
name|builder
decl_stmt|;
switch|switch
condition|(
name|groupExpr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CUBE
case|:
case|case
name|ROLLUP
case|:
comment|// E.g. ROLLUP(a, (b, c)) becomes [{0}, {1, 2}]
comment|// then we roll up to [(0, 1, 2), (0), ()]  -- note no (0, 1)
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|bitSets
init|=
name|analyzeGroupTuple
argument_list|(
name|scope
argument_list|,
name|groupAnalyzer
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|groupExpr
operator|)
operator|.
name|getOperandList
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|groupExpr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|ROLLUP
case|:
name|topBuilder
operator|.
name|add
argument_list|(
name|rollup
argument_list|(
name|bitSets
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|topBuilder
operator|.
name|add
argument_list|(
name|cube
argument_list|(
name|bitSets
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|OTHER
case|:
if|if
condition|(
name|groupExpr
operator|instanceof
name|SqlNodeList
condition|)
block|{
name|SqlNodeList
name|list
init|=
operator|(
name|SqlNodeList
operator|)
name|groupExpr
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|list
control|)
block|{
name|analyzeGroupItem
argument_list|(
name|scope
argument_list|,
name|groupAnalyzer
argument_list|,
name|topBuilder
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// fall through
case|case
name|HOP
case|:
case|case
name|TUMBLE
case|:
case|case
name|SESSION
case|:
case|case
name|GROUPING_SETS
case|:
default|default:
name|builder
operator|=
name|ImmutableList
operator|.
name|builder
argument_list|()
expr_stmt|;
name|convertGroupSet
argument_list|(
name|scope
argument_list|,
name|groupAnalyzer
argument_list|,
name|builder
argument_list|,
name|groupExpr
argument_list|)
expr_stmt|;
name|topBuilder
operator|.
name|add
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Analyzes a GROUPING SETS item in a GROUP BY clause. */
specifier|private
specifier|static
name|void
name|convertGroupSet
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|GroupAnalyzer
name|groupAnalyzer
parameter_list|,
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableBitSet
argument_list|>
name|builder
parameter_list|,
name|SqlNode
name|groupExpr
parameter_list|)
block|{
switch|switch
condition|(
name|groupExpr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|GROUPING_SETS
case|:
specifier|final
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|groupExpr
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|convertGroupSet
argument_list|(
name|scope
argument_list|,
name|groupAnalyzer
argument_list|,
name|builder
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|ROW
case|:
specifier|final
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|bitSets
init|=
name|analyzeGroupTuple
argument_list|(
name|scope
argument_list|,
name|groupAnalyzer
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|groupExpr
operator|)
operator|.
name|getOperandList
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|ImmutableBitSet
operator|.
name|union
argument_list|(
name|bitSets
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|ROLLUP
case|:
case|case
name|CUBE
case|:
block|{
comment|// GROUPING SETS ( (a), ROLLUP(c,b), CUBE(d,e) )
comment|// is EQUIVALENT to
comment|// GROUPING SETS ( (a), (c,b), (b) ,(), (d,e), (d), (e) ).
comment|// Expand all ROLLUP/CUBE nodes
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|operandBitSet
init|=
name|analyzeGroupTuple
argument_list|(
name|scope
argument_list|,
name|groupAnalyzer
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|groupExpr
operator|)
operator|.
name|getOperandList
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|groupExpr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|ROLLUP
case|:
name|builder
operator|.
name|addAll
argument_list|(
name|rollup
argument_list|(
name|operandBitSet
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|builder
operator|.
name|addAll
argument_list|(
name|cube
argument_list|(
name|operandBitSet
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
default|default:
name|builder
operator|.
name|add
argument_list|(
name|analyzeGroupExpr
argument_list|(
name|scope
argument_list|,
name|groupAnalyzer
argument_list|,
name|groupExpr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/** Analyzes a tuple in a GROUPING SETS clause.    *    *<p>For example, in {@code GROUP BY GROUPING SETS ((a, b), a, c)},    * {@code (a, b)} is a tuple.    *    *<p>Gathers into {@code groupExprs} the set of distinct expressions being    * grouped, and returns a bitmap indicating which expressions this tuple    * is grouping. */
specifier|private
specifier|static
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|analyzeGroupTuple
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|GroupAnalyzer
name|groupAnalyzer
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operandList
parameter_list|)
block|{
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|operandList
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|analyzeGroupExpr
argument_list|(
name|scope
argument_list|,
name|groupAnalyzer
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/** Analyzes a component of a tuple in a GROUPING SETS clause. */
specifier|private
specifier|static
name|ImmutableBitSet
name|analyzeGroupExpr
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|GroupAnalyzer
name|groupAnalyzer
parameter_list|,
name|SqlNode
name|groupExpr
parameter_list|)
block|{
specifier|final
name|SqlNode
name|expandedGroupExpr
init|=
name|scope
operator|.
name|getValidator
argument_list|()
operator|.
name|expand
argument_list|(
name|groupExpr
argument_list|,
name|scope
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|expandedGroupExpr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|ROW
case|:
return|return
name|ImmutableBitSet
operator|.
name|union
argument_list|(
name|analyzeGroupTuple
argument_list|(
name|scope
argument_list|,
name|groupAnalyzer
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|expandedGroupExpr
operator|)
operator|.
name|getOperandList
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|OTHER
case|:
if|if
condition|(
name|expandedGroupExpr
operator|instanceof
name|SqlNodeList
operator|&&
operator|(
operator|(
name|SqlNodeList
operator|)
name|expandedGroupExpr
operator|)
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|ImmutableBitSet
operator|.
name|of
argument_list|()
return|;
block|}
block|}
specifier|final
name|int
name|ref
init|=
name|lookupGroupExpr
argument_list|(
name|groupAnalyzer
argument_list|,
name|expandedGroupExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|expandedGroupExpr
operator|instanceof
name|SqlIdentifier
condition|)
block|{
comment|// SQL 2003 does not allow expressions of column references
name|SqlIdentifier
name|expr
init|=
operator|(
name|SqlIdentifier
operator|)
name|expandedGroupExpr
decl_stmt|;
comment|// column references should be fully qualified.
assert|assert
name|expr
operator|.
name|names
operator|.
name|size
argument_list|()
operator|>=
literal|2
assert|;
name|String
name|originalRelName
init|=
name|expr
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|originalFieldName
init|=
name|expr
operator|.
name|names
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|scope
operator|.
name|getValidator
argument_list|()
operator|.
name|getCatalogReader
argument_list|()
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
operator|.
name|ResolvedImpl
name|resolved
init|=
operator|new
name|SqlValidatorScope
operator|.
name|ResolvedImpl
argument_list|()
decl_stmt|;
name|scope
operator|.
name|resolve
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|originalRelName
argument_list|)
argument_list|,
name|nameMatcher
argument_list|,
literal|false
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
assert|assert
name|resolved
operator|.
name|count
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|SqlValidatorScope
operator|.
name|Resolve
name|resolve
init|=
name|resolved
operator|.
name|only
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|resolve
operator|.
name|rowType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|childNamespaceIndex
init|=
name|resolve
operator|.
name|path
operator|.
name|steps
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|i
decl_stmt|;
name|int
name|namespaceOffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|childNamespaceIndex
operator|>
literal|0
condition|)
block|{
comment|// If not the first child, need to figure out the width of
comment|// output types from all the preceding namespaces
specifier|final
name|SqlValidatorScope
name|ancestorScope
init|=
name|resolve
operator|.
name|scope
decl_stmt|;
assert|assert
name|ancestorScope
operator|instanceof
name|ListScope
assert|;
name|List
argument_list|<
name|SqlValidatorNamespace
argument_list|>
name|children
init|=
operator|(
operator|(
name|ListScope
operator|)
name|ancestorScope
operator|)
operator|.
name|getChildren
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|childNamespaceIndex
condition|;
name|j
operator|++
control|)
block|{
name|namespaceOffset
operator|+=
name|children
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
block|}
name|RelDataTypeField
name|field
init|=
name|nameMatcher
operator|.
name|field
argument_list|(
name|rowType
argument_list|,
name|originalFieldName
argument_list|)
decl_stmt|;
name|int
name|origPos
init|=
name|namespaceOffset
operator|+
name|field
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|groupAnalyzer
operator|.
name|groupExprProjection
operator|.
name|put
argument_list|(
name|origPos
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|ref
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|lookupGroupExpr
parameter_list|(
name|GroupAnalyzer
name|groupAnalyzer
parameter_list|,
name|SqlNode
name|expr
parameter_list|)
block|{
for|for
control|(
name|Ord
argument_list|<
name|SqlNode
argument_list|>
name|node
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|groupAnalyzer
operator|.
name|groupExprs
argument_list|)
control|)
block|{
if|if
condition|(
name|node
operator|.
name|e
operator|.
name|equalsDeep
argument_list|(
name|expr
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
return|return
name|node
operator|.
name|i
return|;
block|}
block|}
switch|switch
condition|(
name|expr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|HOP
case|:
case|case
name|TUMBLE
case|:
case|case
name|SESSION
case|:
name|groupAnalyzer
operator|.
name|extraExprs
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
break|break;
block|}
name|groupAnalyzer
operator|.
name|groupExprs
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|groupAnalyzer
operator|.
name|groupExprs
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
block|}
comment|/** Computes the rollup of bit sets.    *    *<p>For example,<code>rollup({0}, {1})</code>    * returns<code>({0, 1}, {0}, {})</code>.    *    *<p>Bit sets are not necessarily singletons:    *<code>rollup({0, 2}, {3, 5})</code>    * returns<code>({0, 2, 3, 5}, {0, 2}, {})</code>. */
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|rollup
parameter_list|(
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|bitSets
parameter_list|)
block|{
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|builder
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|ImmutableBitSet
name|union
init|=
name|ImmutableBitSet
operator|.
name|union
argument_list|(
name|bitSets
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|union
argument_list|)
expr_stmt|;
if|if
condition|(
name|union
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
name|bitSets
operator|=
name|bitSets
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|bitSets
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|builder
argument_list|)
return|;
block|}
comment|/** Computes the cube of bit sets.    *    *<p>For example,<code>rollup({0}, {1})</code>    * returns<code>({0, 1}, {0}, {})</code>.    *    *<p>Bit sets are not necessarily singletons:    *<code>rollup({0, 2}, {3, 5})</code>    * returns<code>({0, 2, 3, 5}, {0, 2}, {})</code>. */
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|cube
parameter_list|(
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|bitSets
parameter_list|)
block|{
comment|// Given the bit sets [{1}, {2, 3}, {5}],
comment|// form the lists [[{1}, {}], [{2, 3}, {}], [{5}, {}]].
specifier|final
name|Set
argument_list|<
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
argument_list|>
name|builder
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ImmutableBitSet
name|bitSet
range|:
name|bitSets
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|bitSet
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|flattenedBitSets
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|o
range|:
name|Linq4j
operator|.
name|product
argument_list|(
name|builder
argument_list|)
control|)
block|{
name|flattenedBitSets
operator|.
name|add
argument_list|(
name|ImmutableBitSet
operator|.
name|union
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|flattenedBitSets
argument_list|)
return|;
block|}
comment|/**    * Finds a {@link org.apache.calcite.jdbc.CalciteSchema.TypeEntry} in a    * given schema whose type has the given name, possibly qualified.    *    * @param rootSchema root schema    * @param typeName name of the type, may be qualified or fully-qualified    *    * @return TypeEntry with a table with the given name, or null    */
specifier|public
specifier|static
name|CalciteSchema
operator|.
name|TypeEntry
name|getTypeEntry
parameter_list|(
name|CalciteSchema
name|rootSchema
parameter_list|,
name|SqlIdentifier
name|typeName
parameter_list|)
block|{
specifier|final
name|String
name|name
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|path
decl_stmt|;
if|if
condition|(
name|typeName
operator|.
name|isSimple
argument_list|()
condition|)
block|{
name|path
operator|=
name|ImmutableList
operator|.
name|of
argument_list|()
expr_stmt|;
name|name
operator|=
name|typeName
operator|.
name|getSimple
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|path
operator|=
name|Util
operator|.
name|skipLast
argument_list|(
name|typeName
operator|.
name|names
argument_list|)
expr_stmt|;
name|name
operator|=
name|Util
operator|.
name|last
argument_list|(
name|typeName
operator|.
name|names
argument_list|)
expr_stmt|;
block|}
name|CalciteSchema
name|schema
init|=
name|rootSchema
decl_stmt|;
for|for
control|(
name|String
name|p
range|:
name|path
control|)
block|{
if|if
condition|(
name|schema
operator|==
name|rootSchema
operator|&&
name|SqlNameMatchers
operator|.
name|withCaseSensitive
argument_list|(
literal|true
argument_list|)
operator|.
name|matches
argument_list|(
name|p
argument_list|,
name|schema
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|schema
operator|=
name|schema
operator|.
name|getSubSchema
argument_list|(
name|p
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|schema
operator|==
literal|null
condition|?
literal|null
else|:
name|schema
operator|.
name|getType
argument_list|(
name|name
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Finds a {@link org.apache.calcite.jdbc.CalciteSchema.TableEntry} in a    * given catalog reader whose table has the given name, possibly qualified.    *    *<p>Uses the case-sensitivity policy of the specified catalog reader.    *    *<p>If not found, returns null.    *    * @param catalogReader accessor to the table metadata    * @param names Name of table, may be qualified or fully-qualified    *    * @return TableEntry with a table with the given name, or null    */
specifier|public
specifier|static
name|CalciteSchema
operator|.
name|TableEntry
name|getTableEntry
parameter_list|(
name|SqlValidatorCatalogReader
name|catalogReader
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
block|{
comment|// First look in the default schema, if any.
comment|// If not found, look in the root schema.
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|schemaPath
range|:
name|catalogReader
operator|.
name|getSchemaPaths
argument_list|()
control|)
block|{
name|CalciteSchema
name|schema
init|=
name|getSchema
argument_list|(
name|catalogReader
operator|.
name|getRootSchema
argument_list|()
argument_list|,
name|Iterables
operator|.
name|concat
argument_list|(
name|schemaPath
argument_list|,
name|Util
operator|.
name|skipLast
argument_list|(
name|names
argument_list|)
argument_list|)
argument_list|,
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|schema
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|CalciteSchema
operator|.
name|TableEntry
name|entry
init|=
name|getTableEntryFrom
argument_list|(
name|schema
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|names
argument_list|)
argument_list|,
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
return|return
name|entry
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Finds and returns {@link CalciteSchema} nested to the given rootSchema    * with specified schemaPath.    *    *<p>Uses the case-sensitivity policy of specified nameMatcher.    *    *<p>If not found, returns null.    *    * @param rootSchema root schema    * @param schemaPath full schema path of required schema    * @param nameMatcher name matcher    *    * @return CalciteSchema that corresponds specified schemaPath    */
specifier|public
specifier|static
name|CalciteSchema
name|getSchema
parameter_list|(
name|CalciteSchema
name|rootSchema
parameter_list|,
name|Iterable
argument_list|<
name|String
argument_list|>
name|schemaPath
parameter_list|,
name|SqlNameMatcher
name|nameMatcher
parameter_list|)
block|{
name|CalciteSchema
name|schema
init|=
name|rootSchema
decl_stmt|;
for|for
control|(
name|String
name|schemaName
range|:
name|schemaPath
control|)
block|{
if|if
condition|(
name|schema
operator|==
name|rootSchema
operator|&&
name|nameMatcher
operator|.
name|matches
argument_list|(
name|schemaName
argument_list|,
name|schema
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|schema
operator|=
name|schema
operator|.
name|getSubSchema
argument_list|(
name|schemaName
argument_list|,
name|nameMatcher
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|schema
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
name|schema
return|;
block|}
specifier|private
specifier|static
name|CalciteSchema
operator|.
name|TableEntry
name|getTableEntryFrom
parameter_list|(
name|CalciteSchema
name|schema
parameter_list|,
name|String
name|name
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|)
block|{
name|CalciteSchema
operator|.
name|TableEntry
name|entry
init|=
name|schema
operator|.
name|getTable
argument_list|(
name|name
argument_list|,
name|caseSensitive
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
name|entry
operator|=
name|schema
operator|.
name|getTableBasedOnNullaryFunction
argument_list|(
name|name
argument_list|,
name|caseSensitive
argument_list|)
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
comment|/**    * Returns whether there are any input columns that are sorted.    *    *<p>If so, it can be the default ORDER BY clause for a WINDOW specification.    * (This is an extension to the SQL standard for streaming.)    */
specifier|public
specifier|static
name|boolean
name|containsMonotonic
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
for|for
control|(
name|SqlValidatorNamespace
name|ns
range|:
name|children
argument_list|(
name|scope
argument_list|)
control|)
block|{
name|ns
operator|=
name|ns
operator|.
name|resolve
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|field
range|:
name|ns
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
name|SqlMonotonicity
name|monotonicity
init|=
name|ns
operator|.
name|getMonotonicity
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|monotonicity
operator|!=
literal|null
operator|&&
operator|!
name|monotonicity
operator|.
name|mayRepeat
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|SqlValidatorNamespace
argument_list|>
name|children
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
return|return
name|scope
operator|instanceof
name|ListScope
condition|?
operator|(
operator|(
name|ListScope
operator|)
name|scope
operator|)
operator|.
name|getChildren
argument_list|()
else|:
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
comment|/**    * Returns whether any of the given expressions are sorted.    *    *<p>If so, it can be the default ORDER BY clause for a WINDOW specification.    * (This is an extension to the SQL standard for streaming.)    */
specifier|static
name|boolean
name|containsMonotonic
parameter_list|(
name|SelectScope
name|scope
parameter_list|,
name|SqlNodeList
name|nodes
parameter_list|)
block|{
for|for
control|(
name|SqlNode
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
operator|!
name|scope
operator|.
name|getMonotonicity
argument_list|(
name|node
argument_list|)
operator|.
name|mayRepeat
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Lookup sql function by sql identifier and function category.    *    * @param opTab    operator table to look up    * @param funName  function name    * @param funcType function category    * @return A sql function if and only if there is one operator matches, else null    */
specifier|public
specifier|static
name|SqlOperator
name|lookupSqlFunctionByID
parameter_list|(
name|SqlOperatorTable
name|opTab
parameter_list|,
name|SqlIdentifier
name|funName
parameter_list|,
name|SqlFunctionCategory
name|funcType
parameter_list|)
block|{
if|if
condition|(
name|funName
operator|.
name|isSimple
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|opTab
operator|.
name|lookupOperatorOverloads
argument_list|(
name|funName
argument_list|,
name|funcType
argument_list|,
name|SqlSyntax
operator|.
name|FUNCTION
argument_list|,
name|list
argument_list|,
name|SqlNameMatchers
operator|.
name|withCaseSensitive
argument_list|(
name|funName
operator|.
name|isComponentQuoted
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Validate the sql node with specified base table row type. For "base table", we mean the    * table that the sql node expression references fields with.    *    * @param caseSensitive whether to match the catalog case-sensitively    * @param operatorTable operator table    * @param typeFactory   type factory    * @param rowType       the table row type that has fields referenced by the expression    * @param expr          the expression to validate    * @return pair of a validated expression sql node and its data type,    * usually a SqlUnresolvedFunction is converted to a resolved function    */
specifier|public
specifier|static
name|Pair
argument_list|<
name|SqlNode
argument_list|,
name|RelDataType
argument_list|>
name|validateExprWithRowType
parameter_list|(
name|boolean
name|caseSensitive
parameter_list|,
name|SqlOperatorTable
name|operatorTable
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|SqlNode
name|expr
parameter_list|)
block|{
specifier|final
name|String
name|tableName
init|=
literal|"_table_"
decl_stmt|;
specifier|final
name|SqlSelect
name|select0
init|=
operator|new
name|SqlSelect
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
literal|null
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|expr
argument_list|)
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|tableName
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
init|=
name|createSingleTableCatalogReader
argument_list|(
name|caseSensitive
argument_list|,
name|tableName
argument_list|,
name|typeFactory
argument_list|,
name|rowType
argument_list|)
decl_stmt|;
name|SqlValidator
name|validator
init|=
name|newValidator
argument_list|(
name|operatorTable
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|SqlValidator
operator|.
name|Config
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|validator
operator|.
name|validate
argument_list|(
name|select0
argument_list|)
decl_stmt|;
assert|assert
name|select
operator|.
name|getSelectList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|:
literal|"Expression "
operator|+
name|expr
operator|+
literal|" should be atom expression"
assert|;
specifier|final
name|SqlNode
name|node
init|=
name|select
operator|.
name|getSelectList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|nodeType
init|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|select
argument_list|)
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|node
argument_list|,
name|nodeType
argument_list|)
return|;
block|}
comment|/**    * Creates a catalog reader that contains a single {@link Table} with temporary table name    * and specified {@code rowType}.    *    *<p>Make this method public so that other systems can also use it.    *    * @param caseSensitive whether to match case sensitively    * @param tableName     table name to register with    * @param typeFactory   type factory    * @param rowType       table row type    * @return the {@link CalciteCatalogReader} instance    */
specifier|public
specifier|static
name|CalciteCatalogReader
name|createSingleTableCatalogReader
parameter_list|(
name|boolean
name|caseSensitive
parameter_list|,
name|String
name|tableName
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
block|{
comment|// connection properties
name|Properties
name|properties
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|properties
operator|.
name|put
argument_list|(
name|CalciteConnectionProperty
operator|.
name|CASE_SENSITIVE
operator|.
name|camelName
argument_list|()
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|caseSensitive
argument_list|)
argument_list|)
expr_stmt|;
name|CalciteConnectionConfig
name|connectionConfig
init|=
operator|new
name|CalciteConnectionConfigImpl
argument_list|(
name|properties
argument_list|)
decl_stmt|;
comment|// prepare root schema
specifier|final
name|ExplicitRowTypeTable
name|table
init|=
operator|new
name|ExplicitRowTypeTable
argument_list|(
name|rowType
argument_list|)
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Table
argument_list|>
name|tableMap
init|=
name|Collections
operator|.
name|singletonMap
argument_list|(
name|tableName
argument_list|,
name|table
argument_list|)
decl_stmt|;
name|CalciteSchema
name|schema
init|=
name|CalciteSchema
operator|.
name|createRootSchema
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|,
literal|""
argument_list|,
operator|new
name|ExplicitTableSchema
argument_list|(
name|tableMap
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|CalciteCatalogReader
argument_list|(
name|schema
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
argument_list|,
name|typeFactory
argument_list|,
name|connectionConfig
argument_list|)
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Walks over an expression, copying every node, and fully-qualifying every    * identifier.    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
class|class
name|DeepCopier
extends|extends
name|SqlScopedShuttle
block|{
name|DeepCopier
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|super
argument_list|(
name|scope
argument_list|)
expr_stmt|;
block|}
comment|/** Copies a list of nodes. */
specifier|public
specifier|static
name|SqlNodeList
name|copy
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNodeList
name|list
parameter_list|)
block|{
comment|//noinspection deprecation
return|return
operator|(
name|SqlNodeList
operator|)
name|list
operator|.
name|accept
argument_list|(
operator|new
name|DeepCopier
argument_list|(
name|scope
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlNodeList
name|list
parameter_list|)
block|{
name|SqlNodeList
name|copy
init|=
operator|new
name|SqlNodeList
argument_list|(
name|list
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|list
control|)
block|{
name|copy
operator|.
name|add
argument_list|(
name|node
operator|.
name|accept
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
comment|// Override to copy all arguments regardless of whether visitor changes
comment|// them.
specifier|protected
name|SqlNode
name|visitScoped
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
name|ArgHandler
argument_list|<
name|SqlNode
argument_list|>
name|argHandler
init|=
operator|new
name|CallCopyingArgHandler
argument_list|(
name|call
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|acceptCall
argument_list|(
name|this
argument_list|,
name|call
argument_list|,
literal|false
argument_list|,
name|argHandler
argument_list|)
expr_stmt|;
return|return
name|argHandler
operator|.
name|result
argument_list|()
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
return|return
name|SqlNode
operator|.
name|clone
argument_list|(
name|literal
argument_list|)
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
comment|// First check for builtin functions which don't have parentheses,
comment|// like "LOCALTIME".
name|SqlValidator
name|validator
init|=
name|getScope
argument_list|()
operator|.
name|getValidator
argument_list|()
decl_stmt|;
specifier|final
name|SqlCall
name|call
init|=
name|validator
operator|.
name|makeNullaryCall
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
return|return
name|call
return|;
block|}
return|return
name|getScope
argument_list|()
operator|.
name|fullyQualify
argument_list|(
name|id
argument_list|)
operator|.
name|identifier
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlDataTypeSpec
name|type
parameter_list|)
block|{
return|return
name|SqlNode
operator|.
name|clone
argument_list|(
name|type
argument_list|)
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
return|return
name|SqlNode
operator|.
name|clone
argument_list|(
name|param
argument_list|)
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
name|SqlNode
operator|.
name|clone
argument_list|(
name|intervalQualifier
argument_list|)
return|;
block|}
block|}
comment|/** Suggests candidates for unique names, given the number of attempts so far    * and the number of expressions in the project list. */
specifier|public
interface|interface
name|Suggester
block|{
name|String
name|apply
parameter_list|(
name|String
name|original
parameter_list|,
name|int
name|attempt
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
block|}
specifier|public
specifier|static
specifier|final
name|Suggester
name|EXPR_SUGGESTER
init|=
parameter_list|(
name|original
parameter_list|,
name|attempt
parameter_list|,
name|size
parameter_list|)
lambda|->
name|Util
operator|.
name|first
argument_list|(
name|original
argument_list|,
literal|"EXPR$"
argument_list|)
operator|+
name|attempt
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Suggester
name|F_SUGGESTER
init|=
parameter_list|(
name|original
parameter_list|,
name|attempt
parameter_list|,
name|size
parameter_list|)
lambda|->
name|Util
operator|.
name|first
argument_list|(
name|original
argument_list|,
literal|"$f"
argument_list|)
operator|+
name|Math
operator|.
name|max
argument_list|(
name|size
argument_list|,
name|attempt
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Suggester
name|ATTEMPT_SUGGESTER
init|=
parameter_list|(
name|original
parameter_list|,
name|attempt
parameter_list|,
name|size
parameter_list|)
lambda|->
name|Util
operator|.
name|first
argument_list|(
name|original
argument_list|,
literal|"$"
argument_list|)
operator|+
name|attempt
decl_stmt|;
comment|/** Builds a list of GROUP BY expressions. */
specifier|static
class|class
name|GroupAnalyzer
block|{
comment|/** Extra expressions, computed from the input as extra GROUP BY      * expressions. For example, calls to the {@code TUMBLE} functions. */
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|extraExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|groupExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|groupExprProjection
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
block|}
comment|/**    * A {@link AbstractTable} that can specify the row type explicitly.    */
specifier|private
specifier|static
class|class
name|ExplicitRowTypeTable
extends|extends
name|AbstractTable
block|{
specifier|private
specifier|final
name|RelDataType
name|rowType
decl_stmt|;
name|ExplicitRowTypeTable
parameter_list|(
name|RelDataType
name|rowType
parameter_list|)
block|{
name|this
operator|.
name|rowType
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|rowType
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RelDataType
name|getRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|this
operator|.
name|rowType
return|;
block|}
block|}
comment|/**    * A {@link AbstractSchema} that can specify the table map explicitly.    */
specifier|private
specifier|static
class|class
name|ExplicitTableSchema
extends|extends
name|AbstractSchema
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Table
argument_list|>
name|tableMap
decl_stmt|;
name|ExplicitTableSchema
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Table
argument_list|>
name|tableMap
parameter_list|)
block|{
name|this
operator|.
name|tableMap
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|tableMap
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|Table
argument_list|>
name|getTableMap
parameter_list|()
block|{
return|return
name|tableMap
return|;
block|}
block|}
block|}
end_class

end_unit

