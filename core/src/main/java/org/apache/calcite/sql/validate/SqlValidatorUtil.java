begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Linq4j
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptSchemaWithSampling
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|prepare
operator|.
name|Prepare
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDataTypeSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIntervalQualifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_comment
comment|/**  * Utility methods related to validation.  */
end_comment

begin_class
specifier|public
class|class
name|SqlValidatorUtil
block|{
specifier|private
name|SqlValidatorUtil
parameter_list|()
block|{
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Converts a {@link SqlValidatorScope} into a {@link RelOptTable}. This is    * only possible if the scope represents an identifier, such as "sales.emp".    * Otherwise, returns null.    *    * @param namespace     Namespace    * @param catalogReader Schema    * @param datasetName   Name of sample dataset to substitute, or null to use    *                      the regular table    * @param usedDataset   Output parameter which is set to true if a sample    *                      dataset is found; may be null    */
specifier|public
specifier|static
name|RelOptTable
name|getRelOptTable
parameter_list|(
name|SqlValidatorNamespace
name|namespace
parameter_list|,
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
parameter_list|,
name|String
name|datasetName
parameter_list|,
name|boolean
index|[]
name|usedDataset
parameter_list|)
block|{
if|if
condition|(
operator|!
name|namespace
operator|.
name|isWrapperFor
argument_list|(
name|TableNamespace
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|TableNamespace
name|tableNamespace
init|=
name|namespace
operator|.
name|unwrap
argument_list|(
name|TableNamespace
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|tableNamespace
operator|.
name|getTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
decl_stmt|;
name|RelOptTable
name|table
decl_stmt|;
if|if
condition|(
name|datasetName
operator|!=
literal|null
operator|&&
name|catalogReader
operator|instanceof
name|RelOptSchemaWithSampling
condition|)
block|{
specifier|final
name|RelOptSchemaWithSampling
name|reader
init|=
operator|(
name|RelOptSchemaWithSampling
operator|)
name|catalogReader
decl_stmt|;
name|table
operator|=
name|reader
operator|.
name|getTableForMember
argument_list|(
name|names
argument_list|,
name|datasetName
argument_list|,
name|usedDataset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Schema does not support substitution. Ignore the data set, if any.
name|table
operator|=
name|catalogReader
operator|.
name|getTableForMember
argument_list|(
name|names
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tableNamespace
operator|.
name|extendedFields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|table
operator|=
name|table
operator|.
name|extend
argument_list|(
name|tableNamespace
operator|.
name|extendedFields
argument_list|)
expr_stmt|;
block|}
return|return
name|table
return|;
block|}
comment|/**    * Looks up a field with a given name, returning null if not found.    *    * @param caseSensitive Whether match is case-sensitive    * @param rowType    Row type    * @param columnName Field name    * @return Field, or null if not found    */
specifier|public
specifier|static
name|RelDataTypeField
name|lookupField
parameter_list|(
name|boolean
name|caseSensitive
parameter_list|,
specifier|final
name|RelDataType
name|rowType
parameter_list|,
name|String
name|columnName
parameter_list|)
block|{
return|return
name|rowType
operator|.
name|getField
argument_list|(
name|columnName
argument_list|,
name|caseSensitive
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|void
name|checkCharsetAndCollateConsistentIfCharType
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
comment|//(every charset must have a default collation)
if|if
condition|(
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|Charset
name|strCharset
init|=
name|type
operator|.
name|getCharset
argument_list|()
decl_stmt|;
name|Charset
name|colCharset
init|=
name|type
operator|.
name|getCollation
argument_list|()
operator|.
name|getCharset
argument_list|()
decl_stmt|;
assert|assert
literal|null
operator|!=
name|strCharset
assert|;
assert|assert
literal|null
operator|!=
name|colCharset
assert|;
if|if
condition|(
operator|!
name|strCharset
operator|.
name|equals
argument_list|(
name|colCharset
argument_list|)
condition|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
comment|// todo: enable this checking when we have a charset to
comment|//   collation mapping
throw|throw
operator|new
name|Error
argument_list|(
name|type
operator|.
name|toString
argument_list|()
operator|+
literal|" was found to have charset '"
operator|+
name|strCharset
operator|.
name|name
argument_list|()
operator|+
literal|"' and a mismatched collation charset '"
operator|+
name|colCharset
operator|.
name|name
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Converts an expression "expr" into "expr AS alias".    */
specifier|public
specifier|static
name|SqlNode
name|addAlias
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
specifier|final
name|SqlParserPos
name|pos
init|=
name|expr
operator|.
name|getParserPosition
argument_list|()
decl_stmt|;
specifier|final
name|SqlIdentifier
name|id
init|=
operator|new
name|SqlIdentifier
argument_list|(
name|alias
argument_list|,
name|pos
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|expr
argument_list|,
name|id
argument_list|)
return|;
block|}
comment|/**    * Derives an alias for a node, and invents a mangled identifier if it    * cannot.    *    *<p>Examples:    *    *<ul>    *<li>Alias: "1 + 2 as foo" yields "foo"    *<li>Identifier: "foo.bar.baz" yields "baz"    *<li>Anything else yields "expr$<i>ordinal</i>"    *</ul>    *    * @return An alias, if one can be derived; or a synthetic alias    * "expr$<i>ordinal</i>" if ordinal&lt; 0; otherwise null    */
specifier|public
specifier|static
name|String
name|getAlias
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
comment|// E.g. "1 + 2 as foo" --> "foo"
return|return
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
return|;
case|case
name|OVER
case|:
comment|// E.g. "bids over w" --> "bids"
return|return
name|getAlias
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|ordinal
argument_list|)
return|;
case|case
name|IDENTIFIER
case|:
comment|// E.g. "foo.bar" --> "bar"
return|return
name|Util
operator|.
name|last
argument_list|(
operator|(
operator|(
name|SqlIdentifier
operator|)
name|node
operator|)
operator|.
name|names
argument_list|)
return|;
default|default:
if|if
condition|(
name|ordinal
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|SqlUtil
operator|.
name|deriveAliasFromOrdinal
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Factory method for {@link SqlValidator}.    */
specifier|public
specifier|static
name|SqlValidatorWithHints
name|newValidator
parameter_list|(
name|SqlOperatorTable
name|opTab
parameter_list|,
name|SqlValidatorCatalogReader
name|catalogReader
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|SqlConformance
name|conformance
parameter_list|)
block|{
return|return
operator|new
name|SqlValidatorImpl
argument_list|(
name|opTab
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|conformance
argument_list|)
return|;
block|}
comment|/**    * Factory method for {@link SqlValidator}, with default conformance.    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|SqlValidatorWithHints
name|newValidator
parameter_list|(
name|SqlOperatorTable
name|opTab
parameter_list|,
name|SqlValidatorCatalogReader
name|catalogReader
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|newValidator
argument_list|(
name|opTab
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|SqlConformanceEnum
operator|.
name|DEFAULT
argument_list|)
return|;
block|}
comment|/**    * Makes a name distinct from other names which have already been used, adds    * it to the list, and returns it.    *    * @param name      Suggested name, may not be unique    * @param usedNames  Collection of names already used    * @param suggester Base for name when input name is null    * @return Unique name    */
specifier|public
specifier|static
name|String
name|uniquify
parameter_list|(
name|String
name|name
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|usedNames
parameter_list|,
name|Suggester
name|suggester
parameter_list|)
block|{
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|usedNames
operator|.
name|add
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|name
return|;
block|}
block|}
specifier|final
name|String
name|originalName
init|=
name|name
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
block|{
name|name
operator|=
name|suggester
operator|.
name|apply
argument_list|(
name|originalName
argument_list|,
name|j
argument_list|,
name|usedNames
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|usedNames
operator|.
name|add
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|name
return|;
block|}
block|}
block|}
comment|/**    * Makes sure that the names in a list are unique.    *    *<p>Does not modify the input list. Returns the input list if the strings    * are unique, otherwise allocates a new list. Deprecated in favor of caseSensitive    * aware version.    *    * @param nameList List of strings    * @return List of unique strings    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|uniquify
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|)
block|{
return|return
name|uniquify
argument_list|(
name|nameList
argument_list|,
name|EXPR_SUGGESTER
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Makes sure that the names in a list are unique.    *    *<p>Does not modify the input list. Returns the input list if the strings    * are unique, otherwise allocates a new list.    *    * @deprecated Use {@link #uniquify(List, Suggester, boolean)}    *    * @param nameList List of strings    * @param suggester How to generate new names if duplicate names are found    * @return List of unique strings    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|uniquify
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|,
name|Suggester
name|suggester
parameter_list|)
block|{
return|return
name|uniquify
argument_list|(
name|nameList
argument_list|,
name|suggester
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Makes sure that the names in a list are unique.    *    *<p>Does not modify the input list. Returns the input list if the strings    * are unique, otherwise allocates a new list.    *    * @param nameList List of strings    * @param caseSensitive Whether upper and lower case names are considered    *     distinct    * @return List of unique strings    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|uniquify
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|)
block|{
return|return
name|uniquify
argument_list|(
name|nameList
argument_list|,
name|EXPR_SUGGESTER
argument_list|,
name|caseSensitive
argument_list|)
return|;
block|}
comment|/**    * Makes sure that the names in a list are unique.    *    *<p>Does not modify the input list. Returns the input list if the strings    * are unique, otherwise allocates a new list.    *    * @param nameList List of strings    * @param suggester How to generate new names if duplicate names are found    * @param caseSensitive Whether upper and lower case names are considered    *     distinct    * @return List of unique strings    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|uniquify
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|,
name|Suggester
name|suggester
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|used
init|=
name|caseSensitive
condition|?
operator|new
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|()
else|:
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|String
operator|.
name|CASE_INSENSITIVE_ORDER
argument_list|)
decl_stmt|;
name|int
name|changeCount
init|=
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|newNameList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|nameList
control|)
block|{
name|String
name|uniqueName
init|=
name|uniquify
argument_list|(
name|name
argument_list|,
name|used
argument_list|,
name|suggester
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|uniqueName
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
operator|++
name|changeCount
expr_stmt|;
block|}
name|newNameList
operator|.
name|add
argument_list|(
name|uniqueName
argument_list|)
expr_stmt|;
block|}
return|return
name|changeCount
operator|==
literal|0
condition|?
name|nameList
else|:
name|newNameList
return|;
block|}
comment|/**    * Derives the type of a join relational expression.    *    * @param leftType        Row type of left input to join    * @param rightType       Row type of right input to join    * @param joinType        Type of join    * @param typeFactory     Type factory    * @param fieldNameList   List of names of fields; if null, field names are    *                        inherited and made unique    * @param systemFieldList List of system fields that will be prefixed to    *                        output row type; typically empty but must not be    *                        null    * @return join type    */
specifier|public
specifier|static
name|RelDataType
name|deriveJoinRowType
parameter_list|(
name|RelDataType
name|leftType
parameter_list|,
name|RelDataType
name|rightType
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|systemFieldList
parameter_list|)
block|{
assert|assert
name|systemFieldList
operator|!=
literal|null
assert|;
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|LEFT
case|:
name|rightType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|rightType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|leftType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|leftType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|FULL
case|:
name|leftType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|leftType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|rightType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|rightType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|createJoinType
argument_list|(
name|typeFactory
argument_list|,
name|leftType
argument_list|,
name|rightType
argument_list|,
name|fieldNameList
argument_list|,
name|systemFieldList
argument_list|)
return|;
block|}
comment|/**    * Returns the type the row which results when two relations are joined.    *    *<p>The resulting row type consists of    * the system fields (if any), followed by    * the fields of the left type, followed by    * the fields of the right type. The field name list, if present, overrides    * the original names of the fields.    *    * @param typeFactory     Type factory    * @param leftType        Type of left input to join    * @param rightType       Type of right input to join    * @param fieldNameList   If not null, overrides the original names of the    *                        fields    * @param systemFieldList List of system fields that will be prefixed to    *                        output row type; typically empty but must not be    *                        null    * @return type of row which results when two relations are joined    */
specifier|public
specifier|static
name|RelDataType
name|createJoinType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|leftType
parameter_list|,
name|RelDataType
name|rightType
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|systemFieldList
parameter_list|)
block|{
assert|assert
operator|(
name|fieldNameList
operator|==
literal|null
operator|)
operator|||
operator|(
name|fieldNameList
operator|.
name|size
argument_list|()
operator|==
operator|(
name|systemFieldList
operator|.
name|size
argument_list|()
operator|+
name|leftType
operator|.
name|getFieldCount
argument_list|()
operator|+
name|rightType
operator|.
name|getFieldCount
argument_list|()
operator|)
operator|)
assert|;
name|List
argument_list|<
name|String
argument_list|>
name|nameList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Use a set to keep track of the field names; this is needed
comment|// to ensure that the contains() call to check for name uniqueness
comment|// runs in constant time; otherwise, if the number of fields is large,
comment|// doing a contains() on a list can be expensive.
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|uniqueNameList
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|isSchemaCaseSensitive
argument_list|()
condition|?
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
else|:
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|String
operator|.
name|CASE_INSENSITIVE_ORDER
argument_list|)
decl_stmt|;
name|addFields
argument_list|(
name|systemFieldList
argument_list|,
name|typeList
argument_list|,
name|nameList
argument_list|,
name|uniqueNameList
argument_list|)
expr_stmt|;
name|addFields
argument_list|(
name|leftType
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|typeList
argument_list|,
name|nameList
argument_list|,
name|uniqueNameList
argument_list|)
expr_stmt|;
if|if
condition|(
name|rightType
operator|!=
literal|null
condition|)
block|{
name|addFields
argument_list|(
name|rightType
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|typeList
argument_list|,
name|nameList
argument_list|,
name|uniqueNameList
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fieldNameList
operator|!=
literal|null
condition|)
block|{
assert|assert
name|fieldNameList
operator|.
name|size
argument_list|()
operator|==
name|nameList
operator|.
name|size
argument_list|()
assert|;
name|nameList
operator|=
name|fieldNameList
expr_stmt|;
block|}
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|typeList
argument_list|,
name|nameList
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|addFields
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fieldList
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|uniqueNames
parameter_list|)
block|{
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|fieldList
control|)
block|{
name|String
name|name
init|=
name|field
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// Ensure that name is unique from all previous field names
if|if
condition|(
name|uniqueNames
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|nameBase
init|=
name|name
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
block|{
name|name
operator|=
name|nameBase
operator|+
name|j
expr_stmt|;
if|if
condition|(
operator|!
name|uniqueNames
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
name|nameList
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|uniqueNames
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|typeList
operator|.
name|add
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Resolves a multi-part identifier such as "SCHEMA.EMP.EMPNO" to a    * namespace. The returned namespace, never null, may represent a    * schema, table, column, etc.    */
specifier|public
specifier|static
name|SqlValidatorNamespace
name|lookup
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
block|{
assert|assert
name|names
operator|.
name|size
argument_list|()
operator|>
literal|0
assert|;
specifier|final
name|SqlValidatorScope
operator|.
name|ResolvedImpl
name|resolved
init|=
operator|new
name|SqlValidatorScope
operator|.
name|ResolvedImpl
argument_list|()
decl_stmt|;
name|scope
operator|.
name|resolve
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
assert|assert
name|resolved
operator|.
name|count
argument_list|()
operator|==
literal|1
assert|;
name|SqlValidatorNamespace
name|namespace
init|=
name|resolved
operator|.
name|only
argument_list|()
operator|.
name|namespace
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|Util
operator|.
name|skip
argument_list|(
name|names
argument_list|)
control|)
block|{
name|namespace
operator|=
name|namespace
operator|.
name|lookupChild
argument_list|(
name|name
argument_list|)
expr_stmt|;
assert|assert
name|namespace
operator|!=
literal|null
assert|;
block|}
return|return
name|namespace
return|;
block|}
specifier|public
specifier|static
name|void
name|getSchemaObjectMonikers
parameter_list|(
name|SqlValidatorCatalogReader
name|catalogReader
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|,
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|hints
parameter_list|)
block|{
comment|// Assume that the last name is 'dummy' or similar.
name|List
argument_list|<
name|String
argument_list|>
name|subNames
init|=
name|Util
operator|.
name|skipLast
argument_list|(
name|names
argument_list|)
decl_stmt|;
comment|// Try successively with catalog.schema, catalog and no prefix
name|List
argument_list|<
name|String
argument_list|>
name|x
init|=
name|catalogReader
operator|.
name|getSchemaName
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names2
init|=
name|ImmutableList
operator|.
expr|<
name|String
operator|>
name|builder
argument_list|()
operator|.
name|addAll
argument_list|(
name|x
argument_list|)
operator|.
name|addAll
argument_list|(
name|subNames
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|hints
operator|.
name|addAll
argument_list|(
name|catalogReader
operator|.
name|getAllSchemaObjectNames
argument_list|(
name|names2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
name|x
operator|=
name|Util
operator|.
name|skipLast
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|SelectScope
name|getEnclosingSelectScope
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
while|while
condition|(
name|scope
operator|instanceof
name|DelegatingScope
condition|)
block|{
if|if
condition|(
name|scope
operator|instanceof
name|SelectScope
condition|)
block|{
return|return
operator|(
name|SelectScope
operator|)
name|scope
return|;
block|}
name|scope
operator|=
operator|(
operator|(
name|DelegatingScope
operator|)
name|scope
operator|)
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
specifier|static
name|AggregatingSelectScope
name|getEnclosingAggregateSelectScope
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
while|while
condition|(
name|scope
operator|instanceof
name|DelegatingScope
condition|)
block|{
if|if
condition|(
name|scope
operator|instanceof
name|AggregatingSelectScope
condition|)
block|{
return|return
operator|(
name|AggregatingSelectScope
operator|)
name|scope
return|;
block|}
name|scope
operator|=
operator|(
operator|(
name|DelegatingScope
operator|)
name|scope
operator|)
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Derives the list of column names suitable for NATURAL JOIN. These are the    * columns that occur exactly once on each side of the join.    *    * @param leftRowType  Row type of left input to the join    * @param rightRowType Row type of right input to the join    * @return List of columns that occur once on each side    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|deriveNaturalJoinColumnList
parameter_list|(
name|RelDataType
name|leftRowType
parameter_list|,
name|RelDataType
name|rightRowType
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|naturalColumnNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|leftNames
init|=
name|leftRowType
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|rightNames
init|=
name|rightRowType
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|leftNames
control|)
block|{
if|if
condition|(
operator|(
name|Collections
operator|.
name|frequency
argument_list|(
name|leftNames
argument_list|,
name|name
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|Collections
operator|.
name|frequency
argument_list|(
name|rightNames
argument_list|,
name|name
argument_list|)
operator|==
literal|1
operator|)
condition|)
block|{
name|naturalColumnNames
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|naturalColumnNames
return|;
block|}
specifier|public
specifier|static
name|RelDataType
name|createTypeFromProjection
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNameList
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|)
block|{
comment|// If the names in columnNameList and type have case-sensitive differences,
comment|// the resulting type will use those from type. These are presumably more
comment|// canonical.
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|columnNameList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|columnNameList
control|)
block|{
name|RelDataTypeField
name|field
init|=
name|type
operator|.
name|getField
argument_list|(
name|name
argument_list|,
name|caseSensitive
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|type
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|fields
argument_list|)
return|;
block|}
comment|/** Analyzes an expression in a GROUP BY clause.    *    *<p>It may be an expression, an empty list (), or a call to    * {@code GROUPING SETS}, {@code CUBE} or {@code ROLLUP}.    *    *<p>Each group item produces a list of group sets, which are written to    * {@code topBuilder}. To find the grouping sets of the query, we will take    * the cartesian product of the group sets. */
specifier|public
specifier|static
name|void
name|analyzeGroupItem
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|groupExprs
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|groupExprProjection
parameter_list|,
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
argument_list|>
name|topBuilder
parameter_list|,
name|SqlNode
name|groupExpr
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableBitSet
argument_list|>
name|builder
decl_stmt|;
switch|switch
condition|(
name|groupExpr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CUBE
case|:
case|case
name|ROLLUP
case|:
comment|// E.g. ROLLUP(a, (b, c)) becomes [{0}, {1, 2}]
comment|// then we roll up to [(0, 1, 2), (0), ()]  -- note no (0, 1)
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|bitSets
init|=
name|analyzeGroupTuple
argument_list|(
name|scope
argument_list|,
name|groupExprs
argument_list|,
name|groupExprProjection
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|groupExpr
operator|)
operator|.
name|getOperandList
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|groupExpr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|ROLLUP
case|:
name|topBuilder
operator|.
name|add
argument_list|(
name|rollup
argument_list|(
name|bitSets
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|topBuilder
operator|.
name|add
argument_list|(
name|cube
argument_list|(
name|bitSets
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|OTHER
case|:
if|if
condition|(
name|groupExpr
operator|instanceof
name|SqlNodeList
condition|)
block|{
name|SqlNodeList
name|list
init|=
operator|(
name|SqlNodeList
operator|)
name|groupExpr
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|list
control|)
block|{
name|analyzeGroupItem
argument_list|(
name|scope
argument_list|,
name|groupExprs
argument_list|,
name|groupExprProjection
argument_list|,
name|topBuilder
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// fall through
case|case
name|GROUPING_SETS
case|:
default|default:
name|builder
operator|=
name|ImmutableList
operator|.
name|builder
argument_list|()
expr_stmt|;
name|convertGroupSet
argument_list|(
name|scope
argument_list|,
name|groupExprs
argument_list|,
name|groupExprProjection
argument_list|,
name|builder
argument_list|,
name|groupExpr
argument_list|)
expr_stmt|;
name|topBuilder
operator|.
name|add
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Analyzes a GROUPING SETS item in a GROUP BY clause. */
specifier|private
specifier|static
name|void
name|convertGroupSet
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|groupExprs
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|groupExprProjection
parameter_list|,
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableBitSet
argument_list|>
name|builder
parameter_list|,
name|SqlNode
name|groupExpr
parameter_list|)
block|{
switch|switch
condition|(
name|groupExpr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|GROUPING_SETS
case|:
specifier|final
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|groupExpr
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|convertGroupSet
argument_list|(
name|scope
argument_list|,
name|groupExprs
argument_list|,
name|groupExprProjection
argument_list|,
name|builder
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|ROW
case|:
specifier|final
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|bitSets
init|=
name|analyzeGroupTuple
argument_list|(
name|scope
argument_list|,
name|groupExprs
argument_list|,
name|groupExprProjection
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|groupExpr
operator|)
operator|.
name|getOperandList
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|ImmutableBitSet
operator|.
name|union
argument_list|(
name|bitSets
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|builder
operator|.
name|add
argument_list|(
name|analyzeGroupExpr
argument_list|(
name|scope
argument_list|,
name|groupExprs
argument_list|,
name|groupExprProjection
argument_list|,
name|groupExpr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/** Analyzes a tuple in a GROUPING SETS clause.    *    *<p>For example, in {@code GROUP BY GROUPING SETS ((a, b), a, c)},    * {@code (a, b)} is a tuple.    *    *<p>Gathers into {@code groupExprs} the set of distinct expressions being    * grouped, and returns a bitmap indicating which expressions this tuple    * is grouping. */
specifier|private
specifier|static
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|analyzeGroupTuple
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|groupExprs
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|groupExprProjection
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operandList
parameter_list|)
block|{
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|operandList
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|analyzeGroupExpr
argument_list|(
name|scope
argument_list|,
name|groupExprs
argument_list|,
name|groupExprProjection
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/** Analyzes a component of a tuple in a GROUPING SETS clause. */
specifier|private
specifier|static
name|ImmutableBitSet
name|analyzeGroupExpr
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|groupExprs
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|groupExprProjection
parameter_list|,
name|SqlNode
name|groupExpr
parameter_list|)
block|{
specifier|final
name|SqlNode
name|expandedGroupExpr
init|=
name|scope
operator|.
name|getValidator
argument_list|()
operator|.
name|expand
argument_list|(
name|groupExpr
argument_list|,
name|scope
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|expandedGroupExpr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|ROW
case|:
return|return
name|ImmutableBitSet
operator|.
name|union
argument_list|(
name|analyzeGroupTuple
argument_list|(
name|scope
argument_list|,
name|groupExprs
argument_list|,
name|groupExprProjection
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|expandedGroupExpr
operator|)
operator|.
name|getOperandList
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|OTHER
case|:
if|if
condition|(
name|expandedGroupExpr
operator|instanceof
name|SqlNodeList
operator|&&
operator|(
operator|(
name|SqlNodeList
operator|)
name|expandedGroupExpr
operator|)
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|ImmutableBitSet
operator|.
name|of
argument_list|()
return|;
block|}
block|}
specifier|final
name|int
name|ref
init|=
name|lookupGroupExpr
argument_list|(
name|groupExprs
argument_list|,
name|groupExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|expandedGroupExpr
operator|instanceof
name|SqlIdentifier
condition|)
block|{
comment|// SQL 2003 does not allow expressions of column references
name|SqlIdentifier
name|expr
init|=
operator|(
name|SqlIdentifier
operator|)
name|expandedGroupExpr
decl_stmt|;
comment|// column references should be fully qualified.
assert|assert
name|expr
operator|.
name|names
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
name|String
name|originalRelName
init|=
name|expr
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|originalFieldName
init|=
name|expr
operator|.
name|names
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorScope
operator|.
name|ResolvedImpl
name|resolved
init|=
operator|new
name|SqlValidatorScope
operator|.
name|ResolvedImpl
argument_list|()
decl_stmt|;
name|scope
operator|.
name|resolve
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|originalRelName
argument_list|)
argument_list|,
literal|false
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
assert|assert
name|resolved
operator|.
name|count
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|SqlValidatorScope
operator|.
name|Resolve
name|resolve
init|=
name|resolved
operator|.
name|only
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|foundNs
init|=
name|resolve
operator|.
name|namespace
decl_stmt|;
specifier|final
name|int
name|childNamespaceIndex
init|=
name|resolve
operator|.
name|path
operator|.
name|steps
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|i
decl_stmt|;
name|int
name|namespaceOffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|childNamespaceIndex
operator|>
literal|0
condition|)
block|{
comment|// If not the first child, need to figure out the width of
comment|// output types from all the preceding namespaces
specifier|final
name|SqlValidatorScope
name|ancestorScope
init|=
name|resolve
operator|.
name|scope
decl_stmt|;
assert|assert
name|ancestorScope
operator|instanceof
name|ListScope
assert|;
name|List
argument_list|<
name|SqlValidatorNamespace
argument_list|>
name|children
init|=
operator|(
operator|(
name|ListScope
operator|)
name|ancestorScope
operator|)
operator|.
name|getChildren
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|childNamespaceIndex
condition|;
name|j
operator|++
control|)
block|{
name|namespaceOffset
operator|+=
name|children
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
block|}
name|RelDataTypeField
name|field
init|=
name|scope
operator|.
name|getValidator
argument_list|()
operator|.
name|getCatalogReader
argument_list|()
operator|.
name|field
argument_list|(
name|foundNs
operator|.
name|getRowType
argument_list|()
argument_list|,
name|originalFieldName
argument_list|)
decl_stmt|;
name|int
name|origPos
init|=
name|namespaceOffset
operator|+
name|field
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|groupExprProjection
operator|.
name|put
argument_list|(
name|origPos
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|ref
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|lookupGroupExpr
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|groupExprs
parameter_list|,
name|SqlNode
name|expr
parameter_list|)
block|{
for|for
control|(
name|Ord
argument_list|<
name|SqlNode
argument_list|>
name|node
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|groupExprs
argument_list|)
control|)
block|{
if|if
condition|(
name|node
operator|.
name|e
operator|.
name|equalsDeep
argument_list|(
name|expr
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
return|return
name|node
operator|.
name|i
return|;
block|}
block|}
name|groupExprs
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|groupExprs
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
block|}
comment|/** Computes the rollup of bit sets.    *    *<p>For example,<code>rollup({0}, {1})</code>    * returns<code>({0, 1}, {0}, {})</code>.    *    *<p>Bit sets are not necessarily singletons:    *<code>rollup({0, 2}, {3, 5})</code>    * returns<code>({0, 2, 3, 5}, {0, 2}, {})</code>. */
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|rollup
parameter_list|(
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|bitSets
parameter_list|)
block|{
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|builder
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|ImmutableBitSet
name|union
init|=
name|ImmutableBitSet
operator|.
name|union
argument_list|(
name|bitSets
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|union
argument_list|)
expr_stmt|;
if|if
condition|(
name|union
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
name|bitSets
operator|=
name|bitSets
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|bitSets
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|builder
argument_list|)
return|;
block|}
comment|/** Computes the cube of bit sets.    *    *<p>For example,<code>rollup({0}, {1})</code>    * returns<code>({0, 1}, {0}, {})</code>.    *    *<p>Bit sets are not necessarily singletons:    *<code>rollup({0, 2}, {3, 5})</code>    * returns<code>({0, 2, 3, 5}, {0, 2}, {})</code>. */
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|cube
parameter_list|(
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|bitSets
parameter_list|)
block|{
comment|// Given the bit sets [{1}, {2, 3}, {5}],
comment|// form the lists [[{1}, {}], [{2, 3}, {}], [{5}, {}]].
specifier|final
name|Set
argument_list|<
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
argument_list|>
name|builder
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|ImmutableBitSet
name|bitSet
range|:
name|bitSets
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|bitSet
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|flattenedBitSets
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|o
range|:
name|Linq4j
operator|.
name|product
argument_list|(
name|builder
argument_list|)
control|)
block|{
name|flattenedBitSets
operator|.
name|add
argument_list|(
name|ImmutableBitSet
operator|.
name|union
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|flattenedBitSets
argument_list|)
return|;
block|}
comment|/**    * Returns whether there are any input columns that are sorted.    *    *<p>If so, it can be the default ORDER BY clause for a WINDOW specification.    * (This is an extension to the SQL standard for streaming.)    */
specifier|public
specifier|static
name|boolean
name|containsMonotonic
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
for|for
control|(
name|SqlValidatorNamespace
name|ns
range|:
name|children
argument_list|(
name|scope
argument_list|)
control|)
block|{
name|ns
operator|=
name|ns
operator|.
name|resolve
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|field
range|:
name|ns
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|ns
operator|.
name|getMonotonicity
argument_list|(
name|field
argument_list|)
operator|.
name|mayRepeat
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|SqlValidatorNamespace
argument_list|>
name|children
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
return|return
name|scope
operator|instanceof
name|ListScope
condition|?
operator|(
operator|(
name|ListScope
operator|)
name|scope
operator|)
operator|.
name|getChildren
argument_list|()
else|:
name|ImmutableList
operator|.
expr|<
name|SqlValidatorNamespace
operator|>
name|of
argument_list|()
return|;
block|}
comment|/**    * Returns whether any of the given expressions are sorted.    *    *<p>If so, it can be the default ORDER BY clause for a WINDOW specification.    * (This is an extension to the SQL standard for streaming.)    */
specifier|static
name|boolean
name|containsMonotonic
parameter_list|(
name|SelectScope
name|scope
parameter_list|,
name|SqlNodeList
name|nodes
parameter_list|)
block|{
for|for
control|(
name|SqlNode
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
operator|!
name|scope
operator|.
name|getMonotonicity
argument_list|(
name|node
argument_list|)
operator|.
name|mayRepeat
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Walks over an expression, copying every node, and fully-qualifying every    * identifier.    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
class|class
name|DeepCopier
extends|extends
name|SqlScopedShuttle
block|{
name|DeepCopier
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|super
argument_list|(
name|scope
argument_list|)
expr_stmt|;
block|}
comment|/** Copies a list of nodes. */
specifier|public
specifier|static
name|SqlNodeList
name|copy
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNodeList
name|list
parameter_list|)
block|{
return|return
operator|(
name|SqlNodeList
operator|)
name|list
operator|.
name|accept
argument_list|(
operator|new
name|DeepCopier
argument_list|(
name|scope
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlNodeList
name|list
parameter_list|)
block|{
name|SqlNodeList
name|copy
init|=
operator|new
name|SqlNodeList
argument_list|(
name|list
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|list
control|)
block|{
name|copy
operator|.
name|add
argument_list|(
name|node
operator|.
name|accept
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
comment|// Override to copy all arguments regardless of whether visitor changes
comment|// them.
specifier|protected
name|SqlNode
name|visitScoped
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
name|ArgHandler
argument_list|<
name|SqlNode
argument_list|>
name|argHandler
init|=
operator|new
name|CallCopyingArgHandler
argument_list|(
name|call
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|acceptCall
argument_list|(
name|this
argument_list|,
name|call
argument_list|,
literal|false
argument_list|,
name|argHandler
argument_list|)
expr_stmt|;
return|return
name|argHandler
operator|.
name|result
argument_list|()
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
return|return
operator|(
name|SqlNode
operator|)
name|literal
operator|.
name|clone
argument_list|()
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
comment|// First check for builtin functions which don't have parentheses,
comment|// like "LOCALTIME".
specifier|final
name|SqlCall
name|call
init|=
name|SqlUtil
operator|.
name|makeCall
argument_list|(
name|getScope
argument_list|()
operator|.
name|getValidator
argument_list|()
operator|.
name|getOperatorTable
argument_list|()
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
return|return
name|call
return|;
block|}
return|return
name|getScope
argument_list|()
operator|.
name|fullyQualify
argument_list|(
name|id
argument_list|)
operator|.
name|identifier
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlDataTypeSpec
name|type
parameter_list|)
block|{
return|return
operator|(
name|SqlNode
operator|)
name|type
operator|.
name|clone
argument_list|()
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
return|return
operator|(
name|SqlNode
operator|)
name|param
operator|.
name|clone
argument_list|()
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
operator|(
name|SqlNode
operator|)
name|intervalQualifier
operator|.
name|clone
argument_list|()
return|;
block|}
block|}
comment|/** Suggests candidates for unique names, given the number of attempts so far    * and the number of expressions in the project list. */
specifier|public
interface|interface
name|Suggester
block|{
name|String
name|apply
parameter_list|(
name|String
name|original
parameter_list|,
name|int
name|attempt
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
block|}
specifier|public
specifier|static
specifier|final
name|Suggester
name|EXPR_SUGGESTER
init|=
operator|new
name|Suggester
argument_list|()
block|{
specifier|public
name|String
name|apply
parameter_list|(
name|String
name|original
parameter_list|,
name|int
name|attempt
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
name|Util
operator|.
name|first
argument_list|(
name|original
argument_list|,
literal|"EXPR$"
argument_list|)
operator|+
name|attempt
return|;
block|}
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Suggester
name|F_SUGGESTER
init|=
operator|new
name|Suggester
argument_list|()
block|{
specifier|public
name|String
name|apply
parameter_list|(
name|String
name|original
parameter_list|,
name|int
name|attempt
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
name|Util
operator|.
name|first
argument_list|(
name|original
argument_list|,
literal|"$f"
argument_list|)
operator|+
name|Math
operator|.
name|max
argument_list|(
name|size
argument_list|,
name|attempt
argument_list|)
return|;
block|}
block|}
decl_stmt|;
block|}
end_class

begin_comment
comment|// End SqlValidatorUtil.java
end_comment

end_unit

