begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Functions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypePrecedenceList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|CalciteContextException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|CalciteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlBasicVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlNameMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|BarfingInvocationHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ConversionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Glossary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NlsString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicates
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Utf8
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterators
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|UnsupportedCharsetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DatabaseMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|MessageFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
operator|.
name|RESOURCE
import|;
end_import

begin_comment
comment|/**  * Contains utility functions related to SQL parsing, all static.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|SqlUtil
block|{
comment|//~ Methods ----------------------------------------------------------------
specifier|static
name|SqlNode
name|andExpressions
parameter_list|(
name|SqlNode
name|node1
parameter_list|,
name|SqlNode
name|node2
parameter_list|)
block|{
if|if
condition|(
name|node1
operator|==
literal|null
condition|)
block|{
return|return
name|node2
return|;
block|}
name|ArrayList
argument_list|<
name|SqlNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|node1
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
condition|)
block|{
name|list
operator|.
name|addAll
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|node1
operator|)
operator|.
name|getOperandList
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|node1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node2
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
condition|)
block|{
name|list
operator|.
name|addAll
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|node2
operator|)
operator|.
name|getOperandList
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|node2
argument_list|)
expr_stmt|;
block|}
return|return
name|SqlStdOperatorTable
operator|.
name|AND
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|list
argument_list|)
return|;
block|}
specifier|static
name|ArrayList
argument_list|<
name|SqlNode
argument_list|>
name|flatten
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|SqlNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|flatten
argument_list|(
name|node
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|/**    * Returns the<code>n</code>th (0-based) input to a join expression.    */
specifier|public
specifier|static
name|SqlNode
name|getFromNode
parameter_list|(
name|SqlSelect
name|query
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|SqlNode
argument_list|>
name|list
init|=
name|flatten
argument_list|(
name|query
operator|.
name|getFrom
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|list
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|flatten
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|ArrayList
argument_list|<
name|SqlNode
argument_list|>
name|list
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|JOIN
case|:
name|SqlJoin
name|join
init|=
operator|(
name|SqlJoin
operator|)
name|node
decl_stmt|;
name|flatten
argument_list|(
name|join
operator|.
name|getLeft
argument_list|()
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|flatten
argument_list|(
name|join
operator|.
name|getRight
argument_list|()
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return;
case|case
name|AS
case|:
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
name|flatten
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return;
default|default:
name|list
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/**    * Converts an SqlNode array to a SqlNodeList    */
specifier|public
specifier|static
name|SqlNodeList
name|toNodeList
parameter_list|(
name|SqlNode
index|[]
name|operands
parameter_list|)
block|{
name|SqlNodeList
name|ret
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|operands
control|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Returns whether a node represents the NULL value.    *    *<p>Examples:    *    *<ul>    *<li>For {@link SqlLiteral} Unknown, returns false.    *<li>For<code>CAST(NULL AS<i>type</i>)</code>, returns true if<code>    * allowCast</code> is true, false otherwise.    *<li>For<code>CAST(CAST(NULL AS<i>type</i>) AS<i>type</i>))</code>,    * returns false.    *</ul>    */
specifier|public
specifier|static
name|boolean
name|isNullLiteral
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|boolean
name|allowCast
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlLiteral
condition|)
block|{
name|SqlLiteral
name|literal
init|=
operator|(
name|SqlLiteral
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
condition|)
block|{
assert|assert
literal|null
operator|==
name|literal
operator|.
name|getValue
argument_list|()
assert|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// We don't regard UNKNOWN -- SqlLiteral(null,Boolean) -- as
comment|// NULL.
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|allowCast
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
condition|)
block|{
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|isNullLiteral
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// node is "CAST(NULL as type)"
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether a node represents the NULL value or a series of nested    *<code>CAST(NULL AS type)</code> calls. For example:    *<code>isNull(CAST(CAST(NULL as INTEGER) AS VARCHAR(1)))</code>    * returns {@code true}.    */
specifier|public
specifier|static
name|boolean
name|isNull
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
return|return
name|isNullLiteral
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
operator|||
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
operator|&&
name|isNull
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns whether a node is a literal.    *    *<p>Examples:    *    *<ul>    *<li>For<code>CAST(literal AS<i>type</i>)</code>, returns true if<code>    * allowCast</code> is true, false otherwise.    *<li>For<code>CAST(CAST(literal AS<i>type</i>) AS<i>type</i>))</code>,    * returns false.    *</ul>    *    * @param node The node, never null.    * @param allowCast whether to regard CAST(literal) as a literal    * @return Whether the node is a literal    */
specifier|public
specifier|static
name|boolean
name|isLiteral
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|boolean
name|allowCast
parameter_list|)
block|{
assert|assert
name|node
operator|!=
literal|null
assert|;
if|if
condition|(
name|node
operator|instanceof
name|SqlLiteral
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|allowCast
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
condition|)
block|{
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|isLiteral
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// node is "CAST(literal as type)"
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether a node is a literal.    *    *<p>Many constructs which require literals also accept<code>CAST(NULL AS    *<i>type</i>)</code>. This method does not accept casts, so you should    * call {@link #isNullLiteral} first.    *    * @param node The node, never null.    * @return Whether the node is a literal    */
specifier|public
specifier|static
name|boolean
name|isLiteral
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
return|return
name|isLiteral
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns whether a node is a literal chain which is used to represent a    * continued string literal.    *    * @param node The node, never null.    * @return Whether the node is a literal chain    */
specifier|public
specifier|static
name|boolean
name|isLiteralChain
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
assert|assert
name|node
operator|!=
literal|null
assert|;
if|if
condition|(
name|node
operator|instanceof
name|SqlCall
condition|)
block|{
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
return|return
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LITERAL_CHAIN
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Unparses a call to an operator which has function syntax.    *    * @param operator    The operator    * @param writer      Writer    * @param call    List of 0 or more operands    */
specifier|public
specifier|static
name|void
name|unparseFunctionSyntax
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|SqlWriter
name|writer
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|operator
operator|instanceof
name|SqlFunction
condition|)
block|{
name|SqlFunction
name|function
init|=
operator|(
name|SqlFunction
operator|)
name|operator
decl_stmt|;
if|if
condition|(
name|function
operator|.
name|getFunctionType
argument_list|()
operator|.
name|isSpecific
argument_list|()
condition|)
block|{
name|writer
operator|.
name|keyword
argument_list|(
literal|"SPECIFIC"
argument_list|)
expr_stmt|;
block|}
name|SqlIdentifier
name|id
init|=
name|function
operator|.
name|getSqlIdentifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
name|writer
operator|.
name|keyword
argument_list|(
name|operator
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unparseSqlIdentifierSyntax
argument_list|(
name|writer
argument_list|,
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|writer
operator|.
name|print
argument_list|(
name|operator
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getSyntax
argument_list|()
condition|)
block|{
case|case
name|FUNCTION_ID
case|:
comment|// For example, the "LOCALTIME" function appears as "LOCALTIME"
comment|// when it has 0 args, not "LOCALTIME()".
return|return;
case|case
name|FUNCTION_STAR
case|:
comment|// E.g. "COUNT(*)"
case|case
name|FUNCTION
case|:
comment|// E.g. "RANK()"
comment|// fall through - dealt with below
block|}
block|}
specifier|final
name|SqlWriter
operator|.
name|Frame
name|frame
init|=
name|writer
operator|.
name|startList
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|FUN_CALL
argument_list|,
literal|"("
argument_list|,
literal|")"
argument_list|)
decl_stmt|;
specifier|final
name|SqlLiteral
name|quantifier
init|=
name|call
operator|.
name|getFunctionQuantifier
argument_list|()
decl_stmt|;
if|if
condition|(
name|quantifier
operator|!=
literal|null
condition|)
block|{
name|quantifier
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getSyntax
argument_list|()
condition|)
block|{
case|case
name|FUNCTION_STAR
case|:
name|writer
operator|.
name|sep
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|writer
operator|.
name|sep
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|operand
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|endList
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
comment|/**    * Unparse a SqlIdentifier syntax.    *    * @param writer       Writer    * @param identifier   SqlIdentifier    * @param asFunctionID Whether this identifier comes from a SqlFunction    */
specifier|public
specifier|static
name|void
name|unparseSqlIdentifierSyntax
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlIdentifier
name|identifier
parameter_list|,
name|boolean
name|asFunctionID
parameter_list|)
block|{
specifier|final
name|boolean
name|isUnquotedSimple
init|=
name|identifier
operator|.
name|isSimple
argument_list|()
operator|&&
operator|!
name|identifier
operator|.
name|getParserPosition
argument_list|()
operator|.
name|isQuoted
argument_list|()
decl_stmt|;
specifier|final
name|SqlOperator
name|operator
init|=
name|isUnquotedSimple
condition|?
name|SqlValidatorUtil
operator|.
name|lookupSqlFunctionByID
argument_list|(
name|SqlStdOperatorTable
operator|.
name|instance
argument_list|()
argument_list|,
name|identifier
argument_list|,
literal|null
argument_list|)
else|:
literal|null
decl_stmt|;
name|boolean
name|unparsedAsFunc
init|=
literal|false
decl_stmt|;
specifier|final
name|SqlWriter
operator|.
name|Frame
name|frame
init|=
name|writer
operator|.
name|startList
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|IDENTIFIER
argument_list|)
decl_stmt|;
if|if
condition|(
name|isUnquotedSimple
operator|&&
name|operator
operator|!=
literal|null
condition|)
block|{
comment|// Unparse conditions:
comment|// 1. If the identifier is quoted or is component, unparse as normal.
comment|// 2. If the identifier comes from a sql function, lookup in the
comment|// standard sql operator table to see if the function is a builtin,
comment|// unparse without quoting for builtins.
comment|// 3. If the identifier does not come from a function(resolved as a SqlIdentifier),
comment|// look up in the standard sql operator table to see if it is a function
comment|// with empty argument list, e.g. LOCALTIME, we should not quote
comment|// such identifier cause quoted `LOCALTIME` always represents a sql identifier.
if|if
condition|(
name|asFunctionID
operator|||
name|operator
operator|.
name|getSyntax
argument_list|()
operator|==
name|SqlSyntax
operator|.
name|FUNCTION_ID
condition|)
block|{
name|writer
operator|.
name|keyword
argument_list|(
name|identifier
operator|.
name|getSimple
argument_list|()
argument_list|)
expr_stmt|;
name|unparsedAsFunc
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|unparsedAsFunc
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|identifier
operator|.
name|names
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|writer
operator|.
name|sep
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
name|identifier
operator|.
name|names
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|SqlParserPos
name|pos
init|=
name|identifier
operator|.
name|getComponentParserPosition
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|writer
operator|.
name|print
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|identifier
argument_list|(
name|name
argument_list|,
name|pos
operator|.
name|isQuoted
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
literal|null
operator|!=
name|identifier
operator|.
name|getCollation
argument_list|()
condition|)
block|{
name|identifier
operator|.
name|getCollation
argument_list|()
operator|.
name|unparse
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|endList
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|unparseBinarySyntax
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|SqlWriter
name|writer
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|2
assert|;
specifier|final
name|SqlWriter
operator|.
name|Frame
name|frame
init|=
name|writer
operator|.
name|startList
argument_list|(
operator|(
name|operator
operator|instanceof
name|SqlSetOperator
operator|)
condition|?
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|SETOP
else|:
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|SIMPLE
argument_list|)
decl_stmt|;
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
name|leftPrec
argument_list|,
name|operator
operator|.
name|getLeftPrec
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|needsSpace
init|=
name|operator
operator|.
name|needsSpace
argument_list|()
decl_stmt|;
name|writer
operator|.
name|setNeedWhitespace
argument_list|(
name|needsSpace
argument_list|)
expr_stmt|;
name|writer
operator|.
name|sep
argument_list|(
name|operator
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|setNeedWhitespace
argument_list|(
name|needsSpace
argument_list|)
expr_stmt|;
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
name|operator
operator|.
name|getRightPrec
argument_list|()
argument_list|,
name|rightPrec
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
comment|/**    * Concatenates string literals.    *    *<p>This method takes an array of arguments, since pairwise concatenation    * means too much string copying.    *    * @param lits an array of {@link SqlLiteral}, not empty, all of the same    *             class    * @return a new {@link SqlLiteral}, of that same class, whose value is the    * string concatenation of the values of the literals    * @throws ClassCastException             if the lits are not homogeneous.    * @throws ArrayIndexOutOfBoundsException if lits is an empty array.    */
specifier|public
specifier|static
name|SqlLiteral
name|concatenateLiterals
parameter_list|(
name|List
argument_list|<
name|SqlLiteral
argument_list|>
name|lits
parameter_list|)
block|{
if|if
condition|(
name|lits
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|lits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
comment|// nothing to do
block|}
return|return
operator|(
operator|(
name|SqlAbstractStringLiteral
operator|)
name|lits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|concat1
argument_list|(
name|lits
argument_list|)
return|;
block|}
comment|/**    * Looks up a (possibly overloaded) routine based on name and argument    * types.    *    * @param opTab         operator table to search    * @param funcName      name of function being invoked    * @param argTypes      argument types    * @param argNames      argument names, or null if call by position    * @param category      whether a function or a procedure. (If a procedure is    *                      being invoked, the overload rules are simpler.)    * @param nameMatcher   Whether to look up the function case-sensitively    * @param coerce        Whether to allow type coercion when do filter routines    *                      by parameter types    * @return matching routine, or null if none found    *    * @see Glossary#SQL99 SQL:1999 Part 2 Section 10.4    */
specifier|public
specifier|static
name|SqlOperator
name|lookupRoutine
parameter_list|(
name|SqlOperatorTable
name|opTab
parameter_list|,
name|SqlIdentifier
name|funcName
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argNames
parameter_list|,
name|SqlFunctionCategory
name|category
parameter_list|,
name|SqlSyntax
name|syntax
parameter_list|,
name|SqlKind
name|sqlKind
parameter_list|,
name|SqlNameMatcher
name|nameMatcher
parameter_list|,
name|boolean
name|coerce
parameter_list|)
block|{
name|Iterator
argument_list|<
name|SqlOperator
argument_list|>
name|list
init|=
name|lookupSubjectRoutines
argument_list|(
name|opTab
argument_list|,
name|funcName
argument_list|,
name|argTypes
argument_list|,
name|argNames
argument_list|,
name|syntax
argument_list|,
name|sqlKind
argument_list|,
name|category
argument_list|,
name|nameMatcher
argument_list|,
name|coerce
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// return first on schema path
return|return
name|list
operator|.
name|next
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|static
name|Iterator
argument_list|<
name|SqlOperator
argument_list|>
name|filterOperatorRoutinesByKind
parameter_list|(
name|Iterator
argument_list|<
name|SqlOperator
argument_list|>
name|routines
parameter_list|,
specifier|final
name|SqlKind
name|sqlKind
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|routines
argument_list|,
name|operator
lambda|->
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|operator
argument_list|)
operator|.
name|getKind
argument_list|()
operator|==
name|sqlKind
argument_list|)
return|;
block|}
comment|/**    * Looks up all subject routines matching the given name and argument types.    *    * @param opTab       operator table to search    * @param funcName    name of function being invoked    * @param argTypes    argument types    * @param argNames    argument names, or null if call by position    * @param sqlSyntax   the SqlSyntax of the SqlOperator being looked up    * @param sqlKind     the SqlKind of the SqlOperator being looked up    * @param category    Category of routine to look up    * @param nameMatcher Whether to look up the function case-sensitively    * @param coerce      Whether to allow type coercion when do filter routine    *                    by parameter types    * @return list of matching routines    * @see Glossary#SQL99 SQL:1999 Part 2 Section 10.4    */
specifier|public
specifier|static
name|Iterator
argument_list|<
name|SqlOperator
argument_list|>
name|lookupSubjectRoutines
parameter_list|(
name|SqlOperatorTable
name|opTab
parameter_list|,
name|SqlIdentifier
name|funcName
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argNames
parameter_list|,
name|SqlSyntax
name|sqlSyntax
parameter_list|,
name|SqlKind
name|sqlKind
parameter_list|,
name|SqlFunctionCategory
name|category
parameter_list|,
name|SqlNameMatcher
name|nameMatcher
parameter_list|,
name|boolean
name|coerce
parameter_list|)
block|{
comment|// start with all routines matching by name
name|Iterator
argument_list|<
name|SqlOperator
argument_list|>
name|routines
init|=
name|lookupSubjectRoutinesByName
argument_list|(
name|opTab
argument_list|,
name|funcName
argument_list|,
name|sqlSyntax
argument_list|,
name|category
argument_list|,
name|nameMatcher
argument_list|)
decl_stmt|;
comment|// first pass:  eliminate routines which don't accept the given
comment|// number of arguments
name|routines
operator|=
name|filterRoutinesByParameterCount
argument_list|(
name|routines
argument_list|,
name|argTypes
argument_list|)
expr_stmt|;
comment|// NOTE: according to SQL99, procedures are NOT overloaded on type,
comment|// only on number of arguments.
if|if
condition|(
name|category
operator|==
name|SqlFunctionCategory
operator|.
name|USER_DEFINED_PROCEDURE
condition|)
block|{
return|return
name|routines
return|;
block|}
comment|// second pass:  eliminate routines which don't accept the given
comment|// argument types
name|routines
operator|=
name|filterRoutinesByParameterType
argument_list|(
name|sqlSyntax
argument_list|,
name|routines
argument_list|,
name|argTypes
argument_list|,
name|argNames
argument_list|,
name|coerce
argument_list|)
expr_stmt|;
comment|// see if we can stop now; this is necessary for the case
comment|// of builtin functions where we don't have param type info,
comment|// or UDF whose operands can make type coercion.
specifier|final
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|routines
argument_list|)
decl_stmt|;
name|routines
operator|=
name|list
operator|.
name|iterator
argument_list|()
expr_stmt|;
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|<
literal|2
operator|||
name|coerce
condition|)
block|{
return|return
name|routines
return|;
block|}
comment|// third pass:  for each parameter from left to right, eliminate
comment|// all routines except those with the best precedence match for
comment|// the given arguments
name|routines
operator|=
name|filterRoutinesByTypePrecedence
argument_list|(
name|sqlSyntax
argument_list|,
name|routines
argument_list|,
name|argTypes
argument_list|)
expr_stmt|;
comment|// fourth pass: eliminate routines which do not have the same
comment|// SqlKind as requested
return|return
name|filterOperatorRoutinesByKind
argument_list|(
name|routines
argument_list|,
name|sqlKind
argument_list|)
return|;
block|}
comment|/**    * Determines whether there is a routine matching the given name and number    * of arguments.    *    * @param opTab         operator table to search    * @param funcName      name of function being invoked    * @param argTypes      argument types    * @param category      category of routine to look up    * @param nameMatcher   Whether to look up the function case-sensitively    * @return true if match found    */
specifier|public
specifier|static
name|boolean
name|matchRoutinesByParameterCount
parameter_list|(
name|SqlOperatorTable
name|opTab
parameter_list|,
name|SqlIdentifier
name|funcName
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|,
name|SqlFunctionCategory
name|category
parameter_list|,
name|SqlNameMatcher
name|nameMatcher
parameter_list|)
block|{
comment|// start with all routines matching by name
name|Iterator
argument_list|<
name|SqlOperator
argument_list|>
name|routines
init|=
name|lookupSubjectRoutinesByName
argument_list|(
name|opTab
argument_list|,
name|funcName
argument_list|,
name|SqlSyntax
operator|.
name|FUNCTION
argument_list|,
name|category
argument_list|,
name|nameMatcher
argument_list|)
decl_stmt|;
comment|// first pass:  eliminate routines which don't accept the given
comment|// number of arguments
name|routines
operator|=
name|filterRoutinesByParameterCount
argument_list|(
name|routines
argument_list|,
name|argTypes
argument_list|)
expr_stmt|;
return|return
name|routines
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|Iterator
argument_list|<
name|SqlOperator
argument_list|>
name|lookupSubjectRoutinesByName
parameter_list|(
name|SqlOperatorTable
name|opTab
parameter_list|,
name|SqlIdentifier
name|funcName
parameter_list|,
specifier|final
name|SqlSyntax
name|syntax
parameter_list|,
name|SqlFunctionCategory
name|category
parameter_list|,
name|SqlNameMatcher
name|nameMatcher
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|sqlOperators
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|opTab
operator|.
name|lookupOperatorOverloads
argument_list|(
name|funcName
argument_list|,
name|category
argument_list|,
name|syntax
argument_list|,
name|sqlOperators
argument_list|,
name|nameMatcher
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|syntax
condition|)
block|{
case|case
name|FUNCTION
case|:
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|sqlOperators
operator|.
name|iterator
argument_list|()
argument_list|,
name|Predicates
operator|.
name|instanceOf
argument_list|(
name|SqlFunction
operator|.
name|class
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|sqlOperators
operator|.
name|iterator
argument_list|()
argument_list|,
name|operator
lambda|->
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|operator
argument_list|)
operator|.
name|getSyntax
argument_list|()
operator|==
name|syntax
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|Iterator
argument_list|<
name|SqlOperator
argument_list|>
name|filterRoutinesByParameterCount
parameter_list|(
name|Iterator
argument_list|<
name|SqlOperator
argument_list|>
name|routines
parameter_list|,
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|routines
argument_list|,
name|operator
lambda|->
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|operator
argument_list|)
operator|.
name|getOperandCountRange
argument_list|()
operator|.
name|isValidCount
argument_list|(
name|argTypes
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @see Glossary#SQL99 SQL:1999 Part 2 Section 10.4 Syntax Rule 6.b.iii.2.B    */
specifier|private
specifier|static
name|Iterator
argument_list|<
name|SqlOperator
argument_list|>
name|filterRoutinesByParameterType
parameter_list|(
name|SqlSyntax
name|syntax
parameter_list|,
specifier|final
name|Iterator
argument_list|<
name|SqlOperator
argument_list|>
name|routines
parameter_list|,
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|argNames
parameter_list|,
specifier|final
name|boolean
name|coerce
parameter_list|)
block|{
if|if
condition|(
name|syntax
operator|!=
name|SqlSyntax
operator|.
name|FUNCTION
condition|)
block|{
return|return
name|routines
return|;
block|}
comment|//noinspection unchecked
return|return
operator|(
name|Iterator
operator|)
name|Iterators
operator|.
name|filter
argument_list|(
name|Iterators
operator|.
name|filter
argument_list|(
name|routines
argument_list|,
name|SqlFunction
operator|.
name|class
argument_list|)
argument_list|,
name|function
lambda|->
block|{
name|List
argument_list|<
name|RelDataType
argument_list|>
name|paramTypes
init|=
name|function
operator|.
name|getParamTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|paramTypes
operator|==
literal|null
condition|)
block|{
comment|// no parameter information for builtins; keep for now,
comment|// the type coerce will not work here.
return|return
literal|true
return|;
block|}
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|permutedArgTypes
decl_stmt|;
if|if
condition|(
name|argNames
operator|!=
literal|null
condition|)
block|{
comment|// Arguments passed by name. Make sure that the function has
comment|// parameters of all of these names.
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|String
argument_list|>
name|argName
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|argNames
argument_list|)
control|)
block|{
specifier|final
name|int
name|i
init|=
name|function
operator|.
name|getParamNames
argument_list|()
operator|.
name|indexOf
argument_list|(
name|argName
operator|.
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|map
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|argName
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
name|permutedArgTypes
operator|=
name|Functions
operator|.
name|generate
argument_list|(
name|paramTypes
operator|.
name|size
argument_list|()
argument_list|,
name|a0
lambda|->
block|{
if|if
condition|(
name|map
operator|.
name|containsKey
argument_list|(
name|a0
argument_list|)
condition|)
block|{
return|return
name|argTypes
operator|.
name|get
argument_list|(
name|map
operator|.
name|get
argument_list|(
name|a0
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|permutedArgTypes
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|argTypes
argument_list|)
expr_stmt|;
while|while
condition|(
name|permutedArgTypes
operator|.
name|size
argument_list|()
operator|<
name|argTypes
operator|.
name|size
argument_list|()
condition|)
block|{
name|paramTypes
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Pair
argument_list|<
name|RelDataType
argument_list|,
name|RelDataType
argument_list|>
name|p
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|paramTypes
argument_list|,
name|permutedArgTypes
argument_list|)
control|)
block|{
specifier|final
name|RelDataType
name|argType
init|=
name|p
operator|.
name|right
decl_stmt|;
specifier|final
name|RelDataType
name|paramType
init|=
name|p
operator|.
name|left
decl_stmt|;
if|if
condition|(
name|argType
operator|!=
literal|null
operator|&&
operator|!
name|SqlTypeUtil
operator|.
name|canCastFrom
argument_list|(
name|paramType
argument_list|,
name|argType
argument_list|,
name|coerce
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
argument_list|)
return|;
block|}
comment|/**    * @see Glossary#SQL99 SQL:1999 Part 2 Section 9.4    */
specifier|private
specifier|static
name|Iterator
argument_list|<
name|SqlOperator
argument_list|>
name|filterRoutinesByTypePrecedence
parameter_list|(
name|SqlSyntax
name|sqlSyntax
parameter_list|,
name|Iterator
argument_list|<
name|SqlOperator
argument_list|>
name|routines
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|)
block|{
if|if
condition|(
name|sqlSyntax
operator|!=
name|SqlSyntax
operator|.
name|FUNCTION
condition|)
block|{
return|return
name|routines
return|;
block|}
name|List
argument_list|<
name|SqlFunction
argument_list|>
name|sqlFunctions
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|Iterators
operator|.
name|filter
argument_list|(
name|routines
argument_list|,
name|SqlFunction
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Ord
argument_list|<
name|RelDataType
argument_list|>
name|argType
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|argTypes
argument_list|)
control|)
block|{
specifier|final
name|RelDataTypePrecedenceList
name|precList
init|=
name|argType
operator|.
name|e
operator|.
name|getPrecedenceList
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|bestMatch
init|=
name|bestMatch
argument_list|(
name|sqlFunctions
argument_list|,
name|argType
operator|.
name|i
argument_list|,
name|precList
argument_list|)
decl_stmt|;
if|if
condition|(
name|bestMatch
operator|!=
literal|null
condition|)
block|{
name|sqlFunctions
operator|=
name|sqlFunctions
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|function
lambda|->
block|{
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|paramTypes
init|=
name|function
operator|.
name|getParamTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|paramTypes
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|RelDataType
name|paramType
init|=
name|paramTypes
operator|.
name|get
argument_list|(
name|argType
operator|.
name|i
argument_list|)
decl_stmt|;
return|return
name|precList
operator|.
name|compareTypePrecedence
argument_list|(
name|paramType
argument_list|,
name|bestMatch
argument_list|)
operator|>=
literal|0
return|;
block|}
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|//noinspection unchecked
return|return
operator|(
name|Iterator
operator|)
name|sqlFunctions
operator|.
name|iterator
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|RelDataType
name|bestMatch
parameter_list|(
name|List
argument_list|<
name|SqlFunction
argument_list|>
name|sqlFunctions
parameter_list|,
name|int
name|i
parameter_list|,
name|RelDataTypePrecedenceList
name|precList
parameter_list|)
block|{
name|RelDataType
name|bestMatch
init|=
literal|null
decl_stmt|;
for|for
control|(
name|SqlFunction
name|function
range|:
name|sqlFunctions
control|)
block|{
name|List
argument_list|<
name|RelDataType
argument_list|>
name|paramTypes
init|=
name|function
operator|.
name|getParamTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|paramTypes
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
specifier|final
name|RelDataType
name|paramType
init|=
name|paramTypes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|bestMatch
operator|==
literal|null
condition|)
block|{
name|bestMatch
operator|=
name|paramType
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
init|=
name|precList
operator|.
name|compareTypePrecedence
argument_list|(
name|bestMatch
argument_list|,
name|paramType
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|bestMatch
operator|=
name|paramType
expr_stmt|;
block|}
block|}
block|}
return|return
name|bestMatch
return|;
block|}
comment|/**    * Returns the<code>i</code>th select-list item of a query.    */
specifier|public
specifier|static
name|SqlNode
name|getSelectListItem
parameter_list|(
name|SqlNode
name|query
parameter_list|,
name|int
name|i
parameter_list|)
block|{
switch|switch
condition|(
name|query
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|SELECT
case|:
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|query
decl_stmt|;
specifier|final
name|SqlNode
name|from
init|=
name|stripAs
argument_list|(
name|select
operator|.
name|getFrom
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|!=
literal|null
operator|&&
name|from
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|VALUES
condition|)
block|{
comment|// They wrote "VALUES (x, y)", but the validator has
comment|// converted this into "SELECT * FROM VALUES (x, y)".
return|return
name|getSelectListItem
argument_list|(
name|from
argument_list|,
name|i
argument_list|)
return|;
block|}
specifier|final
name|SqlNodeList
name|fields
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
comment|// Range check the index to avoid index out of range.  This
comment|// could be expanded to actually check to see if the select
comment|// list is a "*"
if|if
condition|(
name|i
operator|>=
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
case|case
name|VALUES
case|:
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|query
decl_stmt|;
assert|assert
name|call
operator|.
name|operandCount
argument_list|()
operator|>
literal|0
operator|:
literal|"VALUES must have at least one operand"
assert|;
specifier|final
name|SqlCall
name|row
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|row
operator|.
name|operandCount
argument_list|()
operator|>
name|i
operator|:
literal|"VALUES has too few columns"
assert|;
return|return
name|row
operator|.
name|operand
argument_list|(
name|i
argument_list|)
return|;
default|default:
comment|// Unexpected type of query.
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|query
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
name|String
name|deriveAliasFromOrdinal
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
comment|// Use a '$' so that queries can't easily reference the
comment|// generated name.
return|return
literal|"EXPR$"
operator|+
name|ordinal
return|;
block|}
comment|/**    * Constructs an operator signature from a type list.    *    * @param op       operator    * @param typeList list of types to use for operands. Types may be    *                 represented as {@link String}, {@link SqlTypeFamily}, or    *                 any object with a valid {@link Object#toString()} method.    * @return constructed signature    */
specifier|public
specifier|static
name|String
name|getOperatorSignature
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|List
argument_list|<
name|?
argument_list|>
name|typeList
parameter_list|)
block|{
return|return
name|getAliasedSignature
argument_list|(
name|op
argument_list|,
name|op
operator|.
name|getName
argument_list|()
argument_list|,
name|typeList
argument_list|)
return|;
block|}
comment|/**    * Constructs an operator signature from a type list, substituting an alias    * for the operator name.    *    * @param op       operator    * @param opName   name to use for operator    * @param typeList list of {@link SqlTypeName} or {@link String} to use for    *                 operands    * @return constructed signature    */
specifier|public
specifier|static
name|String
name|getAliasedSignature
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|String
name|opName
parameter_list|,
name|List
argument_list|<
name|?
argument_list|>
name|typeList
parameter_list|)
block|{
name|StringBuilder
name|ret
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|template
init|=
name|op
operator|.
name|getSignatureTemplate
argument_list|(
name|typeList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|template
condition|)
block|{
name|ret
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|opName
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|typeList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|ret
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
specifier|final
name|String
name|t
init|=
name|typeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|ret
operator|.
name|append
argument_list|(
literal|"<"
argument_list|)
operator|.
name|append
argument_list|(
name|t
argument_list|)
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
name|ret
operator|.
name|append
argument_list|(
literal|")'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Object
index|[]
name|values
init|=
operator|new
name|Object
index|[
name|typeList
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
name|opName
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|typeList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|t
init|=
name|typeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|values
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|"<"
operator|+
name|t
operator|+
literal|">"
expr_stmt|;
block|}
name|ret
operator|.
name|append
argument_list|(
operator|new
name|MessageFormat
argument_list|(
name|template
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
operator|.
name|format
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|typeList
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|)
operator|==
name|values
operator|.
name|length
assert|;
block|}
return|return
name|ret
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Wraps an exception with context.    */
specifier|public
specifier|static
name|CalciteException
name|newContextException
parameter_list|(
specifier|final
name|SqlParserPos
name|pos
parameter_list|,
name|Resources
operator|.
name|ExInst
argument_list|<
name|?
argument_list|>
name|e
parameter_list|,
name|String
name|inputText
parameter_list|)
block|{
name|CalciteContextException
name|ex
init|=
name|newContextException
argument_list|(
name|pos
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|ex
operator|.
name|setOriginalStatement
argument_list|(
name|inputText
argument_list|)
expr_stmt|;
return|return
name|ex
return|;
block|}
comment|/**    * Wraps an exception with context.    */
specifier|public
specifier|static
name|CalciteContextException
name|newContextException
parameter_list|(
specifier|final
name|SqlParserPos
name|pos
parameter_list|,
name|Resources
operator|.
name|ExInst
argument_list|<
name|?
argument_list|>
name|e
parameter_list|)
block|{
name|int
name|line
init|=
name|pos
operator|.
name|getLineNum
argument_list|()
decl_stmt|;
name|int
name|col
init|=
name|pos
operator|.
name|getColumnNum
argument_list|()
decl_stmt|;
name|int
name|endLine
init|=
name|pos
operator|.
name|getEndLineNum
argument_list|()
decl_stmt|;
name|int
name|endCol
init|=
name|pos
operator|.
name|getEndColumnNum
argument_list|()
decl_stmt|;
return|return
name|newContextException
argument_list|(
name|line
argument_list|,
name|col
argument_list|,
name|endLine
argument_list|,
name|endCol
argument_list|,
name|e
argument_list|)
return|;
block|}
comment|/**    * Wraps an exception with context.    */
specifier|public
specifier|static
name|CalciteContextException
name|newContextException
parameter_list|(
name|int
name|line
parameter_list|,
name|int
name|col
parameter_list|,
name|int
name|endLine
parameter_list|,
name|int
name|endCol
parameter_list|,
name|Resources
operator|.
name|ExInst
argument_list|<
name|?
argument_list|>
name|e
parameter_list|)
block|{
name|CalciteContextException
name|contextExcn
init|=
operator|(
name|line
operator|==
name|endLine
operator|&&
name|col
operator|==
name|endCol
condition|?
name|RESOURCE
operator|.
name|validatorContextPoint
argument_list|(
name|line
argument_list|,
name|col
argument_list|)
else|:
name|RESOURCE
operator|.
name|validatorContext
argument_list|(
name|line
argument_list|,
name|col
argument_list|,
name|endLine
argument_list|,
name|endCol
argument_list|)
operator|)
operator|.
name|ex
argument_list|(
name|e
operator|.
name|ex
argument_list|()
argument_list|)
decl_stmt|;
name|contextExcn
operator|.
name|setPosition
argument_list|(
name|line
argument_list|,
name|col
argument_list|,
name|endLine
argument_list|,
name|endCol
argument_list|)
expr_stmt|;
return|return
name|contextExcn
return|;
block|}
comment|/**    * Returns whether a {@link SqlNode node} is a {@link SqlCall call} to a    * given {@link SqlOperator operator}.    */
specifier|public
specifier|static
name|boolean
name|isCallTo
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|SqlOperator
name|operator
parameter_list|)
block|{
return|return
operator|(
name|node
operator|instanceof
name|SqlCall
operator|)
operator|&&
operator|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|operator
operator|)
return|;
block|}
comment|/**    * Creates the type of an {@link org.apache.calcite.util.NlsString}.    *    *<p>The type inherits the The NlsString's {@link Charset} and    * {@link SqlCollation}, if they are set, otherwise it gets the system    * defaults.    *    * @param typeFactory Type factory    * @param str         String    * @return Type, including collation and charset    */
specifier|public
specifier|static
name|RelDataType
name|createNlsStringType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|NlsString
name|str
parameter_list|)
block|{
name|Charset
name|charset
init|=
name|str
operator|.
name|getCharset
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|charset
condition|)
block|{
name|charset
operator|=
name|typeFactory
operator|.
name|getDefaultCharset
argument_list|()
expr_stmt|;
block|}
name|SqlCollation
name|collation
init|=
name|str
operator|.
name|getCollation
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|collation
condition|)
block|{
name|collation
operator|=
name|SqlCollation
operator|.
name|COERCIBLE
expr_stmt|;
block|}
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|,
name|str
operator|.
name|getValue
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithCharsetAndCollation
argument_list|(
name|type
argument_list|,
name|charset
argument_list|,
name|collation
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/**    * Translates a character set name from a SQL-level name into a Java-level    * name.    *    * @param name SQL-level name    * @return Java-level name, or null if SQL-level name is unknown    */
specifier|public
specifier|static
name|String
name|translateCharacterSetName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
switch|switch
condition|(
name|name
condition|)
block|{
case|case
literal|"BIG5"
case|:
return|return
literal|"Big5"
return|;
case|case
literal|"LATIN1"
case|:
return|return
literal|"ISO-8859-1"
return|;
case|case
literal|"GB2312"
case|:
case|case
literal|"GBK"
case|:
return|return
name|name
return|;
case|case
literal|"UTF8"
case|:
return|return
literal|"UTF-8"
return|;
case|case
literal|"UTF16"
case|:
return|return
name|ConversionUtil
operator|.
name|NATIVE_UTF16_CHARSET_NAME
return|;
case|case
literal|"UTF-16BE"
case|:
case|case
literal|"UTF-16LE"
case|:
case|case
literal|"ISO-8859-1"
case|:
case|case
literal|"UTF-8"
case|:
return|return
name|name
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Returns the Java-level {@link Charset} based on given SQL-level name.    *    * @param charsetName Sql charset name, must not be null.    * @return charset, or default charset if charsetName is null.    * @throws UnsupportedCharsetException If no support for the named charset    *     is available in this instance of the Java virtual machine    */
specifier|public
specifier|static
name|Charset
name|getCharset
parameter_list|(
name|String
name|charsetName
parameter_list|)
block|{
assert|assert
name|charsetName
operator|!=
literal|null
assert|;
name|charsetName
operator|=
name|charsetName
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
expr_stmt|;
name|String
name|javaCharsetName
init|=
name|translateCharacterSetName
argument_list|(
name|charsetName
argument_list|)
decl_stmt|;
if|if
condition|(
name|javaCharsetName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedCharsetException
argument_list|(
name|charsetName
argument_list|)
throw|;
block|}
return|return
name|Charset
operator|.
name|forName
argument_list|(
name|javaCharsetName
argument_list|)
return|;
block|}
comment|/**    * Validate if value can be decoded by given charset.    *    * @param value nls string in byte array    * @param charset charset    * @throws RuntimeException If the given value cannot be represented in the    *     given charset    */
specifier|public
specifier|static
name|void
name|validateCharset
parameter_list|(
name|ByteString
name|value
parameter_list|,
name|Charset
name|charset
parameter_list|)
block|{
if|if
condition|(
name|charset
operator|==
name|StandardCharsets
operator|.
name|UTF_8
condition|)
block|{
specifier|final
name|byte
index|[]
name|bytes
init|=
name|value
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Utf8
operator|.
name|isWellFormed
argument_list|(
name|bytes
argument_list|)
condition|)
block|{
comment|//CHECKSTYLE: IGNORE 1
specifier|final
name|String
name|string
init|=
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
name|charset
argument_list|)
decl_stmt|;
throw|throw
name|RESOURCE
operator|.
name|charsetEncoding
argument_list|(
name|string
argument_list|,
name|charset
operator|.
name|name
argument_list|()
argument_list|)
operator|.
name|ex
argument_list|()
throw|;
block|}
block|}
block|}
comment|/** If a node is "AS", returns the underlying expression; otherwise returns    * the node. */
specifier|public
specifier|static
name|SqlNode
name|stripAs
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AS
condition|)
block|{
return|return
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|node
return|;
block|}
comment|/** Returns a list of ancestors of {@code predicate} within a given    * {@code SqlNode} tree.    *    *<p>The first element of the list is {@code root}, and the last is    * the node that matched {@code predicate}. Throws if no node matches.    */
specifier|public
specifier|static
name|ImmutableList
argument_list|<
name|SqlNode
argument_list|>
name|getAncestry
parameter_list|(
name|SqlNode
name|root
parameter_list|,
name|Predicate
argument_list|<
name|SqlNode
argument_list|>
name|predicate
parameter_list|,
name|Predicate
argument_list|<
name|SqlNode
argument_list|>
name|postPredicate
parameter_list|)
block|{
try|try
block|{
operator|new
name|Genealogist
argument_list|(
name|predicate
argument_list|,
name|postPredicate
argument_list|)
operator|.
name|visitChild
argument_list|(
name|root
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"not found: "
operator|+
name|predicate
operator|+
literal|" in "
operator|+
name|root
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|ImmutableList
argument_list|<
name|SqlNode
argument_list|>
operator|)
name|e
operator|.
name|getNode
argument_list|()
return|;
block|}
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Handles particular {@link DatabaseMetaData} methods; invocations of other    * methods will fall through to the base class,    * {@link org.apache.calcite.util.BarfingInvocationHandler}, which will throw    * an error.    */
specifier|public
specifier|static
class|class
name|DatabaseMetaDataInvocationHandler
extends|extends
name|BarfingInvocationHandler
block|{
specifier|private
specifier|final
name|String
name|databaseProductName
decl_stmt|;
specifier|private
specifier|final
name|String
name|identifierQuoteString
decl_stmt|;
specifier|public
name|DatabaseMetaDataInvocationHandler
parameter_list|(
name|String
name|databaseProductName
parameter_list|,
name|String
name|identifierQuoteString
parameter_list|)
block|{
name|this
operator|.
name|databaseProductName
operator|=
name|databaseProductName
expr_stmt|;
name|this
operator|.
name|identifierQuoteString
operator|=
name|identifierQuoteString
expr_stmt|;
block|}
specifier|public
name|String
name|getDatabaseProductName
parameter_list|()
throws|throws
name|SQLException
block|{
return|return
name|databaseProductName
return|;
block|}
specifier|public
name|String
name|getIdentifierQuoteString
parameter_list|()
throws|throws
name|SQLException
block|{
return|return
name|identifierQuoteString
return|;
block|}
block|}
comment|/** Walks over a {@link org.apache.calcite.sql.SqlNode} tree and returns the    * ancestry stack when it finds a given node. */
specifier|private
specifier|static
class|class
name|Genealogist
extends|extends
name|SqlBasicVisitor
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|ancestors
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Predicate
argument_list|<
name|SqlNode
argument_list|>
name|predicate
decl_stmt|;
specifier|private
specifier|final
name|Predicate
argument_list|<
name|SqlNode
argument_list|>
name|postPredicate
decl_stmt|;
name|Genealogist
parameter_list|(
name|Predicate
argument_list|<
name|SqlNode
argument_list|>
name|predicate
parameter_list|,
name|Predicate
argument_list|<
name|SqlNode
argument_list|>
name|postPredicate
parameter_list|)
block|{
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
name|this
operator|.
name|postPredicate
operator|=
name|postPredicate
expr_stmt|;
block|}
specifier|private
name|Void
name|check
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
name|preCheck
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|postCheck
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|private
name|Void
name|preCheck
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|node
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|ancestors
argument_list|)
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|Void
name|postCheck
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|postPredicate
operator|.
name|test
argument_list|(
name|node
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|ancestors
argument_list|)
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|visitChild
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|ancestors
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|ancestors
operator|.
name|remove
argument_list|(
name|ancestors
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
return|return
name|check
argument_list|(
name|id
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
name|preCheck
argument_list|(
name|call
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|visitChild
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|postCheck
argument_list|(
name|call
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
name|check
argument_list|(
name|intervalQualifier
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
return|return
name|check
argument_list|(
name|literal
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
name|preCheck
argument_list|(
name|nodeList
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|nodeList
control|)
block|{
name|visitChild
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|postCheck
argument_list|(
name|nodeList
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
return|return
name|check
argument_list|(
name|param
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlDataTypeSpec
name|type
parameter_list|)
block|{
return|return
name|check
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End SqlUtil.java
end_comment

end_unit

