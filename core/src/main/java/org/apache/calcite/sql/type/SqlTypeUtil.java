begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFieldImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBasicTypeNameSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCallBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDataTypeSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlNameMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NumberUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
operator|.
name|RESOURCE
import|;
end_import

begin_comment
comment|/**  * Contains utility methods used during SQL validation or type derivation.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|SqlTypeUtil
block|{
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Checks whether two types or more are char comparable.    *    * @return Returns true if all operands are of char type and if they are    * comparable, i.e. of the same charset and collation of same charset    */
specifier|public
specifier|static
name|boolean
name|isCharTypeComparable
parameter_list|(
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|)
block|{
assert|assert
name|argTypes
operator|!=
literal|null
assert|;
assert|assert
name|argTypes
operator|.
name|size
argument_list|()
operator|>=
literal|2
assert|;
comment|// Filter out ANY and NULL elements.
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes2
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataType
name|t
range|:
name|argTypes
control|)
block|{
if|if
condition|(
operator|!
name|isAny
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|isNull
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|argTypes2
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Pair
argument_list|<
name|RelDataType
argument_list|,
name|RelDataType
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|adjacents
argument_list|(
name|argTypes2
argument_list|)
control|)
block|{
name|RelDataType
name|t0
init|=
name|pair
operator|.
name|left
decl_stmt|;
name|RelDataType
name|t1
init|=
name|pair
operator|.
name|right
decl_stmt|;
if|if
condition|(
operator|!
name|inCharFamily
argument_list|(
name|t0
argument_list|)
operator|||
operator|!
name|inCharFamily
argument_list|(
name|t1
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|t0
operator|.
name|getCharset
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"RelDataType object should have been assigned "
operator|+
literal|"a (default) charset when calling deriveType"
argument_list|)
throw|;
block|}
if|else if
condition|(
operator|!
name|t0
operator|.
name|getCharset
argument_list|()
operator|.
name|equals
argument_list|(
name|t1
operator|.
name|getCharset
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|t0
operator|.
name|getCollation
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"RelDataType object should have been assigned "
operator|+
literal|"a (default) collation when calling deriveType"
argument_list|)
throw|;
block|}
if|else if
condition|(
operator|!
name|t0
operator|.
name|getCollation
argument_list|()
operator|.
name|getCharset
argument_list|()
operator|.
name|equals
argument_list|(
name|t1
operator|.
name|getCollation
argument_list|()
operator|.
name|getCharset
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether the operands to a call are char type-comparable.    *    * @param binding        Binding of call to operands    * @param operands       Operands to check for compatibility; usually the    *                       operands of the bound call, but not always    * @param throwOnFailure Whether to throw an exception on failure    * @return whether operands are valid    */
specifier|public
specifier|static
name|boolean
name|isCharTypeComparable
parameter_list|(
name|SqlCallBinding
name|binding
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
parameter_list|,
name|boolean
name|throwOnFailure
parameter_list|)
block|{
specifier|final
name|SqlValidator
name|validator
init|=
name|binding
operator|.
name|getValidator
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|scope
init|=
name|binding
operator|.
name|getScope
argument_list|()
decl_stmt|;
assert|assert
name|operands
operator|!=
literal|null
assert|;
assert|assert
name|operands
operator|.
name|size
argument_list|()
operator|>=
literal|2
assert|;
if|if
condition|(
operator|!
name|isCharTypeComparable
argument_list|(
name|deriveAndCollectTypes
argument_list|(
name|validator
argument_list|,
name|scope
argument_list|,
name|operands
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|throwOnFailure
condition|)
block|{
name|String
name|msg
init|=
literal|""
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|msg
operator|+=
literal|", "
expr_stmt|;
block|}
name|msg
operator|+=
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
throw|throw
name|binding
operator|.
name|newError
argument_list|(
name|RESOURCE
operator|.
name|operandNotComparable
argument_list|(
name|msg
argument_list|)
argument_list|)
throw|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Iterates over all operands, derives their types, and collects them into    * a list.    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataType
argument_list|>
name|deriveAndCollectTypes
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
parameter_list|)
block|{
comment|// NOTE: Do not use an AbstractList. Don't want to be lazy. We want
comment|// errors.
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|operands
control|)
block|{
name|types
operator|.
name|add
argument_list|(
name|validator
operator|.
name|deriveType
argument_list|(
name|scope
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|types
return|;
block|}
comment|/**    * Promotes a type to a row type (does nothing if it already is one).    *    * @param type      type to be promoted    * @param fieldName name to give field in row type; null for default of    *                  "ROW_VALUE"    * @return row type    */
specifier|public
specifier|static
name|RelDataType
name|promoteToRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
block|{
name|fieldName
operator|=
literal|"ROW_VALUE"
expr_stmt|;
block|}
name|type
operator|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
name|fieldName
argument_list|,
name|type
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
comment|/**    * Recreates a given RelDataType with nullability iff any of the operands    * of a call are nullable.    */
specifier|public
specifier|static
name|RelDataType
name|makeNullableIfOperandsAre
parameter_list|(
specifier|final
name|SqlValidator
name|validator
parameter_list|,
specifier|final
name|SqlValidatorScope
name|scope
parameter_list|,
specifier|final
name|SqlCall
name|call
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|RelDataType
name|operandType
init|=
name|validator
operator|.
name|deriveType
argument_list|(
name|scope
argument_list|,
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|containsNullable
argument_list|(
name|operandType
argument_list|)
condition|)
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|validator
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|type
return|;
block|}
comment|/**    * Recreates a given RelDataType with nullability iff any of the param    * argTypes are nullable.    */
specifier|public
specifier|static
name|RelDataType
name|makeNullableIfOperandsAre
parameter_list|(
specifier|final
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|containsNullable
argument_list|(
name|argTypes
argument_list|)
condition|)
block|{
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
comment|/**    * Returns whether all of array of types are nullable.    */
specifier|public
specifier|static
name|boolean
name|allNullable
parameter_list|(
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
parameter_list|)
block|{
for|for
control|(
name|RelDataType
name|type
range|:
name|types
control|)
block|{
if|if
condition|(
operator|!
name|containsNullable
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether one or more of an array of types is nullable.    */
specifier|public
specifier|static
name|boolean
name|containsNullable
parameter_list|(
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
parameter_list|)
block|{
for|for
control|(
name|RelDataType
name|type
range|:
name|types
control|)
block|{
if|if
condition|(
name|containsNullable
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Determines whether a type or any of its fields (if a structured type) are    * nullable.    */
specifier|public
specifier|static
name|boolean
name|containsNullable
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|type
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
name|containsNullable
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns typeName.equals(type.getSqlTypeName()). If    * typeName.equals(SqlTypeName.Any) true is always returned.    */
specifier|public
specifier|static
name|boolean
name|isOfSameTypeName
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|SqlTypeName
operator|.
name|ANY
operator|==
name|typeName
operator|||
name|typeName
operator|==
name|type
operator|.
name|getSqlTypeName
argument_list|()
return|;
block|}
comment|/**    * Returns true if any element in<code>typeNames</code> matches    * type.getSqlTypeName().    *    * @see #isOfSameTypeName(SqlTypeName, RelDataType)    */
specifier|public
specifier|static
name|boolean
name|isOfSameTypeName
parameter_list|(
name|Collection
argument_list|<
name|SqlTypeName
argument_list|>
name|typeNames
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
for|for
control|(
name|SqlTypeName
name|typeName
range|:
name|typeNames
control|)
block|{
if|if
condition|(
name|isOfSameTypeName
argument_list|(
name|typeName
argument_list|,
name|type
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * @return true if type is DATE, TIME, or TIMESTAMP    */
specifier|public
specifier|static
name|boolean
name|isDatetime
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|SqlTypeFamily
operator|.
name|DATETIME
operator|.
name|contains
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * @return true if type is DATE    */
specifier|public
specifier|static
name|boolean
name|isDate
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|DATE
return|;
block|}
comment|/**    * @return true if type is TIMESTAMP    */
specifier|public
specifier|static
name|boolean
name|isTimestamp
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|SqlTypeFamily
operator|.
name|TIMESTAMP
operator|.
name|contains
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * @return true if type is some kind of INTERVAL    */
specifier|public
specifier|static
name|boolean
name|isInterval
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|SqlTypeFamily
operator|.
name|DATETIME_INTERVAL
operator|.
name|contains
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * @return true if type is in SqlTypeFamily.Character    */
specifier|public
specifier|static
name|boolean
name|inCharFamily
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|type
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
return|;
block|}
comment|/**    * @return true if type is in SqlTypeFamily.Character    */
specifier|public
specifier|static
name|boolean
name|inCharFamily
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|)
block|{
return|return
name|typeName
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
return|;
block|}
comment|/**    * @return true if type is in SqlTypeFamily.Boolean    */
specifier|public
specifier|static
name|boolean
name|inBooleanFamily
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|type
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|BOOLEAN
return|;
block|}
comment|/**    * @return true if two types are in same type family    */
specifier|public
specifier|static
name|boolean
name|inSameFamily
parameter_list|(
name|RelDataType
name|t1
parameter_list|,
name|RelDataType
name|t2
parameter_list|)
block|{
return|return
name|t1
operator|.
name|getFamily
argument_list|()
operator|==
name|t2
operator|.
name|getFamily
argument_list|()
return|;
block|}
comment|/**    * @return true if two types are in same type family, or one or the other is    * of type {@link SqlTypeName#NULL}.    */
specifier|public
specifier|static
name|boolean
name|inSameFamilyOrNull
parameter_list|(
name|RelDataType
name|t1
parameter_list|,
name|RelDataType
name|t2
parameter_list|)
block|{
return|return
operator|(
name|t1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
operator|)
operator|||
operator|(
name|t2
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
operator|)
operator|||
operator|(
name|t1
operator|.
name|getFamily
argument_list|()
operator|==
name|t2
operator|.
name|getFamily
argument_list|()
operator|)
return|;
block|}
comment|/**    * @return true if type family is either character or binary    */
specifier|public
specifier|static
name|boolean
name|inCharOrBinaryFamilies
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
operator|(
name|type
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
operator|)
operator|||
operator|(
name|type
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|BINARY
operator|)
return|;
block|}
comment|/**    * @return true if type is a LOB of some kind    */
specifier|public
specifier|static
name|boolean
name|isLob
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
comment|// TODO jvs 9-Dec-2004:  once we support LOB types
return|return
literal|false
return|;
block|}
comment|/**    * @return true if type is variable width with bounded precision    */
specifier|public
specifier|static
name|boolean
name|isBoundedVariableWidth
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|VARCHAR
case|:
case|case
name|VARBINARY
case|:
comment|// TODO angel 8-June-2005: Multiset should be LOB
case|case
name|MULTISET
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * @return true if type is one of the integer types    */
specifier|public
specifier|static
name|boolean
name|isIntType
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * @return true if type is decimal    */
specifier|public
specifier|static
name|boolean
name|isDecimal
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|typeName
operator|==
name|SqlTypeName
operator|.
name|DECIMAL
return|;
block|}
comment|/**    * @return true if type is double    */
specifier|public
specifier|static
name|boolean
name|isDouble
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|typeName
operator|==
name|SqlTypeName
operator|.
name|DOUBLE
return|;
block|}
comment|/**    * @return true if type is bigint    */
specifier|public
specifier|static
name|boolean
name|isBigint
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|typeName
operator|==
name|SqlTypeName
operator|.
name|BIGINT
return|;
block|}
comment|/**    * @return true if type is numeric with exact precision    */
specifier|public
specifier|static
name|boolean
name|isExactNumeric
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/** Returns whether a type's scale is set. */
specifier|public
specifier|static
name|boolean
name|hasScale
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|type
operator|.
name|getScale
argument_list|()
operator|!=
name|Integer
operator|.
name|MIN_VALUE
return|;
block|}
comment|/**    * Returns the maximum value of an integral type, as a long value    */
specifier|public
specifier|static
name|long
name|maxValue
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
assert|assert
name|SqlTypeUtil
operator|.
name|isIntType
argument_list|(
name|type
argument_list|)
assert|;
switch|switch
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|TINYINT
case|:
return|return
name|Byte
operator|.
name|MAX_VALUE
return|;
case|case
name|SMALLINT
case|:
return|return
name|Short
operator|.
name|MAX_VALUE
return|;
case|case
name|INTEGER
case|:
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
case|case
name|BIGINT
case|:
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return true if type is numeric with approximate precision    */
specifier|public
specifier|static
name|boolean
name|isApproximateNumeric
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|FLOAT
case|:
case|case
name|REAL
case|:
case|case
name|DOUBLE
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * @return true if type is numeric    */
specifier|public
specifier|static
name|boolean
name|isNumeric
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|isExactNumeric
argument_list|(
name|type
argument_list|)
operator|||
name|isApproximateNumeric
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * @return true if type is null.    */
specifier|public
specifier|static
name|boolean
name|isNull
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|typeName
operator|==
name|SqlTypeName
operator|.
name|NULL
return|;
block|}
comment|/**    * Tests whether two types have the same name and structure, possibly with    * differing modifiers. For example, VARCHAR(1) and VARCHAR(10) are    * considered the same, while VARCHAR(1) and CHAR(1) are considered    * different. Likewise, VARCHAR(1) MULTISET and VARCHAR(10) MULTISET are    * considered the same.    *    * @return true if types have same name and structure    */
specifier|public
specifier|static
name|boolean
name|sameNamedType
parameter_list|(
name|RelDataType
name|t1
parameter_list|,
name|RelDataType
name|t2
parameter_list|)
block|{
if|if
condition|(
name|t1
operator|.
name|isStruct
argument_list|()
operator|||
name|t2
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|t1
operator|.
name|isStruct
argument_list|()
operator|||
operator|!
name|t2
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|t1
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|t2
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields1
init|=
name|t1
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields2
init|=
name|t2
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields1
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|sameNamedType
argument_list|(
name|fields1
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|fields2
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
name|RelDataType
name|comp1
init|=
name|t1
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
name|RelDataType
name|comp2
init|=
name|t2
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|comp1
operator|!=
literal|null
operator|)
operator|||
operator|(
name|comp2
operator|!=
literal|null
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|comp1
operator|==
literal|null
operator|)
operator|||
operator|(
name|comp2
operator|==
literal|null
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|sameNamedType
argument_list|(
name|comp1
argument_list|,
name|comp2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|t1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|t2
operator|.
name|getSqlTypeName
argument_list|()
return|;
block|}
comment|/**    * Computes the maximum number of bytes required to represent a value of a    * type having user-defined precision. This computation assumes no overhead    * such as length indicators and NUL-terminators. Complex types for which    * multiple representations are possible (e.g. DECIMAL or TIMESTAMP) return    * 0.    *    * @param type type for which to compute storage    * @return maximum bytes, or 0 for a fixed-width type or type with unknown    * maximum    */
specifier|public
specifier|static
name|int
name|getMaxByteSize
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|VARCHAR
case|:
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
operator|(
name|double
operator|)
name|type
operator|.
name|getPrecision
argument_list|()
operator|)
operator|*
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|newEncoder
argument_list|()
operator|.
name|maxBytesPerChar
argument_list|()
argument_list|)
return|;
case|case
name|BINARY
case|:
case|case
name|VARBINARY
case|:
return|return
name|type
operator|.
name|getPrecision
argument_list|()
return|;
case|case
name|MULTISET
case|:
comment|// TODO Wael Jan-24-2005: Need a better way to tell fennel this
comment|// number. This a very generic place and implementation details like
comment|// this doesnt belong here. Waiting to change this once we have blob
comment|// support
return|return
literal|4096
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
comment|/**    * Determines the minimum unscaled value of a numeric type    *    * @param type a numeric type    */
specifier|public
specifier|static
name|long
name|getMinValue
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
return|return
name|Byte
operator|.
name|MIN_VALUE
return|;
case|case
name|SMALLINT
case|:
return|return
name|Short
operator|.
name|MIN_VALUE
return|;
case|case
name|INTEGER
case|:
return|return
name|Integer
operator|.
name|MIN_VALUE
return|;
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
return|return
name|NumberUtil
operator|.
name|getMinUnscaled
argument_list|(
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"getMinValue("
operator|+
name|typeName
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Determines the maximum unscaled value of a numeric type    *    * @param type a numeric type    */
specifier|public
specifier|static
name|long
name|getMaxValue
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
return|return
name|Byte
operator|.
name|MAX_VALUE
return|;
case|case
name|SMALLINT
case|:
return|return
name|Short
operator|.
name|MAX_VALUE
return|;
case|case
name|INTEGER
case|:
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
return|return
name|NumberUtil
operator|.
name|getMaxUnscaled
argument_list|(
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"getMaxValue("
operator|+
name|typeName
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return true if type has a representation as a Java primitive (ignoring    * nullability)    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|boolean
name|isJavaPrimitive
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|BOOLEAN
case|:
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
case|case
name|FLOAT
case|:
case|case
name|REAL
case|:
case|case
name|DOUBLE
case|:
case|case
name|SYMBOL
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * @return class name of the wrapper for the primitive data type.    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|String
name|getPrimitiveWrapperJavaClassName
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|BOOLEAN
case|:
return|return
literal|"Boolean"
return|;
default|default:
comment|//noinspection deprecation
return|return
name|getNumericJavaClassName
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
comment|/**    * @return class name of the numeric data type.    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|String
name|getNumericJavaClassName
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
return|return
literal|"Byte"
return|;
case|case
name|SMALLINT
case|:
return|return
literal|"Short"
return|;
case|case
name|INTEGER
case|:
return|return
literal|"Integer"
return|;
case|case
name|BIGINT
case|:
return|return
literal|"Long"
return|;
case|case
name|REAL
case|:
return|return
literal|"Float"
return|;
case|case
name|DECIMAL
case|:
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
return|return
literal|"Double"
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isAny
parameter_list|(
name|RelDataType
name|t
parameter_list|)
block|{
return|return
name|t
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|ANY
return|;
block|}
comment|/**    * Tests whether a value can be assigned to a site.    *    * @param toType   type of the target site    * @param fromType type of the source value    * @return true iff assignable    */
specifier|public
specifier|static
name|boolean
name|canAssignFrom
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RelDataType
name|fromType
parameter_list|)
block|{
if|if
condition|(
name|isAny
argument_list|(
name|toType
argument_list|)
operator|||
name|isAny
argument_list|(
name|fromType
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// TODO jvs 2-Jan-2005:  handle all the other cases like
comment|// rows, collections, UDT's
if|if
condition|(
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
condition|)
block|{
comment|// REVIEW jvs 4-Dec-2008: We allow assignment from NULL to any
comment|// type, including NOT NULL types, since in the case where no
comment|// rows are actually processed, the assignment is legal
comment|// (FRG-365).  However, it would be better if the validator's
comment|// NULL type inference guaranteed that we had already
comment|// assigned a real (nullable) type to every NULL literal.
return|return
literal|true
return|;
block|}
if|if
condition|(
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ARRAY
condition|)
block|{
if|if
condition|(
name|toType
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|ARRAY
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|canAssignFrom
argument_list|(
name|toType
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|fromType
operator|.
name|getComponentType
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|areCharacterSetsMismatched
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|toType
operator|.
name|getFamily
argument_list|()
operator|==
name|fromType
operator|.
name|getFamily
argument_list|()
return|;
block|}
comment|/**    * Determines whether two types both have different character sets. If one    * or the other type has no character set (e.g. in cast from INT to    * VARCHAR), that is not a mismatch.    *    * @param t1 first type    * @param t2 second type    * @return true iff mismatched    */
specifier|public
specifier|static
name|boolean
name|areCharacterSetsMismatched
parameter_list|(
name|RelDataType
name|t1
parameter_list|,
name|RelDataType
name|t2
parameter_list|)
block|{
if|if
condition|(
name|isAny
argument_list|(
name|t1
argument_list|)
operator|||
name|isAny
argument_list|(
name|t2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Charset
name|cs1
init|=
name|t1
operator|.
name|getCharset
argument_list|()
decl_stmt|;
name|Charset
name|cs2
init|=
name|t2
operator|.
name|getCharset
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|cs1
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|cs2
operator|!=
literal|null
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|cs1
operator|.
name|equals
argument_list|(
name|cs2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Compares two types and returns true if fromType can be cast to toType.    *    *<p>REVIEW jvs 17-Dec-2004: the coerce param below shouldn't really be    * necessary. We're using it as a hack because    * {@link SqlTypeFactoryImpl#leastRestrictive} isn't complete enough    * yet.  Once it is, this param (and the non-coerce rules of    * {@link SqlTypeAssignmentRule}) should go away.    *    * @param toType   target of assignment    * @param fromType source of assignment    * @param coerce   if true, the SQL rules for CAST are used; if false, the    *                 rules are similar to Java; e.g. you can't assign short x =    *                 (int) y, and you can't assign int x = (String) z.    * @return true iff cast is legal    */
specifier|public
specifier|static
name|boolean
name|canCastFrom
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RelDataType
name|fromType
parameter_list|,
name|boolean
name|coerce
parameter_list|)
block|{
if|if
condition|(
name|toType
operator|.
name|equals
argument_list|(
name|fromType
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|isAny
argument_list|(
name|toType
argument_list|)
operator|||
name|isAny
argument_list|(
name|fromType
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|final
name|SqlTypeName
name|fromTypeName
init|=
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
specifier|final
name|SqlTypeName
name|toTypeName
init|=
name|toType
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|toType
operator|.
name|isStruct
argument_list|()
operator|||
name|fromType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
name|toTypeName
operator|==
name|SqlTypeName
operator|.
name|DISTINCT
condition|)
block|{
if|if
condition|(
name|fromTypeName
operator|==
name|SqlTypeName
operator|.
name|DISTINCT
condition|)
block|{
comment|// can't cast between different distinct types
return|return
literal|false
return|;
block|}
return|return
name|canCastFrom
argument_list|(
name|toType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|fromType
argument_list|,
name|coerce
argument_list|)
return|;
block|}
if|else if
condition|(
name|fromTypeName
operator|==
name|SqlTypeName
operator|.
name|DISTINCT
condition|)
block|{
return|return
name|canCastFrom
argument_list|(
name|toType
argument_list|,
name|fromType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|coerce
argument_list|)
return|;
block|}
if|else if
condition|(
name|toTypeName
operator|==
name|SqlTypeName
operator|.
name|ROW
condition|)
block|{
if|if
condition|(
name|fromTypeName
operator|!=
name|SqlTypeName
operator|.
name|ROW
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|n
init|=
name|toType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|fromType
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|n
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|RelDataTypeField
name|toField
init|=
name|toType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RelDataTypeField
name|fromField
init|=
name|fromType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|canCastFrom
argument_list|(
name|toField
operator|.
name|getType
argument_list|()
argument_list|,
name|fromField
operator|.
name|getType
argument_list|()
argument_list|,
name|coerce
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
if|else if
condition|(
name|toTypeName
operator|==
name|SqlTypeName
operator|.
name|MULTISET
condition|)
block|{
if|if
condition|(
operator|!
name|fromType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fromTypeName
operator|!=
name|SqlTypeName
operator|.
name|MULTISET
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|canCastFrom
argument_list|(
name|toType
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|fromType
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|coerce
argument_list|)
return|;
block|}
if|else if
condition|(
name|fromTypeName
operator|==
name|SqlTypeName
operator|.
name|MULTISET
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|toType
operator|.
name|getFamily
argument_list|()
operator|==
name|fromType
operator|.
name|getFamily
argument_list|()
return|;
block|}
block|}
name|RelDataType
name|c1
init|=
name|toType
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|c1
operator|!=
literal|null
condition|)
block|{
name|RelDataType
name|c2
init|=
name|fromType
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|c2
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|canCastFrom
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|coerce
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|isInterval
argument_list|(
name|fromType
argument_list|)
operator|&&
name|isExactNumeric
argument_list|(
name|toType
argument_list|)
operator|)
operator|||
operator|(
name|isInterval
argument_list|(
name|toType
argument_list|)
operator|&&
name|isExactNumeric
argument_list|(
name|fromType
argument_list|)
operator|)
condition|)
block|{
name|IntervalSqlType
name|intervalType
init|=
operator|(
name|IntervalSqlType
operator|)
operator|(
name|isInterval
argument_list|(
name|fromType
argument_list|)
condition|?
name|fromType
else|:
name|toType
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|isSingleDatetimeField
argument_list|()
condition|)
block|{
comment|// Casts between intervals and exact numerics must involve
comment|// intervals with a single datetime field.
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|toTypeName
operator|==
literal|null
operator|||
name|fromTypeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// REVIEW jvs 9-Feb-2009: we don't impose SQL rules for character sets
comment|// here; instead, we do that in SqlCastFunction.  The reason is that
comment|// this method is called from at least one place (MedJdbcNameDirectory)
comment|// where internally a cast across character repertoires is OK.  Should
comment|// probably clean that up.
name|SqlTypeMappingRule
name|rules
init|=
name|SqlTypeMappingRules
operator|.
name|instance
argument_list|(
name|coerce
argument_list|)
decl_stmt|;
return|return
name|rules
operator|.
name|canApplyFrom
argument_list|(
name|toTypeName
argument_list|,
name|fromTypeName
argument_list|)
return|;
block|}
comment|/**    * Flattens a record type by recursively expanding any fields which are    * themselves record types. For each record type, a representative null    * value field is also prepended (with state NULL for a null value and FALSE    * for non-null), and all component types are asserted to be nullable, since    * SQL doesn't allow NOT NULL to be specified on attributes.    *    * @param typeFactory   factory which should produced flattened type    * @param recordType    type with possible nesting    * @param flatteningMap if non-null, receives map from unflattened ordinal    *                      to flattened ordinal (must have length at least    *                      recordType.getFieldList().size())    * @return flattened equivalent    */
specifier|public
specifier|static
name|RelDataType
name|flattenRecordType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|recordType
parameter_list|,
name|int
index|[]
name|flatteningMap
parameter_list|)
block|{
if|if
condition|(
operator|!
name|recordType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
name|recordType
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fieldList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|nested
init|=
name|flattenFields
argument_list|(
name|typeFactory
argument_list|,
name|recordType
argument_list|,
name|fieldList
argument_list|,
name|flatteningMap
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nested
condition|)
block|{
return|return
name|recordType
return|;
block|}
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|fieldCnt
init|=
name|fieldList
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|RelDataTypeField
operator|::
name|getName
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|groupingBy
argument_list|(
name|Function
operator|.
name|identity
argument_list|()
argument_list|,
name|Collectors
operator|.
name|counting
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|fieldList
control|)
block|{
operator|++
name|i
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|oriFieldName
init|=
name|field
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// Patch up the field name with index if there are duplicates.
comment|// There is still possibility that the patched name conflicts with existing ones,
comment|// but that should be rare case.
name|String
name|fieldName
init|=
name|fieldCnt
operator|.
name|get
argument_list|(
name|oriFieldName
argument_list|)
operator|>
literal|1
condition|?
name|oriFieldName
operator|+
literal|"_"
operator|+
name|i
else|:
name|oriFieldName
decl_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|types
argument_list|,
name|fieldNames
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|needsNullIndicator
parameter_list|(
name|RelDataType
name|recordType
parameter_list|)
block|{
comment|// NOTE jvs 9-Mar-2005: It would be more storage-efficient to say that
comment|// no null indicator is required for structured type columns declared
comment|// as NOT NULL.  However, the uniformity of always having a null
comment|// indicator makes things cleaner in many places.
return|return
name|recordType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|STRUCTURED
return|;
block|}
specifier|private
specifier|static
name|boolean
name|flattenFields
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|list
parameter_list|,
name|int
index|[]
name|flatteningMap
parameter_list|)
block|{
name|boolean
name|nested
init|=
literal|false
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|type
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
name|flatteningMap
operator|!=
literal|null
condition|)
block|{
name|flatteningMap
index|[
name|field
operator|.
name|getIndex
argument_list|()
index|]
operator|=
name|list
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|nested
operator|=
literal|true
expr_stmt|;
name|flattenFields
argument_list|(
name|typeFactory
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|list
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|nested
operator|=
literal|true
expr_stmt|;
comment|// TODO jvs 14-Feb-2005:  generalize to any kind of
comment|// collection type
name|RelDataType
name|flattenedCollectionType
init|=
name|typeFactory
operator|.
name|createMultisetType
argument_list|(
name|flattenRecordType
argument_list|(
name|typeFactory
argument_list|,
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|instanceof
name|ArraySqlType
condition|)
block|{
name|flattenedCollectionType
operator|=
name|typeFactory
operator|.
name|createArrayType
argument_list|(
name|flattenRecordType
argument_list|(
name|typeFactory
argument_list|,
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|field
operator|=
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
argument_list|,
name|flattenedCollectionType
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nested
return|;
block|}
comment|/**    * Converts an instance of RelDataType to an instance of SqlDataTypeSpec.    *    * @param type         type descriptor    * @param charSetName  charSet name    * @param maxPrecision The max allowed precision.    * @return corresponding parse representation    */
specifier|public
specifier|static
name|SqlDataTypeSpec
name|convertTypeToSpec
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|String
name|charSetName
parameter_list|,
name|int
name|maxPrecision
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
comment|// TODO jvs 28-Dec-2004:  support row types, user-defined types,
comment|// interval types, multiset types, etc
assert|assert
name|typeName
operator|!=
literal|null
assert|;
name|int
name|precision
init|=
name|typeName
operator|.
name|allowsPrec
argument_list|()
condition|?
name|type
operator|.
name|getPrecision
argument_list|()
else|:
operator|-
literal|1
decl_stmt|;
comment|// fix up the precision.
if|if
condition|(
name|maxPrecision
operator|>
literal|0
operator|&&
name|precision
operator|>
name|maxPrecision
condition|)
block|{
name|precision
operator|=
name|maxPrecision
expr_stmt|;
block|}
name|int
name|scale
init|=
name|typeName
operator|.
name|allowsScale
argument_list|()
condition|?
name|type
operator|.
name|getScale
argument_list|()
else|:
operator|-
literal|1
decl_stmt|;
specifier|final
name|SqlBasicTypeNameSpec
name|typeNameSpec
init|=
operator|new
name|SqlBasicTypeNameSpec
argument_list|(
name|typeName
argument_list|,
name|precision
argument_list|,
name|scale
argument_list|,
name|charSetName
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
comment|// REVIEW jvs 28-Dec-2004:  discriminate between precision/scale
comment|// zero and unspecified?
comment|// REVIEW angel 11-Jan-2006:
comment|// Use neg numbers to indicate unspecified precision/scale
return|return
operator|new
name|SqlDataTypeSpec
argument_list|(
name|typeNameSpec
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
comment|/**    * Converts an instance of RelDataType to an instance of SqlDataTypeSpec.    *    * @param type type descriptor    * @return corresponding parse representation    */
specifier|public
specifier|static
name|SqlDataTypeSpec
name|convertTypeToSpec
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
comment|// TODO jvs 28-Dec-2004:  collation
name|String
name|charSetName
init|=
name|inCharFamily
argument_list|(
name|type
argument_list|)
condition|?
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|name
argument_list|()
else|:
literal|null
decl_stmt|;
return|return
name|convertTypeToSpec
argument_list|(
name|type
argument_list|,
name|charSetName
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RelDataType
name|createMultisetType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|boolean
name|nullable
parameter_list|)
block|{
name|RelDataType
name|ret
init|=
name|typeFactory
operator|.
name|createMultisetType
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|ret
argument_list|,
name|nullable
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RelDataType
name|createArrayType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|boolean
name|nullable
parameter_list|)
block|{
name|RelDataType
name|ret
init|=
name|typeFactory
operator|.
name|createArrayType
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|ret
argument_list|,
name|nullable
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RelDataType
name|createMapType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|keyType
parameter_list|,
name|RelDataType
name|valueType
parameter_list|,
name|boolean
name|nullable
parameter_list|)
block|{
name|RelDataType
name|ret
init|=
name|typeFactory
operator|.
name|createMapType
argument_list|(
name|keyType
argument_list|,
name|valueType
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|ret
argument_list|,
name|nullable
argument_list|)
return|;
block|}
comment|/**    * Adds collation and charset to a character type, returns other types    * unchanged.    *    * @param type        Type    * @param typeFactory Type factory    * @return Type with added charset and collation, or unchanged type if it is    * not a char type.    */
specifier|public
specifier|static
name|RelDataType
name|addCharsetAndCollation
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inCharFamily
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|type
return|;
block|}
name|Charset
name|charset
init|=
name|type
operator|.
name|getCharset
argument_list|()
decl_stmt|;
if|if
condition|(
name|charset
operator|==
literal|null
condition|)
block|{
name|charset
operator|=
name|typeFactory
operator|.
name|getDefaultCharset
argument_list|()
expr_stmt|;
block|}
name|SqlCollation
name|collation
init|=
name|type
operator|.
name|getCollation
argument_list|()
decl_stmt|;
if|if
condition|(
name|collation
operator|==
literal|null
condition|)
block|{
name|collation
operator|=
name|SqlCollation
operator|.
name|IMPLICIT
expr_stmt|;
block|}
comment|// todo: should get the implicit collation from repository
comment|//   instead of null
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithCharsetAndCollation
argument_list|(
name|type
argument_list|,
name|charset
argument_list|,
name|collation
argument_list|)
expr_stmt|;
name|SqlValidatorUtil
operator|.
name|checkCharsetAndCollateConsistentIfCharType
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/**    * Returns whether two types are equal, ignoring nullability.    *    *<p>They need not come from the same factory.    *    * @param factory Type factory    * @param type1   First type    * @param type2   Second type    * @return whether types are equal, ignoring nullability    */
specifier|public
specifier|static
name|boolean
name|equalSansNullability
parameter_list|(
name|RelDataTypeFactory
name|factory
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
if|if
condition|(
name|type1
operator|.
name|equals
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|type1
operator|.
name|isNullable
argument_list|()
operator|==
name|type2
operator|.
name|isNullable
argument_list|()
condition|)
block|{
comment|// If types have the same nullability and they weren't equal above,
comment|// they must be different.
return|return
literal|false
return|;
block|}
return|return
name|type1
operator|.
name|equals
argument_list|(
name|factory
operator|.
name|createTypeWithNullability
argument_list|(
name|type2
argument_list|,
name|type1
operator|.
name|isNullable
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns whether two collection types are equal, ignoring nullability.    *    *<p>They need not come from the same factory.    *    * @param factory       Type factory    * @param type1         First type    * @param type2         Second type    * @return Whether types are equal, ignoring nullability    */
specifier|public
specifier|static
name|boolean
name|equalAsCollectionSansNullability
parameter_list|(
name|RelDataTypeFactory
name|factory
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|isCollection
argument_list|(
name|type1
argument_list|)
argument_list|,
literal|"Input type must be collection type"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|isCollection
argument_list|(
name|type2
argument_list|)
argument_list|,
literal|"Input type must be collection type"
argument_list|)
expr_stmt|;
return|return
operator|(
name|type1
operator|==
name|type2
operator|)
operator|||
operator|(
name|type1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|type2
operator|.
name|getSqlTypeName
argument_list|()
operator|&&
name|equalSansNullability
argument_list|(
name|factory
argument_list|,
name|type1
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|type2
operator|.
name|getComponentType
argument_list|()
argument_list|)
operator|)
return|;
block|}
comment|/**    * Returns whether two map types are equal, ignoring nullability.    *    *<p>They need not come from the same factory.    *    * @param factory       Type factory    * @param type1         First type    * @param type2         Second type    * @return Whether types are equal, ignoring nullability    */
specifier|public
specifier|static
name|boolean
name|equalAsMapSansNullability
parameter_list|(
name|RelDataTypeFactory
name|factory
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|isMap
argument_list|(
name|type1
argument_list|)
argument_list|,
literal|"Input type must be map type"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|isMap
argument_list|(
name|type2
argument_list|)
argument_list|,
literal|"Input type must be map type"
argument_list|)
expr_stmt|;
name|MapSqlType
name|mType1
init|=
operator|(
name|MapSqlType
operator|)
name|type1
decl_stmt|;
name|MapSqlType
name|mType2
init|=
operator|(
name|MapSqlType
operator|)
name|type2
decl_stmt|;
return|return
operator|(
name|type1
operator|==
name|type2
operator|)
operator|||
operator|(
name|equalSansNullability
argument_list|(
name|factory
argument_list|,
name|mType1
operator|.
name|getKeyType
argument_list|()
argument_list|,
name|mType2
operator|.
name|getKeyType
argument_list|()
argument_list|)
operator|&&
name|equalSansNullability
argument_list|(
name|factory
argument_list|,
name|mType1
operator|.
name|getValueType
argument_list|()
argument_list|,
name|mType2
operator|.
name|getValueType
argument_list|()
argument_list|)
operator|)
return|;
block|}
comment|/**    * Returns whether two struct types are equal, ignoring nullability.    *    *<p>They do not need to come from the same factory.    *    * @param factory       Type factory    * @param type1         First type    * @param type2         Second type    * @param nameMatcher   Name matcher used to compare the field names, if null,    *                      the field names are also ignored    *    * @return Whether types are equal, ignoring nullability    */
specifier|public
specifier|static
name|boolean
name|equalAsStructSansNullability
parameter_list|(
name|RelDataTypeFactory
name|factory
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|,
name|SqlNameMatcher
name|nameMatcher
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|type1
operator|.
name|isStruct
argument_list|()
argument_list|,
literal|"Input type must be struct type"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|type2
operator|.
name|isStruct
argument_list|()
argument_list|,
literal|"Input type must be struct type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|==
name|type2
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|type1
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|type2
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|type1
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|type2
operator|.
name|getFieldList
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|nameMatcher
operator|!=
literal|null
operator|&&
operator|!
name|nameMatcher
operator|.
name|matches
argument_list|(
name|pair
operator|.
name|left
operator|.
name|getName
argument_list|()
argument_list|,
name|pair
operator|.
name|right
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|equalSansNullability
argument_list|(
name|factory
argument_list|,
name|pair
operator|.
name|left
operator|.
name|getType
argument_list|()
argument_list|,
name|pair
operator|.
name|right
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns the ordinal of a given field in a record type, or -1 if the field    * is not found.    *    * @param type      Record type    * @param fieldName Name of field    * @return Ordinal of field    */
specifier|public
specifier|static
name|int
name|findField
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|type
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Selects data types of the specified fields from an input row type.    * This is useful when identifying data types of a function that is going    * to operate on inputs that are specified as field ordinals (e.g.    * aggregate calls).    *    * @param rowType input row type    * @param requiredFields ordinals of the projected fields    * @return list of data types that are requested by requiredFields    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataType
argument_list|>
name|projectTypes
parameter_list|(
specifier|final
name|RelDataType
name|rowType
parameter_list|,
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|Number
argument_list|>
name|requiredFields
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
return|return
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|fields
operator|.
name|get
argument_list|(
name|requiredFields
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
operator|.
name|getType
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|requiredFields
operator|.
name|size
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Records a struct type with no fields.    *    * @param typeFactory Type factory    * @return Struct type with no fields    */
specifier|public
specifier|static
name|RelDataType
name|createEmptyStructType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Returns whether a type is flat. It is not flat if it is a record type that    * has one or more fields that are themselves record types. */
specifier|public
specifier|static
name|boolean
name|isFlat
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|type
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether two types are comparable. They need to be scalar types of    * the same family, or struct types whose fields are pairwise comparable.    *    * @param type1 First type    * @param type2 Second type    * @return Whether types are comparable    */
specifier|public
specifier|static
name|boolean
name|isComparable
parameter_list|(
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
if|if
condition|(
name|type1
operator|.
name|isStruct
argument_list|()
operator|!=
name|type2
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|type1
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|int
name|n
init|=
name|type1
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|!=
name|type2
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|type1
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|type2
operator|.
name|getFieldList
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|isComparable
argument_list|(
name|pair
operator|.
name|left
operator|.
name|getType
argument_list|()
argument_list|,
name|pair
operator|.
name|right
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|final
name|RelDataTypeFamily
name|family1
init|=
name|family
argument_list|(
name|type1
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeFamily
name|family2
init|=
name|family
argument_list|(
name|type2
argument_list|)
decl_stmt|;
if|if
condition|(
name|family1
operator|==
name|family2
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// If one of the arguments is of type 'ANY', return true.
if|if
condition|(
name|family1
operator|==
name|SqlTypeFamily
operator|.
name|ANY
operator|||
name|family2
operator|==
name|SqlTypeFamily
operator|.
name|ANY
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// If one of the arguments is of type 'NULL', return true.
if|if
condition|(
name|family1
operator|==
name|SqlTypeFamily
operator|.
name|NULL
operator|||
name|family2
operator|==
name|SqlTypeFamily
operator|.
name|NULL
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// We can implicitly convert from character to date
if|if
condition|(
name|family1
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
operator|&&
name|canConvertStringInCompare
argument_list|(
name|family2
argument_list|)
operator|||
name|family2
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
operator|&&
name|canConvertStringInCompare
argument_list|(
name|family1
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Returns the least restrictive type T, such that a value of type T can be    * compared with values of type {@code type0} and {@code type1} using    * {@code =}. */
specifier|public
specifier|static
name|RelDataType
name|leastRestrictiveForComparison
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|leastRestrictive
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
return|return
name|type
return|;
block|}
specifier|final
name|RelDataTypeFamily
name|family1
init|=
name|family
argument_list|(
name|type1
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeFamily
name|family2
init|=
name|family
argument_list|(
name|type2
argument_list|)
decl_stmt|;
comment|// If one of the arguments is of type 'ANY', we can compare.
if|if
condition|(
name|family1
operator|==
name|SqlTypeFamily
operator|.
name|ANY
condition|)
block|{
return|return
name|type2
return|;
block|}
if|if
condition|(
name|family2
operator|==
name|SqlTypeFamily
operator|.
name|ANY
condition|)
block|{
return|return
name|type1
return|;
block|}
comment|// If one of the arguments is of type 'NULL', we can compare.
if|if
condition|(
name|family1
operator|==
name|SqlTypeFamily
operator|.
name|NULL
condition|)
block|{
return|return
name|type2
return|;
block|}
if|if
condition|(
name|family2
operator|==
name|SqlTypeFamily
operator|.
name|NULL
condition|)
block|{
return|return
name|type1
return|;
block|}
comment|// We can implicitly convert from character to date, numeric, etc.
if|if
condition|(
name|family1
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
operator|&&
name|canConvertStringInCompare
argument_list|(
name|family2
argument_list|)
condition|)
block|{
return|return
name|type2
return|;
block|}
if|if
condition|(
name|family2
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
operator|&&
name|canConvertStringInCompare
argument_list|(
name|family1
argument_list|)
condition|)
block|{
return|return
name|type1
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|protected
specifier|static
name|RelDataTypeFamily
name|family
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
comment|// REVIEW jvs 2-June-2005:  This is needed to keep
comment|// the Saffron type system happy.
name|RelDataTypeFamily
name|family
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|family
operator|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|.
name|getFamily
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|family
operator|==
literal|null
condition|)
block|{
name|family
operator|=
name|type
operator|.
name|getFamily
argument_list|()
expr_stmt|;
block|}
return|return
name|family
return|;
block|}
comment|/**    * Returns whether all types in a collection have the same family, as    * determined by {@link #isSameFamily(RelDataType, RelDataType)}.    *    * @param types Types to check    * @return true if all types are of the same family    */
specifier|public
specifier|static
name|boolean
name|areSameFamily
parameter_list|(
name|Iterable
argument_list|<
name|RelDataType
argument_list|>
name|types
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|types
argument_list|)
decl_stmt|;
if|if
condition|(
name|Sets
operator|.
name|newHashSet
argument_list|(
name|RexUtil
operator|.
name|families
argument_list|(
name|typeList
argument_list|)
argument_list|)
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|RelDataType
argument_list|,
name|RelDataType
argument_list|>
name|adjacent
range|:
name|Pair
operator|.
name|adjacents
argument_list|(
name|typeList
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|isSameFamily
argument_list|(
name|adjacent
operator|.
name|left
argument_list|,
name|adjacent
operator|.
name|right
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether two types are scalar types of the same family, or struct types whose fields    * are pairwise of the same family.    *    * @param type1 First type    * @param type2 Second type    * @return Whether types have the same family    */
specifier|private
specifier|static
name|boolean
name|isSameFamily
parameter_list|(
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
if|if
condition|(
name|type1
operator|.
name|isStruct
argument_list|()
operator|!=
name|type2
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|type1
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|int
name|n
init|=
name|type1
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|!=
name|type2
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|type1
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|type2
operator|.
name|getFieldList
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|isSameFamily
argument_list|(
name|pair
operator|.
name|left
operator|.
name|getType
argument_list|()
argument_list|,
name|pair
operator|.
name|right
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|final
name|RelDataTypeFamily
name|family1
init|=
name|family
argument_list|(
name|type1
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeFamily
name|family2
init|=
name|family
argument_list|(
name|type2
argument_list|)
decl_stmt|;
return|return
name|family1
operator|==
name|family2
return|;
block|}
comment|/** Returns whether a character data type can be implicitly converted to a    * given family in a compare operation. */
specifier|private
specifier|static
name|boolean
name|canConvertStringInCompare
parameter_list|(
name|RelDataTypeFamily
name|family
parameter_list|)
block|{
if|if
condition|(
name|family
operator|instanceof
name|SqlTypeFamily
condition|)
block|{
name|SqlTypeFamily
name|sqlTypeFamily
init|=
operator|(
name|SqlTypeFamily
operator|)
name|family
decl_stmt|;
switch|switch
condition|(
name|sqlTypeFamily
condition|)
block|{
case|case
name|DATE
case|:
case|case
name|TIME
case|:
case|case
name|TIMESTAMP
case|:
case|case
name|INTERVAL_DAY_TIME
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|NUMERIC
case|:
case|case
name|APPROXIMATE_NUMERIC
case|:
case|case
name|EXACT_NUMERIC
case|:
case|case
name|INTEGER
case|:
case|case
name|BOOLEAN
case|:
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Checks whether a type represents Unicode character data.    *    * @param type type to test    * @return whether type represents Unicode character data    */
specifier|public
specifier|static
name|boolean
name|isUnicode
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|Charset
name|charset
init|=
name|type
operator|.
name|getCharset
argument_list|()
decl_stmt|;
if|if
condition|(
name|charset
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|charset
operator|.
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"UTF"
argument_list|)
return|;
block|}
comment|/** Returns the larger of two precisions, treating    * {@link RelDataType#PRECISION_NOT_SPECIFIED} as infinity. */
specifier|public
specifier|static
name|int
name|maxPrecision
parameter_list|(
name|int
name|p0
parameter_list|,
name|int
name|p1
parameter_list|)
block|{
return|return
operator|(
name|p0
operator|==
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
operator|||
name|p0
operator|>=
name|p1
operator|&&
name|p1
operator|!=
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
operator|)
condition|?
name|p0
else|:
name|p1
return|;
block|}
comment|/** Returns whether a precision is greater or equal than another,    * treating {@link RelDataType#PRECISION_NOT_SPECIFIED} as infinity. */
specifier|public
specifier|static
name|int
name|comparePrecision
parameter_list|(
name|int
name|p0
parameter_list|,
name|int
name|p1
parameter_list|)
block|{
if|if
condition|(
name|p0
operator|==
name|p1
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|p0
operator|==
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|p1
operator|==
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|Integer
operator|.
name|compare
argument_list|(
name|p0
argument_list|,
name|p1
argument_list|)
return|;
block|}
comment|/**    * @return true if type is ARRAY    */
specifier|public
specifier|static
name|boolean
name|isArray
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ARRAY
return|;
block|}
comment|/**    * @return true if type is MAP    */
specifier|public
specifier|static
name|boolean
name|isMap
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|MAP
return|;
block|}
comment|/**    * @return true if type is MULTISET    */
specifier|public
specifier|static
name|boolean
name|isMultiset
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|MULTISET
return|;
block|}
comment|/**    * @return true if type is ARRAY/MULTISET    */
specifier|public
specifier|static
name|boolean
name|isCollection
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ARRAY
operator|||
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|MULTISET
return|;
block|}
comment|/**    * @return true if type is CHARACTER    */
specifier|public
specifier|static
name|boolean
name|isCharacter
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|SqlTypeFamily
operator|.
name|CHARACTER
operator|.
name|contains
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * @return true if the type is a CHARACTER or contains a CHARACTER type    */
specifier|public
specifier|static
name|boolean
name|hasCharactor
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|isCharacter
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|isArray
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|hasCharactor
argument_list|(
name|type
operator|.
name|getComponentType
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * @return true if type is STRING    */
specifier|public
specifier|static
name|boolean
name|isString
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|SqlTypeFamily
operator|.
name|STRING
operator|.
name|contains
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * @return true if type is BOOLEAN    */
specifier|public
specifier|static
name|boolean
name|isBoolean
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|SqlTypeFamily
operator|.
name|BOOLEAN
operator|.
name|contains
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * @return true if type is BINARY    */
specifier|public
specifier|static
name|boolean
name|isBinary
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|SqlTypeFamily
operator|.
name|BINARY
operator|.
name|contains
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * @return true if type is Atomic    */
specifier|public
specifier|static
name|boolean
name|isAtomic
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|SqlTypeUtil
operator|.
name|isDatetime
argument_list|(
name|type
argument_list|)
operator|||
name|SqlTypeUtil
operator|.
name|isNumeric
argument_list|(
name|type
argument_list|)
operator|||
name|SqlTypeUtil
operator|.
name|isString
argument_list|(
name|type
argument_list|)
operator|||
name|SqlTypeUtil
operator|.
name|isBoolean
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/** Get decimal with max precision/scale for the current type system. */
specifier|public
specifier|static
name|RelDataType
name|getMaxPrecisionScaleDecimal
parameter_list|(
name|RelDataTypeFactory
name|factory
parameter_list|)
block|{
name|int
name|maxPrecision
init|=
name|factory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|getMaxNumericPrecision
argument_list|()
decl_stmt|;
name|int
name|maxScale
init|=
name|factory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|getMaxNumericScale
argument_list|()
decl_stmt|;
return|return
name|factory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
name|maxPrecision
argument_list|,
name|maxScale
argument_list|)
return|;
block|}
comment|/**    * Keeps only the last N fields and returns the new struct type.    */
specifier|public
specifier|static
name|RelDataType
name|extractLastNFields
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|int
name|numToKeep
parameter_list|)
block|{
assert|assert
name|type
operator|.
name|isStruct
argument_list|()
assert|;
assert|assert
name|type
operator|.
name|getFieldCount
argument_list|()
operator|>=
name|numToKeep
assert|;
specifier|final
name|int
name|fieldsCnt
init|=
name|type
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|type
operator|.
name|getFieldList
argument_list|()
operator|.
name|subList
argument_list|(
name|fieldsCnt
operator|-
name|numToKeep
argument_list|,
name|fieldsCnt
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

end_unit

