begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|implicit
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|java
operator|.
name|JavaTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|DynamicRecordType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactoryImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorNamespace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_comment
comment|/**  * Base class for all the type coercion rules. If you want to have a custom type coercion rules,  * inheriting this class is not necessary, but would have some convenient tool methods.  *  *<p>We make tool methods: {@link #coerceOperandType}, {@link #coerceColumnType},  * {@link #needToCast}, {@link #updateInferredType}, {@link #updateInferredColumnType}  * all overridable by derived classes, you can define system specific type coercion logic.  *  *<p>Caution that these methods may modify the {@link SqlNode} tree, you should know what the  * effect is when using these methods to customize your type coercion rules.  *  *<p>This class also defines the default implementation of the type widening strategies, see  * {@link TypeCoercion} doc and methods: {@link #getTightestCommonType}, {@link #getWiderTypeFor},  * {@link #getWiderTypeForTwo}, {@link #getWiderTypeForDecimal},  * {@link #commonTypeForBinaryComparison} for the detail strategies.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|AbstractTypeCoercion
implements|implements
name|TypeCoercion
block|{
specifier|protected
name|SqlValidator
name|validator
decl_stmt|;
specifier|protected
name|RelDataTypeFactory
name|factory
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
name|AbstractTypeCoercion
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|SqlValidator
name|validator
parameter_list|)
block|{
name|this
operator|.
name|factory
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|typeFactory
argument_list|)
expr_stmt|;
name|this
operator|.
name|validator
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|validator
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Cast operand at index {@code index} to target type.    * we do this base on the fact that validate happens before type coercion.    */
specifier|protected
name|boolean
name|coerceOperandType
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|int
name|index
parameter_list|,
name|RelDataType
name|targetType
parameter_list|)
block|{
comment|// Transform the JavaType to SQL type because the SqlDataTypeSpec
comment|// does not support deriving JavaType yet.
if|if
condition|(
name|RelDataTypeFactoryImpl
operator|.
name|isJavaType
argument_list|(
name|targetType
argument_list|)
condition|)
block|{
name|targetType
operator|=
operator|(
operator|(
name|JavaTypeFactory
operator|)
name|factory
operator|)
operator|.
name|toSql
argument_list|(
name|targetType
argument_list|)
expr_stmt|;
block|}
name|SqlNode
name|operand
init|=
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand
operator|instanceof
name|SqlDynamicParam
condition|)
block|{
comment|// Do not support implicit type coercion for dynamic param.
return|return
literal|false
return|;
block|}
comment|// Check it early.
if|if
condition|(
operator|!
name|needToCast
argument_list|(
name|scope
argument_list|,
name|operand
argument_list|,
name|targetType
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Fix up nullable attr.
name|RelDataType
name|targetType1
init|=
name|syncAttributes
argument_list|(
name|validator
operator|.
name|deriveType
argument_list|(
name|scope
argument_list|,
name|operand
argument_list|)
argument_list|,
name|targetType
argument_list|)
decl_stmt|;
name|SqlNode
name|desired
init|=
name|castTo
argument_list|(
name|operand
argument_list|,
name|targetType1
argument_list|)
decl_stmt|;
name|call
operator|.
name|setOperand
argument_list|(
name|index
argument_list|,
name|desired
argument_list|)
expr_stmt|;
name|updateInferredType
argument_list|(
name|desired
argument_list|,
name|targetType1
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Coerce all the operands to {@code commonType}.    *    * @param scope      Validator scope    * @param call       the call    * @param commonType common type to coerce to    */
specifier|protected
name|boolean
name|coerceOperandsType
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|RelDataType
name|commonType
parameter_list|)
block|{
name|boolean
name|coerced
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|call
operator|.
name|operandCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|coerced
operator|=
name|coerceOperandType
argument_list|(
name|scope
argument_list|,
name|call
argument_list|,
name|i
argument_list|,
name|commonType
argument_list|)
operator|||
name|coerced
expr_stmt|;
block|}
return|return
name|coerced
return|;
block|}
comment|/**    * Cast column at index {@code index} to target type.    *    * @param scope      Validator scope for the node list    * @param nodeList   Column node list    * @param index      Index of column    * @param targetType Target type to cast to    */
specifier|protected
name|boolean
name|coerceColumnType
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNodeList
name|nodeList
parameter_list|,
name|int
name|index
parameter_list|,
name|RelDataType
name|targetType
parameter_list|)
block|{
comment|// Transform the JavaType to SQL type because the SqlDataTypeSpec
comment|// does not support deriving JavaType yet.
if|if
condition|(
name|RelDataTypeFactoryImpl
operator|.
name|isJavaType
argument_list|(
name|targetType
argument_list|)
condition|)
block|{
name|targetType
operator|=
operator|(
operator|(
name|JavaTypeFactory
operator|)
name|factory
operator|)
operator|.
name|toSql
argument_list|(
name|targetType
argument_list|)
expr_stmt|;
block|}
comment|// This will happen when there is a star/dynamic-star column in the select list,
comment|// and the source is values expression, i.e. `select * from (values(1, 2, 3))`.
comment|// There is no need to coerce the column type, only remark
comment|// the inferred row type has changed, we will then add in type coercion
comment|// when expanding star/dynamic-star.
comment|// See SqlToRelConverter#convertSelectList for details.
if|if
condition|(
name|index
operator|>=
name|nodeList
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// Can only happen when there is a star(*) in the column,
comment|// just return true.
return|return
literal|true
return|;
block|}
specifier|final
name|SqlNode
name|node
init|=
name|nodeList
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|SqlDynamicParam
condition|)
block|{
comment|// Do not support implicit type coercion for dynamic param.
return|return
literal|false
return|;
block|}
if|if
condition|(
name|node
operator|instanceof
name|SqlIdentifier
condition|)
block|{
comment|// Do not expand a star/dynamic table col.
name|SqlIdentifier
name|node1
init|=
operator|(
name|SqlIdentifier
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|node1
operator|.
name|isStar
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|else if
condition|(
name|DynamicRecordType
operator|.
name|isDynamicStarColName
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|node1
operator|.
name|names
argument_list|)
argument_list|)
condition|)
block|{
comment|// Should support implicit cast for dynamic table.
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|node
operator|instanceof
name|SqlCall
condition|)
block|{
name|SqlCall
name|node2
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|node2
operator|.
name|getOperator
argument_list|()
operator|.
name|kind
operator|==
name|SqlKind
operator|.
name|AS
condition|)
block|{
specifier|final
name|SqlNode
name|operand
init|=
name|node2
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|needToCast
argument_list|(
name|scope
argument_list|,
name|operand
argument_list|,
name|targetType
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RelDataType
name|targetType2
init|=
name|syncAttributes
argument_list|(
name|validator
operator|.
name|deriveType
argument_list|(
name|scope
argument_list|,
name|operand
argument_list|)
argument_list|,
name|targetType
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|casted
init|=
name|castTo
argument_list|(
name|operand
argument_list|,
name|targetType2
argument_list|)
decl_stmt|;
name|node2
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
name|casted
argument_list|)
expr_stmt|;
name|updateInferredType
argument_list|(
name|casted
argument_list|,
name|targetType2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
operator|!
name|needToCast
argument_list|(
name|scope
argument_list|,
name|node
argument_list|,
name|targetType
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RelDataType
name|targetType3
init|=
name|syncAttributes
argument_list|(
name|validator
operator|.
name|deriveType
argument_list|(
name|scope
argument_list|,
name|node
argument_list|)
argument_list|,
name|targetType
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|node3
init|=
name|castTo
argument_list|(
name|node
argument_list|,
name|targetType3
argument_list|)
decl_stmt|;
name|nodeList
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|node3
argument_list|)
expr_stmt|;
name|updateInferredType
argument_list|(
name|node3
argument_list|,
name|targetType3
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Sync the data type additional attributes before casting,    * i.e. nullability, charset, collation.    */
name|RelDataType
name|syncAttributes
parameter_list|(
name|RelDataType
name|fromType
parameter_list|,
name|RelDataType
name|toType
parameter_list|)
block|{
name|RelDataType
name|syncedType
init|=
name|toType
decl_stmt|;
if|if
condition|(
name|fromType
operator|!=
literal|null
condition|)
block|{
name|syncedType
operator|=
name|factory
operator|.
name|createTypeWithNullability
argument_list|(
name|syncedType
argument_list|,
name|fromType
operator|.
name|isNullable
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|inCharOrBinaryFamilies
argument_list|(
name|fromType
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|inCharOrBinaryFamilies
argument_list|(
name|toType
argument_list|)
condition|)
block|{
name|Charset
name|charset
init|=
name|fromType
operator|.
name|getCharset
argument_list|()
decl_stmt|;
name|SqlCollation
name|collation
init|=
name|fromType
operator|.
name|getCollation
argument_list|()
decl_stmt|;
if|if
condition|(
name|charset
operator|!=
literal|null
operator|&&
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|syncedType
argument_list|)
condition|)
block|{
name|syncedType
operator|=
name|factory
operator|.
name|createTypeWithCharsetAndCollation
argument_list|(
name|syncedType
argument_list|,
name|charset
argument_list|,
name|collation
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|syncedType
return|;
block|}
comment|/** Decide if a SqlNode should be casted to target type, derived class    * can override this strategy. */
specifier|protected
name|boolean
name|needToCast
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|RelDataType
name|toType
parameter_list|)
block|{
name|RelDataType
name|fromType
init|=
name|validator
operator|.
name|deriveType
argument_list|(
name|scope
argument_list|,
name|node
argument_list|)
decl_stmt|;
comment|// This depends on the fact that type validate happens before coercion.
comment|// We do not have inferred type for some node, i.e. LOCALTIME.
if|if
condition|(
name|fromType
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// This prevents that we cast a JavaType to normal RelDataType.
if|if
condition|(
name|fromType
operator|instanceof
name|RelDataTypeFactoryImpl
operator|.
name|JavaType
operator|&&
name|toType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Do not make a cast when we don't know specific type (ANY) of the origin node.
if|if
condition|(
name|toType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
operator|||
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// No need to cast between char and varchar.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|toType
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|fromType
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// No need to cast if the source type precedence list
comment|// contains target type. i.e. do not cast from
comment|// tinyint to int or int to bigint.
if|if
condition|(
name|fromType
operator|.
name|getPrecedenceList
argument_list|()
operator|.
name|containsType
argument_list|(
name|toType
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isIntType
argument_list|(
name|fromType
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isIntType
argument_list|(
name|toType
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Implicit type coercion does not handle nullability.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|equalSansNullability
argument_list|(
name|factory
argument_list|,
name|fromType
argument_list|,
name|toType
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Should keep sync with rules in SqlTypeCoercionRule.
assert|assert
name|SqlTypeUtil
operator|.
name|canCastFrom
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|,
literal|true
argument_list|)
assert|;
return|return
literal|true
return|;
block|}
comment|/** It should not be used directly, because some other work should be done    * before cast operation, see {@link #coerceColumnType}, {@link #coerceOperandType}.    *    *<p>Ignore constant reduction which should happen in RexSimplify.    */
specifier|private
name|SqlNode
name|castTo
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|CAST
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|node
argument_list|,
name|SqlTypeUtil
operator|.
name|convertTypeToSpec
argument_list|(
name|type
argument_list|)
operator|.
name|withNullable
argument_list|(
name|type
operator|.
name|isNullable
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Update inferred type for a SqlNode.    */
specifier|protected
name|void
name|updateInferredType
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
name|validator
operator|.
name|setValidatedNodeType
argument_list|(
name|node
argument_list|,
name|type
argument_list|)
expr_stmt|;
specifier|final
name|SqlValidatorNamespace
name|namespace
init|=
name|validator
operator|.
name|getNamespace
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|namespace
operator|!=
literal|null
condition|)
block|{
name|namespace
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Update inferred row type for a query, i.e. SqlCall that returns struct type    * or SqlSelect.    *    * @param scope       Validator scope    * @param query       Node to inferred type    * @param columnIndex Column index to update    * @param desiredType Desired column type    */
specifier|protected
name|void
name|updateInferredColumnType
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNode
name|query
parameter_list|,
name|int
name|columnIndex
parameter_list|,
name|RelDataType
name|desiredType
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|validator
operator|.
name|deriveType
argument_list|(
name|scope
argument_list|,
name|query
argument_list|)
decl_stmt|;
assert|assert
name|rowType
operator|.
name|isStruct
argument_list|()
assert|;
assert|assert
name|columnIndex
operator|<
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
assert|;
specifier|final
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|fieldList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowType
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|String
name|name
init|=
name|field
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|targetType
init|=
name|i
operator|==
name|columnIndex
condition|?
name|desiredType
else|:
name|type
decl_stmt|;
name|fieldList
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|name
argument_list|,
name|targetType
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|updateInferredType
argument_list|(
name|query
argument_list|,
name|factory
operator|.
name|createStructType
argument_list|(
name|fieldList
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Case1: type widening with no precision loss.    * Find the tightest common type of two types that might be used in binary expression.    *    * @return tightest common type, i.e. INTEGER + DECIMAL(10, 2) returns DECIMAL(10, 2)    */
annotation|@
name|Override
specifier|public
name|RelDataType
name|getTightestCommonType
parameter_list|(
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
if|if
condition|(
name|type1
operator|==
literal|null
operator|||
name|type2
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// If only different with nullability, return type with be nullable true.
if|if
condition|(
name|type1
operator|.
name|equals
argument_list|(
name|type2
argument_list|)
operator|||
operator|(
name|type1
operator|.
name|isNullable
argument_list|()
operator|!=
name|type2
operator|.
name|isNullable
argument_list|()
operator|&&
name|factory
operator|.
name|createTypeWithNullability
argument_list|(
name|type1
argument_list|,
name|type2
operator|.
name|isNullable
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|type2
argument_list|)
operator|)
condition|)
block|{
return|return
name|factory
operator|.
name|createTypeWithNullability
argument_list|(
name|type1
argument_list|,
name|type1
operator|.
name|isNullable
argument_list|()
operator|||
name|type2
operator|.
name|isNullable
argument_list|()
argument_list|)
return|;
block|}
comment|// If one type is with Null type name: returns the other.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isNull
argument_list|(
name|type1
argument_list|)
condition|)
block|{
return|return
name|type2
return|;
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isNull
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
name|type1
return|;
block|}
name|RelDataType
name|resultType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isString
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isString
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|resultType
operator|=
name|factory
operator|.
name|leastRestrictive
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// For numeric types: promote to highest type.
comment|// i.e. MS-SQL/MYSQL supports numeric types cast from/to each other.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isNumeric
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isNumeric
argument_list|(
name|type2
argument_list|)
condition|)
block|{
comment|// For fixed precision decimals casts from(to) each other or other numeric types,
comment|// we let the operator decide the precision and scale of the result.
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|type1
argument_list|)
operator|&&
operator|!
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|resultType
operator|=
name|factory
operator|.
name|leastRestrictive
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Date + Timestamp -> Timestamp.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDate
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isTimestamp
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|resultType
operator|=
name|type2
expr_stmt|;
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDate
argument_list|(
name|type2
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isTimestamp
argument_list|(
name|type1
argument_list|)
condition|)
block|{
name|resultType
operator|=
name|type1
expr_stmt|;
block|}
if|if
condition|(
name|type1
operator|.
name|isStruct
argument_list|()
operator|&&
name|type2
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|equalAsStructSansNullability
argument_list|(
name|factory
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|,
name|validator
operator|.
name|getCatalogReader
argument_list|()
operator|.
name|nameMatcher
argument_list|()
argument_list|)
condition|)
block|{
comment|// If two fields only differs with name case and/or nullability:
comment|// - different names: use f1.name
comment|// - different nullabilities: `nullable` is true if one of them is nullable.
name|List
argument_list|<
name|RelDataType
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|type1
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|type1
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|type2
operator|.
name|getFieldList
argument_list|()
argument_list|)
control|)
block|{
name|RelDataType
name|leftType
init|=
name|pair
operator|.
name|left
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|rightType
init|=
name|pair
operator|.
name|right
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|dataType
init|=
name|getTightestCommonType
argument_list|(
name|leftType
argument_list|,
name|rightType
argument_list|)
decl_stmt|;
name|boolean
name|isNullable
init|=
name|leftType
operator|.
name|isNullable
argument_list|()
operator|||
name|rightType
operator|.
name|isNullable
argument_list|()
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|factory
operator|.
name|createTypeWithNullability
argument_list|(
name|dataType
argument_list|,
name|isNullable
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|factory
operator|.
name|createStructType
argument_list|(
name|type1
operator|.
name|getStructKind
argument_list|()
argument_list|,
name|fields
argument_list|,
name|fieldNames
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isArray
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isArray
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|equalSansNullability
argument_list|(
name|factory
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
condition|)
block|{
name|resultType
operator|=
name|factory
operator|.
name|createTypeWithNullability
argument_list|(
name|type1
argument_list|,
name|type1
operator|.
name|isNullable
argument_list|()
operator|||
name|type2
operator|.
name|isNullable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isMap
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isMap
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|equalSansNullability
argument_list|(
name|factory
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
condition|)
block|{
name|RelDataType
name|keyType
init|=
name|getTightestCommonType
argument_list|(
name|type1
operator|.
name|getKeyType
argument_list|()
argument_list|,
name|type2
operator|.
name|getKeyType
argument_list|()
argument_list|)
decl_stmt|;
name|RelDataType
name|valType
init|=
name|getTightestCommonType
argument_list|(
name|type1
operator|.
name|getValueType
argument_list|()
argument_list|,
name|type2
operator|.
name|getValueType
argument_list|()
argument_list|)
decl_stmt|;
name|resultType
operator|=
name|factory
operator|.
name|createMapType
argument_list|(
name|keyType
argument_list|,
name|valType
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|resultType
return|;
block|}
comment|/**    * Promote all the way to VARCHAR.    */
specifier|private
name|RelDataType
name|promoteToVarChar
parameter_list|(
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
name|RelDataType
name|resultType
init|=
literal|null
decl_stmt|;
comment|// No promotion for char and varchar.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// 1. Do not distinguish CHAR and VARCHAR, i.e. (INTEGER + CHAR(3))
comment|//    and (INTEGER + VARCHAR(5)) would both deduce VARCHAR type.
comment|// 2. VARCHAR has 65536 as default precision.
comment|// 3. Following MS-SQL: BINARY or BOOLEAN can be casted to VARCHAR.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isAtomic
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|resultType
operator|=
name|factory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isAtomic
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|resultType
operator|=
name|factory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
expr_stmt|;
block|}
return|return
name|resultType
return|;
block|}
comment|/**    * Determines common type for a comparison operator when one operand is String type and the    * other is not. For date + timestamp operands, use timestamp as common type,    * i.e. Timestamp(2017-01-01 00:00 ...)&gt; Date(2018) evaluates to be false.    */
annotation|@
name|Override
specifier|public
name|RelDataType
name|commonTypeForBinaryComparison
parameter_list|(
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
name|SqlTypeName
name|typeName1
init|=
name|type1
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
name|SqlTypeName
name|typeName2
init|=
name|type2
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName1
operator|==
literal|null
operator|||
name|typeName2
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// DATETIME + CHARACTER -> DATETIME
comment|// REVIEW Danny 2019-09-23: There is some legacy redundant code in SqlToRelConverter
comment|// that coerce Datetime and CHARACTER comparison.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isDatetime
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
name|type2
return|;
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDatetime
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
name|type1
return|;
block|}
comment|// DATE + TIMESTAMP -> TIMESTAMP
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDate
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isTimestamp
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
name|type2
return|;
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDate
argument_list|(
name|type2
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isTimestamp
argument_list|(
name|type1
argument_list|)
condition|)
block|{
return|return
name|type1
return|;
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isString
argument_list|(
name|type1
argument_list|)
operator|&&
name|typeName2
operator|==
name|SqlTypeName
operator|.
name|NULL
condition|)
block|{
return|return
name|type1
return|;
block|}
if|if
condition|(
name|typeName1
operator|==
name|SqlTypeName
operator|.
name|NULL
operator|&&
name|SqlTypeUtil
operator|.
name|isString
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
name|type2
return|;
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|type2
argument_list|)
operator|||
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|type2
argument_list|)
condition|)
block|{
comment|// There is no proper DECIMAL type for VARCHAR, using max precision/scale DECIMAL
comment|// as the best we can do.
return|return
name|SqlTypeUtil
operator|.
name|getMaxPrecisionScaleDecimal
argument_list|(
name|factory
argument_list|)
return|;
block|}
comment|// Keep sync with MS-SQL:
comment|// 1. BINARY/VARBINARY can not cast to FLOAT/REAL/DOUBLE
comment|// because of precision loss,
comment|// 2. CHARACTER to TIMESTAMP need explicit cast because of TimeZone.
comment|// Hive:
comment|// 1. BINARY can not cast to any other types,
comment|// 2. CHARACTER can only be coerced to DOUBLE/DECIMAL.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isBinary
argument_list|(
name|type2
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isApproximateNumeric
argument_list|(
name|type1
argument_list|)
operator|||
name|SqlTypeUtil
operator|.
name|isBinary
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isApproximateNumeric
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// 1> '1' will be coerced to 1> 1.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isAtomic
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isTimestamp
argument_list|(
name|type1
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|type1
return|;
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isAtomic
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isTimestamp
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|type2
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Case2: type widening. The main difference with {@link #getTightestCommonType}    * is that we allow some precision loss when widening decimal to fractional,    * or promote fractional to string type.    */
annotation|@
name|Override
specifier|public
name|RelDataType
name|getWiderTypeForTwo
parameter_list|(
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|,
name|boolean
name|stringPromotion
parameter_list|)
block|{
name|RelDataType
name|resultType
init|=
name|getTightestCommonType
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|resultType
condition|)
block|{
name|resultType
operator|=
name|getWiderTypeForDecimal
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|==
name|resultType
operator|&&
name|stringPromotion
condition|)
block|{
name|resultType
operator|=
name|promoteToVarChar
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|==
name|resultType
condition|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isArray
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isArray
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|RelDataType
name|valType
init|=
name|getWiderTypeForTwo
argument_list|(
name|type1
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|type2
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|stringPromotion
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|valType
condition|)
block|{
name|resultType
operator|=
name|factory
operator|.
name|createArrayType
argument_list|(
name|valType
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|resultType
return|;
block|}
comment|/**    * Finds a wider type when one or both types are decimal type.    * If the wider decimal type's precision/scale exceeds system limitation,    * this rule will truncate the decimal type to the max precision/scale.    * For decimal and fractional types, returns a decimal type    * which has the higher precision of the two.    *    *<p>The default implementation depends on the max precision/scale of the type system,    * you can override it based on the specific system requirement in    * {@link org.apache.calcite.rel.type.RelDataTypeSystem}.    */
annotation|@
name|Override
specifier|public
name|RelDataType
name|getWiderTypeForDecimal
parameter_list|(
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|type1
argument_list|)
operator|&&
operator|!
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// For Calcite `DECIMAL` default to have max allowed precision,
comment|// so just return decimal type.
comment|// This is based on the RelDataTypeSystem implementation,
comment|// subclass should override it correctly.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isNumeric
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isNumeric
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
name|factory
operator|.
name|leastRestrictive
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Similar to {@link #getWiderTypeForTwo}, but can handle    * sequence types. {@link #getWiderTypeForTwo} doesn't satisfy the associative law,    * i.e. (a op b) op c may not equal to a op (b op c). This is only a problem for STRING type or    * nested STRING type in collection type like ARRAY. Excluding these types,    * {@link #getWiderTypeForTwo} satisfies the associative law. For instance,    * (DATE, INTEGER, VARCHAR) should have VARCHAR as the wider common type.    */
annotation|@
name|Override
specifier|public
name|RelDataType
name|getWiderTypeFor
parameter_list|(
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
parameter_list|,
name|boolean
name|stringPromotion
parameter_list|)
block|{
assert|assert
name|typeList
operator|.
name|size
argument_list|()
operator|>
literal|1
assert|;
name|RelDataType
name|resultType
init|=
name|typeList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelDataType
argument_list|>
name|target
init|=
name|stringPromotion
condition|?
name|partitionByCharacter
argument_list|(
name|typeList
argument_list|)
else|:
name|typeList
decl_stmt|;
for|for
control|(
name|RelDataType
name|tp
range|:
name|target
control|)
block|{
name|resultType
operator|=
name|getWiderTypeForTwo
argument_list|(
name|tp
argument_list|,
name|resultType
argument_list|,
name|stringPromotion
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|resultType
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
name|resultType
return|;
block|}
specifier|private
name|List
argument_list|<
name|RelDataType
argument_list|>
name|partitionByCharacter
parameter_list|(
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
parameter_list|)
block|{
name|List
argument_list|<
name|RelDataType
argument_list|>
name|withCharacterTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataType
argument_list|>
name|nonCharacterTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataType
name|tp
range|:
name|types
control|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|hasCharacter
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|withCharacterTypes
operator|.
name|add
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nonCharacterTypes
operator|.
name|add
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|RelDataType
argument_list|>
name|partitioned
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|partitioned
operator|.
name|addAll
argument_list|(
name|withCharacterTypes
argument_list|)
expr_stmt|;
name|partitioned
operator|.
name|addAll
argument_list|(
name|nonCharacterTypes
argument_list|)
expr_stmt|;
return|return
name|partitioned
return|;
block|}
comment|/**    * Checks if the types and families can have implicit type coercion.    * We will check the type one by one, that means the 1th type and 1th family,    * 2th type and 2th family, and the like.    *    * @param types    Data type need to check    * @param families Desired type families list    */
name|boolean
name|canImplicitTypeCast
parameter_list|(
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
parameter_list|,
name|List
argument_list|<
name|SqlTypeFamily
argument_list|>
name|families
parameter_list|)
block|{
name|boolean
name|needed
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|types
operator|.
name|size
argument_list|()
operator|!=
name|families
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|RelDataType
argument_list|,
name|SqlTypeFamily
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|types
argument_list|,
name|families
argument_list|)
control|)
block|{
name|RelDataType
name|implicitType
init|=
name|implicitCast
argument_list|(
name|pair
operator|.
name|left
argument_list|,
name|pair
operator|.
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|implicitType
condition|)
block|{
return|return
literal|false
return|;
block|}
name|needed
operator|=
name|pair
operator|.
name|left
operator|!=
name|implicitType
operator|||
name|needed
expr_stmt|;
block|}
return|return
name|needed
return|;
block|}
comment|/**    * Type coercion based on the inferred type from passed in operand    * and the {@link SqlTypeFamily} defined in the checkers,    * e.g. the {@link org.apache.calcite.sql.type.FamilyOperandTypeChecker}.    *    *<p>Caution that we do not cast from NUMERIC to NUMERIC.    * See<a href="https://docs.google.com/spreadsheets/d/1GhleX5h5W8-kJKh7NMJ4vtoE78pwfaZRJl88ULX_MgU/edit?usp=sharing">CalciteImplicitCasts</a>    * for the details.    *    * @param in       Inferred operand type    * @param expected Expected {@link SqlTypeFamily} of registered SqlFunction    * @return common type of implicit cast, null if we do not find any    */
specifier|public
name|RelDataType
name|implicitCast
parameter_list|(
name|RelDataType
name|in
parameter_list|,
name|SqlTypeFamily
name|expected
parameter_list|)
block|{
name|List
argument_list|<
name|SqlTypeFamily
argument_list|>
name|numericFamilies
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|,
name|SqlTypeFamily
operator|.
name|DECIMAL
argument_list|,
name|SqlTypeFamily
operator|.
name|APPROXIMATE_NUMERIC
argument_list|,
name|SqlTypeFamily
operator|.
name|EXACT_NUMERIC
argument_list|,
name|SqlTypeFamily
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SqlTypeFamily
argument_list|>
name|dateTimeFamilies
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlTypeFamily
operator|.
name|DATE
argument_list|,
name|SqlTypeFamily
operator|.
name|TIME
argument_list|,
name|SqlTypeFamily
operator|.
name|TIMESTAMP
argument_list|)
decl_stmt|;
comment|// If the expected type is already a parent of the input type, no need to cast.
if|if
condition|(
name|expected
operator|.
name|getTypeNames
argument_list|()
operator|.
name|contains
argument_list|(
name|in
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|in
return|;
block|}
comment|// Cast null type (usually from null literals) into target type.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isNull
argument_list|(
name|in
argument_list|)
condition|)
block|{
return|return
name|expected
operator|.
name|getDefaultConcreteType
argument_list|(
name|factory
argument_list|)
return|;
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isNumeric
argument_list|(
name|in
argument_list|)
operator|&&
name|expected
operator|==
name|SqlTypeFamily
operator|.
name|DECIMAL
condition|)
block|{
return|return
name|factory
operator|.
name|decimalOf
argument_list|(
name|in
argument_list|)
return|;
block|}
comment|// FLOAT/DOUBLE -> DECIMAL
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isApproximateNumeric
argument_list|(
name|in
argument_list|)
operator|&&
name|expected
operator|==
name|SqlTypeFamily
operator|.
name|EXACT_NUMERIC
condition|)
block|{
return|return
name|factory
operator|.
name|decimalOf
argument_list|(
name|in
argument_list|)
return|;
block|}
comment|// DATE to TIMESTAMP
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDate
argument_list|(
name|in
argument_list|)
operator|&&
name|expected
operator|==
name|SqlTypeFamily
operator|.
name|TIMESTAMP
condition|)
block|{
return|return
name|factory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|)
return|;
block|}
comment|// TIMESTAMP to DATE.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isTimestamp
argument_list|(
name|in
argument_list|)
operator|&&
name|expected
operator|==
name|SqlTypeFamily
operator|.
name|DATE
condition|)
block|{
return|return
name|factory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DATE
argument_list|)
return|;
block|}
comment|// If the function accepts any NUMERIC type and the input is a STRING,
comment|// returns the expected type family's default type.
comment|// REVIEW Danny 2018-05-22: same with MS-SQL and MYSQL.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|in
argument_list|)
operator|&&
name|numericFamilies
operator|.
name|contains
argument_list|(
name|expected
argument_list|)
condition|)
block|{
return|return
name|expected
operator|.
name|getDefaultConcreteType
argument_list|(
name|factory
argument_list|)
return|;
block|}
comment|// STRING + DATE -> DATE;
comment|// STRING + TIME -> TIME;
comment|// STRING + TIMESTAMP -> TIMESTAMP
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|in
argument_list|)
operator|&&
name|dateTimeFamilies
operator|.
name|contains
argument_list|(
name|expected
argument_list|)
condition|)
block|{
return|return
name|expected
operator|.
name|getDefaultConcreteType
argument_list|(
name|factory
argument_list|)
return|;
block|}
comment|// STRING + BINARY -> VARBINARY
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isCharacter
argument_list|(
name|in
argument_list|)
operator|&&
name|expected
operator|==
name|SqlTypeFamily
operator|.
name|BINARY
condition|)
block|{
return|return
name|expected
operator|.
name|getDefaultConcreteType
argument_list|(
name|factory
argument_list|)
return|;
block|}
comment|// If we get here, `in` will never be STRING type.
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isAtomic
argument_list|(
name|in
argument_list|)
operator|&&
operator|(
name|expected
operator|==
name|SqlTypeFamily
operator|.
name|STRING
operator|||
name|expected
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
operator|)
condition|)
block|{
return|return
name|expected
operator|.
name|getDefaultConcreteType
argument_list|(
name|factory
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

