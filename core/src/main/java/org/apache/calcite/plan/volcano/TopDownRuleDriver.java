begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|DeriveMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|PhysicalNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|convert
operator|.
name|ConverterRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|trace
operator|.
name|CalciteTrace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_comment
comment|/**  * A rule driver that apply rules in a Top-Down manner.  * By ensuring rule applying orders, there could be ways for  * space pruning and rule mutual exclusivity check.  *  *<p>This implementation use tasks to manage rule matches.  * A Task is a piece of work to be executed, it may apply some rules  * or schedule other tasks</p>  */
end_comment

begin_class
class|class
name|TopDownRuleDriver
implements|implements
name|RuleDriver
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|CalciteTrace
operator|.
name|getPlannerTaskTracer
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|VolcanoPlanner
name|planner
decl_stmt|;
comment|/**    * The rule queue designed for top-down rule applying.    */
specifier|private
specifier|final
name|TopDownRuleQueue
name|ruleQueue
decl_stmt|;
comment|/**    * All tasks waiting for execution.    */
specifier|private
name|Stack
argument_list|<
name|Task
argument_list|>
name|tasks
init|=
operator|new
name|Stack
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * A task that is currently applying and may generate new RelNode.    * It provides a callback to schedule tasks for new RelNodes that    * are registered during task performing.    */
specifier|private
name|GeneratorTask
name|applying
init|=
literal|null
decl_stmt|;
comment|/**    * RelNodes that are generated by passThrough or derive    * these nodes will not takes part in another passThrough or derive.    */
specifier|private
name|Set
argument_list|<
name|RelNode
argument_list|>
name|passThroughCache
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
name|TopDownRuleDriver
parameter_list|(
name|VolcanoPlanner
name|planner
parameter_list|)
block|{
name|this
operator|.
name|planner
operator|=
name|planner
expr_stmt|;
name|ruleQueue
operator|=
operator|new
name|TopDownRuleQueue
argument_list|(
name|planner
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
annotation|@
name|Override
specifier|public
name|void
name|drive
parameter_list|()
block|{
name|TaskDescriptor
name|description
init|=
operator|new
name|TaskDescriptor
argument_list|()
decl_stmt|;
comment|// Starting from the root's OptimizeGroup task.
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|OptimizeGroup
argument_list|(
name|planner
operator|.
name|root
argument_list|,
name|planner
operator|.
name|infCost
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensure materialized view roots get explored.
comment|// Note that implementation rules or enforcement rules are not applied
comment|// unless the mv is matched
name|exploreMaterializationRoots
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Iterates until the root is fully optimized
while|while
condition|(
operator|!
name|tasks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Task
name|task
init|=
name|tasks
operator|.
name|pop
argument_list|()
decl_stmt|;
name|description
operator|.
name|log
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|task
operator|.
name|perform
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|VolcanoTimeoutException
name|ex
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Volcano planning times out, cancels the subsequent optimization."
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|exploreMaterializationRoots
parameter_list|()
block|{
for|for
control|(
name|RelSubset
name|extraRoot
range|:
name|planner
operator|.
name|explorationRoots
control|)
block|{
name|RelSet
name|rootSet
init|=
name|VolcanoPlanner
operator|.
name|equivRoot
argument_list|(
name|extraRoot
operator|.
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootSet
operator|==
name|planner
operator|.
name|root
operator|.
name|set
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|RelNode
name|rel
range|:
name|extraRoot
operator|.
name|set
operator|.
name|rels
control|)
block|{
if|if
condition|(
name|planner
operator|.
name|isLogical
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|OptimizeMExpr
argument_list|(
name|rel
argument_list|,
name|extraRoot
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|TopDownRuleQueue
name|getRuleQueue
parameter_list|()
block|{
return|return
name|ruleQueue
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|ruleQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|tasks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|passThroughCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|applying
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Procedure. */
specifier|private
interface|interface
name|Procedure
block|{
name|void
name|exec
parameter_list|()
function_decl|;
block|}
specifier|private
name|void
name|applyGenerator
parameter_list|(
name|GeneratorTask
name|task
parameter_list|,
name|Procedure
name|proc
parameter_list|)
block|{
name|GeneratorTask
name|applying
init|=
name|this
operator|.
name|applying
decl_stmt|;
name|this
operator|.
name|applying
operator|=
name|task
expr_stmt|;
try|try
block|{
name|proc
operator|.
name|exec
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|applying
operator|=
name|applying
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|onSetMerged
parameter_list|(
name|RelSet
name|set
parameter_list|)
block|{
comment|// When RelSets get merged, an optimized group may get extra opportunities.
comment|// Clear the OPTIMISED state for the RelSubsets and all theirs ancestors
comment|// so that they will be optimized again
name|applyGenerator
argument_list|(
literal|null
argument_list|,
parameter_list|()
lambda|->
name|clearProcessed
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|clearProcessed
parameter_list|(
name|RelSet
name|set
parameter_list|)
block|{
name|boolean
name|explored
init|=
name|set
operator|.
name|exploringState
operator|!=
literal|null
decl_stmt|;
name|set
operator|.
name|exploringState
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|RelSubset
name|subset
range|:
name|set
operator|.
name|subsets
control|)
block|{
if|if
condition|(
name|subset
operator|.
name|resetTaskState
argument_list|()
operator|||
name|explored
condition|)
block|{
name|Collection
argument_list|<
name|RelNode
argument_list|>
name|parentRels
init|=
name|subset
operator|.
name|getParentRels
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|parentRel
range|:
name|parentRels
control|)
block|{
name|clearProcessed
argument_list|(
name|planner
operator|.
name|getSet
argument_list|(
name|parentRel
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subset
operator|==
name|planner
operator|.
name|root
condition|)
block|{
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|OptimizeGroup
argument_list|(
name|subset
argument_list|,
name|planner
operator|.
name|infCost
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// a callback invoked when a RelNode is going to be added into a RelSubset,
comment|// either by Register or Reregister. The task driver should need to schedule
comment|// tasks for the new nodes.
annotation|@
name|Override
specifier|public
name|void
name|onProduce
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|RelSubset
name|subset
parameter_list|)
block|{
comment|// if the RelNode is added to another RelSubset, just ignore it.
comment|// It should be schedule in the later OptimizeGroup task
if|if
condition|(
name|applying
operator|==
literal|null
operator|||
name|subset
operator|.
name|set
operator|!=
name|VolcanoPlanner
operator|.
name|equivRoot
argument_list|(
name|applying
operator|.
name|group
argument_list|()
operator|.
name|set
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// extra callback from each task
if|if
condition|(
operator|!
name|applying
operator|.
name|onProduce
argument_list|(
name|node
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|planner
operator|.
name|isLogical
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|// For a physical node, schedule tasks to optimize its inputs.
comment|// The upper bound depends on all optimizing RelSubsets that this Rel belongs to.
comment|// If there are optimizing subsets that comes from the same RelSet,
comment|// invoke the passThrough method to generate a candidate for that Subset.
name|RelSubset
name|optimizingGroup
init|=
literal|null
decl_stmt|;
name|boolean
name|canPassThrough
init|=
name|node
operator|instanceof
name|PhysicalNode
operator|&&
operator|!
name|passThroughCache
operator|.
name|contains
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|canPassThrough
operator|&&
name|subset
operator|.
name|taskState
operator|!=
literal|null
condition|)
block|{
name|optimizingGroup
operator|=
name|subset
expr_stmt|;
block|}
else|else
block|{
name|RelOptCost
name|upperBound
init|=
name|planner
operator|.
name|zeroCost
decl_stmt|;
name|RelSet
name|set
init|=
name|subset
operator|.
name|getSet
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelSubset
argument_list|>
name|subsetsToPassThrough
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelSubset
name|otherSubset
range|:
name|set
operator|.
name|subsets
control|)
block|{
if|if
condition|(
operator|!
name|otherSubset
operator|.
name|isRequired
argument_list|()
operator|||
name|otherSubset
operator|!=
name|planner
operator|.
name|root
operator|&&
name|otherSubset
operator|.
name|taskState
operator|!=
name|RelSubset
operator|.
name|OptimizeState
operator|.
name|OPTIMIZING
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|node
operator|.
name|getTraitSet
argument_list|()
operator|.
name|satisfies
argument_list|(
name|otherSubset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|upperBound
operator|.
name|isLt
argument_list|(
name|otherSubset
operator|.
name|upperBound
argument_list|)
condition|)
block|{
name|upperBound
operator|=
name|otherSubset
operator|.
name|upperBound
expr_stmt|;
name|optimizingGroup
operator|=
name|otherSubset
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|canPassThrough
condition|)
block|{
name|subsetsToPassThrough
operator|.
name|add
argument_list|(
name|otherSubset
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|RelSubset
name|otherSubset
range|:
name|subsetsToPassThrough
control|)
block|{
name|Task
name|task
init|=
name|getOptimizeInputTask
argument_list|(
name|node
argument_list|,
name|otherSubset
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|tasks
operator|.
name|push
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|optimizingGroup
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Task
name|task
init|=
name|getOptimizeInputTask
argument_list|(
name|node
argument_list|,
name|optimizingGroup
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|tasks
operator|.
name|push
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|boolean
name|optimizing
init|=
name|subset
operator|.
name|set
operator|.
name|subsets
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|s
lambda|->
name|s
operator|.
name|taskState
operator|==
name|RelSubset
operator|.
name|OptimizeState
operator|.
name|OPTIMIZING
argument_list|)
decl_stmt|;
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|OptimizeMExpr
argument_list|(
name|node
argument_list|,
name|applying
operator|.
name|group
argument_list|()
argument_list|,
name|applying
operator|.
name|exploring
argument_list|()
operator|&&
operator|!
name|optimizing
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Base class for planner task.    */
specifier|private
interface|interface
name|Task
block|{
name|void
name|perform
parameter_list|()
function_decl|;
name|void
name|describe
parameter_list|(
name|TaskDescriptor
name|desc
parameter_list|)
function_decl|;
block|}
comment|/**    * A class for task logging.    */
specifier|private
specifier|static
class|class
name|TaskDescriptor
block|{
specifier|private
name|boolean
name|first
init|=
literal|true
decl_stmt|;
specifier|private
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|void
name|log
parameter_list|(
name|Task
name|task
parameter_list|)
block|{
if|if
condition|(
operator|!
name|LOGGER
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
name|first
operator|=
literal|true
expr_stmt|;
name|builder
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"Execute task: "
argument_list|)
operator|.
name|append
argument_list|(
name|task
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|task
operator|.
name|describe
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|LOGGER
operator|.
name|info
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|TaskDescriptor
name|item
parameter_list|(
name|String
name|name
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
name|name
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/** Task for generator. */
specifier|private
interface|interface
name|GeneratorTask
extends|extends
name|Task
block|{
name|RelSubset
name|group
parameter_list|()
function_decl|;
name|boolean
name|exploring
parameter_list|()
function_decl|;
specifier|default
name|boolean
name|onProduce
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Optimize a RelSubset.    * It schedule optimization tasks for RelNodes in the RelSet.    */
specifier|private
class|class
name|OptimizeGroup
implements|implements
name|Task
block|{
specifier|private
specifier|final
name|RelSubset
name|group
decl_stmt|;
specifier|private
name|RelOptCost
name|upperBound
decl_stmt|;
name|OptimizeGroup
parameter_list|(
name|RelSubset
name|group
parameter_list|,
name|RelOptCost
name|upperBound
parameter_list|)
block|{
name|this
operator|.
name|group
operator|=
name|group
expr_stmt|;
name|this
operator|.
name|upperBound
operator|=
name|upperBound
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|perform
parameter_list|()
block|{
name|RelOptCost
name|winner
init|=
name|group
operator|.
name|getWinnerCost
argument_list|()
decl_stmt|;
if|if
condition|(
name|winner
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|group
operator|.
name|taskState
operator|!=
literal|null
operator|&&
name|upperBound
operator|.
name|isLe
argument_list|(
name|group
operator|.
name|upperBound
argument_list|)
condition|)
block|{
comment|// either this group failed to optimize before or it is a ring
return|return;
block|}
name|group
operator|.
name|startOptimize
argument_list|(
name|upperBound
argument_list|)
expr_stmt|;
comment|// cannot decide an actual lower bound before MExpr are fully explored
comment|// so delay the lower bound checking
comment|// a gate keeper to update context
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|GroupOptimized
argument_list|(
name|group
argument_list|)
argument_list|)
expr_stmt|;
comment|// optimize mExprs in group
name|List
argument_list|<
name|RelNode
argument_list|>
name|physicals
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|group
operator|.
name|set
operator|.
name|rels
control|)
block|{
if|if
condition|(
name|planner
operator|.
name|isLogical
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|OptimizeMExpr
argument_list|(
name|rel
argument_list|,
name|group
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|rel
operator|.
name|isEnforcer
argument_list|()
condition|)
block|{
comment|// Enforcers have lower priority than other physical nodes
name|physicals
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|physicals
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
block|}
comment|// always apply O_INPUTS first so as to get an valid upper bound
for|for
control|(
name|RelNode
name|rel
range|:
name|physicals
control|)
block|{
name|Task
name|task
init|=
name|getOptimizeInputTask
argument_list|(
name|rel
argument_list|,
name|group
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|tasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|describe
parameter_list|(
name|TaskDescriptor
name|desc
parameter_list|)
block|{
name|desc
operator|.
name|item
argument_list|(
literal|"group"
argument_list|,
name|group
argument_list|)
operator|.
name|item
argument_list|(
literal|"upperBound"
argument_list|,
name|upperBound
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Mark the RelSubset optimized.    * When GroupOptimized returns, the group is either fully    * optimized and has a winner or failed to optimized    */
specifier|private
specifier|static
class|class
name|GroupOptimized
implements|implements
name|Task
block|{
specifier|private
specifier|final
name|RelSubset
name|group
decl_stmt|;
name|GroupOptimized
parameter_list|(
name|RelSubset
name|group
parameter_list|)
block|{
name|this
operator|.
name|group
operator|=
name|group
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|perform
parameter_list|()
block|{
name|group
operator|.
name|setOptimized
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|describe
parameter_list|(
name|TaskDescriptor
name|desc
parameter_list|)
block|{
name|desc
operator|.
name|item
argument_list|(
literal|"group"
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Optimize a logical node, including exploring its input and applying rules for it.    */
specifier|private
class|class
name|OptimizeMExpr
implements|implements
name|Task
block|{
specifier|private
specifier|final
name|RelNode
name|mExpr
decl_stmt|;
specifier|private
specifier|final
name|RelSubset
name|group
decl_stmt|;
comment|// when true, only apply transformation rules for mExpr
specifier|private
specifier|final
name|boolean
name|explore
decl_stmt|;
name|OptimizeMExpr
parameter_list|(
name|RelNode
name|mExpr
parameter_list|,
name|RelSubset
name|group
parameter_list|,
name|boolean
name|explore
parameter_list|)
block|{
name|this
operator|.
name|mExpr
operator|=
name|mExpr
expr_stmt|;
name|this
operator|.
name|group
operator|=
name|group
expr_stmt|;
name|this
operator|.
name|explore
operator|=
name|explore
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|perform
parameter_list|()
block|{
if|if
condition|(
name|explore
operator|&&
name|group
operator|.
name|isExplored
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// 1. explode input
comment|// 2. apply other rules
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|ApplyRules
argument_list|(
name|mExpr
argument_list|,
name|group
argument_list|,
name|explore
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|mExpr
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|ExploreInput
argument_list|(
name|mExpr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|describe
parameter_list|(
name|TaskDescriptor
name|desc
parameter_list|)
block|{
name|desc
operator|.
name|item
argument_list|(
literal|"mExpr"
argument_list|,
name|mExpr
argument_list|)
operator|.
name|item
argument_list|(
literal|"explore"
argument_list|,
name|explore
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Ensure that ExploreInputs are working on the correct input group.    * Currently, a RelNode's input may change since calcite may merge RelSets.    */
specifier|private
class|class
name|EnsureGroupExplored
implements|implements
name|Task
block|{
specifier|private
specifier|final
name|RelSubset
name|input
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|parent
decl_stmt|;
specifier|private
specifier|final
name|int
name|inputOrdinal
decl_stmt|;
name|EnsureGroupExplored
parameter_list|(
name|RelSubset
name|input
parameter_list|,
name|RelNode
name|parent
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|inputOrdinal
operator|=
name|inputOrdinal
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|perform
parameter_list|()
block|{
if|if
condition|(
name|parent
operator|.
name|getInput
argument_list|(
name|inputOrdinal
argument_list|)
operator|!=
name|input
condition|)
block|{
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|ExploreInput
argument_list|(
name|parent
argument_list|,
name|inputOrdinal
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|input
operator|.
name|setExplored
argument_list|()
expr_stmt|;
for|for
control|(
name|RelSubset
name|subset
range|:
name|input
operator|.
name|getSet
argument_list|()
operator|.
name|subsets
control|)
block|{
comment|// clear the LB cache as exploring state have changed
name|input
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
operator|.
name|clearCache
argument_list|(
name|subset
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|describe
parameter_list|(
name|TaskDescriptor
name|desc
parameter_list|)
block|{
name|desc
operator|.
name|item
argument_list|(
literal|"mExpr"
argument_list|,
name|parent
argument_list|)
operator|.
name|item
argument_list|(
literal|"i"
argument_list|,
name|inputOrdinal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Explore an input for a RelNode.    */
specifier|private
class|class
name|ExploreInput
implements|implements
name|Task
block|{
specifier|private
specifier|final
name|RelSubset
name|group
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|parent
decl_stmt|;
specifier|private
specifier|final
name|int
name|inputOrdinal
decl_stmt|;
name|ExploreInput
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
name|this
operator|.
name|group
operator|=
operator|(
name|RelSubset
operator|)
name|parent
operator|.
name|getInput
argument_list|(
name|inputOrdinal
argument_list|)
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|inputOrdinal
operator|=
name|inputOrdinal
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|perform
parameter_list|()
block|{
if|if
condition|(
operator|!
name|group
operator|.
name|explore
argument_list|()
condition|)
block|{
return|return;
block|}
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|EnsureGroupExplored
argument_list|(
name|group
argument_list|,
name|parent
argument_list|,
name|inputOrdinal
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|group
operator|.
name|set
operator|.
name|rels
control|)
block|{
if|if
condition|(
name|planner
operator|.
name|isLogical
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|OptimizeMExpr
argument_list|(
name|rel
argument_list|,
name|group
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|describe
parameter_list|(
name|TaskDescriptor
name|desc
parameter_list|)
block|{
name|desc
operator|.
name|item
argument_list|(
literal|"group"
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Extract rule matches from rule queue and add them to task stack.    */
specifier|private
class|class
name|ApplyRules
implements|implements
name|Task
block|{
specifier|private
specifier|final
name|RelNode
name|mExpr
decl_stmt|;
specifier|private
specifier|final
name|RelSubset
name|group
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|exploring
decl_stmt|;
name|ApplyRules
parameter_list|(
name|RelNode
name|mExpr
parameter_list|,
name|RelSubset
name|group
parameter_list|,
name|boolean
name|exploring
parameter_list|)
block|{
name|this
operator|.
name|mExpr
operator|=
name|mExpr
expr_stmt|;
name|this
operator|.
name|group
operator|=
name|group
expr_stmt|;
name|this
operator|.
name|exploring
operator|=
name|exploring
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|perform
parameter_list|()
block|{
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Predicate
argument_list|<
name|VolcanoRuleMatch
argument_list|>
argument_list|>
name|category
init|=
name|exploring
condition|?
name|Pair
operator|.
name|of
argument_list|(
name|mExpr
argument_list|,
name|planner
operator|::
name|isTransformationRule
argument_list|)
else|:
name|Pair
operator|.
name|of
argument_list|(
name|mExpr
argument_list|,
name|m
lambda|->
literal|true
argument_list|)
decl_stmt|;
name|VolcanoRuleMatch
name|match
init|=
name|ruleQueue
operator|.
name|popMatch
argument_list|(
name|category
argument_list|)
decl_stmt|;
while|while
condition|(
name|match
operator|!=
literal|null
condition|)
block|{
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|ApplyRule
argument_list|(
name|match
argument_list|,
name|group
argument_list|,
name|exploring
argument_list|)
argument_list|)
expr_stmt|;
name|match
operator|=
name|ruleQueue
operator|.
name|popMatch
argument_list|(
name|category
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|describe
parameter_list|(
name|TaskDescriptor
name|desc
parameter_list|)
block|{
name|desc
operator|.
name|item
argument_list|(
literal|"mExpr"
argument_list|,
name|mExpr
argument_list|)
operator|.
name|item
argument_list|(
literal|"exploring"
argument_list|,
name|exploring
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Apply a rule match.    */
specifier|private
class|class
name|ApplyRule
implements|implements
name|GeneratorTask
block|{
specifier|private
specifier|final
name|VolcanoRuleMatch
name|match
decl_stmt|;
specifier|private
specifier|final
name|RelSubset
name|group
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|exploring
decl_stmt|;
name|ApplyRule
parameter_list|(
name|VolcanoRuleMatch
name|match
parameter_list|,
name|RelSubset
name|group
parameter_list|,
name|boolean
name|exploring
parameter_list|)
block|{
name|this
operator|.
name|match
operator|=
name|match
expr_stmt|;
name|this
operator|.
name|group
operator|=
name|group
expr_stmt|;
name|this
operator|.
name|exploring
operator|=
name|exploring
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|describe
parameter_list|(
name|TaskDescriptor
name|desc
parameter_list|)
block|{
name|desc
operator|.
name|item
argument_list|(
literal|"match"
argument_list|,
name|match
argument_list|)
operator|.
name|item
argument_list|(
literal|"exploring"
argument_list|,
name|exploring
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|perform
parameter_list|()
block|{
name|applyGenerator
argument_list|(
name|this
argument_list|,
name|match
operator|::
name|onMatch
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RelSubset
name|group
parameter_list|()
block|{
return|return
name|group
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|exploring
parameter_list|()
block|{
return|return
name|exploring
return|;
block|}
block|}
comment|// Decide how to optimize a physical node.
specifier|private
name|Task
name|getOptimizeInputTask
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelSubset
name|group
parameter_list|)
block|{
comment|// If the physical does not in current optimizing RelSubset, it firstly tries to
comment|// convert the physical node either by converter rule or traits pass though.
if|if
condition|(
operator|!
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|satisfies
argument_list|(
name|group
operator|.
name|getTraitSet
argument_list|()
argument_list|)
condition|)
block|{
name|RelNode
name|passThroughRel
init|=
name|convert
argument_list|(
name|rel
argument_list|,
name|group
argument_list|)
decl_stmt|;
if|if
condition|(
name|passThroughRel
operator|==
literal|null
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Skip optimizing because of traits: {}"
argument_list|,
name|rel
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|RelNode
name|finalPassThroughRel
init|=
name|passThroughRel
decl_stmt|;
name|applyGenerator
argument_list|(
literal|null
argument_list|,
parameter_list|()
lambda|->
name|planner
operator|.
name|register
argument_list|(
name|finalPassThroughRel
argument_list|,
name|group
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|=
name|passThroughRel
expr_stmt|;
block|}
name|boolean
name|unProcess
init|=
literal|false
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|RelOptCost
name|winner
init|=
operator|(
operator|(
name|RelSubset
operator|)
name|input
operator|)
operator|.
name|getWinnerCost
argument_list|()
decl_stmt|;
if|if
condition|(
name|winner
operator|==
literal|null
condition|)
block|{
name|unProcess
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// If the inputs are all processed, only DeriveTrait is required.
if|if
condition|(
operator|!
name|unProcess
condition|)
block|{
return|return
operator|new
name|DeriveTrait
argument_list|(
name|rel
argument_list|,
name|group
argument_list|)
return|;
block|}
comment|// If part of the inputs are not optimized, schedule for the node an OptimizeInput task,
comment|// which tried to optimize the inputs first and derive traits for further execution.
if|if
condition|(
name|rel
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
operator|new
name|OptimizeInput1
argument_list|(
name|rel
argument_list|,
name|group
argument_list|)
return|;
block|}
return|return
operator|new
name|OptimizeInputs
argument_list|(
name|rel
argument_list|,
name|group
argument_list|)
return|;
block|}
comment|// Try to convert the physical node to another trait sets,
comment|// either by converter rule or traits pass through.
specifier|private
name|RelNode
name|convert
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelSubset
name|group
parameter_list|)
block|{
if|if
condition|(
operator|!
name|passThroughCache
operator|.
name|contains
argument_list|(
name|rel
argument_list|)
condition|)
block|{
if|if
condition|(
name|checkLowerBound
argument_list|(
name|rel
argument_list|,
name|group
argument_list|)
condition|)
block|{
name|RelNode
name|passThrough
init|=
name|group
operator|.
name|passThrough
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|passThrough
operator|!=
literal|null
condition|)
block|{
assert|assert
name|passThrough
operator|.
name|getConvention
argument_list|()
operator|==
name|rel
operator|.
name|getConvention
argument_list|()
assert|;
name|passThroughCache
operator|.
name|add
argument_list|(
name|passThrough
argument_list|)
expr_stmt|;
return|return
name|passThrough
return|;
block|}
block|}
else|else
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Skip pass though because of lower bound. LB = {}, UP = {}"
argument_list|,
name|rel
argument_list|,
name|group
operator|.
name|upperBound
argument_list|)
expr_stmt|;
block|}
block|}
name|VolcanoRuleMatch
name|match
init|=
name|ruleQueue
operator|.
name|popMatch
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|rel
argument_list|,
name|m
lambda|->
name|m
operator|.
name|getRule
argument_list|()
operator|instanceof
name|ConverterRule
operator|&&
name|m
operator|.
name|getRule
argument_list|()
operator|.
name|getOutTrait
argument_list|()
operator|.
name|satisfies
argument_list|(
name|group
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getConvention
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|!=
literal|null
condition|)
block|{
name|tasks
operator|.
name|add
argument_list|(
operator|new
name|ApplyRule
argument_list|(
name|match
argument_list|,
name|group
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// check whether a node's lower bound is less than a RelSubset's upper bound
specifier|private
name|boolean
name|checkLowerBound
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelSubset
name|group
parameter_list|)
block|{
name|RelOptCost
name|upperBound
init|=
name|group
operator|.
name|upperBound
decl_stmt|;
if|if
condition|(
name|upperBound
operator|.
name|isInfinite
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|RelOptCost
name|lb
init|=
name|planner
operator|.
name|getLowerBound
argument_list|(
name|rel
argument_list|)
decl_stmt|;
return|return
operator|!
name|upperBound
operator|.
name|isLe
argument_list|(
name|lb
argument_list|)
return|;
block|}
comment|/**    * A task that optimize input for physical nodes who has only one input.    * This task can be replaced by OptimizeInputs but simplify lots of logic.    */
specifier|private
class|class
name|OptimizeInput1
implements|implements
name|Task
block|{
specifier|private
specifier|final
name|RelNode
name|mExpr
decl_stmt|;
specifier|private
specifier|final
name|RelSubset
name|group
decl_stmt|;
name|OptimizeInput1
parameter_list|(
name|RelNode
name|mExpr
parameter_list|,
name|RelSubset
name|group
parameter_list|)
block|{
name|this
operator|.
name|mExpr
operator|=
name|mExpr
expr_stmt|;
name|this
operator|.
name|group
operator|=
name|group
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|describe
parameter_list|(
name|TaskDescriptor
name|desc
parameter_list|)
block|{
name|desc
operator|.
name|item
argument_list|(
literal|"mExpr"
argument_list|,
name|mExpr
argument_list|)
operator|.
name|item
argument_list|(
literal|"upperBound"
argument_list|,
name|group
operator|.
name|upperBound
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|perform
parameter_list|()
block|{
name|RelOptCost
name|upperBound
init|=
name|group
operator|.
name|upperBound
decl_stmt|;
name|RelOptCost
name|upperForInput
init|=
name|planner
operator|.
name|upperBoundForInputs
argument_list|(
name|mExpr
argument_list|,
name|upperBound
argument_list|)
decl_stmt|;
if|if
condition|(
name|upperForInput
operator|.
name|isLe
argument_list|(
name|planner
operator|.
name|zeroCost
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Skip O_INPUT because of lower bound. UB4Inputs = {}, UB = {}"
argument_list|,
name|upperForInput
argument_list|,
name|upperBound
argument_list|)
expr_stmt|;
return|return;
block|}
name|RelSubset
name|input
init|=
operator|(
name|RelSubset
operator|)
name|mExpr
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Apply enforcing rules
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|DeriveTrait
argument_list|(
name|mExpr
argument_list|,
name|group
argument_list|)
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|CheckInput
argument_list|(
literal|null
argument_list|,
name|mExpr
argument_list|,
name|input
argument_list|,
literal|0
argument_list|,
name|upperForInput
argument_list|)
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|OptimizeGroup
argument_list|(
name|input
argument_list|,
name|upperForInput
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Optimize a physical node's inputs.    * This task calculates a proper upper bound for the input and invoke    * the OptimizeGroup task. Group pruning mainly happens here when    * the upper bound for an input is less than the input's lower bound    */
specifier|private
class|class
name|OptimizeInputs
implements|implements
name|Task
block|{
specifier|private
specifier|final
name|RelNode
name|mExpr
decl_stmt|;
specifier|private
specifier|final
name|RelSubset
name|group
decl_stmt|;
specifier|private
specifier|final
name|int
name|childCount
decl_stmt|;
specifier|private
name|RelOptCost
name|upperBound
decl_stmt|;
specifier|private
name|RelOptCost
name|upperForInput
decl_stmt|;
specifier|private
name|int
name|processingChild
decl_stmt|;
name|OptimizeInputs
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelSubset
name|group
parameter_list|)
block|{
name|this
operator|.
name|mExpr
operator|=
name|rel
expr_stmt|;
name|this
operator|.
name|group
operator|=
name|group
expr_stmt|;
name|this
operator|.
name|upperBound
operator|=
name|group
operator|.
name|upperBound
expr_stmt|;
name|this
operator|.
name|upperForInput
operator|=
name|planner
operator|.
name|infCost
expr_stmt|;
name|this
operator|.
name|childCount
operator|=
name|rel
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
name|this
operator|.
name|processingChild
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|describe
parameter_list|(
name|TaskDescriptor
name|desc
parameter_list|)
block|{
name|desc
operator|.
name|item
argument_list|(
literal|"mExpr"
argument_list|,
name|mExpr
argument_list|)
operator|.
name|item
argument_list|(
literal|"upperBound"
argument_list|,
name|upperBound
argument_list|)
operator|.
name|item
argument_list|(
literal|"processingChild"
argument_list|,
name|processingChild
argument_list|)
expr_stmt|;
block|}
specifier|private
name|List
argument_list|<
name|RelOptCost
argument_list|>
name|lowerBounds
decl_stmt|;
specifier|private
name|RelOptCost
name|lowerBoundSum
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|perform
parameter_list|()
block|{
name|RelOptCost
name|bestCost
init|=
name|group
operator|.
name|bestCost
decl_stmt|;
if|if
condition|(
operator|!
name|bestCost
operator|.
name|isInfinite
argument_list|()
condition|)
block|{
comment|// calculate the upper bound for inputs
if|if
condition|(
name|bestCost
operator|.
name|isLt
argument_list|(
name|upperBound
argument_list|)
condition|)
block|{
name|upperBound
operator|=
name|bestCost
expr_stmt|;
name|upperForInput
operator|=
name|planner
operator|.
name|upperBoundForInputs
argument_list|(
name|mExpr
argument_list|,
name|upperBound
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lowerBoundSum
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|upperForInput
operator|.
name|isInfinite
argument_list|()
condition|)
block|{
name|upperForInput
operator|=
name|planner
operator|.
name|upperBoundForInputs
argument_list|(
name|mExpr
argument_list|,
name|upperBound
argument_list|)
expr_stmt|;
block|}
name|lowerBounds
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|childCount
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|mExpr
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|RelOptCost
name|lb
init|=
name|planner
operator|.
name|getLowerBound
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|lowerBounds
operator|.
name|add
argument_list|(
name|lb
argument_list|)
expr_stmt|;
name|lowerBoundSum
operator|=
name|lowerBoundSum
operator|==
literal|null
condition|?
name|lb
else|:
name|lowerBoundSum
operator|.
name|plus
argument_list|(
name|lb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|upperForInput
operator|.
name|isLt
argument_list|(
name|lowerBoundSum
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Skip O_INPUT because of lower bound. LB = {}, UP = {}"
argument_list|,
name|lowerBoundSum
argument_list|,
name|upperForInput
argument_list|)
expr_stmt|;
return|return;
comment|// group pruned
block|}
block|}
if|if
condition|(
name|lowerBoundSum
operator|!=
literal|null
operator|&&
name|lowerBoundSum
operator|.
name|isInfinite
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Skip O_INPUT as one of the inputs fail to optimize"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|processingChild
operator|==
literal|0
condition|)
block|{
comment|// derive traits after all inputs are optimized successfully
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|DeriveTrait
argument_list|(
name|mExpr
argument_list|,
name|group
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|processingChild
operator|<
name|childCount
condition|)
block|{
name|RelSubset
name|input
init|=
operator|(
name|RelSubset
operator|)
name|mExpr
operator|.
name|getInput
argument_list|(
name|processingChild
argument_list|)
decl_stmt|;
name|RelOptCost
name|winner
init|=
name|input
operator|.
name|getWinnerCost
argument_list|()
decl_stmt|;
if|if
condition|(
name|winner
operator|!=
literal|null
condition|)
block|{
operator|++
name|processingChild
expr_stmt|;
continue|continue;
block|}
name|RelOptCost
name|upper
init|=
name|upperForInput
decl_stmt|;
if|if
condition|(
operator|!
name|upper
operator|.
name|isInfinite
argument_list|()
condition|)
block|{
comment|// UB(one input)
comment|//  = UB(current subset) - Parent's NonCumulativeCost - LB(other inputs)
comment|//  = UB(current subset) - Parent's NonCumulativeCost - LB(all inputs) + LB(current input)
name|upper
operator|=
name|upperForInput
operator|.
name|minus
argument_list|(
name|lowerBoundSum
argument_list|)
operator|.
name|plus
argument_list|(
name|lowerBounds
operator|.
name|get
argument_list|(
name|processingChild
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input
operator|.
name|taskState
operator|!=
literal|null
operator|&&
name|upper
operator|.
name|isLe
argument_list|(
name|input
operator|.
name|upperBound
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Failed to optimize because of upper bound. LB = {}, UP = {}"
argument_list|,
name|lowerBoundSum
argument_list|,
name|upperForInput
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|processingChild
operator|!=
name|childCount
operator|-
literal|1
condition|)
block|{
name|tasks
operator|.
name|push
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|CheckInput
argument_list|(
name|this
argument_list|,
name|mExpr
argument_list|,
name|input
argument_list|,
name|processingChild
argument_list|,
name|upper
argument_list|)
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|OptimizeGroup
argument_list|(
name|input
argument_list|,
name|upper
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|processingChild
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/**    * Ensure input is optimized correctly and modify context.    */
specifier|private
class|class
name|CheckInput
implements|implements
name|Task
block|{
specifier|private
specifier|final
name|OptimizeInputs
name|context
decl_stmt|;
specifier|private
specifier|final
name|RelOptCost
name|upper
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|parent
decl_stmt|;
specifier|private
name|RelSubset
name|input
decl_stmt|;
specifier|private
specifier|final
name|int
name|i
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|describe
parameter_list|(
name|TaskDescriptor
name|desc
parameter_list|)
block|{
name|desc
operator|.
name|item
argument_list|(
literal|"parent"
argument_list|,
name|parent
argument_list|)
operator|.
name|item
argument_list|(
literal|"i"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|CheckInput
parameter_list|(
name|OptimizeInputs
name|context
parameter_list|,
name|RelNode
name|parent
parameter_list|,
name|RelSubset
name|input
parameter_list|,
name|int
name|i
parameter_list|,
name|RelOptCost
name|upper
parameter_list|)
block|{
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
name|this
operator|.
name|i
operator|=
name|i
expr_stmt|;
name|this
operator|.
name|upper
operator|=
name|upper
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|perform
parameter_list|()
block|{
if|if
condition|(
name|input
operator|!=
name|parent
operator|.
name|getInput
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|// The input has chnaged. So reschedule the optimize task.
name|input
operator|=
operator|(
name|RelSubset
operator|)
name|parent
operator|.
name|getInput
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|push
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|OptimizeGroup
argument_list|(
name|input
argument_list|,
name|upper
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Optimize input completed. Update the context for other inputs
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
comment|// If there is no other input, just return (no need to optimize other inputs)
return|return;
block|}
name|RelOptCost
name|winner
init|=
name|input
operator|.
name|getWinnerCost
argument_list|()
decl_stmt|;
if|if
condition|(
name|winner
operator|==
literal|null
condition|)
block|{
comment|// The input fail to optimize due to group pruning
comment|// Then there's no need to optimize other inputs.
name|context
operator|.
name|lowerBoundSum
operator|=
name|planner
operator|.
name|infCost
expr_stmt|;
return|return;
block|}
comment|// Update the context.
if|if
condition|(
name|context
operator|.
name|lowerBoundSum
operator|!=
literal|null
operator|&&
name|context
operator|.
name|lowerBoundSum
operator|!=
name|planner
operator|.
name|infCost
condition|)
block|{
name|context
operator|.
name|lowerBoundSum
operator|=
name|context
operator|.
name|lowerBoundSum
operator|.
name|minus
argument_list|(
name|context
operator|.
name|lowerBounds
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|lowerBoundSum
operator|=
name|context
operator|.
name|lowerBoundSum
operator|.
name|plus
argument_list|(
name|winner
argument_list|)
expr_stmt|;
name|context
operator|.
name|lowerBounds
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|winner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Derive traits for already optimized physical nodes.    */
specifier|private
class|class
name|DeriveTrait
implements|implements
name|GeneratorTask
block|{
specifier|private
specifier|final
name|RelNode
name|mExpr
decl_stmt|;
specifier|private
specifier|final
name|RelSubset
name|group
decl_stmt|;
name|DeriveTrait
parameter_list|(
name|RelNode
name|mExpr
parameter_list|,
name|RelSubset
name|group
parameter_list|)
block|{
name|this
operator|.
name|mExpr
operator|=
name|mExpr
expr_stmt|;
name|this
operator|.
name|group
operator|=
name|group
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|perform
parameter_list|()
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|mExpr
operator|.
name|getInputs
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|inputs
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|RelSubset
operator|)
name|input
operator|)
operator|.
name|getWinnerCost
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// fail to optimize input, then no need to deliver traits
return|return;
block|}
block|}
comment|// In case some implementations use rules to convert between different physical conventions.
comment|// Note that this is deprecated and will be removed in the future.
name|tasks
operator|.
name|push
argument_list|(
operator|new
name|ApplyRules
argument_list|(
name|mExpr
argument_list|,
name|group
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Derive traits from inputs
if|if
condition|(
operator|!
name|passThroughCache
operator|.
name|contains
argument_list|(
name|mExpr
argument_list|)
condition|)
block|{
name|applyGenerator
argument_list|(
name|this
argument_list|,
name|this
operator|::
name|derive
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|derive
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|mExpr
operator|instanceof
name|PhysicalNode
operator|)
operator|||
operator|(
operator|(
name|PhysicalNode
operator|)
name|mExpr
operator|)
operator|.
name|getDeriveMode
argument_list|()
operator|==
name|DeriveMode
operator|.
name|PROHIBITED
condition|)
block|{
return|return;
block|}
name|PhysicalNode
name|rel
init|=
operator|(
name|PhysicalNode
operator|)
name|mExpr
decl_stmt|;
name|DeriveMode
name|mode
init|=
name|rel
operator|.
name|getDeriveMode
argument_list|()
decl_stmt|;
name|int
name|arity
init|=
name|rel
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// for OMAKASE
name|List
argument_list|<
name|List
argument_list|<
name|RelTraitSet
argument_list|>
argument_list|>
name|inputTraits
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|arity
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arity
condition|;
name|i
operator|++
control|)
block|{
name|int
name|childId
init|=
name|i
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|DeriveMode
operator|.
name|RIGHT_FIRST
condition|)
block|{
name|childId
operator|=
name|arity
operator|-
name|i
operator|-
literal|1
expr_stmt|;
block|}
name|RelSubset
name|input
init|=
operator|(
name|RelSubset
operator|)
name|rel
operator|.
name|getInput
argument_list|(
name|childId
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelTraitSet
argument_list|>
name|traits
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|inputTraits
operator|.
name|add
argument_list|(
name|traits
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numSubset
init|=
name|input
operator|.
name|set
operator|.
name|subsets
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numSubset
condition|;
name|j
operator|++
control|)
block|{
name|RelSubset
name|subset
init|=
name|input
operator|.
name|set
operator|.
name|subsets
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|subset
operator|.
name|isDelivered
argument_list|()
operator|||
name|subset
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equalsSansConvention
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|traitSet
argument_list|()
argument_list|)
condition|)
block|{
comment|// Ideally we should stop deriving new relnodes when the
comment|// subset's traitSet equals with input traitSet, but
comment|// in case someone manually builds a physical relnode
comment|// tree, which is highly discouraged, without specifying
comment|// correct traitSet, e.g.
comment|//   EnumerableFilter  [].ANY
comment|//       -> EnumerableMergeJoin  [a].Hash[a]
comment|// We should still be able to derive the correct traitSet
comment|// for the dumb filter, even though the filter's traitSet
comment|// should be derived from the MergeJoin when it is created.
comment|// But if the subset's traitSet equals with the default
comment|// empty traitSet sans convention (the default traitSet
comment|// from cluster may have logical convention, NONE, which
comment|// is not interesting), we are safe to ignore it, because
comment|// a physical filter with non default traitSet, but has a
comment|// input with default empty traitSet, e.g.
comment|//   EnumerableFilter  [a].Hash[a]
comment|//       -> EnumerableProject  [].ANY
comment|// is definitely wrong, we should fail fast.
continue|continue;
block|}
if|if
condition|(
name|mode
operator|==
name|DeriveMode
operator|.
name|OMAKASE
condition|)
block|{
name|traits
operator|.
name|add
argument_list|(
name|subset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RelNode
name|newRel
init|=
name|rel
operator|.
name|derive
argument_list|(
name|subset
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|childId
argument_list|)
decl_stmt|;
if|if
condition|(
name|newRel
operator|!=
literal|null
operator|&&
operator|!
name|planner
operator|.
name|isRegistered
argument_list|(
name|newRel
argument_list|)
condition|)
block|{
name|RelNode
name|newInput
init|=
name|newRel
operator|.
name|getInput
argument_list|(
name|childId
argument_list|)
decl_stmt|;
assert|assert
name|newInput
operator|instanceof
name|RelSubset
assert|;
if|if
condition|(
name|newInput
operator|==
name|subset
condition|)
block|{
comment|// If the child subset is used to derive new traits for
comment|// current relnode, the subset will be marked REQUIRED
comment|// when registering the new derived relnode and later
comment|// will add enforcers between other delivered subsets.
comment|// e.g. a MergeJoin request both inputs hash distributed
comment|// by [a,b] sorted by [a,b]. If the left input R1 happens to
comment|// be distributed by [a], the MergeJoin can derive new
comment|// traits from this input and request both input to be
comment|// distributed by [a] sorted by [a,b]. In case there is a
comment|// alternative R2 with ANY distribution in the left input's
comment|// RelSet, we may end up with requesting hash distribution
comment|// [a] on alternative R2, which is unnecessary and waste,
comment|// because we request distribution by [a] because of R1 can
comment|// deliver the exact same distribution and we don't need to
comment|// enforce properties on other subsets that can't satisfy
comment|// the specific trait requirement.
comment|// Here we add a constraint that {@code newInput == subset},
comment|// because if the delivered child subset is HASH[a], but
comment|// we require HASH[a].SORT[a,b], we still need to enable
comment|// property enforcement on the required subset. Otherwise,
comment|// we need to restrict enforcement between HASH[a].SORT[a,b]
comment|// and HASH[a] only, which will make things a little bit
comment|// complicated. We might optimize it in the future.
name|subset
operator|.
name|disableEnforcing
argument_list|()
expr_stmt|;
block|}
name|RelSubset
name|relSubset
init|=
name|planner
operator|.
name|register
argument_list|(
name|newRel
argument_list|,
name|rel
argument_list|)
decl_stmt|;
assert|assert
name|relSubset
operator|.
name|set
operator|==
name|planner
operator|.
name|getSubset
argument_list|(
name|rel
argument_list|)
operator|.
name|set
assert|;
block|}
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|DeriveMode
operator|.
name|LEFT_FIRST
operator|||
name|mode
operator|==
name|DeriveMode
operator|.
name|RIGHT_FIRST
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|DeriveMode
operator|.
name|OMAKASE
condition|)
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|relList
init|=
name|rel
operator|.
name|derive
argument_list|(
name|inputTraits
argument_list|)
decl_stmt|;
for|for
control|(
name|RelNode
name|relNode
range|:
name|relList
control|)
block|{
if|if
condition|(
operator|!
name|planner
operator|.
name|isRegistered
argument_list|(
name|relNode
argument_list|)
condition|)
block|{
name|planner
operator|.
name|register
argument_list|(
name|relNode
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|describe
parameter_list|(
name|TaskDescriptor
name|desc
parameter_list|)
block|{
name|desc
operator|.
name|item
argument_list|(
literal|"mExpr"
argument_list|,
name|mExpr
argument_list|)
operator|.
name|item
argument_list|(
literal|"group"
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RelSubset
name|group
parameter_list|()
block|{
return|return
name|group
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|exploring
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onProduce
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
name|passThroughCache
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
end_class

end_unit

