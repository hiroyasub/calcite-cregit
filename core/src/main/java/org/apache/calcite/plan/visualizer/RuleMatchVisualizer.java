begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|visualizer
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepRelVertex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|RelSubset
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|core
operator|.
name|JsonProcessingException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|core
operator|.
name|util
operator|.
name|DefaultPrettyPrinter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|databind
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UncheckedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|StandardOpenOption
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DecimalFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|MessageFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_comment
comment|/**  * This is a tool to visualize the rule match process of a RelOptPlanner.  *  *<pre>{@code  * // create the visualizer  * RuleMatchVisualizer viz = new RuleMatchVisualizer("/path/to/output/dir", "file-name-suffix");  * viz.attachTo(planner)  *  * planner.findBestExpr();  *  * // extra step for HepPlanner: write the output to files  * // a VolcanoPlanner will call it automatically  * viz.writeToFile();  * }</pre>  */
end_comment

begin_class
specifier|public
class|class
name|RuleMatchVisualizer
implements|implements
name|RelOptListener
block|{
specifier|private
specifier|static
specifier|final
name|String
name|INITIAL
init|=
literal|"INITIAL"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|FINAL
init|=
literal|"FINAL"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_SET
init|=
literal|"default"
decl_stmt|;
comment|// default HTML template can be edited at
comment|// core/src/main/resources/org/apache/calcite/plan/visualizer/viz-template.html
specifier|private
specifier|final
name|String
name|templateDirectory
init|=
literal|"org/apache/calcite/plan/visualizer"
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|String
name|outputDirectory
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|String
name|outputSuffix
decl_stmt|;
specifier|private
name|String
name|latestRuleID
init|=
literal|""
decl_stmt|;
specifier|private
name|int
name|latestRuleTransformCount
init|=
literal|1
decl_stmt|;
specifier|private
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
specifier|private
annotation|@
name|Nullable
name|RelOptPlanner
name|planner
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|includeTransitiveEdges
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|includeIntermediateCosts
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|StepInfo
argument_list|>
name|steps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|NodeUpdateHelper
argument_list|>
name|allNodes
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Use this constructor to save the result on disk at the end of the planning    * phase.    *    *<p>Note: when using HepPlanner, {@link #writeToFile()} needs to be called    * manually.    */
specifier|public
name|RuleMatchVisualizer
parameter_list|(
name|String
name|outputDirectory
parameter_list|,
name|String
name|outputSuffix
parameter_list|)
block|{
name|this
operator|.
name|outputDirectory
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|outputDirectory
argument_list|,
literal|"outputDirectory"
argument_list|)
expr_stmt|;
name|this
operator|.
name|outputSuffix
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|outputSuffix
argument_list|,
literal|"outputSuffix"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Use this constructor when the result shall not be written to disk.    */
specifier|public
name|RuleMatchVisualizer
parameter_list|()
block|{
name|this
operator|.
name|outputDirectory
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|outputSuffix
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Attaches the visualizer to the planner.    * Must be called before applying the rules.    * Must be called exactly once.    */
specifier|public
name|void
name|attachTo
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
assert|assert
name|this
operator|.
name|planner
operator|==
literal|null
assert|;
name|planner
operator|.
name|addListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|planner
operator|=
name|planner
expr_stmt|;
block|}
comment|/**    * Output edges from a subset to the nodes of all subsets that satisfy it.    */
specifier|public
name|void
name|setIncludeTransitiveEdges
parameter_list|(
specifier|final
name|boolean
name|includeTransitiveEdges
parameter_list|)
block|{
name|this
operator|.
name|includeTransitiveEdges
operator|=
name|includeTransitiveEdges
expr_stmt|;
block|}
comment|/**    * Output intermediate costs, including all cost updates.    */
specifier|public
name|void
name|setIncludeIntermediateCosts
parameter_list|(
specifier|final
name|boolean
name|includeIntermediateCosts
parameter_list|)
block|{
name|this
operator|.
name|includeIntermediateCosts
operator|=
name|includeIntermediateCosts
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|ruleAttempted
parameter_list|(
name|RuleAttemptedEvent
name|event
parameter_list|)
block|{
comment|// HepPlanner compatibility
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
assert|assert
name|planner
operator|!=
literal|null
assert|;
name|RelNode
name|root
init|=
name|planner
operator|.
name|getRoot
argument_list|()
decl_stmt|;
assert|assert
name|root
operator|!=
literal|null
assert|;
name|initialized
operator|=
literal|true
expr_stmt|;
name|updateInitialPlan
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Register initial plan.    * (Workaround for HepPlanner)    */
specifier|private
name|void
name|updateInitialPlan
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|HepRelVertex
condition|)
block|{
name|HepRelVertex
name|v
init|=
operator|(
name|HepRelVertex
operator|)
name|node
decl_stmt|;
name|updateInitialPlan
argument_list|(
name|v
operator|.
name|getCurrentRel
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|this
operator|.
name|registerRelNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|getInputs
argument_list|(
name|node
argument_list|)
control|)
block|{
name|updateInitialPlan
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the inputs for a node, unwrapping {@link HepRelVertex} nodes.    * (Workaround for HepPlanner)    */
specifier|private
specifier|static
name|List
argument_list|<
name|RelNode
argument_list|>
name|getInputs
parameter_list|(
specifier|final
name|RelNode
name|node
parameter_list|)
block|{
return|return
name|node
operator|.
name|getInputs
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|n
lambda|->
block|{
if|if
condition|(
name|n
operator|instanceof
name|HepRelVertex
condition|)
block|{
return|return
operator|(
operator|(
name|HepRelVertex
operator|)
name|n
operator|)
operator|.
name|getCurrentRel
argument_list|()
return|;
block|}
return|return
name|n
return|;
block|}
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|relChosen
parameter_list|(
name|RelChosenEvent
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|.
name|getRel
argument_list|()
operator|==
literal|null
condition|)
block|{
assert|assert
name|this
operator|.
name|planner
operator|!=
literal|null
assert|;
name|RelNode
name|root
init|=
name|this
operator|.
name|planner
operator|.
name|getRoot
argument_list|()
decl_stmt|;
assert|assert
name|root
operator|!=
literal|null
assert|;
name|updateFinalPlan
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|this
operator|.
name|addStep
argument_list|(
name|FINAL
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|writeToFile
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Mark nodes that are part of the final plan.    */
specifier|private
name|void
name|updateFinalPlan
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
name|int
name|size
init|=
name|this
operator|.
name|steps
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|FINAL
operator|.
name|equals
argument_list|(
name|this
operator|.
name|steps
operator|.
name|get
argument_list|(
name|size
operator|-
literal|1
argument_list|)
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|this
operator|.
name|registerRelNode
argument_list|(
name|node
argument_list|)
operator|.
name|updateAttribute
argument_list|(
literal|"inFinalPlan"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|RelSubset
condition|)
block|{
name|RelNode
name|best
init|=
operator|(
operator|(
name|RelSubset
operator|)
name|node
operator|)
operator|.
name|getBest
argument_list|()
decl_stmt|;
if|if
condition|(
name|best
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|updateFinalPlan
argument_list|(
name|best
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|RelNode
name|input
range|:
name|getInputs
argument_list|(
name|node
argument_list|)
control|)
block|{
name|updateFinalPlan
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|ruleProductionSucceeded
parameter_list|(
name|RuleProductionEvent
name|event
parameter_list|)
block|{
comment|// method is called once before ruleMatch, and once after ruleMatch
if|if
condition|(
name|event
operator|.
name|isBefore
argument_list|()
condition|)
block|{
comment|// add the initialState
if|if
condition|(
name|latestRuleID
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|addStep
argument_list|(
name|INITIAL
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|latestRuleID
operator|=
name|INITIAL
expr_stmt|;
block|}
return|return;
block|}
comment|// we add the state after the rule is applied
name|RelOptRuleCall
name|ruleCall
init|=
name|event
operator|.
name|getRuleCall
argument_list|()
decl_stmt|;
name|String
name|ruleID
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|ruleCall
operator|.
name|id
argument_list|)
decl_stmt|;
name|String
name|displayRuleName
init|=
name|ruleCall
operator|.
name|id
operator|+
literal|"-"
operator|+
name|ruleCall
operator|.
name|getRule
argument_list|()
decl_stmt|;
comment|// a rule might call transform to multiple times, handle it by modifying the rule name
if|if
condition|(
name|ruleID
operator|.
name|equals
argument_list|(
name|this
operator|.
name|latestRuleID
argument_list|)
condition|)
block|{
name|latestRuleTransformCount
operator|++
expr_stmt|;
name|displayRuleName
operator|+=
literal|"-"
operator|+
name|latestRuleTransformCount
expr_stmt|;
block|}
else|else
block|{
name|latestRuleTransformCount
operator|=
literal|1
expr_stmt|;
block|}
name|this
operator|.
name|latestRuleID
operator|=
name|ruleID
expr_stmt|;
name|this
operator|.
name|addStep
argument_list|(
name|displayRuleName
argument_list|,
name|ruleCall
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|relDiscarded
parameter_list|(
name|RelDiscardedEvent
name|event
parameter_list|)
block|{
block|}
annotation|@
name|Override
specifier|public
name|void
name|relEquivalenceFound
parameter_list|(
name|RelEquivalenceEvent
name|event
parameter_list|)
block|{
name|RelNode
name|rel
init|=
name|event
operator|.
name|getRel
argument_list|()
decl_stmt|;
assert|assert
name|rel
operator|!=
literal|null
assert|;
name|Object
name|eqClass
init|=
name|event
operator|.
name|getEquivalenceClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|eqClass
operator|instanceof
name|String
condition|)
block|{
name|String
name|eqClassStr
init|=
operator|(
name|String
operator|)
name|eqClass
decl_stmt|;
name|eqClassStr
operator|=
name|eqClassStr
operator|.
name|replace
argument_list|(
literal|"equivalence class "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|String
name|setId
init|=
literal|"set-"
operator|+
name|eqClassStr
decl_stmt|;
name|registerSet
argument_list|(
name|setId
argument_list|)
expr_stmt|;
name|registerRelNode
argument_list|(
name|rel
argument_list|)
operator|.
name|updateAttribute
argument_list|(
literal|"set"
argument_list|,
name|setId
argument_list|)
expr_stmt|;
block|}
comment|// register node
name|this
operator|.
name|registerRelNode
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a set.    */
specifier|private
name|void
name|registerSet
parameter_list|(
specifier|final
name|String
name|setID
parameter_list|)
block|{
name|this
operator|.
name|allNodes
operator|.
name|computeIfAbsent
argument_list|(
name|setID
argument_list|,
name|k
lambda|->
block|{
name|NodeUpdateHelper
name|h
init|=
operator|new
name|NodeUpdateHelper
argument_list|(
name|setID
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|h
operator|.
name|updateAttribute
argument_list|(
literal|"label"
argument_list|,
name|DEFAULT_SET
operator|.
name|equals
argument_list|(
name|setID
argument_list|)
condition|?
literal|""
else|:
name|setID
argument_list|)
expr_stmt|;
name|h
operator|.
name|updateAttribute
argument_list|(
literal|"kind"
argument_list|,
literal|"set"
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a RelNode to track its changes.    */
specifier|private
name|NodeUpdateHelper
name|registerRelNode
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|this
operator|.
name|allNodes
operator|.
name|computeIfAbsent
argument_list|(
name|key
argument_list|(
name|rel
argument_list|)
argument_list|,
name|k
lambda|->
block|{
name|NodeUpdateHelper
name|h
init|=
operator|new
name|NodeUpdateHelper
argument_list|(
name|key
argument_list|(
name|rel
argument_list|)
argument_list|,
name|rel
argument_list|)
decl_stmt|;
comment|// attributes that need to be set only once
name|h
operator|.
name|updateAttribute
argument_list|(
literal|"label"
argument_list|,
name|getNodeLabel
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|updateAttribute
argument_list|(
literal|"explanation"
argument_list|,
name|getNodeExplanation
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|updateAttribute
argument_list|(
literal|"set"
argument_list|,
name|DEFAULT_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|instanceof
name|RelSubset
condition|)
block|{
name|h
operator|.
name|updateAttribute
argument_list|(
literal|"kind"
argument_list|,
literal|"subset"
argument_list|)
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
argument_list|)
return|;
block|}
comment|/**    * Check and store the changes of the rel node.    */
specifier|private
name|void
name|updateNodeInfo
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
specifier|final
name|boolean
name|isLastStep
parameter_list|)
block|{
name|NodeUpdateHelper
name|helper
init|=
name|registerRelNode
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|includeIntermediateCosts
operator|||
name|isLastStep
condition|)
block|{
name|RelOptPlanner
name|planner
init|=
name|this
operator|.
name|planner
decl_stmt|;
assert|assert
name|planner
operator|!=
literal|null
assert|;
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RelOptCost
name|cost
init|=
name|planner
operator|.
name|getCost
argument_list|(
name|rel
argument_list|,
name|mq
argument_list|)
decl_stmt|;
name|Double
name|rowCount
init|=
name|mq
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|helper
operator|.
name|updateAttribute
argument_list|(
literal|"cost"
argument_list|,
name|formatCost
argument_list|(
name|rowCount
argument_list|,
name|cost
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|inputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|rel
operator|instanceof
name|RelSubset
condition|)
block|{
name|RelSubset
name|relSubset
init|=
operator|(
name|RelSubset
operator|)
name|rel
decl_stmt|;
name|relSubset
operator|.
name|getRels
argument_list|()
operator|.
name|forEach
argument_list|(
name|input
lambda|->
name|inputs
operator|.
name|add
argument_list|(
name|key
argument_list|(
name|input
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|transitive
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|relSubset
operator|.
name|getSubsetsSatisfyingThis
argument_list|()
operator|.
name|filter
argument_list|(
name|other
lambda|->
operator|!
name|other
operator|.
name|equals
argument_list|(
name|relSubset
argument_list|)
argument_list|)
operator|.
name|forEach
argument_list|(
name|input
lambda|->
block|{
name|inputs
operator|.
name|add
argument_list|(
name|key
argument_list|(
name|input
argument_list|)
argument_list|)
argument_list|;
if|if
condition|(
operator|!
name|includeTransitiveEdges
condition|)
block|{
name|input
operator|.
name|getRels
argument_list|()
operator|.
name|forEach
argument_list|(
name|r
lambda|->
name|transitive
operator|.
name|add
argument_list|(
name|key
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block_content|)
function|;
name|inputs
operator|.
name|removeAll
parameter_list|(
name|transitive
parameter_list|)
constructor_decl|;
block|}
end_class

begin_if_stmt
else|else
block|{
name|getInputs
argument_list|(
name|rel
argument_list|)
operator|.
name|forEach
argument_list|(
name|input
lambda|->
name|inputs
operator|.
name|add
argument_list|(
name|key
argument_list|(
name|input
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_if_stmt

begin_expr_stmt
name|helper
operator|.
name|updateAttribute
argument_list|(
literal|"inputs"
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    * Add the updates since the last step to {@link #steps}.    */
end_comment

begin_function
unit|private
name|void
name|addStep
parameter_list|(
name|String
name|stepID
parameter_list|,
annotation|@
name|Nullable
name|RelOptRuleCall
name|ruleCall
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|nextNodeUpdates
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// HepPlanner compatibility
name|boolean
name|usesDefaultSet
init|=
name|this
operator|.
name|allNodes
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|h
lambda|->
name|DEFAULT_SET
operator|.
name|equals
argument_list|(
name|h
operator|.
name|getValue
argument_list|(
literal|"set"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|usesDefaultSet
condition|)
block|{
name|this
operator|.
name|registerSet
argument_list|(
name|DEFAULT_SET
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|NodeUpdateHelper
name|h
range|:
name|allNodes
operator|.
name|values
argument_list|()
control|)
block|{
name|RelNode
name|rel
init|=
name|h
operator|.
name|getRel
argument_list|()
decl_stmt|;
if|if
condition|(
name|rel
operator|!=
literal|null
condition|)
block|{
name|updateNodeInfo
argument_list|(
name|rel
argument_list|,
name|FINAL
operator|.
name|equals
argument_list|(
name|stepID
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|.
name|isEmptyUpdate
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|Object
name|update
init|=
name|h
operator|.
name|getAndResetUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
name|update
operator|!=
literal|null
condition|)
block|{
name|nextNodeUpdates
operator|.
name|put
argument_list|(
name|h
operator|.
name|getKey
argument_list|()
argument_list|,
name|update
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|String
argument_list|>
name|matchedRels
init|=
name|Arrays
operator|.
name|stream
argument_list|(
name|ruleCall
operator|==
literal|null
condition|?
operator|new
name|RelNode
index|[
literal|0
index|]
else|:
name|ruleCall
operator|.
name|rels
argument_list|)
operator|.
name|map
argument_list|(
name|RuleMatchVisualizer
operator|::
name|key
argument_list|)
operator|.
name|collect
argument_list|(
name|Util
operator|.
name|toImmutableList
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|steps
operator|.
name|add
argument_list|(
operator|new
name|StepInfo
argument_list|(
name|stepID
argument_list|,
name|nextNodeUpdates
argument_list|,
name|matchedRels
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|public
name|String
name|getJsonStringResult
parameter_list|()
block|{
try|try
block|{
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|data
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|data
operator|.
name|put
argument_list|(
literal|"steps"
argument_list|,
name|steps
argument_list|)
expr_stmt|;
name|ObjectMapper
name|objectMapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
name|DefaultPrettyPrinter
name|printer
init|=
operator|new
name|DefaultPrettyPrinter
argument_list|()
decl_stmt|;
name|printer
operator|=
name|printer
operator|.
name|withoutSpacesInObjectEntries
argument_list|()
expr_stmt|;
return|return
name|objectMapper
operator|.
name|writer
argument_list|(
name|printer
argument_list|)
operator|.
name|writeValueAsString
argument_list|(
name|data
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JsonProcessingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    * Writes the HTML and JS files of the rule match visualization.    *<p>    * The old files with the same name will be replaced.    */
end_comment

begin_function
specifier|public
name|void
name|writeToFile
parameter_list|()
block|{
if|if
condition|(
name|outputDirectory
operator|==
literal|null
operator|||
name|outputSuffix
operator|==
literal|null
condition|)
block|{
return|return;
block|}
try|try
block|{
name|String
name|templatePath
init|=
name|Paths
operator|.
name|get
argument_list|(
name|templateDirectory
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"viz-template.html"
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|ClassLoader
name|cl
init|=
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
decl_stmt|;
assert|assert
name|cl
operator|!=
literal|null
assert|;
name|InputStream
name|resourceAsStream
init|=
name|cl
operator|.
name|getResourceAsStream
argument_list|(
name|templatePath
argument_list|)
decl_stmt|;
assert|assert
name|resourceAsStream
operator|!=
literal|null
assert|;
name|String
name|htmlTemplate
init|=
name|IOUtils
operator|.
name|toString
argument_list|(
name|resourceAsStream
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
name|String
name|htmlFileName
init|=
literal|"planner-viz"
operator|+
name|outputSuffix
operator|+
literal|".html"
decl_stmt|;
name|String
name|dataFileName
init|=
literal|"planner-viz-data"
operator|+
name|outputSuffix
operator|+
literal|".js"
decl_stmt|;
name|String
name|replaceString
init|=
literal|"src=\"planner-viz-data.js\""
decl_stmt|;
name|int
name|replaceIndex
init|=
name|htmlTemplate
operator|.
name|indexOf
argument_list|(
name|replaceString
argument_list|)
decl_stmt|;
name|String
name|htmlContent
init|=
name|htmlTemplate
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|replaceIndex
argument_list|)
operator|+
literal|"src=\""
operator|+
name|dataFileName
operator|+
literal|"\""
operator|+
name|htmlTemplate
operator|.
name|substring
argument_list|(
name|replaceIndex
operator|+
name|replaceString
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|dataJsContent
init|=
literal|"var data = "
operator|+
name|getJsonStringResult
argument_list|()
operator|+
literal|";\n"
decl_stmt|;
name|Path
name|outputDirPath
init|=
name|Paths
operator|.
name|get
argument_list|(
name|outputDirectory
argument_list|)
decl_stmt|;
name|Path
name|htmlOutput
init|=
name|outputDirPath
operator|.
name|resolve
argument_list|(
name|htmlFileName
argument_list|)
decl_stmt|;
name|Path
name|dataOutput
init|=
name|outputDirPath
operator|.
name|resolve
argument_list|(
name|dataFileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Files
operator|.
name|exists
argument_list|(
name|outputDirPath
argument_list|)
condition|)
block|{
name|Files
operator|.
name|createDirectories
argument_list|(
name|outputDirPath
argument_list|)
expr_stmt|;
block|}
name|Files
operator|.
name|write
argument_list|(
name|htmlOutput
argument_list|,
name|htmlContent
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|,
name|StandardOpenOption
operator|.
name|CREATE
argument_list|,
name|StandardOpenOption
operator|.
name|TRUNCATE_EXISTING
argument_list|)
expr_stmt|;
name|Files
operator|.
name|write
argument_list|(
name|dataOutput
argument_list|,
name|dataJsContent
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|,
name|StandardOpenOption
operator|.
name|CREATE
argument_list|,
name|StandardOpenOption
operator|.
name|TRUNCATE_EXISTING
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UncheckedIOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|//--------------------------------------------------------------------------------
end_comment

begin_comment
comment|// methods related to string representation
end_comment

begin_comment
comment|//--------------------------------------------------------------------------------
end_comment

begin_function
specifier|private
specifier|static
name|String
name|key
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|)
block|{
return|return
literal|""
operator|+
name|rel
operator|.
name|getId
argument_list|()
return|;
block|}
end_function

begin_function
specifier|private
name|String
name|getNodeLabel
parameter_list|(
specifier|final
name|RelNode
name|relNode
parameter_list|)
block|{
if|if
condition|(
name|relNode
operator|instanceof
name|RelSubset
condition|)
block|{
specifier|final
name|RelSubset
name|relSubset
init|=
operator|(
name|RelSubset
operator|)
name|relNode
decl_stmt|;
name|String
name|setId
init|=
name|getSetId
argument_list|(
name|relSubset
argument_list|)
decl_stmt|;
return|return
literal|"subset#"
operator|+
name|relSubset
operator|.
name|getId
argument_list|()
operator|+
literal|"-set"
operator|+
name|setId
operator|+
literal|"-\n"
operator|+
name|relSubset
operator|.
name|getTraitSet
argument_list|()
return|;
block|}
return|return
literal|"#"
operator|+
name|relNode
operator|.
name|getId
argument_list|()
operator|+
literal|"-"
operator|+
name|relNode
operator|.
name|getRelTypeName
argument_list|()
return|;
block|}
end_function

begin_function
specifier|private
name|String
name|getSetId
parameter_list|(
specifier|final
name|RelSubset
name|relSubset
parameter_list|)
block|{
name|String
name|explanation
init|=
name|getNodeExplanation
argument_list|(
name|relSubset
argument_list|)
decl_stmt|;
name|int
name|start
init|=
name|explanation
operator|.
name|indexOf
argument_list|(
literal|"RelSubset"
argument_list|)
operator|+
literal|"RelSubset"
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
name|int
name|end
init|=
name|explanation
operator|.
name|indexOf
argument_list|(
literal|"."
argument_list|,
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
return|return
name|explanation
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
name|String
name|getNodeExplanation
parameter_list|(
specifier|final
name|RelNode
name|relNode
parameter_list|)
block|{
name|InputExcludedRelWriter
name|relWriter
init|=
operator|new
name|InputExcludedRelWriter
argument_list|()
decl_stmt|;
name|relNode
operator|.
name|explain
argument_list|(
name|relWriter
argument_list|)
expr_stmt|;
return|return
name|relWriter
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|String
name|formatCost
parameter_list|(
name|Double
name|rowCount
parameter_list|,
annotation|@
name|Nullable
name|RelOptCost
name|cost
parameter_list|)
block|{
if|if
condition|(
name|cost
operator|==
literal|null
condition|)
block|{
return|return
literal|"null"
return|;
block|}
name|String
name|originalStr
init|=
name|cost
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|originalStr
operator|.
name|contains
argument_list|(
literal|"inf"
argument_list|)
operator|||
name|originalStr
operator|.
name|contains
argument_list|(
literal|"huge"
argument_list|)
operator|||
name|originalStr
operator|.
name|contains
argument_list|(
literal|"tiny"
argument_list|)
condition|)
block|{
return|return
name|originalStr
return|;
block|}
return|return
operator|new
name|MessageFormat
argument_list|(
literal|"\nrowCount: {0}\nrows: {1}\ncpu:  {2}\nio:   {3}"
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
operator|.
name|format
argument_list|(
operator|new
name|String
index|[]
block|{
name|formatCostScientific
argument_list|(
name|rowCount
argument_list|)
block|,
name|formatCostScientific
argument_list|(
name|cost
operator|.
name|getRows
argument_list|()
argument_list|)
block|,
name|formatCostScientific
argument_list|(
name|cost
operator|.
name|getCpu
argument_list|()
argument_list|)
block|,
name|formatCostScientific
argument_list|(
name|cost
operator|.
name|getIo
argument_list|()
argument_list|)
block|}
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|String
name|formatCostScientific
parameter_list|(
name|double
name|costNumber
parameter_list|)
block|{
name|long
name|costRounded
init|=
name|Math
operator|.
name|round
argument_list|(
name|costNumber
argument_list|)
decl_stmt|;
name|DecimalFormat
name|formatter
init|=
operator|(
name|DecimalFormat
operator|)
name|DecimalFormat
operator|.
name|getInstance
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|formatter
operator|.
name|applyPattern
argument_list|(
literal|"#.#############################################E0"
argument_list|)
expr_stmt|;
return|return
name|formatter
operator|.
name|format
argument_list|(
name|costRounded
argument_list|)
return|;
block|}
end_function

unit|}
end_unit

