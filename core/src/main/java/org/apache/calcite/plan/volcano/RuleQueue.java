begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleOperand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ChunkList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|trace
operator|.
name|CalciteTrace
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|HashMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Priority queue of relexps whose rules have not been called, and rule-matches  * which have not yet been acted upon.  */
end_comment

begin_class
class|class
name|RuleQueue
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|CalciteTrace
operator|.
name|getPlannerTracer
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|ALL_RULES
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|"<ALL RULES>"
argument_list|)
decl_stmt|;
comment|/**    * Largest value which is less than one.    */
specifier|private
specifier|static
specifier|final
name|double
name|ONE_MINUS_EPSILON
init|=
name|computeOneMinusEpsilon
argument_list|()
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|/**    * The importance of each subset.    */
specifier|final
name|Map
argument_list|<
name|RelSubset
argument_list|,
name|Double
argument_list|>
name|subsetImportances
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * The set of RelSubsets whose importance is currently in an artificially    * raised state. Typically this only includes RelSubsets which have only    * logical RelNodes.    */
specifier|final
name|Set
argument_list|<
name|RelSubset
argument_list|>
name|boostedSubsets
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Map of {@link VolcanoPlannerPhase} to a list of rule-matches. Initially,    * there is an empty {@link PhaseMatchList} for each planner phase. As the    * planner invokes {@link #addMatch(VolcanoRuleMatch)} the rule-match is    * added to the appropriate PhaseMatchList(s). As the planner completes    * phases, the matching entry is removed from this list to avoid unused    * work.    */
specifier|final
name|Map
argument_list|<
name|VolcanoPlannerPhase
argument_list|,
name|PhaseMatchList
argument_list|>
name|matchListMap
init|=
operator|new
name|EnumMap
argument_list|<>
argument_list|(
name|VolcanoPlannerPhase
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Sorts rule-matches into decreasing order of importance.    */
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|VolcanoRuleMatch
argument_list|>
name|MATCH_COMPARATOR
init|=
operator|new
name|RuleMatchImportanceComparator
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|VolcanoPlanner
name|planner
decl_stmt|;
comment|/**    * Compares relexps according to their cached 'importance'.    */
specifier|private
specifier|final
name|Ordering
argument_list|<
name|RelSubset
argument_list|>
name|relImportanceOrdering
init|=
name|Ordering
operator|.
name|from
argument_list|(
operator|new
name|RelImportanceComparator
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Maps a {@link VolcanoPlannerPhase} to a set of rule descriptions. Named rules    * may be invoked in their corresponding phase.    *    *<p>See {@link VolcanoPlannerPhaseRuleMappingInitializer} for more    * information regarding the contents of this Map and how it is initialized.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|VolcanoPlannerPhase
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|phaseRuleMapping
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
name|RuleQueue
parameter_list|(
name|VolcanoPlanner
name|planner
parameter_list|)
block|{
name|this
operator|.
name|planner
operator|=
name|planner
expr_stmt|;
name|phaseRuleMapping
operator|=
operator|new
name|EnumMap
argument_list|<>
argument_list|(
name|VolcanoPlannerPhase
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// init empty sets for all phases
for|for
control|(
name|VolcanoPlannerPhase
name|phase
range|:
name|VolcanoPlannerPhase
operator|.
name|values
argument_list|()
control|)
block|{
name|phaseRuleMapping
operator|.
name|put
argument_list|(
name|phase
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// configure phases
name|planner
operator|.
name|getPhaseRuleMappingInitializer
argument_list|()
operator|.
name|initialize
argument_list|(
name|phaseRuleMapping
argument_list|)
expr_stmt|;
for|for
control|(
name|VolcanoPlannerPhase
name|phase
range|:
name|VolcanoPlannerPhase
operator|.
name|values
argument_list|()
control|)
block|{
comment|// empty phases get converted to "all rules"
if|if
condition|(
name|phaseRuleMapping
operator|.
name|get
argument_list|(
name|phase
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|phaseRuleMapping
operator|.
name|put
argument_list|(
name|phase
argument_list|,
name|ALL_RULES
argument_list|)
expr_stmt|;
block|}
comment|// create a match list data structure for each phase
name|PhaseMatchList
name|matchList
init|=
operator|new
name|PhaseMatchList
argument_list|(
name|phase
argument_list|)
decl_stmt|;
name|matchListMap
operator|.
name|put
argument_list|(
name|phase
argument_list|,
name|matchList
argument_list|)
expr_stmt|;
block|}
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Clear internal data structure for this rule queue.    */
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|this
operator|.
name|subsetImportances
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|boostedSubsets
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|PhaseMatchList
name|matchList
range|:
name|matchListMap
operator|.
name|values
argument_list|()
control|)
block|{
name|matchList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Removes the {@link PhaseMatchList rule-match list} for the given planner    * phase.    */
specifier|public
name|void
name|phaseCompleted
parameter_list|(
name|VolcanoPlannerPhase
name|phase
parameter_list|)
block|{
name|matchListMap
operator|.
name|get
argument_list|(
name|phase
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Computes the importance of a set (which is that of its most important    * subset).    */
specifier|public
name|double
name|getImportance
parameter_list|(
name|RelSet
name|set
parameter_list|)
block|{
name|double
name|importance
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelSubset
name|subset
range|:
name|set
operator|.
name|subsets
control|)
block|{
name|importance
operator|=
name|Math
operator|.
name|max
argument_list|(
name|importance
argument_list|,
name|getImportance
argument_list|(
name|subset
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|importance
return|;
block|}
comment|/**    * Recomputes the importance of the given RelSubset.    *    * @param subset RelSubset whose importance is to be recomputed    * @param force  if true, forces an importance update even if the subset has    *               not been registered    */
specifier|public
name|void
name|recompute
parameter_list|(
name|RelSubset
name|subset
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
name|Double
name|previousImportance
init|=
name|subsetImportances
operator|.
name|get
argument_list|(
name|subset
argument_list|)
decl_stmt|;
if|if
condition|(
name|previousImportance
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|force
condition|)
block|{
comment|// Subset has not been registered yet. Don't worry about it.
return|return;
block|}
name|previousImportance
operator|=
name|Double
operator|.
name|NEGATIVE_INFINITY
expr_stmt|;
block|}
name|double
name|importance
init|=
name|computeImportance
argument_list|(
name|subset
argument_list|)
decl_stmt|;
if|if
condition|(
name|previousImportance
operator|==
name|importance
condition|)
block|{
return|return;
block|}
name|updateImportance
argument_list|(
name|subset
argument_list|,
name|importance
argument_list|)
expr_stmt|;
block|}
comment|/**    * Equivalent to    * {@link #recompute(RelSubset, boolean) recompute(subset, false)}.    */
specifier|public
name|void
name|recompute
parameter_list|(
name|RelSubset
name|subset
parameter_list|)
block|{
name|recompute
argument_list|(
name|subset
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Artificially boosts the importance of the given {@link RelSubset}s by a    * given factor.    *    *<p>Iterates over the currently boosted RelSubsets and removes their    * importance boost, forcing a recalculation of the RelSubsets' importances    * (see {@link #recompute(RelSubset)}).    *    *<p>Once RelSubsets have been restored to their normal importance, the    * given RelSubsets have their importances boosted. A RelSubset's boosted    * importance is always less than 1.0 (and never equal to 1.0).    *    * @param subsets RelSubsets to boost importance (priority)    * @param factor  the amount to boost their importances (e.g., 1.25 increases    *                importance by 25%)    */
specifier|public
name|void
name|boostImportance
parameter_list|(
name|Collection
argument_list|<
name|RelSubset
argument_list|>
name|subsets
parameter_list|,
name|double
name|factor
parameter_list|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"boostImportance({}, {})"
argument_list|,
name|factor
argument_list|,
name|subsets
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|RelSubset
argument_list|>
name|boostRemovals
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|RelSubset
argument_list|>
name|iter
init|=
name|boostedSubsets
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RelSubset
name|subset
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|subsets
operator|.
name|contains
argument_list|(
name|subset
argument_list|)
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|boostRemovals
operator|.
name|add
argument_list|(
name|subset
argument_list|)
expr_stmt|;
block|}
block|}
name|boostRemovals
operator|.
name|sort
argument_list|(
operator|new
name|Comparator
argument_list|<
name|RelSubset
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|RelSubset
name|o1
parameter_list|,
name|RelSubset
name|o2
parameter_list|)
block|{
name|int
name|o1children
init|=
name|countChildren
argument_list|(
name|o1
argument_list|)
decl_stmt|;
name|int
name|o2children
init|=
name|countChildren
argument_list|(
name|o2
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|Integer
operator|.
name|compare
argument_list|(
name|o1children
argument_list|,
name|o2children
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|// for determinism
name|c
operator|=
name|Integer
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|getId
argument_list|()
argument_list|,
name|o2
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
specifier|private
name|int
name|countChildren
parameter_list|(
name|RelSubset
name|subset
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|subset
operator|.
name|getRels
argument_list|()
control|)
block|{
name|count
operator|+=
name|rel
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|RelSubset
name|subset
range|:
name|boostRemovals
control|)
block|{
name|subset
operator|.
name|propagateBoostRemoval
argument_list|(
name|planner
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RelSubset
name|subset
range|:
name|subsets
control|)
block|{
name|double
name|importance
init|=
name|subsetImportances
operator|.
name|get
argument_list|(
name|subset
argument_list|)
decl_stmt|;
name|updateImportance
argument_list|(
name|subset
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|ONE_MINUS_EPSILON
argument_list|,
name|importance
operator|*
name|factor
argument_list|)
argument_list|)
expr_stmt|;
name|subset
operator|.
name|boosted
operator|=
literal|true
expr_stmt|;
name|boostedSubsets
operator|.
name|add
argument_list|(
name|subset
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|updateImportance
parameter_list|(
name|RelSubset
name|subset
parameter_list|,
name|Double
name|importance
parameter_list|)
block|{
name|subsetImportances
operator|.
name|put
argument_list|(
name|subset
argument_list|,
name|importance
argument_list|)
expr_stmt|;
for|for
control|(
name|PhaseMatchList
name|matchList
range|:
name|matchListMap
operator|.
name|values
argument_list|()
control|)
block|{
name|Multimap
argument_list|<
name|RelSubset
argument_list|,
name|VolcanoRuleMatch
argument_list|>
name|relMatchMap
init|=
name|matchList
operator|.
name|matchMap
decl_stmt|;
if|if
condition|(
name|relMatchMap
operator|.
name|containsKey
argument_list|(
name|subset
argument_list|)
condition|)
block|{
for|for
control|(
name|VolcanoRuleMatch
name|match
range|:
name|relMatchMap
operator|.
name|get
argument_list|(
name|subset
argument_list|)
control|)
block|{
name|match
operator|.
name|clearCachedImportance
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Returns the importance of an equivalence class of relational expressions.    * Subset importances are held in a lookup table, and importance changes    * gradually propagate through that table.    *    *<p>If a subset in the same set but with a different calling convention is    * deemed to be important, then this subset has at least half of its    * importance. (This rule is designed to encourage conversions to take    * place.)</p>    */
name|double
name|getImportance
parameter_list|(
name|RelSubset
name|rel
parameter_list|)
block|{
assert|assert
name|rel
operator|!=
literal|null
assert|;
name|double
name|importance
init|=
literal|0
decl_stmt|;
specifier|final
name|RelSet
name|set
init|=
name|planner
operator|.
name|getSet
argument_list|(
name|rel
argument_list|)
decl_stmt|;
assert|assert
name|set
operator|!=
literal|null
assert|;
for|for
control|(
name|RelSubset
name|subset2
range|:
name|set
operator|.
name|subsets
control|)
block|{
specifier|final
name|Double
name|d
init|=
name|subsetImportances
operator|.
name|get
argument_list|(
name|subset2
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|double
name|subsetImportance
init|=
name|d
decl_stmt|;
if|if
condition|(
name|subset2
operator|!=
name|rel
condition|)
block|{
name|subsetImportance
operator|/=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|subsetImportance
operator|>
name|importance
condition|)
block|{
name|importance
operator|=
name|subsetImportance
expr_stmt|;
block|}
block|}
return|return
name|importance
return|;
block|}
comment|/**    * Adds a rule match. The rule-matches are automatically added to all    * existing {@link PhaseMatchList per-phase rule-match lists} which allow    * the rule referenced by the match.    */
name|void
name|addMatch
parameter_list|(
name|VolcanoRuleMatch
name|match
parameter_list|)
block|{
specifier|final
name|String
name|matchName
init|=
name|match
operator|.
name|toString
argument_list|()
decl_stmt|;
for|for
control|(
name|PhaseMatchList
name|matchList
range|:
name|matchListMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|matchList
operator|.
name|names
operator|.
name|add
argument_list|(
name|matchName
argument_list|)
condition|)
block|{
comment|// Identical match has already been added.
continue|continue;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|phaseRuleSet
init|=
name|phaseRuleMapping
operator|.
name|get
argument_list|(
name|matchList
operator|.
name|phase
argument_list|)
decl_stmt|;
if|if
condition|(
name|phaseRuleSet
operator|!=
name|ALL_RULES
condition|)
block|{
name|String
name|ruleDescription
init|=
name|match
operator|.
name|getRule
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|phaseRuleSet
operator|.
name|contains
argument_list|(
name|ruleDescription
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"{} Rule-match queued: {}"
argument_list|,
name|matchList
operator|.
name|phase
operator|.
name|toString
argument_list|()
argument_list|,
name|matchName
argument_list|)
expr_stmt|;
name|matchList
operator|.
name|list
operator|.
name|add
argument_list|(
name|match
argument_list|)
expr_stmt|;
name|matchList
operator|.
name|matchMap
operator|.
name|put
argument_list|(
name|planner
operator|.
name|getSubset
argument_list|(
name|match
operator|.
name|rels
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|match
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Computes the<dfn>importance</dfn> of a node. Importance is defined as    * follows:    *    *<ul>    *<li>the root {@link RelSubset} has an importance of 1</li>    *<li>the importance of any other subset is the sum of its importance to    * its parents</li>    *<li>The importance of children is pro-rated according to the cost of the    * children. Consider a node which has a cost of 3, and children with costs    * of 2 and 5. The total cost is 10. If the node has an importance of .5,    * then the children will have importance of .1 and .25. The retains .15    * importance points, to reflect the fact that work needs to be done on the    * node's algorithm.</li>    *</ul>    *    *<p>The formula for the importance<i>I</i> of node n is:    *    *<blockquote>I<sub>n</sub> = Sum<sub>parents p of n</sub>{I<sub>p</sub> .    * W<sub>n, p</sub>}</blockquote>    *    *<p>where W<sub>n, p</sub>, the weight of n within its parent p, is    *    *<blockquote>W<sub>n, p</sub> = Cost<sub>n</sub> / (SelfCost<sub>p</sub> +    * Cost<sub>n0</sub> + ... + Cost<sub>nk</sub>)    *</blockquote>    */
name|double
name|computeImportance
parameter_list|(
name|RelSubset
name|subset
parameter_list|)
block|{
name|double
name|importance
decl_stmt|;
if|if
condition|(
name|subset
operator|==
name|planner
operator|.
name|root
condition|)
block|{
comment|// The root always has importance = 1
name|importance
operator|=
literal|1.0
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|subset
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
comment|// The importance of a subset is the max of its importance to its
comment|// parents
name|importance
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|RelSubset
name|parent
range|:
name|subset
operator|.
name|getParentSubsets
argument_list|(
name|planner
argument_list|)
control|)
block|{
specifier|final
name|double
name|childImportance
init|=
name|computeImportanceOfChild
argument_list|(
name|mq
argument_list|,
name|subset
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|importance
operator|=
name|Math
operator|.
name|max
argument_list|(
name|importance
argument_list|,
name|childImportance
argument_list|)
expr_stmt|;
block|}
block|}
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Importance of [{}] is {}"
argument_list|,
name|subset
argument_list|,
name|importance
argument_list|)
expr_stmt|;
return|return
name|importance
return|;
block|}
specifier|private
name|void
name|dump
parameter_list|()
block|{
if|if
condition|(
name|LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|dump
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
name|LOGGER
operator|.
name|trace
argument_list|(
name|sw
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|dump
parameter_list|(
name|PrintWriter
name|pw
parameter_list|)
block|{
name|planner
operator|.
name|dump
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"Importances: {"
argument_list|)
expr_stmt|;
for|for
control|(
name|RelSubset
name|subset
range|:
name|relImportanceOrdering
operator|.
name|sortedCopy
argument_list|(
name|subsetImportances
operator|.
name|keySet
argument_list|()
argument_list|)
control|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|" "
operator|+
name|subset
operator|.
name|toString
argument_list|()
operator|+
literal|"="
operator|+
name|subsetImportances
operator|.
name|get
argument_list|(
name|subset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|println
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Removes the rule match with the highest importance, and returns it.    *    *<p>Returns {@code null} if there are no more matches.</p>    *    *<p>Note that the VolcanoPlanner may still decide to reject rule matches    * which have become invalid, say if one of their operands belongs to an    * obsolete set or has importance=0.    *    * @throws java.lang.AssertionError if this method is called with a phase    *                              previously marked as completed via    *                              {@link #phaseCompleted(VolcanoPlannerPhase)}.    */
name|VolcanoRuleMatch
name|popMatch
parameter_list|(
name|VolcanoPlannerPhase
name|phase
parameter_list|)
block|{
name|dump
argument_list|()
expr_stmt|;
name|PhaseMatchList
name|phaseMatchList
init|=
name|matchListMap
operator|.
name|get
argument_list|(
name|phase
argument_list|)
decl_stmt|;
if|if
condition|(
name|phaseMatchList
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Used match list for phase "
operator|+
name|phase
operator|+
literal|" after phase complete"
argument_list|)
throw|;
block|}
specifier|final
name|List
argument_list|<
name|VolcanoRuleMatch
argument_list|>
name|matchList
init|=
name|phaseMatchList
operator|.
name|list
decl_stmt|;
name|VolcanoRuleMatch
name|match
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|matchList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|matchList
operator|.
name|sort
argument_list|(
name|MATCH_COMPARATOR
argument_list|)
expr_stmt|;
name|match
operator|=
name|matchList
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"Sorted rule queue:"
argument_list|)
expr_stmt|;
for|for
control|(
name|VolcanoRuleMatch
name|match2
range|:
name|matchList
control|)
block|{
specifier|final
name|double
name|importance
init|=
name|match2
operator|.
name|computeImportance
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|match2
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" importance "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|importance
argument_list|)
expr_stmt|;
block|}
name|LOGGER
operator|.
name|trace
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If we're not tracing, it's not worth the effort of sorting the
comment|// list to find the minimum.
name|match
operator|=
literal|null
expr_stmt|;
name|int
name|bestPos
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|VolcanoRuleMatch
name|match2
range|:
name|matchList
control|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|match
operator|==
literal|null
operator|||
name|MATCH_COMPARATOR
operator|.
name|compare
argument_list|(
name|match2
argument_list|,
name|match
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bestPos
operator|=
name|i
expr_stmt|;
name|match
operator|=
name|match2
expr_stmt|;
block|}
block|}
name|match
operator|=
name|matchList
operator|.
name|remove
argument_list|(
name|bestPos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skipMatch
argument_list|(
name|match
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Skip match: {}"
argument_list|,
name|match
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|// A rule match's digest is composed of the operand RelNodes' digests,
comment|// which may have changed if sets have merged since the rule match was
comment|// enqueued.
name|match
operator|.
name|recomputeDigest
argument_list|()
expr_stmt|;
name|phaseMatchList
operator|.
name|matchMap
operator|.
name|remove
argument_list|(
name|planner
operator|.
name|getSubset
argument_list|(
name|match
operator|.
name|rels
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|match
argument_list|)
expr_stmt|;
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Pop match: {}"
argument_list|,
name|match
argument_list|)
expr_stmt|;
return|return
name|match
return|;
block|}
comment|/** Returns whether to skip a match. This happens if any of the    * {@link RelNode}s have importance zero. */
specifier|private
name|boolean
name|skipMatch
parameter_list|(
name|VolcanoRuleMatch
name|match
parameter_list|)
block|{
for|for
control|(
name|RelNode
name|rel
range|:
name|match
operator|.
name|rels
control|)
block|{
name|Double
name|importance
init|=
name|planner
operator|.
name|relImportances
operator|.
name|get
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|importance
operator|!=
literal|null
operator|&&
name|importance
operator|==
literal|0d
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// If the same subset appears more than once along any path from root
comment|// operand to a leaf operand, we have matched a cycle. A relational
comment|// expression that consumes its own output can never be implemented, and
comment|// furthermore, if we fire rules on it we may generate lots of garbage.
comment|// For example, if
comment|//   Project(A, X = X + 0)
comment|// is in the same subset as A, then we would generate
comment|//   Project(A, X = X + 0 + 0)
comment|//   Project(A, X = X + 0 + 0 + 0)
comment|// also in the same subset. They are valid but useless.
specifier|final
name|Deque
argument_list|<
name|RelSubset
argument_list|>
name|subsets
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
name|checkDuplicateSubsets
argument_list|(
name|subsets
argument_list|,
name|match
operator|.
name|rule
operator|.
name|getOperand
argument_list|()
argument_list|,
name|match
operator|.
name|rels
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Recursively checks whether there are any duplicate subsets along any path    * from root of the operand tree to one of the leaves.    *    *<p>It is OK for a match to have duplicate subsets if they are not on the    * same path. For example,    *    *<blockquote><pre>    *   Join    *  /   \    * X     X    *</pre></blockquote>    *    *<p>is a valid match.    *    * @throws org.apache.calcite.util.Util.FoundOne on match    */
specifier|private
name|void
name|checkDuplicateSubsets
parameter_list|(
name|Deque
argument_list|<
name|RelSubset
argument_list|>
name|subsets
parameter_list|,
name|RelOptRuleOperand
name|operand
parameter_list|,
name|RelNode
index|[]
name|rels
parameter_list|)
block|{
specifier|final
name|RelSubset
name|subset
init|=
name|planner
operator|.
name|getSubset
argument_list|(
name|rels
index|[
name|operand
operator|.
name|ordinalInRule
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|subsets
operator|.
name|contains
argument_list|(
name|subset
argument_list|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
if|if
condition|(
operator|!
name|operand
operator|.
name|getChildOperands
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|subsets
operator|.
name|push
argument_list|(
name|subset
argument_list|)
expr_stmt|;
for|for
control|(
name|RelOptRuleOperand
name|childOperand
range|:
name|operand
operator|.
name|getChildOperands
argument_list|()
control|)
block|{
name|checkDuplicateSubsets
argument_list|(
name|subsets
argument_list|,
name|childOperand
argument_list|,
name|rels
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelSubset
name|x
init|=
name|subsets
operator|.
name|pop
argument_list|()
decl_stmt|;
assert|assert
name|x
operator|==
name|subset
assert|;
block|}
block|}
comment|/**    * Returns the importance of a child to a parent. This is defined by the    * importance of the parent, pro-rated by the cost of the child. For    * example, if the parent has importance = 0.8 and cost 100, then a child    * with cost 50 will have importance 0.4, and a child with cost 25 will have    * importance 0.2.    */
specifier|private
name|double
name|computeImportanceOfChild
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelSubset
name|child
parameter_list|,
name|RelSubset
name|parent
parameter_list|)
block|{
specifier|final
name|double
name|parentImportance
init|=
name|getImportance
argument_list|(
name|parent
argument_list|)
decl_stmt|;
specifier|final
name|double
name|childCost
init|=
name|toDouble
argument_list|(
name|planner
operator|.
name|getCost
argument_list|(
name|child
argument_list|,
name|mq
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|double
name|parentCost
init|=
name|toDouble
argument_list|(
name|planner
operator|.
name|getCost
argument_list|(
name|parent
argument_list|,
name|mq
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|alpha
init|=
name|childCost
operator|/
name|parentCost
decl_stmt|;
if|if
condition|(
name|alpha
operator|>=
literal|1.0
condition|)
block|{
comment|// child is always less important than parent
name|alpha
operator|=
literal|0.99
expr_stmt|;
block|}
specifier|final
name|double
name|importance
init|=
name|parentImportance
operator|*
name|alpha
decl_stmt|;
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Importance of [{}] to its parent [{}] is {} (parent importance={}, child cost={},"
operator|+
literal|" parent cost={})"
argument_list|,
name|child
argument_list|,
name|parent
argument_list|,
name|importance
argument_list|,
name|parentImportance
argument_list|,
name|childCost
argument_list|,
name|parentCost
argument_list|)
expr_stmt|;
return|return
name|importance
return|;
block|}
comment|/**    * Converts a cost to a scalar quantity.    */
specifier|private
name|double
name|toDouble
parameter_list|(
name|RelOptCost
name|cost
parameter_list|)
block|{
if|if
condition|(
name|cost
operator|.
name|isInfinite
argument_list|()
condition|)
block|{
return|return
literal|1e+30
return|;
block|}
else|else
block|{
return|return
name|cost
operator|.
name|getCpu
argument_list|()
operator|+
name|cost
operator|.
name|getRows
argument_list|()
operator|+
name|cost
operator|.
name|getIo
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|static
name|double
name|computeOneMinusEpsilon
parameter_list|()
block|{
for|for
control|(
name|double
name|d
init|=
literal|0d
init|;
condition|;
control|)
block|{
name|double
name|d0
init|=
name|d
decl_stmt|;
name|d
operator|=
operator|(
name|d
operator|+
literal|1d
operator|)
operator|/
literal|2d
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|1.0
condition|)
block|{
return|return
name|d0
return|;
block|}
block|}
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Compares {@link RelNode} objects according to their cached 'importance'.    */
specifier|private
class|class
name|RelImportanceComparator
implements|implements
name|Comparator
argument_list|<
name|RelSubset
argument_list|>
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|RelSubset
name|rel1
parameter_list|,
name|RelSubset
name|rel2
parameter_list|)
block|{
name|double
name|imp1
init|=
name|getImportance
argument_list|(
name|rel1
argument_list|)
decl_stmt|;
name|double
name|imp2
init|=
name|getImportance
argument_list|(
name|rel2
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|Double
operator|.
name|compare
argument_list|(
name|imp2
argument_list|,
name|imp1
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|rel1
operator|.
name|getId
argument_list|()
operator|-
name|rel2
operator|.
name|getId
argument_list|()
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
block|}
comment|/**    * Compares {@link VolcanoRuleMatch} objects according to their importance.    * Matches which are more important collate earlier. Ties are adjudicated by    * comparing the {@link RelNode#getId id}s of the relational expressions    * matched.    */
specifier|private
specifier|static
class|class
name|RuleMatchImportanceComparator
implements|implements
name|Comparator
argument_list|<
name|VolcanoRuleMatch
argument_list|>
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|VolcanoRuleMatch
name|match1
parameter_list|,
name|VolcanoRuleMatch
name|match2
parameter_list|)
block|{
name|double
name|imp1
init|=
name|match1
operator|.
name|getImportance
argument_list|()
decl_stmt|;
name|double
name|imp2
init|=
name|match2
operator|.
name|getImportance
argument_list|()
decl_stmt|;
name|int
name|c
init|=
name|Double
operator|.
name|compare
argument_list|(
name|imp1
argument_list|,
name|imp2
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
name|c
return|;
block|}
name|c
operator|=
name|match1
operator|.
name|rule
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|match2
operator|.
name|rule
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
name|c
return|;
block|}
return|return
operator|-
name|RelNodes
operator|.
name|compareRels
argument_list|(
name|match1
operator|.
name|rels
argument_list|,
name|match2
operator|.
name|rels
argument_list|)
return|;
block|}
block|}
comment|/**    * PhaseMatchList represents a set of {@link VolcanoRuleMatch rule-matches}    * for a particular    * {@link VolcanoPlannerPhase phase of the planner's execution}.    */
specifier|private
specifier|static
class|class
name|PhaseMatchList
block|{
comment|/**      * The VolcanoPlannerPhase that this PhaseMatchList is used in.      */
specifier|final
name|VolcanoPlannerPhase
name|phase
decl_stmt|;
comment|/**      * Current list of VolcanoRuleMatches for this phase. New rule-matches      * are appended to the end of this list. When removing a rule-match, the      * list is sorted and the highest importance rule-match removed. It is      * important for performance that this list remain mostly sorted.      *      *<p>Use a hunkList because {@link java.util.ArrayList} does not implement      * remove(0) efficiently.</p>      */
specifier|final
name|List
argument_list|<
name|VolcanoRuleMatch
argument_list|>
name|list
init|=
operator|new
name|ChunkList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * A set of rule-match names contained in {@link #list}. Allows fast      * detection of duplicate rule-matches.      */
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * Multi-map of RelSubset to VolcanoRuleMatches. Used to      * {@link VolcanoRuleMatch#clearCachedImportance() clear} the rule-match's      * cached importance when the importance of a related RelSubset is modified      * (e.g., due to invocation of      * {@link RuleQueue#boostImportance(Collection, double)}).      */
specifier|final
name|Multimap
argument_list|<
name|RelSubset
argument_list|,
name|VolcanoRuleMatch
argument_list|>
name|matchMap
init|=
name|HashMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|PhaseMatchList
parameter_list|(
name|VolcanoPlannerPhase
name|phase
parameter_list|)
block|{
name|this
operator|.
name|phase
operator|=
name|phase
expr_stmt|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|list
operator|.
name|clear
argument_list|()
expr_stmt|;
name|names
operator|.
name|clear
argument_list|()
expr_stmt|;
name|matchMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End RuleQueue.java
end_comment

end_unit

