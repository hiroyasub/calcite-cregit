begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteSystemProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|mutable
operator|.
name|Holder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|mutable
operator|.
name|MutableAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|mutable
operator|.
name|MutableCalc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|mutable
operator|.
name|MutableFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|mutable
operator|.
name|MutableIntersect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|mutable
operator|.
name|MutableJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|mutable
operator|.
name|MutableMinus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|mutable
operator|.
name|MutableRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|mutable
operator|.
name|MutableRelVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|mutable
operator|.
name|MutableRels
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|mutable
operator|.
name|MutableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|mutable
operator|.
name|MutableSetOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|mutable
operator|.
name|MutableUnion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLocalRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexOver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSimplify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ControlFlowException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedHashMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
operator|.
name|andNot
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
operator|.
name|removeAll
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * Substitutes part of a tree of relational expressions with another tree.  *  *<p>The call {@code new SubstitutionVisitor(target, query).go(replacement))}  * will return {@code query} with every occurrence of {@code target} replaced  * by {@code replacement}.</p>  *  *<p>The following example shows how {@code SubstitutionVisitor} can be used  * for materialized view recognition.</p>  *  *<ul>  *<li>query = SELECT a, c FROM t WHERE x = 5 AND b = 4</li>  *<li>target = SELECT a, b, c FROM t WHERE x = 5</li>  *<li>replacement = SELECT * FROM mv</li>  *<li>result = SELECT a, c FROM mv WHERE b = 4</li>  *</ul>  *  *<p>Note that {@code result} uses the materialized view table {@code mv} and a  * simplified condition {@code b = 4}.</p>  *  *<p>Uses a bottom-up matching algorithm. Nodes do not need to be identical.  * At each level, returns the residue.</p>  *  *<p>The inputs must only include the core relational operators:  * {@link org.apache.calcite.rel.core.TableScan},  * {@link org.apache.calcite.rel.core.Filter},  * {@link org.apache.calcite.rel.core.Project},  * {@link org.apache.calcite.rel.core.Calc},  * {@link org.apache.calcite.rel.core.Join},  * {@link org.apache.calcite.rel.core.Union},  * {@link org.apache.calcite.rel.core.Intersect},  * {@link org.apache.calcite.rel.core.Aggregate}.</p>  */
end_comment

begin_class
specifier|public
class|class
name|SubstitutionVisitor
block|{
specifier|private
specifier|static
specifier|final
name|boolean
name|DEBUG
init|=
name|CalciteSystemProperty
operator|.
name|DEBUG
operator|.
name|value
argument_list|()
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|UnifyRule
argument_list|>
name|DEFAULT_RULES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|TrivialRule
operator|.
name|INSTANCE
argument_list|,
name|ScanToCalcUnifyRule
operator|.
name|INSTANCE
argument_list|,
name|CalcToCalcUnifyRule
operator|.
name|INSTANCE
argument_list|,
name|JoinOnLeftCalcToJoinUnifyRule
operator|.
name|INSTANCE
argument_list|,
name|JoinOnRightCalcToJoinUnifyRule
operator|.
name|INSTANCE
argument_list|,
name|JoinOnCalcsToJoinUnifyRule
operator|.
name|INSTANCE
argument_list|,
name|AggregateToAggregateUnifyRule
operator|.
name|INSTANCE
argument_list|,
name|AggregateOnCalcToAggregateUnifyRule
operator|.
name|INSTANCE
argument_list|,
name|UnionToUnionUnifyRule
operator|.
name|INSTANCE
argument_list|,
name|UnionOnCalcsToUnionUnifyRule
operator|.
name|INSTANCE
argument_list|,
name|IntersectToIntersectUnifyRule
operator|.
name|INSTANCE
argument_list|,
name|IntersectOnCalcsToIntersectUnifyRule
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
comment|/**    * Factory for a builder for relational expressions.    */
specifier|protected
specifier|final
name|RelBuilder
name|relBuilder
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|UnifyRule
argument_list|>
name|rules
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|Pair
argument_list|<
name|Class
argument_list|,
name|Class
argument_list|>
argument_list|,
name|List
argument_list|<
name|UnifyRule
argument_list|>
argument_list|>
name|ruleMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|RelOptCluster
name|cluster
decl_stmt|;
specifier|private
specifier|final
name|RexSimplify
name|simplify
decl_stmt|;
specifier|private
specifier|final
name|Holder
name|query
decl_stmt|;
specifier|private
specifier|final
name|MutableRel
name|target
decl_stmt|;
comment|/**    * Nodes in {@link #target} that have no children.    */
specifier|final
name|List
argument_list|<
name|MutableRel
argument_list|>
name|targetLeaves
decl_stmt|;
comment|/**    * Nodes in {@link #query} that have no children.    */
specifier|final
name|List
argument_list|<
name|MutableRel
argument_list|>
name|queryLeaves
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|MutableRel
argument_list|,
name|MutableRel
argument_list|>
name|replacementMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Multimap
argument_list|<
name|MutableRel
argument_list|,
name|MutableRel
argument_list|>
name|equivalents
init|=
name|LinkedHashMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
comment|/** Workspace while rule is being matched.    * Careful, re-entrant!    * Assumes no rule needs more than 2 slots. */
specifier|protected
specifier|final
name|MutableRel
index|[]
name|slots
init|=
operator|new
name|MutableRel
index|[
literal|2
index|]
decl_stmt|;
comment|/** Creates a SubstitutionVisitor with the default rule set. */
specifier|public
name|SubstitutionVisitor
parameter_list|(
name|RelNode
name|target_
parameter_list|,
name|RelNode
name|query_
parameter_list|)
block|{
name|this
argument_list|(
name|target_
argument_list|,
name|query_
argument_list|,
name|DEFAULT_RULES
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a SubstitutionVisitor with the default logical builder. */
specifier|public
name|SubstitutionVisitor
parameter_list|(
name|RelNode
name|target_
parameter_list|,
name|RelNode
name|query_
parameter_list|,
name|ImmutableList
argument_list|<
name|UnifyRule
argument_list|>
name|rules
parameter_list|)
block|{
name|this
argument_list|(
name|target_
argument_list|,
name|query_
argument_list|,
name|rules
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
expr_stmt|;
block|}
specifier|public
name|SubstitutionVisitor
parameter_list|(
name|RelNode
name|target_
parameter_list|,
name|RelNode
name|query_
parameter_list|,
name|ImmutableList
argument_list|<
name|UnifyRule
argument_list|>
name|rules
parameter_list|,
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|this
operator|.
name|cluster
operator|=
name|target_
operator|.
name|getCluster
argument_list|()
expr_stmt|;
specifier|final
name|RexExecutor
name|executor
init|=
name|Util
operator|.
name|first
argument_list|(
name|cluster
operator|.
name|getPlanner
argument_list|()
operator|.
name|getExecutor
argument_list|()
argument_list|,
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
decl_stmt|;
specifier|final
name|RelOptPredicateList
name|predicates
init|=
name|RelOptPredicateList
operator|.
name|EMPTY
decl_stmt|;
name|this
operator|.
name|simplify
operator|=
operator|new
name|RexSimplify
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|predicates
argument_list|,
name|executor
argument_list|)
expr_stmt|;
name|this
operator|.
name|rules
operator|=
name|rules
expr_stmt|;
name|this
operator|.
name|query
operator|=
name|Holder
operator|.
name|of
argument_list|(
name|MutableRels
operator|.
name|toMutable
argument_list|(
name|query_
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|MutableRels
operator|.
name|toMutable
argument_list|(
name|target_
argument_list|)
expr_stmt|;
name|this
operator|.
name|relBuilder
operator|=
name|relBuilderFactory
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
literal|null
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
annotation|@
name|Nullable
name|MutableRel
argument_list|>
name|parents
init|=
name|Sets
operator|.
name|newIdentityHashSet
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|MutableRel
argument_list|>
name|allNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|MutableRelVisitor
name|visitor
init|=
operator|new
name|MutableRelVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
annotation|@
name|Nullable
name|MutableRel
name|node
parameter_list|)
block|{
name|requireNonNull
argument_list|(
name|node
argument_list|,
literal|"node"
argument_list|)
expr_stmt|;
name|parents
operator|.
name|add
argument_list|(
name|node
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
name|allNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|visitor
operator|.
name|go
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|// Populate the list of leaves in the tree under "target".
comment|// Leaves are all nodes that are not parents.
comment|// For determinism, it is important that the list is in scan order.
name|allNodes
operator|.
name|removeAll
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|targetLeaves
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|allNodes
argument_list|)
expr_stmt|;
name|allNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|parents
operator|.
name|clear
argument_list|()
expr_stmt|;
name|visitor
operator|.
name|go
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|allNodes
operator|.
name|removeAll
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|queryLeaves
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|allNodes
argument_list|)
expr_stmt|;
block|}
name|void
name|register
parameter_list|(
name|MutableRel
name|result
parameter_list|,
name|MutableRel
name|query
parameter_list|)
block|{
block|}
comment|/**    * Maps a condition onto a target.    *    *<p>If condition is stronger than target, returns the residue.    * If it is equal to target, returns the expression that evaluates to    * the constant {@code true}. If it is weaker than target, returns    * {@code null}.</p>    *    *<p>The terms satisfy the relation</p>    *    *<blockquote>    *<pre>{@code condition = target AND residue}</pre>    *</blockquote>    *    *<p>and {@code residue} must be as weak as possible.</p>    *    *<p>Example #1: condition stronger than target</p>    *<ul>    *<li>condition: x = 1 AND y = 2</li>    *<li>target: x = 1</li>    *<li>residue: y = 2</li>    *</ul>    *    *<p>Note that residue {@code x> 0 AND y = 2} would also satisfy the    * relation {@code condition = target AND residue} but is stronger than    * necessary, so we prefer {@code y = 2}.</p>    *    *<p>Example #2: target weaker than condition (valid, but not currently    * implemented)</p>    *<ul>    *<li>condition: x = 1</li>    *<li>target: x = 1 OR z = 3</li>    *<li>residue: x = 1</li>    *</ul>    *    *<p>Example #3: condition and target are equivalent</p>    *<ul>    *<li>condition: x = 1 AND y = 2</li>    *<li>target: y = 2 AND x = 1</li>    *<li>residue: TRUE</li>    *</ul>    *    *<p>Example #4: condition weaker than target</p>    *<ul>    *<li>condition: x = 1</li>    *<li>target: x = 1 AND y = 2</li>    *<li>residue: null (i.e. no match)</li>    *</ul>    *    *<p>There are many other possible examples. It amounts to solving    * whether {@code condition AND NOT target} can ever evaluate to    * true, and therefore is a form of the NP-complete    *<a href="http://en.wikipedia.org/wiki/Satisfiability">Satisfiability</a>    * problem.</p>    */
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
annotation|@
name|Nullable
name|RexNode
name|splitFilter
parameter_list|(
specifier|final
name|RexSimplify
name|simplify
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|RexNode
name|target
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|simplify
operator|.
name|rexBuilder
decl_stmt|;
name|condition
operator|=
name|simplify
operator|.
name|simplify
argument_list|(
name|condition
argument_list|)
expr_stmt|;
name|target
operator|=
name|simplify
operator|.
name|simplify
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|RexNode
name|condition2
init|=
name|canonizeNode
argument_list|(
name|rexBuilder
argument_list|,
name|condition
argument_list|)
decl_stmt|;
name|RexNode
name|target2
init|=
name|canonizeNode
argument_list|(
name|rexBuilder
argument_list|,
name|target
argument_list|)
decl_stmt|;
comment|// First, try splitting into ORs.
comment|// Given target    c1 OR c2 OR c3 OR c4
comment|// and condition   c2 OR c4
comment|// residue is      c2 OR c4
comment|// Also deals with case target [x] condition [x] yields residue [true].
name|RexNode
name|z
init|=
name|splitOr
argument_list|(
name|rexBuilder
argument_list|,
name|condition2
argument_list|,
name|target2
argument_list|)
decl_stmt|;
if|if
condition|(
name|z
operator|!=
literal|null
condition|)
block|{
return|return
name|z
return|;
block|}
if|if
condition|(
name|isEquivalent
argument_list|(
name|condition2
argument_list|,
name|target2
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
block|}
name|RexNode
name|x
init|=
name|andNot
argument_list|(
name|rexBuilder
argument_list|,
name|target2
argument_list|,
name|condition2
argument_list|)
decl_stmt|;
if|if
condition|(
name|mayBeSatisfiable
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|RexNode
name|x2
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|condition2
argument_list|,
name|target2
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|r
init|=
name|canonizeNode
argument_list|(
name|rexBuilder
argument_list|,
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|x2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|isAlwaysFalse
argument_list|()
operator|&&
name|isEquivalent
argument_list|(
name|condition2
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|conjs
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|r
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|target2
argument_list|)
control|)
block|{
name|removeAll
argument_list|(
name|conjs
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|conjs
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Reorders some of the operands in this expression so structural comparison,    * i.e., based on string representation, can be more precise.    */
specifier|private
specifier|static
name|RexNode
name|canonizeNode
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
switch|switch
condition|(
name|condition
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
case|case
name|OR
case|:
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
name|NavigableMap
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|newOperands
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|operands
control|)
block|{
name|operand
operator|=
name|canonizeNode
argument_list|(
name|rexBuilder
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|newOperands
operator|.
name|put
argument_list|(
name|operand
operator|.
name|toString
argument_list|()
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newOperands
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
return|return
name|newOperands
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|newOperands
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
case|case
name|EQUALS
case|:
case|case
name|NOT_EQUALS
case|:
case|case
name|LESS_THAN
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
name|RexNode
name|left
init|=
name|canonizeNode
argument_list|(
name|rexBuilder
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|right
init|=
name|canonizeNode
argument_list|(
name|rexBuilder
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|call
operator|=
operator|(
name|RexCall
operator|)
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|.
name|toString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|right
operator|.
name|toString
argument_list|()
argument_list|)
operator|<=
literal|0
condition|)
block|{
return|return
name|call
return|;
block|}
specifier|final
name|RexNode
name|result
init|=
name|RexUtil
operator|.
name|invert
argument_list|(
name|rexBuilder
argument_list|,
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"RexUtil.invert returned null for "
operator|+
name|call
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
case|case
name|SEARCH
case|:
block|{
specifier|final
name|RexNode
name|e
init|=
name|RexUtil
operator|.
name|expandSearch
argument_list|(
name|rexBuilder
argument_list|,
literal|null
argument_list|,
name|condition
argument_list|)
decl_stmt|;
return|return
name|canonizeNode
argument_list|(
name|rexBuilder
argument_list|,
name|e
argument_list|)
return|;
block|}
case|case
name|PLUS
case|:
case|case
name|TIMES
case|:
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
name|RexNode
name|left
init|=
name|canonizeNode
argument_list|(
name|rexBuilder
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|right
init|=
name|canonizeNode
argument_list|(
name|rexBuilder
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|left
operator|.
name|toString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|right
operator|.
name|toString
argument_list|()
argument_list|)
operator|<=
literal|0
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
name|RexNode
name|newCall
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|right
argument_list|,
name|left
argument_list|)
decl_stmt|;
comment|// new call should not be used if its inferred type is not same as old
if|if
condition|(
operator|!
name|newCall
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|call
return|;
block|}
return|return
name|newCall
return|;
block|}
default|default:
return|return
name|condition
return|;
block|}
block|}
specifier|private
specifier|static
annotation|@
name|Nullable
name|RexNode
name|splitOr
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|RexNode
name|target
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|conditions
init|=
name|RelOptUtil
operator|.
name|disjunctions
argument_list|(
name|condition
argument_list|)
decl_stmt|;
name|int
name|conditionsLength
init|=
name|conditions
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|targetsLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|RelOptUtil
operator|.
name|disjunctions
argument_list|(
name|target
argument_list|)
control|)
block|{
name|removeAll
argument_list|(
name|conditions
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|targetsLength
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|conditions
operator|.
name|isEmpty
argument_list|()
operator|&&
name|conditionsLength
operator|==
name|targetsLength
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
block|}
if|else if
condition|(
name|conditions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|condition
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isEquivalent
parameter_list|(
name|RexNode
name|condition
parameter_list|,
name|RexNode
name|target
parameter_list|)
block|{
comment|// Example:
comment|//  e: x = 1 AND y = 2 AND z = 3 AND NOT (x = 1 AND y = 2)
comment|//  disjunctions: {x = 1, y = 2, z = 3}
comment|//  notDisjunctions: {x = 1 AND y = 2}
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|conditionDisjunctions
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|RexUtil
operator|.
name|strings
argument_list|(
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|condition
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|targetDisjunctions
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|RexUtil
operator|.
name|strings
argument_list|(
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|conditionDisjunctions
operator|.
name|equals
argument_list|(
name|targetDisjunctions
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether a boolean expression ever returns true.    *    *<p>This method may give false positives. For instance, it will say    * that {@code x = 5 AND x> 10} is satisfiable, because at present it    * cannot prove that it is not.</p>    */
specifier|public
specifier|static
name|boolean
name|mayBeSatisfiable
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
comment|// Example:
comment|//  e: x = 1 AND y = 2 AND z = 3 AND NOT (x = 1 AND y = 2)
comment|//  disjunctions: {x = 1, y = 2, z = 3}
comment|//  notDisjunctions: {x = 1 AND y = 2}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|disjunctions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|notDisjunctions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|RelOptUtil
operator|.
name|decomposeConjunction
argument_list|(
name|e
argument_list|,
name|disjunctions
argument_list|,
name|notDisjunctions
argument_list|)
expr_stmt|;
comment|// If there is a single FALSE or NOT TRUE, the whole expression is
comment|// always false.
for|for
control|(
name|RexNode
name|disjunction
range|:
name|disjunctions
control|)
block|{
switch|switch
condition|(
name|disjunction
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LITERAL
case|:
if|if
condition|(
operator|!
name|RexLiteral
operator|.
name|booleanValue
argument_list|(
name|disjunction
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
for|for
control|(
name|RexNode
name|disjunction
range|:
name|notDisjunctions
control|)
block|{
switch|switch
condition|(
name|disjunction
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LITERAL
case|:
if|if
condition|(
name|RexLiteral
operator|.
name|booleanValue
argument_list|(
name|disjunction
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|// If one of the not-disjunctions is a disjunction that is wholly
comment|// contained in the disjunctions list, the expression is not
comment|// satisfiable.
comment|//
comment|// Example #1. x AND y AND z AND NOT (x AND y)  - not satisfiable
comment|// Example #2. x AND y AND NOT (x AND y)        - not satisfiable
comment|// Example #3. x AND y AND NOT (x AND y AND z)  - may be satisfiable
for|for
control|(
name|RexNode
name|notDisjunction
range|:
name|notDisjunctions
control|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|disjunctions2
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|notDisjunction
argument_list|)
decl_stmt|;
if|if
condition|(
name|disjunctions
operator|.
name|containsAll
argument_list|(
name|disjunctions2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
annotation|@
name|Nullable
name|RelNode
name|go0
parameter_list|(
name|RelNode
name|replacement_
parameter_list|)
block|{
assert|assert
literal|false
assert|;
comment|// not called
name|MutableRel
name|replacement
init|=
name|MutableRels
operator|.
name|toMutable
argument_list|(
name|replacement_
argument_list|)
decl_stmt|;
assert|assert
name|equalType
argument_list|(
literal|"target"
argument_list|,
name|target
argument_list|,
literal|"replacement"
argument_list|,
name|replacement
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
name|replacementMap
operator|.
name|put
argument_list|(
name|target
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
specifier|final
name|UnifyResult
name|unifyResult
init|=
name|matchRecurse
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|unifyResult
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|MutableRel
name|node0
init|=
name|unifyResult
operator|.
name|result
decl_stmt|;
name|MutableRel
name|node
init|=
name|node0
decl_stmt|;
comment|// replaceAncestors(node0);
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Convert: query:\n"
operator|+
name|query
operator|.
name|deep
argument_list|()
operator|+
literal|"\nunify.query:\n"
operator|+
name|unifyResult
operator|.
name|call
operator|.
name|query
operator|.
name|deep
argument_list|()
operator|+
literal|"\nunify.result:\n"
operator|+
name|unifyResult
operator|.
name|result
operator|.
name|deep
argument_list|()
operator|+
literal|"\nunify.target:\n"
operator|+
name|unifyResult
operator|.
name|call
operator|.
name|target
operator|.
name|deep
argument_list|()
operator|+
literal|"\nnode0:\n"
operator|+
name|node0
operator|.
name|deep
argument_list|()
operator|+
literal|"\nnode:\n"
operator|+
name|node
operator|.
name|deep
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|MutableRels
operator|.
name|fromMutable
argument_list|(
name|node
argument_list|,
name|relBuilder
argument_list|)
return|;
block|}
comment|/**    * Returns a list of all possible rels that result from substituting the    * matched RelNode with the replacement RelNode within the query.    *    *<p>For example, the substitution result of A join B, while A and B    * are both a qualified match for replacement R, is R join B, R join R,    * A join R.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"MixedMutabilityReturnType"
argument_list|)
specifier|public
name|List
argument_list|<
name|RelNode
argument_list|>
name|go
parameter_list|(
name|RelNode
name|replacement_
parameter_list|)
block|{
name|List
argument_list|<
name|List
argument_list|<
name|Replacement
argument_list|>
argument_list|>
name|matches
init|=
name|go
argument_list|(
name|MutableRels
operator|.
name|toMutable
argument_list|(
name|replacement_
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|matches
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
name|List
argument_list|<
name|RelNode
argument_list|>
name|sub
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|sub
operator|.
name|add
argument_list|(
name|MutableRels
operator|.
name|fromMutable
argument_list|(
name|query
operator|.
name|getInput
argument_list|()
argument_list|,
name|relBuilder
argument_list|)
argument_list|)
expr_stmt|;
name|reverseSubstitute
argument_list|(
name|relBuilder
argument_list|,
name|query
argument_list|,
name|matches
argument_list|,
name|sub
argument_list|,
literal|0
argument_list|,
name|matches
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sub
return|;
block|}
comment|/**    * Substitutes the query with replacement whenever possible but meanwhile    * keeps track of all the substitutions and their original rel before    * replacement, so that in later processing stage, the replacement can be    * recovered individually to produce a list of all possible rels with    * substitution in different places.    */
specifier|private
name|List
argument_list|<
name|List
argument_list|<
name|Replacement
argument_list|>
argument_list|>
name|go
parameter_list|(
name|MutableRel
name|replacement
parameter_list|)
block|{
assert|assert
name|equalType
argument_list|(
literal|"target"
argument_list|,
name|target
argument_list|,
literal|"replacement"
argument_list|,
name|replacement
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
specifier|final
name|List
argument_list|<
name|MutableRel
argument_list|>
name|queryDescendants
init|=
name|MutableRels
operator|.
name|descendants
argument_list|(
name|query
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|MutableRel
argument_list|>
name|targetDescendants
init|=
name|MutableRels
operator|.
name|descendants
argument_list|(
name|target
argument_list|)
decl_stmt|;
comment|// Populate "equivalents" with (q, t) for each query descendant q and
comment|// target descendant t that are equal.
specifier|final
name|Map
argument_list|<
name|MutableRel
argument_list|,
name|MutableRel
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|MutableRel
name|queryDescendant
range|:
name|queryDescendants
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|queryDescendant
argument_list|,
name|queryDescendant
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|MutableRel
name|targetDescendant
range|:
name|targetDescendants
control|)
block|{
name|MutableRel
name|queryDescendant
init|=
name|map
operator|.
name|get
argument_list|(
name|targetDescendant
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryDescendant
operator|!=
literal|null
condition|)
block|{
assert|assert
name|rowTypesAreEquivalent
argument_list|(
name|queryDescendant
argument_list|,
name|targetDescendant
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
name|equivalents
operator|.
name|put
argument_list|(
name|queryDescendant
argument_list|,
name|targetDescendant
argument_list|)
expr_stmt|;
block|}
block|}
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Replacement
argument_list|>
name|attempted
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|Replacement
argument_list|>
argument_list|>
name|substitutions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|MutableRel
name|queryDescendant
init|=
name|query
decl_stmt|;
name|outer
label|:
while|while
condition|(
name|queryDescendant
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Replacement
name|r
range|:
name|attempted
control|)
block|{
if|if
condition|(
name|r
operator|.
name|stopTrying
operator|&&
name|queryDescendant
operator|==
name|r
operator|.
name|after
condition|)
block|{
comment|// This node has been replaced by previous iterations in the
comment|// hope to match its ancestors and stopTrying indicates
comment|// there's no need to be matched again.
name|queryDescendant
operator|=
name|MutableRels
operator|.
name|preOrderTraverseNext
argument_list|(
name|queryDescendant
argument_list|)
expr_stmt|;
continue|continue
name|outer
continue|;
block|}
block|}
specifier|final
name|MutableRel
name|next
init|=
name|MutableRels
operator|.
name|preOrderTraverseNext
argument_list|(
name|queryDescendant
argument_list|)
decl_stmt|;
specifier|final
name|MutableRel
name|childOrNext
init|=
name|queryDescendant
operator|.
name|getInputs
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|next
else|:
name|queryDescendant
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|MutableRel
name|targetDescendant
range|:
name|targetDescendants
control|)
block|{
for|for
control|(
name|UnifyRule
name|rule
range|:
name|applicableRules
argument_list|(
name|queryDescendant
argument_list|,
name|targetDescendant
argument_list|)
control|)
block|{
name|UnifyRuleCall
name|call
init|=
name|rule
operator|.
name|match
argument_list|(
name|this
argument_list|,
name|queryDescendant
argument_list|,
name|targetDescendant
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
specifier|final
name|UnifyResult
name|result
init|=
name|rule
operator|.
name|apply
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|attempted
operator|.
name|add
argument_list|(
operator|new
name|Replacement
argument_list|(
name|result
operator|.
name|call
operator|.
name|query
argument_list|,
name|result
operator|.
name|result
argument_list|,
name|result
operator|.
name|stopTrying
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|call
operator|.
name|query
operator|.
name|replaceInParent
argument_list|(
name|result
operator|.
name|result
argument_list|)
expr_stmt|;
comment|// Replace previous equivalents with new equivalents, higher up
comment|// the tree.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rule
operator|.
name|slotCount
condition|;
name|i
operator|++
control|)
block|{
name|Collection
argument_list|<
name|MutableRel
argument_list|>
name|equi
init|=
name|equivalents
operator|.
name|get
argument_list|(
name|slots
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|equi
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|equivalents
operator|.
name|remove
argument_list|(
name|slots
index|[
name|i
index|]
argument_list|,
name|equi
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|rowTypesAreEquivalent
argument_list|(
name|result
operator|.
name|result
argument_list|,
name|result
operator|.
name|call
operator|.
name|query
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
name|equivalents
operator|.
name|put
argument_list|(
name|result
operator|.
name|result
argument_list|,
name|result
operator|.
name|call
operator|.
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetDescendant
operator|==
name|target
condition|)
block|{
comment|// A real substitution happens. We purge the attempted
comment|// replacement list and add them into substitution list.
comment|// Meanwhile we stop matching the descendants and jump
comment|// to the next subtree in pre-order traversal.
if|if
condition|(
operator|!
name|target
operator|.
name|equals
argument_list|(
name|replacement
argument_list|)
condition|)
block|{
name|Replacement
name|r
init|=
name|replace
argument_list|(
name|query
operator|.
name|getInput
argument_list|()
argument_list|,
name|target
argument_list|,
name|replacement
operator|.
name|clone
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|r
operator|!=
literal|null
operator|:
name|rule
operator|+
literal|"should have returned a result containing the target."
assert|;
name|attempted
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|substitutions
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|attempted
argument_list|)
argument_list|)
expr_stmt|;
name|attempted
operator|.
name|clear
argument_list|()
expr_stmt|;
name|queryDescendant
operator|=
name|next
expr_stmt|;
continue|continue
name|outer
continue|;
block|}
comment|// We will try walking the query tree all over again to see
comment|// if there can be any substitutions after the replacement
comment|// attempt.
break|break
name|outer
break|;
block|}
block|}
block|}
block|}
name|queryDescendant
operator|=
name|childOrNext
expr_stmt|;
block|}
comment|// Quit the entire loop if:
comment|// 1) we have walked the entire query tree with one or more successful
comment|//    substitutions, thus count != 0&& attempted.isEmpty();
comment|// 2) we have walked the entire query tree but have made no replacement
comment|//    attempt, thus count == 0&& attempted.isEmpty();
comment|// 3) we had done some replacement attempt in a previous walk, but in
comment|//    this one we have not found any potential matches or substitutions,
comment|//    thus count == 0&& !attempted.isEmpty().
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|attempted
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|attempted
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// We had done some replacement attempt in the previous walk, but that
comment|// did not lead to any substitutions in this walk, so we need to recover
comment|// the replacement.
name|undoReplacement
argument_list|(
name|attempted
argument_list|)
expr_stmt|;
block|}
return|return
name|substitutions
return|;
block|}
comment|/**    * Equivalence checking for row types, but except for the field names.    */
specifier|private
specifier|static
name|boolean
name|rowTypesAreEquivalent
parameter_list|(
name|MutableRel
name|rel0
parameter_list|,
name|MutableRel
name|rel1
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
if|if
condition|(
name|rel0
operator|.
name|rowType
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|rel1
operator|.
name|rowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"Mismatch for column count: [{}]"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
name|rel0
argument_list|,
name|rel1
argument_list|)
argument_list|)
return|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|rel0
operator|.
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|rel1
operator|.
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|pair
operator|.
name|left
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|pair
operator|.
name|right
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"Mismatch for column type: [{}]"
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
name|rel0
argument_list|,
name|rel1
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Represents a replacement action: before&rarr; after.    * {@code stopTrying} indicates whether there's no need    * to do matching for the same query node again.    */
specifier|static
class|class
name|Replacement
block|{
specifier|final
name|MutableRel
name|before
decl_stmt|;
specifier|final
name|MutableRel
name|after
decl_stmt|;
specifier|final
name|boolean
name|stopTrying
decl_stmt|;
name|Replacement
parameter_list|(
name|MutableRel
name|before
parameter_list|,
name|MutableRel
name|after
parameter_list|)
block|{
name|this
argument_list|(
name|before
argument_list|,
name|after
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|Replacement
parameter_list|(
name|MutableRel
name|before
parameter_list|,
name|MutableRel
name|after
parameter_list|,
name|boolean
name|stopTrying
parameter_list|)
block|{
name|this
operator|.
name|before
operator|=
name|before
expr_stmt|;
name|this
operator|.
name|after
operator|=
name|after
expr_stmt|;
name|this
operator|.
name|stopTrying
operator|=
name|stopTrying
expr_stmt|;
block|}
block|}
comment|/** Within a relational expression {@code query}, replaces occurrences of    * {@code find} with {@code replace}.    *    *<p>Assumes relational expressions (and their descendants) are not null.    * Does not handle cycles. */
specifier|public
specifier|static
annotation|@
name|Nullable
name|Replacement
name|replace
parameter_list|(
name|MutableRel
name|query
parameter_list|,
name|MutableRel
name|find
parameter_list|,
name|MutableRel
name|replace
parameter_list|)
block|{
if|if
condition|(
name|find
operator|.
name|equals
argument_list|(
name|replace
argument_list|)
condition|)
block|{
comment|// Short-cut common case.
return|return
literal|null
return|;
block|}
assert|assert
name|equalType
argument_list|(
literal|"find"
argument_list|,
name|find
argument_list|,
literal|"replace"
argument_list|,
name|replace
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
return|return
name|replaceRecurse
argument_list|(
name|query
argument_list|,
name|find
argument_list|,
name|replace
argument_list|)
return|;
block|}
comment|/** Helper for {@link #replace}. */
specifier|private
specifier|static
annotation|@
name|Nullable
name|Replacement
name|replaceRecurse
parameter_list|(
name|MutableRel
name|query
parameter_list|,
name|MutableRel
name|find
parameter_list|,
name|MutableRel
name|replace
parameter_list|)
block|{
if|if
condition|(
name|find
operator|.
name|equals
argument_list|(
name|query
argument_list|)
condition|)
block|{
name|query
operator|.
name|replaceInParent
argument_list|(
name|replace
argument_list|)
expr_stmt|;
return|return
operator|new
name|Replacement
argument_list|(
name|query
argument_list|,
name|replace
argument_list|)
return|;
block|}
for|for
control|(
name|MutableRel
name|input
range|:
name|query
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|Replacement
name|r
init|=
name|replaceRecurse
argument_list|(
name|input
argument_list|,
name|find
argument_list|,
name|replace
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
return|return
name|r
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|static
name|void
name|undoReplacement
parameter_list|(
name|List
argument_list|<
name|Replacement
argument_list|>
name|replacement
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|replacement
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|Replacement
name|r
init|=
name|replacement
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|r
operator|.
name|after
operator|.
name|replaceInParent
argument_list|(
name|r
operator|.
name|before
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|redoReplacement
parameter_list|(
name|List
argument_list|<
name|Replacement
argument_list|>
name|replacement
parameter_list|)
block|{
for|for
control|(
name|Replacement
name|r
range|:
name|replacement
control|)
block|{
name|r
operator|.
name|before
operator|.
name|replaceInParent
argument_list|(
name|r
operator|.
name|after
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|reverseSubstitute
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|Holder
name|query
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|Replacement
argument_list|>
argument_list|>
name|matches
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|sub
parameter_list|,
name|int
name|replaceCount
parameter_list|,
name|int
name|maxCount
parameter_list|)
block|{
if|if
condition|(
name|matches
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|Replacement
argument_list|>
argument_list|>
name|rem
init|=
name|matches
operator|.
name|subList
argument_list|(
literal|1
argument_list|,
name|matches
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|reverseSubstitute
argument_list|(
name|relBuilder
argument_list|,
name|query
argument_list|,
name|rem
argument_list|,
name|sub
argument_list|,
name|replaceCount
argument_list|,
name|maxCount
argument_list|)
expr_stmt|;
name|undoReplacement
argument_list|(
name|matches
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|replaceCount
operator|<
name|maxCount
condition|)
block|{
name|sub
operator|.
name|add
argument_list|(
name|MutableRels
operator|.
name|fromMutable
argument_list|(
name|query
operator|.
name|getInput
argument_list|()
argument_list|,
name|relBuilder
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reverseSubstitute
argument_list|(
name|relBuilder
argument_list|,
name|query
argument_list|,
name|rem
argument_list|,
name|sub
argument_list|,
name|replaceCount
argument_list|,
name|maxCount
argument_list|)
expr_stmt|;
name|redoReplacement
argument_list|(
name|matches
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
annotation|@
name|Nullable
name|UnifyResult
name|matchRecurse
parameter_list|(
name|MutableRel
name|target
parameter_list|)
block|{
assert|assert
literal|false
assert|;
comment|// not called
specifier|final
name|List
argument_list|<
name|MutableRel
argument_list|>
name|targetInputs
init|=
name|target
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|MutableRel
name|queryParent
init|=
literal|null
decl_stmt|;
for|for
control|(
name|MutableRel
name|targetInput
range|:
name|targetInputs
control|)
block|{
name|UnifyResult
name|unifyResult
init|=
name|matchRecurse
argument_list|(
name|targetInput
argument_list|)
decl_stmt|;
if|if
condition|(
name|unifyResult
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|queryParent
operator|=
name|unifyResult
operator|.
name|call
operator|.
name|query
operator|.
name|replaceInParent
argument_list|(
name|unifyResult
operator|.
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetInputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|MutableRel
name|queryLeaf
range|:
name|queryLeaves
control|)
block|{
for|for
control|(
name|UnifyRule
name|rule
range|:
name|applicableRules
argument_list|(
name|queryLeaf
argument_list|,
name|target
argument_list|)
control|)
block|{
specifier|final
name|UnifyResult
name|x
init|=
name|apply
argument_list|(
name|rule
argument_list|,
name|queryLeaf
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Rule: "
operator|+
name|rule
operator|+
literal|"\nQuery:\n"
operator|+
name|queryParent
operator|+
operator|(
name|x
operator|.
name|call
operator|.
name|query
operator|!=
name|queryParent
condition|?
literal|"\nQuery (original):\n"
operator|+
name|queryParent
else|:
literal|""
operator|)
operator|+
literal|"\nTarget:\n"
operator|+
name|target
operator|.
name|deep
argument_list|()
operator|+
literal|"\nResult:\n"
operator|+
name|x
operator|.
name|result
operator|.
name|deep
argument_list|()
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
block|}
block|}
block|}
else|else
block|{
assert|assert
name|queryParent
operator|!=
literal|null
assert|;
for|for
control|(
name|UnifyRule
name|rule
range|:
name|applicableRules
argument_list|(
name|queryParent
argument_list|,
name|target
argument_list|)
control|)
block|{
specifier|final
name|UnifyResult
name|x
init|=
name|apply
argument_list|(
name|rule
argument_list|,
name|queryParent
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Rule: "
operator|+
name|rule
operator|+
literal|"\nQuery:\n"
operator|+
name|queryParent
operator|.
name|deep
argument_list|()
operator|+
operator|(
name|x
operator|.
name|call
operator|.
name|query
operator|!=
name|queryParent
condition|?
literal|"\nQuery (original):\n"
operator|+
name|queryParent
operator|.
name|toString
argument_list|()
else|:
literal|""
operator|)
operator|+
literal|"\nTarget:\n"
operator|+
name|target
operator|.
name|deep
argument_list|()
operator|+
literal|"\nResult:\n"
operator|+
name|x
operator|.
name|result
operator|.
name|deep
argument_list|()
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
block|}
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Unify failed:"
operator|+
literal|"\nQuery:\n"
operator|+
name|queryParent
operator|+
literal|"\nTarget:\n"
operator|+
name|target
operator|.
name|toString
argument_list|()
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRule
name|rule
parameter_list|,
name|MutableRel
name|query
parameter_list|,
name|MutableRel
name|target
parameter_list|)
block|{
specifier|final
name|UnifyRuleCall
name|call
init|=
operator|new
name|UnifyRuleCall
argument_list|(
name|rule
argument_list|,
name|query
argument_list|,
name|target
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rule
operator|.
name|apply
argument_list|(
name|call
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|UnifyRule
argument_list|>
name|applicableRules
parameter_list|(
name|MutableRel
name|query
parameter_list|,
name|MutableRel
name|target
parameter_list|)
block|{
specifier|final
name|Class
name|queryClass
init|=
name|query
operator|.
name|getClass
argument_list|()
decl_stmt|;
specifier|final
name|Class
name|targetClass
init|=
name|target
operator|.
name|getClass
argument_list|()
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|Class
argument_list|,
name|Class
argument_list|>
name|key
init|=
name|Pair
operator|.
name|of
argument_list|(
name|queryClass
argument_list|,
name|targetClass
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|UnifyRule
argument_list|>
name|list
init|=
name|ruleMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|UnifyRule
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|UnifyRule
name|rule
range|:
name|rules
control|)
block|{
comment|//noinspection unchecked
if|if
condition|(
name|mightMatch
argument_list|(
name|rule
argument_list|,
name|queryClass
argument_list|,
name|targetClass
argument_list|)
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
name|list
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
name|ruleMap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
specifier|private
specifier|static
name|boolean
name|mightMatch
parameter_list|(
name|UnifyRule
name|rule
parameter_list|,
name|Class
name|queryClass
parameter_list|,
name|Class
name|targetClass
parameter_list|)
block|{
return|return
name|rule
operator|.
name|queryOperand
operator|.
name|clazz
operator|.
name|isAssignableFrom
argument_list|(
name|queryClass
argument_list|)
operator|&&
name|rule
operator|.
name|targetOperand
operator|.
name|clazz
operator|.
name|isAssignableFrom
argument_list|(
name|targetClass
argument_list|)
return|;
block|}
comment|/** Exception thrown to exit a matcher. Not really an error. */
specifier|protected
specifier|static
class|class
name|MatchFailed
extends|extends
name|ControlFlowException
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ThrowableInstanceNeverThrown"
argument_list|)
specifier|public
specifier|static
specifier|final
name|MatchFailed
name|INSTANCE
init|=
operator|new
name|MatchFailed
argument_list|()
decl_stmt|;
block|}
comment|/** Rule that attempts to match a query relational expression    * against a target relational expression.    *    *<p>The rule declares the query and target types; this allows the    * engine to fire only a few rules in a given context.</p>    */
specifier|protected
specifier|abstract
specifier|static
class|class
name|UnifyRule
block|{
specifier|protected
specifier|final
name|int
name|slotCount
decl_stmt|;
specifier|protected
specifier|final
name|Operand
name|queryOperand
decl_stmt|;
specifier|protected
specifier|final
name|Operand
name|targetOperand
decl_stmt|;
specifier|protected
name|UnifyRule
parameter_list|(
name|int
name|slotCount
parameter_list|,
name|Operand
name|queryOperand
parameter_list|,
name|Operand
name|targetOperand
parameter_list|)
block|{
name|this
operator|.
name|slotCount
operator|=
name|slotCount
expr_stmt|;
name|this
operator|.
name|queryOperand
operator|=
name|queryOperand
expr_stmt|;
name|this
operator|.
name|targetOperand
operator|=
name|targetOperand
expr_stmt|;
block|}
comment|/**      *<p>Applies this rule to a particular node in a query. The goal is      * to convert {@code query} into {@code target}. Before the rule is      * invoked, Calcite has made sure that query's children are equivalent      * to target's children.      *      *<p>There are 3 possible outcomes:</p>      *      *<ul>      *      *<li>{@code query} already exactly matches {@code target}; returns      * {@code target}</li>      *      *<li>{@code query} is sufficiently close to a match for      * {@code target}; returns {@code target}</li>      *      *<li>{@code query} cannot be made to match {@code target}; returns      * null</li>      *      *</ul>      *      *<p>REVIEW: Is possible that we match query PLUS one or more of its      * ancestors?</p>      *      * @param call Input parameters      */
specifier|protected
specifier|abstract
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
function_decl|;
specifier|protected
annotation|@
name|Nullable
name|UnifyRuleCall
name|match
parameter_list|(
name|SubstitutionVisitor
name|visitor
parameter_list|,
name|MutableRel
name|query
parameter_list|,
name|MutableRel
name|target
parameter_list|)
block|{
if|if
condition|(
name|queryOperand
operator|.
name|matches
argument_list|(
name|visitor
argument_list|,
name|query
argument_list|)
condition|)
block|{
if|if
condition|(
name|targetOperand
operator|.
name|matches
argument_list|(
name|visitor
argument_list|,
name|target
argument_list|)
condition|)
block|{
return|return
name|visitor
operator|.
expr|new
name|UnifyRuleCall
argument_list|(
name|this
argument_list|,
name|query
argument_list|,
name|target
argument_list|,
name|copy
argument_list|(
name|visitor
operator|.
name|slots
argument_list|,
name|slotCount
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|protected
parameter_list|<
name|E
parameter_list|>
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|copy
parameter_list|(
name|E
index|[]
name|slots
parameter_list|,
name|int
name|slotCount
parameter_list|)
block|{
comment|// Optimize if there are 0 or 1 slots.
switch|switch
condition|(
name|slotCount
condition|)
block|{
case|case
literal|0
case|:
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
case|case
literal|1
case|:
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|slots
index|[
literal|0
index|]
argument_list|)
return|;
default|default:
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|slots
argument_list|)
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|slotCount
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Arguments to an application of a {@link UnifyRule}.    */
specifier|protected
class|class
name|UnifyRuleCall
block|{
specifier|protected
specifier|final
name|UnifyRule
name|rule
decl_stmt|;
specifier|public
specifier|final
name|MutableRel
name|query
decl_stmt|;
specifier|public
specifier|final
name|MutableRel
name|target
decl_stmt|;
specifier|protected
specifier|final
name|ImmutableList
argument_list|<
name|MutableRel
argument_list|>
name|slots
decl_stmt|;
specifier|public
name|UnifyRuleCall
parameter_list|(
name|UnifyRule
name|rule
parameter_list|,
name|MutableRel
name|query
parameter_list|,
name|MutableRel
name|target
parameter_list|,
name|ImmutableList
argument_list|<
name|MutableRel
argument_list|>
name|slots
parameter_list|)
block|{
name|this
operator|.
name|rule
operator|=
name|requireNonNull
argument_list|(
name|rule
argument_list|,
literal|"rule"
argument_list|)
expr_stmt|;
name|this
operator|.
name|query
operator|=
name|requireNonNull
argument_list|(
name|query
argument_list|,
literal|"query"
argument_list|)
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|requireNonNull
argument_list|(
name|target
argument_list|,
literal|"target"
argument_list|)
expr_stmt|;
name|this
operator|.
name|slots
operator|=
name|requireNonNull
argument_list|(
name|slots
argument_list|,
literal|"slots"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|UnifyResult
name|result
parameter_list|(
name|MutableRel
name|result
parameter_list|)
block|{
return|return
name|result
argument_list|(
name|result
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
name|UnifyResult
name|result
parameter_list|(
name|MutableRel
name|result
parameter_list|,
name|boolean
name|stopTrying
parameter_list|)
block|{
assert|assert
name|MutableRels
operator|.
name|contains
argument_list|(
name|result
argument_list|,
name|target
argument_list|)
assert|;
assert|assert
name|equalType
argument_list|(
literal|"result"
argument_list|,
name|result
argument_list|,
literal|"query"
argument_list|,
name|query
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
name|MutableRel
name|replace
init|=
name|replacementMap
operator|.
name|get
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|replace
operator|!=
literal|null
condition|)
block|{
assert|assert
literal|false
assert|;
comment|// replacementMap is always empty
comment|// result =
name|replace
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|replace
argument_list|)
expr_stmt|;
block|}
name|register
argument_list|(
name|result
argument_list|,
name|query
argument_list|)
expr_stmt|;
return|return
operator|new
name|UnifyResult
argument_list|(
name|this
argument_list|,
name|result
argument_list|,
name|stopTrying
argument_list|)
return|;
block|}
comment|/**      * Creates a {@link UnifyRuleCall} based on the parent of {@code query}.      */
specifier|public
name|UnifyRuleCall
name|create
parameter_list|(
name|MutableRel
name|query
parameter_list|)
block|{
return|return
operator|new
name|UnifyRuleCall
argument_list|(
name|rule
argument_list|,
name|query
argument_list|,
name|target
argument_list|,
name|slots
argument_list|)
return|;
block|}
specifier|public
name|RelOptCluster
name|getCluster
parameter_list|()
block|{
return|return
name|cluster
return|;
block|}
specifier|public
name|RexSimplify
name|getSimplify
parameter_list|()
block|{
return|return
name|simplify
return|;
block|}
block|}
comment|/**    * Result of an application of a {@link UnifyRule} indicating that the    * rule successfully matched {@code query} against {@code target} and    * generated a {@code result} that is equivalent to {@code query} and    * contains {@code target}. {@code stopTrying} indicates whether there's    * no need to do matching for the same query node again.    */
specifier|protected
specifier|static
class|class
name|UnifyResult
block|{
specifier|private
specifier|final
name|UnifyRuleCall
name|call
decl_stmt|;
specifier|private
specifier|final
name|MutableRel
name|result
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|stopTrying
decl_stmt|;
name|UnifyResult
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|,
name|MutableRel
name|result
parameter_list|,
name|boolean
name|stopTrying
parameter_list|)
block|{
name|this
operator|.
name|call
operator|=
name|call
expr_stmt|;
assert|assert
name|equalType
argument_list|(
literal|"query"
argument_list|,
name|call
operator|.
name|query
argument_list|,
literal|"result"
argument_list|,
name|result
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
name|this
operator|.
name|stopTrying
operator|=
name|stopTrying
expr_stmt|;
block|}
block|}
comment|/** Abstract base class for implementing {@link UnifyRule}. */
specifier|protected
specifier|abstract
specifier|static
class|class
name|AbstractUnifyRule
extends|extends
name|UnifyRule
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"method.invocation.invalid"
argument_list|)
specifier|protected
name|AbstractUnifyRule
parameter_list|(
name|Operand
name|queryOperand
parameter_list|,
name|Operand
name|targetOperand
parameter_list|,
name|int
name|slotCount
parameter_list|)
block|{
name|super
argument_list|(
name|slotCount
argument_list|,
name|queryOperand
argument_list|,
name|targetOperand
argument_list|)
expr_stmt|;
comment|//noinspection AssertWithSideEffects
assert|assert
name|isValid
argument_list|()
assert|;
block|}
specifier|protected
name|boolean
name|isValid
parameter_list|()
block|{
specifier|final
name|SlotCounter
name|slotCounter
init|=
operator|new
name|SlotCounter
argument_list|()
decl_stmt|;
name|slotCounter
operator|.
name|visit
argument_list|(
name|queryOperand
argument_list|)
expr_stmt|;
assert|assert
name|slotCounter
operator|.
name|queryCount
operator|==
name|slotCount
assert|;
assert|assert
name|slotCounter
operator|.
name|targetCount
operator|==
literal|0
assert|;
name|slotCounter
operator|.
name|queryCount
operator|=
literal|0
expr_stmt|;
name|slotCounter
operator|.
name|visit
argument_list|(
name|targetOperand
argument_list|)
expr_stmt|;
assert|assert
name|slotCounter
operator|.
name|queryCount
operator|==
literal|0
assert|;
assert|assert
name|slotCounter
operator|.
name|targetCount
operator|==
name|slotCount
assert|;
return|return
literal|true
return|;
block|}
comment|/** Creates an operand with given inputs. */
specifier|protected
specifier|static
name|Operand
name|operand
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|MutableRel
argument_list|>
name|clazz
parameter_list|,
name|Operand
modifier|...
name|inputOperands
parameter_list|)
block|{
return|return
operator|new
name|InternalOperand
argument_list|(
name|clazz
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|inputOperands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an operand that doesn't check inputs. */
specifier|protected
specifier|static
name|Operand
name|any
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|MutableRel
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
operator|new
name|AnyOperand
argument_list|(
name|clazz
argument_list|)
return|;
block|}
comment|/** Creates an operand that matches a relational expression in the query. */
specifier|protected
specifier|static
name|Operand
name|query
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
return|return
operator|new
name|QueryOperand
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
comment|/** Creates an operand that matches a relational expression in the      * target. */
specifier|protected
specifier|static
name|Operand
name|target
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
return|return
operator|new
name|TargetOperand
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
block|}
comment|/** Implementation of {@link UnifyRule} that matches if the query is already    * equal to the target.    *    *<p>Matches scans to the same table, because these will be    * {@link MutableScan}s with the same    * {@link org.apache.calcite.rel.core.TableScan} instance.</p>    */
specifier|private
specifier|static
class|class
name|TrivialRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|private
specifier|static
specifier|final
name|TrivialRule
name|INSTANCE
init|=
operator|new
name|TrivialRule
argument_list|()
decl_stmt|;
specifier|private
name|TrivialRule
parameter_list|()
block|{
name|super
argument_list|(
name|any
argument_list|(
name|MutableRel
operator|.
name|class
argument_list|)
argument_list|,
name|any
argument_list|(
name|MutableRel
operator|.
name|class
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|query
operator|.
name|equals
argument_list|(
name|call
operator|.
name|target
argument_list|)
condition|)
block|{
return|return
name|call
operator|.
name|result
argument_list|(
name|call
operator|.
name|target
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * A {@link SubstitutionVisitor.UnifyRule} that matches a    * {@link MutableScan} to a {@link MutableCalc}    * which has {@link MutableScan} as child.    */
specifier|private
specifier|static
class|class
name|ScanToCalcUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|ScanToCalcUnifyRule
name|INSTANCE
init|=
operator|new
name|ScanToCalcUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|ScanToCalcUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|any
argument_list|(
name|MutableScan
operator|.
name|class
argument_list|)
argument_list|,
name|operand
argument_list|(
name|MutableCalc
operator|.
name|class
argument_list|,
name|any
argument_list|(
name|MutableScan
operator|.
name|class
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|MutableScan
name|query
init|=
operator|(
name|MutableScan
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|MutableCalc
name|target
init|=
operator|(
name|MutableCalc
operator|)
name|call
operator|.
name|target
decl_stmt|;
specifier|final
name|MutableScan
name|targetInput
init|=
operator|(
name|MutableScan
operator|)
name|target
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|targetExplained
init|=
name|explainCalc
argument_list|(
name|target
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|targetCond
init|=
name|targetExplained
operator|.
name|left
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|targetProjs
init|=
name|targetExplained
operator|.
name|right
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|call
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|query
operator|.
name|equals
argument_list|(
name|targetInput
argument_list|)
operator|||
operator|!
name|targetCond
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|RexShuttle
name|shuttle
init|=
name|getRexShuttle
argument_list|(
name|targetProjs
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|compenProjs
decl_stmt|;
try|try
block|{
name|compenProjs
operator|=
name|shuttle
operator|.
name|apply
argument_list|(
name|rexBuilder
operator|.
name|identityProjects
argument_list|(
name|query
operator|.
name|rowType
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MatchFailed
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|RexUtil
operator|.
name|isIdentity
argument_list|(
name|compenProjs
argument_list|,
name|target
operator|.
name|rowType
argument_list|)
condition|)
block|{
return|return
name|call
operator|.
name|result
argument_list|(
name|target
argument_list|)
return|;
block|}
else|else
block|{
name|RexProgram
name|compenRexProgram
init|=
name|RexProgram
operator|.
name|create
argument_list|(
name|target
operator|.
name|rowType
argument_list|,
name|compenProjs
argument_list|,
literal|null
argument_list|,
name|query
operator|.
name|rowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|MutableCalc
name|compenCalc
init|=
name|MutableCalc
operator|.
name|of
argument_list|(
name|target
argument_list|,
name|compenRexProgram
argument_list|)
decl_stmt|;
return|return
name|tryMergeParentCalcAndGenResult
argument_list|(
name|call
argument_list|,
name|compenCalc
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * A {@link SubstitutionVisitor.UnifyRule} that matches a    * {@link MutableCalc} to a {@link MutableCalc}.    * The matching condition is as below:    * 1. All columns of query can be expressed by target;    * 2. The filtering condition of query must equals to or be weaker than target.    */
specifier|private
specifier|static
class|class
name|CalcToCalcUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|CalcToCalcUnifyRule
name|INSTANCE
init|=
operator|new
name|CalcToCalcUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|CalcToCalcUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|MutableCalc
operator|.
name|class
argument_list|,
name|query
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|operand
argument_list|(
name|MutableCalc
operator|.
name|class
argument_list|,
name|target
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|MutableCalc
name|query
init|=
operator|(
name|MutableCalc
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|queryExplained
init|=
name|explainCalc
argument_list|(
name|query
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|queryCond
init|=
name|queryExplained
operator|.
name|left
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|queryProjs
init|=
name|queryExplained
operator|.
name|right
decl_stmt|;
specifier|final
name|MutableCalc
name|target
init|=
operator|(
name|MutableCalc
operator|)
name|call
operator|.
name|target
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|targetExplained
init|=
name|explainCalc
argument_list|(
name|target
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|targetCond
init|=
name|targetExplained
operator|.
name|left
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|targetProjs
init|=
name|targetExplained
operator|.
name|right
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|call
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|RexShuttle
name|shuttle
init|=
name|getRexShuttle
argument_list|(
name|targetProjs
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|splitted
init|=
name|splitFilter
argument_list|(
name|call
operator|.
name|getSimplify
argument_list|()
argument_list|,
name|queryCond
argument_list|,
name|targetCond
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|compenCond
decl_stmt|;
if|if
condition|(
name|splitted
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|splitted
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|compenCond
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// Compensate the residual filtering condition.
name|compenCond
operator|=
name|shuttle
operator|.
name|apply
argument_list|(
name|splitted
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|implies
argument_list|(
name|call
operator|.
name|getCluster
argument_list|()
argument_list|,
name|queryCond
argument_list|,
name|targetCond
argument_list|,
name|query
operator|.
name|getInput
argument_list|()
operator|.
name|rowType
argument_list|)
condition|)
block|{
comment|// Fail to split filtering condition, but implies that target contains
comment|// all lines of query, thus just set compensating filtering condition
comment|// as the filtering condition of query.
name|compenCond
operator|=
name|shuttle
operator|.
name|apply
argument_list|(
name|queryCond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|compenProjs
init|=
name|shuttle
operator|.
name|apply
argument_list|(
name|queryProjs
argument_list|)
decl_stmt|;
if|if
condition|(
name|compenCond
operator|==
literal|null
operator|&&
name|RexUtil
operator|.
name|isIdentity
argument_list|(
name|compenProjs
argument_list|,
name|target
operator|.
name|rowType
argument_list|)
condition|)
block|{
return|return
name|call
operator|.
name|result
argument_list|(
name|target
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|RexProgram
name|compenRexProgram
init|=
name|RexProgram
operator|.
name|create
argument_list|(
name|target
operator|.
name|rowType
argument_list|,
name|compenProjs
argument_list|,
name|compenCond
argument_list|,
name|query
operator|.
name|rowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
specifier|final
name|MutableCalc
name|compenCalc
init|=
name|MutableCalc
operator|.
name|of
argument_list|(
name|target
argument_list|,
name|compenRexProgram
argument_list|)
decl_stmt|;
return|return
name|tryMergeParentCalcAndGenResult
argument_list|(
name|call
argument_list|,
name|compenCalc
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|MatchFailed
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
comment|/**    * A {@link SubstitutionVisitor.UnifyRule} that matches a {@link MutableJoin}    * which has {@link MutableCalc} as left child to a {@link MutableJoin}.    * We try to pull up the {@link MutableCalc} to top of {@link MutableJoin},    * then match the {@link MutableJoin} in query to {@link MutableJoin} in target.    */
specifier|private
specifier|static
class|class
name|JoinOnLeftCalcToJoinUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|JoinOnLeftCalcToJoinUnifyRule
name|INSTANCE
init|=
operator|new
name|JoinOnLeftCalcToJoinUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|JoinOnLeftCalcToJoinUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|MutableJoin
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|MutableCalc
operator|.
name|class
argument_list|,
name|query
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|query
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|operand
argument_list|(
name|MutableJoin
operator|.
name|class
argument_list|,
name|target
argument_list|(
literal|0
argument_list|)
argument_list|,
name|target
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|MutableJoin
name|query
init|=
operator|(
name|MutableJoin
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|MutableCalc
name|qInput0
init|=
operator|(
name|MutableCalc
operator|)
name|query
operator|.
name|getLeft
argument_list|()
decl_stmt|;
specifier|final
name|MutableRel
name|qInput1
init|=
name|query
operator|.
name|getRight
argument_list|()
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|qInput0Explained
init|=
name|explainCalc
argument_list|(
name|qInput0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|qInput0Cond
init|=
name|qInput0Explained
operator|.
name|left
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|qInput0Projs
init|=
name|qInput0Explained
operator|.
name|right
decl_stmt|;
specifier|final
name|MutableJoin
name|target
init|=
operator|(
name|MutableJoin
operator|)
name|call
operator|.
name|target
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|call
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
comment|// Check whether is same join type.
specifier|final
name|JoinRelType
name|joinRelType
init|=
name|sameJoinType
argument_list|(
name|query
operator|.
name|joinType
argument_list|,
name|target
operator|.
name|joinType
argument_list|)
decl_stmt|;
if|if
condition|(
name|joinRelType
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Check if filter under join can be pulled up.
if|if
condition|(
operator|!
name|canPullUpFilterUnderJoin
argument_list|(
name|joinRelType
argument_list|,
name|qInput0Cond
argument_list|,
literal|null
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Try pulling up MutableCalc only when Join condition references mapping.
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|identityProjects
init|=
name|rexBuilder
operator|.
name|identityProjects
argument_list|(
name|qInput1
operator|.
name|rowType
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|referenceByMapping
argument_list|(
name|query
operator|.
name|condition
argument_list|,
name|qInput0Projs
argument_list|,
name|identityProjects
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|RexNode
name|newQueryJoinCond
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
specifier|final
name|int
name|idx
init|=
name|inputRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
name|fieldCnt
argument_list|(
name|qInput0
argument_list|)
condition|)
block|{
specifier|final
name|int
name|newIdx
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|qInput0Projs
operator|.
name|get
argument_list|(
name|idx
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|newIdx
argument_list|,
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|newIdx
init|=
name|idx
operator|-
name|fieldCnt
argument_list|(
name|qInput0
argument_list|)
operator|+
name|fieldCnt
argument_list|(
name|qInput0
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|newIdx
argument_list|,
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
operator|.
name|apply
argument_list|(
name|query
operator|.
name|condition
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|splitted
init|=
name|splitFilter
argument_list|(
name|call
operator|.
name|getSimplify
argument_list|()
argument_list|,
name|newQueryJoinCond
argument_list|,
name|target
operator|.
name|condition
argument_list|)
decl_stmt|;
comment|// MutableJoin matches only when the conditions are analyzed to be same.
if|if
condition|(
name|splitted
operator|!=
literal|null
operator|&&
name|splitted
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
specifier|final
name|RexNode
name|compenCond
init|=
name|qInput0Cond
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|compenProjs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldCnt
argument_list|(
name|query
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|fieldCnt
argument_list|(
name|qInput0
argument_list|)
condition|)
block|{
name|compenProjs
operator|.
name|add
argument_list|(
name|qInput0Projs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|newIdx
init|=
name|i
operator|-
name|fieldCnt
argument_list|(
name|qInput0
argument_list|)
operator|+
name|fieldCnt
argument_list|(
name|qInput0
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
name|compenProjs
operator|.
name|add
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|newIdx
argument_list|,
name|query
operator|.
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|RexProgram
name|compenRexProgram
init|=
name|RexProgram
operator|.
name|create
argument_list|(
name|target
operator|.
name|rowType
argument_list|,
name|compenProjs
argument_list|,
name|compenCond
argument_list|,
name|query
operator|.
name|rowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
specifier|final
name|MutableCalc
name|compenCalc
init|=
name|MutableCalc
operator|.
name|of
argument_list|(
name|target
argument_list|,
name|compenRexProgram
argument_list|)
decl_stmt|;
return|return
name|tryMergeParentCalcAndGenResult
argument_list|(
name|call
argument_list|,
name|compenCalc
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * A {@link SubstitutionVisitor.UnifyRule} that matches a {@link MutableJoin}    * which has {@link MutableCalc} as right child to a {@link MutableJoin}.    * We try to pull up the {@link MutableCalc} to top of {@link MutableJoin},    * then match the {@link MutableJoin} in query to {@link MutableJoin} in target.    */
specifier|private
specifier|static
class|class
name|JoinOnRightCalcToJoinUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|JoinOnRightCalcToJoinUnifyRule
name|INSTANCE
init|=
operator|new
name|JoinOnRightCalcToJoinUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|JoinOnRightCalcToJoinUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|MutableJoin
operator|.
name|class
argument_list|,
name|query
argument_list|(
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|(
name|MutableCalc
operator|.
name|class
argument_list|,
name|query
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|operand
argument_list|(
name|MutableJoin
operator|.
name|class
argument_list|,
name|target
argument_list|(
literal|0
argument_list|)
argument_list|,
name|target
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|MutableJoin
name|query
init|=
operator|(
name|MutableJoin
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|MutableRel
name|qInput0
init|=
name|query
operator|.
name|getLeft
argument_list|()
decl_stmt|;
specifier|final
name|MutableCalc
name|qInput1
init|=
operator|(
name|MutableCalc
operator|)
name|query
operator|.
name|getRight
argument_list|()
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|qInput1Explained
init|=
name|explainCalc
argument_list|(
name|qInput1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|qInput1Cond
init|=
name|qInput1Explained
operator|.
name|left
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|qInput1Projs
init|=
name|qInput1Explained
operator|.
name|right
decl_stmt|;
specifier|final
name|MutableJoin
name|target
init|=
operator|(
name|MutableJoin
operator|)
name|call
operator|.
name|target
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|call
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
comment|// Check whether is same join type.
specifier|final
name|JoinRelType
name|joinRelType
init|=
name|sameJoinType
argument_list|(
name|query
operator|.
name|joinType
argument_list|,
name|target
operator|.
name|joinType
argument_list|)
decl_stmt|;
if|if
condition|(
name|joinRelType
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Check if filter under join can be pulled up.
if|if
condition|(
operator|!
name|canPullUpFilterUnderJoin
argument_list|(
name|joinRelType
argument_list|,
literal|null
argument_list|,
name|qInput1Cond
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Try pulling up MutableCalc only when Join condition references mapping.
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|identityProjects
init|=
name|rexBuilder
operator|.
name|identityProjects
argument_list|(
name|qInput0
operator|.
name|rowType
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|referenceByMapping
argument_list|(
name|query
operator|.
name|condition
argument_list|,
name|identityProjects
argument_list|,
name|qInput1Projs
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|RexNode
name|newQueryJoinCond
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
specifier|final
name|int
name|idx
init|=
name|inputRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
name|fieldCnt
argument_list|(
name|qInput0
argument_list|)
condition|)
block|{
return|return
name|inputRef
return|;
block|}
else|else
block|{
specifier|final
name|int
name|newIdx
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|qInput1Projs
operator|.
name|get
argument_list|(
name|idx
operator|-
name|fieldCnt
argument_list|(
name|qInput0
argument_list|)
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
operator|+
name|fieldCnt
argument_list|(
name|qInput0
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|newIdx
argument_list|,
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
operator|.
name|apply
argument_list|(
name|query
operator|.
name|condition
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|splitted
init|=
name|splitFilter
argument_list|(
name|call
operator|.
name|getSimplify
argument_list|()
argument_list|,
name|newQueryJoinCond
argument_list|,
name|target
operator|.
name|condition
argument_list|)
decl_stmt|;
comment|// MutableJoin matches only when the conditions are analyzed to be same.
if|if
condition|(
name|splitted
operator|!=
literal|null
operator|&&
name|splitted
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
specifier|final
name|RexNode
name|compenCond
init|=
name|RexUtil
operator|.
name|shift
argument_list|(
name|qInput1Cond
argument_list|,
name|qInput0
operator|.
name|rowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|compenProjs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|query
operator|.
name|rowType
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|fieldCnt
argument_list|(
name|qInput0
argument_list|)
condition|)
block|{
name|compenProjs
operator|.
name|add
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|i
argument_list|,
name|query
operator|.
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|RexNode
name|shifted
init|=
name|RexUtil
operator|.
name|shift
argument_list|(
name|qInput1Projs
operator|.
name|get
argument_list|(
name|i
operator|-
name|fieldCnt
argument_list|(
name|qInput0
argument_list|)
argument_list|)
argument_list|,
name|qInput0
operator|.
name|rowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
name|compenProjs
operator|.
name|add
argument_list|(
name|shifted
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|RexProgram
name|compensatingRexProgram
init|=
name|RexProgram
operator|.
name|create
argument_list|(
name|target
operator|.
name|rowType
argument_list|,
name|compenProjs
argument_list|,
name|compenCond
argument_list|,
name|query
operator|.
name|rowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
specifier|final
name|MutableCalc
name|compenCalc
init|=
name|MutableCalc
operator|.
name|of
argument_list|(
name|target
argument_list|,
name|compensatingRexProgram
argument_list|)
decl_stmt|;
return|return
name|tryMergeParentCalcAndGenResult
argument_list|(
name|call
argument_list|,
name|compenCalc
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * A {@link SubstitutionVisitor.UnifyRule} that matches a {@link MutableJoin}    * which has {@link MutableCalc} as children to a {@link MutableJoin}.    * We try to pull up the {@link MutableCalc} to top of {@link MutableJoin},    * then match the {@link MutableJoin} in query to {@link MutableJoin} in target.    */
specifier|private
specifier|static
class|class
name|JoinOnCalcsToJoinUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|JoinOnCalcsToJoinUnifyRule
name|INSTANCE
init|=
operator|new
name|JoinOnCalcsToJoinUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|JoinOnCalcsToJoinUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|MutableJoin
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|MutableCalc
operator|.
name|class
argument_list|,
name|query
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|operand
argument_list|(
name|MutableCalc
operator|.
name|class
argument_list|,
name|query
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|operand
argument_list|(
name|MutableJoin
operator|.
name|class
argument_list|,
name|target
argument_list|(
literal|0
argument_list|)
argument_list|,
name|target
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|MutableJoin
name|query
init|=
operator|(
name|MutableJoin
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|MutableCalc
name|qInput0
init|=
operator|(
name|MutableCalc
operator|)
name|query
operator|.
name|getLeft
argument_list|()
decl_stmt|;
specifier|final
name|MutableCalc
name|qInput1
init|=
operator|(
name|MutableCalc
operator|)
name|query
operator|.
name|getRight
argument_list|()
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|qInput0Explained
init|=
name|explainCalc
argument_list|(
name|qInput0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|qInput0Cond
init|=
name|qInput0Explained
operator|.
name|left
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|qInput0Projs
init|=
name|qInput0Explained
operator|.
name|right
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|qInput1Explained
init|=
name|explainCalc
argument_list|(
name|qInput1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|qInput1Cond
init|=
name|qInput1Explained
operator|.
name|left
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|qInput1Projs
init|=
name|qInput1Explained
operator|.
name|right
decl_stmt|;
specifier|final
name|MutableJoin
name|target
init|=
operator|(
name|MutableJoin
operator|)
name|call
operator|.
name|target
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|call
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
comment|// Check whether is same join type.
specifier|final
name|JoinRelType
name|joinRelType
init|=
name|sameJoinType
argument_list|(
name|query
operator|.
name|joinType
argument_list|,
name|target
operator|.
name|joinType
argument_list|)
decl_stmt|;
if|if
condition|(
name|joinRelType
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Check if filter under join can be pulled up.
if|if
condition|(
operator|!
name|canPullUpFilterUnderJoin
argument_list|(
name|joinRelType
argument_list|,
name|qInput0Cond
argument_list|,
name|qInput1Cond
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|referenceByMapping
argument_list|(
name|query
operator|.
name|condition
argument_list|,
name|qInput0Projs
argument_list|,
name|qInput1Projs
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|RexNode
name|newQueryJoinCond
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
specifier|final
name|int
name|idx
init|=
name|inputRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
name|fieldCnt
argument_list|(
name|qInput0
argument_list|)
condition|)
block|{
specifier|final
name|int
name|newIdx
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|qInput0Projs
operator|.
name|get
argument_list|(
name|idx
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|newIdx
argument_list|,
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|int
name|newIdx
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|qInput1Projs
operator|.
name|get
argument_list|(
name|idx
operator|-
name|fieldCnt
argument_list|(
name|qInput0
argument_list|)
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
operator|+
name|fieldCnt
argument_list|(
name|qInput0
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|newIdx
argument_list|,
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
operator|.
name|apply
argument_list|(
name|query
operator|.
name|condition
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|splitted
init|=
name|splitFilter
argument_list|(
name|call
operator|.
name|getSimplify
argument_list|()
argument_list|,
name|newQueryJoinCond
argument_list|,
name|target
operator|.
name|condition
argument_list|)
decl_stmt|;
comment|// MutableJoin matches only when the conditions are analyzed to be same.
if|if
condition|(
name|splitted
operator|!=
literal|null
operator|&&
name|splitted
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
specifier|final
name|RexNode
name|qInput1CondShifted
init|=
name|RexUtil
operator|.
name|shift
argument_list|(
name|qInput1Cond
argument_list|,
name|fieldCnt
argument_list|(
name|qInput0
operator|.
name|getInput
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|compenCond
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|qInput0Cond
argument_list|,
name|qInput1CondShifted
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|compenProjs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|query
operator|.
name|rowType
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|fieldCnt
argument_list|(
name|qInput0
argument_list|)
condition|)
block|{
name|compenProjs
operator|.
name|add
argument_list|(
name|qInput0Projs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RexNode
name|shifted
init|=
name|RexUtil
operator|.
name|shift
argument_list|(
name|qInput1Projs
operator|.
name|get
argument_list|(
name|i
operator|-
name|fieldCnt
argument_list|(
name|qInput0
argument_list|)
argument_list|)
argument_list|,
name|fieldCnt
argument_list|(
name|qInput0
operator|.
name|getInput
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|compenProjs
operator|.
name|add
argument_list|(
name|shifted
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|RexProgram
name|compensatingRexProgram
init|=
name|RexProgram
operator|.
name|create
argument_list|(
name|target
operator|.
name|rowType
argument_list|,
name|compenProjs
argument_list|,
name|compenCond
argument_list|,
name|query
operator|.
name|rowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
specifier|final
name|MutableCalc
name|compensatingCalc
init|=
name|MutableCalc
operator|.
name|of
argument_list|(
name|target
argument_list|,
name|compensatingRexProgram
argument_list|)
decl_stmt|;
return|return
name|tryMergeParentCalcAndGenResult
argument_list|(
name|call
argument_list|,
name|compensatingCalc
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * A {@link SubstitutionVisitor.UnifyRule} that matches a {@link MutableAggregate}    * which has {@link MutableCalc} as child to a {@link MutableAggregate}.    * We try to pull up the {@link MutableCalc} to top of {@link MutableAggregate},    * then match the {@link MutableAggregate} in query to {@link MutableAggregate} in target.    */
specifier|private
specifier|static
class|class
name|AggregateOnCalcToAggregateUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|AggregateOnCalcToAggregateUnifyRule
name|INSTANCE
init|=
operator|new
name|AggregateOnCalcToAggregateUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|AggregateOnCalcToAggregateUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|MutableAggregate
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|MutableCalc
operator|.
name|class
argument_list|,
name|query
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|operand
argument_list|(
name|MutableAggregate
operator|.
name|class
argument_list|,
name|target
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|MutableAggregate
name|query
init|=
operator|(
name|MutableAggregate
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|MutableCalc
name|qInput
init|=
operator|(
name|MutableCalc
operator|)
name|query
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|qInputExplained
init|=
name|explainCalc
argument_list|(
name|qInput
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|qInputCond
init|=
name|qInputExplained
operator|.
name|left
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|qInputProjs
init|=
name|qInputExplained
operator|.
name|right
decl_stmt|;
specifier|final
name|MutableAggregate
name|target
init|=
operator|(
name|MutableAggregate
operator|)
name|call
operator|.
name|target
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|call
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Project
operator|.
name|getMapping
argument_list|(
name|fieldCnt
argument_list|(
name|qInput
operator|.
name|getInput
argument_list|()
argument_list|)
argument_list|,
name|qInputProjs
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapping
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|qInputCond
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
try|try
block|{
comment|// Fail the matching when filtering condition references
comment|// non-grouping columns in target.
name|qInputCond
operator|.
name|accept
argument_list|(
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target
operator|.
name|groupSets
operator|.
name|stream
argument_list|()
operator|.
name|allMatch
argument_list|(
name|groupSet
lambda|->
name|groupSet
operator|.
name|get
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
argument_list|Util
operator|.
name|FoundOne
operator|.
name|NULL
block|;               }
return|return
name|super
operator|.
name|visitInputRef
argument_list|(
name|inputRef
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|one
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|final
name|Mapping
name|inverseMapping
init|=
name|mapping
operator|.
name|inverse
argument_list|()
decl_stmt|;
specifier|final
name|MutableAggregate
name|aggregate2
init|=
name|permute
argument_list|(
name|query
argument_list|,
name|qInput
operator|.
name|getInput
argument_list|()
argument_list|,
name|inverseMapping
argument_list|)
decl_stmt|;
specifier|final
name|Mappings
operator|.
name|TargetMapping
name|mappingForQueryCond
init|=
name|Mappings
operator|.
name|target
argument_list|(
name|target
operator|.
name|groupSet
operator|::
name|indexOf
argument_list|,
name|target
operator|.
name|getInput
argument_list|()
operator|.
name|rowType
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|target
operator|.
name|groupSet
operator|.
name|cardinality
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|targetCond
init|=
name|RexUtil
operator|.
name|apply
argument_list|(
name|mappingForQueryCond
argument_list|,
name|qInputCond
argument_list|)
decl_stmt|;
specifier|final
name|MutableRel
name|unifiedAggregate
init|=
name|unifyAggregates
argument_list|(
name|aggregate2
argument_list|,
name|targetCond
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|unifiedAggregate
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Add Project if the mapping breaks order of fields in GroupSet
if|if
condition|(
operator|!
name|Mappings
operator|.
name|keepsOrdering
argument_list|(
name|mapping
argument_list|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|posList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|aggregate2
operator|.
name|rowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|groupings
init|=
name|aggregate2
operator|.
name|groupSet
operator|.
name|toList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|groupings
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|mapping
operator|.
name|getTarget
argument_list|(
name|groupings
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|pairs
argument_list|)
expr_stmt|;
name|pairs
operator|.
name|forEach
argument_list|(
name|pair
lambda|->
name|posList
operator|.
name|add
argument_list|(
name|pair
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|posList
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|fieldCount
condition|;
name|i
operator|++
control|)
block|{
name|posList
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|compenProjs
init|=
name|MutableRels
operator|.
name|createProjectExprs
argument_list|(
name|unifiedAggregate
argument_list|,
name|posList
argument_list|)
decl_stmt|;
specifier|final
name|RexProgram
name|compensatingRexProgram
init|=
name|RexProgram
operator|.
name|create
argument_list|(
name|unifiedAggregate
operator|.
name|rowType
argument_list|,
name|compenProjs
argument_list|,
literal|null
argument_list|,
name|query
operator|.
name|rowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
specifier|final
name|MutableCalc
name|compenCalc
init|=
name|MutableCalc
operator|.
name|of
argument_list|(
name|unifiedAggregate
argument_list|,
name|compensatingRexProgram
argument_list|)
decl_stmt|;
if|if
condition|(
name|unifiedAggregate
operator|instanceof
name|MutableCalc
condition|)
block|{
specifier|final
name|MutableCalc
name|newCompenCalc
init|=
name|mergeCalc
argument_list|(
name|rexBuilder
argument_list|,
name|compenCalc
argument_list|,
operator|(
name|MutableCalc
operator|)
name|unifiedAggregate
argument_list|)
decl_stmt|;
if|if
condition|(
name|newCompenCalc
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|tryMergeParentCalcAndGenResult
argument_list|(
name|call
argument_list|,
name|newCompenCalc
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|tryMergeParentCalcAndGenResult
argument_list|(
name|call
argument_list|,
name|compenCalc
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|tryMergeParentCalcAndGenResult
argument_list|(
name|call
argument_list|,
name|unifiedAggregate
argument_list|)
return|;
block|}
block|}
block|}
comment|/** A {@link SubstitutionVisitor.UnifyRule} that matches a    * {@link org.apache.calcite.rel.core.Aggregate} to a    * {@link org.apache.calcite.rel.core.Aggregate}, provided    * that they have the same child. */
specifier|private
specifier|static
class|class
name|AggregateToAggregateUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|AggregateToAggregateUnifyRule
name|INSTANCE
init|=
operator|new
name|AggregateToAggregateUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|AggregateToAggregateUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|MutableAggregate
operator|.
name|class
argument_list|,
name|query
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|operand
argument_list|(
name|MutableAggregate
operator|.
name|class
argument_list|,
name|target
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|MutableAggregate
name|query
init|=
operator|(
name|MutableAggregate
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|MutableAggregate
name|target
init|=
operator|(
name|MutableAggregate
operator|)
name|call
operator|.
name|target
decl_stmt|;
assert|assert
name|query
operator|!=
name|target
assert|;
comment|// in.query can be rewritten in terms of in.target if its groupSet is
comment|// a subset, and its aggCalls are a superset. For example:
comment|//   query: SELECT x, COUNT(b) FROM t GROUP BY x
comment|//   target: SELECT x, y, SUM(a) AS s, COUNT(b) AS cb FROM t GROUP BY x, y
comment|// transforms to
comment|//   result: SELECT x, SUM(cb) FROM (target) GROUP BY x
if|if
condition|(
name|query
operator|.
name|getInput
argument_list|()
operator|!=
name|target
operator|.
name|getInput
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|target
operator|.
name|groupSet
operator|.
name|contains
argument_list|(
name|query
operator|.
name|groupSet
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|MutableRel
name|result
init|=
name|unifyAggregates
argument_list|(
name|query
argument_list|,
literal|null
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|tryMergeParentCalcAndGenResult
argument_list|(
name|call
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
comment|/**    * A {@link SubstitutionVisitor.UnifyRule} that matches a    * {@link MutableUnion} to a {@link MutableUnion} where the query and target    * have the same inputs but might not have the same order.    */
specifier|private
specifier|static
class|class
name|UnionToUnionUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|UnionToUnionUnifyRule
name|INSTANCE
init|=
operator|new
name|UnionToUnionUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|UnionToUnionUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|any
argument_list|(
name|MutableUnion
operator|.
name|class
argument_list|)
argument_list|,
name|any
argument_list|(
name|MutableUnion
operator|.
name|class
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|MutableUnion
name|query
init|=
operator|(
name|MutableUnion
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|MutableUnion
name|target
init|=
operator|(
name|MutableUnion
operator|)
name|call
operator|.
name|target
decl_stmt|;
specifier|final
name|List
argument_list|<
name|MutableRel
argument_list|>
name|queryInputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|query
operator|.
name|getInputs
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|MutableRel
argument_list|>
name|targetInputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|target
operator|.
name|getInputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|.
name|isAll
argument_list|()
operator|==
name|target
operator|.
name|isAll
argument_list|()
operator|&&
name|sameRelCollectionNoOrderConsidered
argument_list|(
name|queryInputs
argument_list|,
name|targetInputs
argument_list|)
condition|)
block|{
return|return
name|call
operator|.
name|result
argument_list|(
name|target
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * A {@link SubstitutionVisitor.UnifyRule} that matches a {@link MutableUnion}    * which has {@link MutableCalc} as child to a {@link MutableUnion}.    * We try to pull up the {@link MutableCalc} to top of {@link MutableUnion},    * then match the {@link MutableUnion} in query to {@link MutableUnion} in target.    */
specifier|private
specifier|static
class|class
name|UnionOnCalcsToUnionUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|UnionOnCalcsToUnionUnifyRule
name|INSTANCE
init|=
operator|new
name|UnionOnCalcsToUnionUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|UnionOnCalcsToUnionUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|any
argument_list|(
name|MutableUnion
operator|.
name|class
argument_list|)
argument_list|,
name|any
argument_list|(
name|MutableUnion
operator|.
name|class
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
return|return
name|setOpApply
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
comment|/**    * A {@link SubstitutionVisitor.UnifyRule} that matches a    * {@link MutableIntersect} to a {@link MutableIntersect} where the query and target    * have the same inputs but might not have the same order.    */
specifier|private
specifier|static
class|class
name|IntersectToIntersectUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|IntersectToIntersectUnifyRule
name|INSTANCE
init|=
operator|new
name|IntersectToIntersectUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|IntersectToIntersectUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|any
argument_list|(
name|MutableIntersect
operator|.
name|class
argument_list|)
argument_list|,
name|any
argument_list|(
name|MutableIntersect
operator|.
name|class
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|MutableIntersect
name|query
init|=
operator|(
name|MutableIntersect
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|MutableIntersect
name|target
init|=
operator|(
name|MutableIntersect
operator|)
name|call
operator|.
name|target
decl_stmt|;
specifier|final
name|List
argument_list|<
name|MutableRel
argument_list|>
name|queryInputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|query
operator|.
name|getInputs
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|MutableRel
argument_list|>
name|targetInputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|target
operator|.
name|getInputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|.
name|isAll
argument_list|()
operator|==
name|target
operator|.
name|isAll
argument_list|()
operator|&&
name|sameRelCollectionNoOrderConsidered
argument_list|(
name|queryInputs
argument_list|,
name|targetInputs
argument_list|)
condition|)
block|{
return|return
name|call
operator|.
name|result
argument_list|(
name|target
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * A {@link SubstitutionVisitor.UnifyRule} that matches a {@link MutableIntersect}    * which has {@link MutableCalc} as child to a {@link MutableIntersect}.    * We try to pull up the {@link MutableCalc} to top of {@link MutableIntersect},    * then match the {@link MutableIntersect} in query to {@link MutableIntersect} in target.    */
specifier|private
specifier|static
class|class
name|IntersectOnCalcsToIntersectUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|IntersectOnCalcsToIntersectUnifyRule
name|INSTANCE
init|=
operator|new
name|IntersectOnCalcsToIntersectUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|IntersectOnCalcsToIntersectUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|any
argument_list|(
name|MutableIntersect
operator|.
name|class
argument_list|)
argument_list|,
name|any
argument_list|(
name|MutableIntersect
operator|.
name|class
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
return|return
name|setOpApply
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
comment|/**    * Applies a AbstractUnifyRule to a particular node in a query. We try to pull up the    * {@link MutableCalc} to top of {@link MutableUnion} or {@link MutableIntersect}, this    * method not suit for {@link MutableMinus}.    *    * @param call Input parameters    */
specifier|private
specifier|static
annotation|@
name|Nullable
name|UnifyResult
name|setOpApply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|query
operator|instanceof
name|MutableMinus
operator|&&
name|call
operator|.
name|target
operator|instanceof
name|MutableMinus
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|MutableSetOp
name|query
init|=
operator|(
name|MutableSetOp
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|MutableSetOp
name|target
init|=
operator|(
name|MutableSetOp
operator|)
name|call
operator|.
name|target
decl_stmt|;
specifier|final
name|List
argument_list|<
name|MutableCalc
argument_list|>
name|queryInputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|MutableRel
argument_list|>
name|queryGrandInputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|MutableRel
argument_list|>
name|targetInputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|target
operator|.
name|getInputs
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|call
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|MutableRel
name|rel
range|:
name|query
operator|.
name|getInputs
argument_list|()
control|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|MutableCalc
condition|)
block|{
name|queryInputs
operator|.
name|add
argument_list|(
operator|(
name|MutableCalc
operator|)
name|rel
argument_list|)
expr_stmt|;
name|queryGrandInputs
operator|.
name|add
argument_list|(
operator|(
operator|(
name|MutableCalc
operator|)
name|rel
operator|)
operator|.
name|getInput
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
if|if
condition|(
name|query
operator|.
name|isAll
argument_list|()
operator|&&
name|target
operator|.
name|isAll
argument_list|()
operator|&&
name|sameRelCollectionNoOrderConsidered
argument_list|(
name|queryGrandInputs
argument_list|,
name|targetInputs
argument_list|)
condition|)
block|{
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|queryInputExplained0
init|=
name|explainCalc
argument_list|(
name|queryInputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|queryGrandInputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|queryInputExplained
init|=
name|explainCalc
argument_list|(
name|queryInputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
comment|// Matching fails when filtering conditions are not equal or projects are not equal.
name|RexNode
name|residue
init|=
name|splitFilter
argument_list|(
name|call
operator|.
name|getSimplify
argument_list|()
argument_list|,
name|queryInputExplained0
operator|.
name|left
argument_list|,
name|queryInputExplained
operator|.
name|left
argument_list|)
decl_stmt|;
if|if
condition|(
name|residue
operator|==
literal|null
operator|||
operator|!
name|residue
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|queryInputExplained0
operator|.
name|right
argument_list|,
name|queryInputExplained
operator|.
name|right
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|pair
operator|.
name|left
operator|.
name|equals
argument_list|(
name|pair
operator|.
name|right
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|projectExprs
init|=
name|MutableRels
operator|.
name|createProjects
argument_list|(
name|target
argument_list|,
name|queryInputExplained0
operator|.
name|right
argument_list|)
decl_stmt|;
specifier|final
name|RexProgram
name|compenRexProgram
init|=
name|RexProgram
operator|.
name|create
argument_list|(
name|target
operator|.
name|rowType
argument_list|,
name|projectExprs
argument_list|,
name|queryInputExplained0
operator|.
name|left
argument_list|,
name|query
operator|.
name|rowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
specifier|final
name|MutableCalc
name|compenCalc
init|=
name|MutableCalc
operator|.
name|of
argument_list|(
name|target
argument_list|,
name|compenRexProgram
argument_list|)
decl_stmt|;
return|return
name|tryMergeParentCalcAndGenResult
argument_list|(
name|call
argument_list|,
name|compenCalc
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Check if list0 and list1 contains the same nodes -- order is not considered. */
specifier|private
specifier|static
name|boolean
name|sameRelCollectionNoOrderConsidered
parameter_list|(
name|List
argument_list|<
name|MutableRel
argument_list|>
name|list0
parameter_list|,
name|List
argument_list|<
name|MutableRel
argument_list|>
name|list1
parameter_list|)
block|{
if|if
condition|(
name|list0
operator|.
name|size
argument_list|()
operator|!=
name|list1
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|MutableRel
name|rel
range|:
name|list0
control|)
block|{
name|int
name|index
init|=
name|list1
operator|.
name|indexOf
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|list1
operator|.
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|int
name|fieldCnt
parameter_list|(
name|MutableRel
name|rel
parameter_list|)
block|{
return|return
name|rel
operator|.
name|rowType
operator|.
name|getFieldCount
argument_list|()
return|;
block|}
comment|/** Explain filtering condition and projections from MutableCalc. */
specifier|private
specifier|static
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|explainCalc
parameter_list|(
name|MutableCalc
name|calc
parameter_list|)
block|{
specifier|final
name|RexShuttle
name|shuttle
init|=
name|getExpandShuttle
argument_list|(
name|calc
operator|.
name|program
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|condition
init|=
name|shuttle
operator|.
name|apply
argument_list|(
name|calc
operator|.
name|program
operator|.
name|getCondition
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|rex
range|:
name|shuttle
operator|.
name|apply
argument_list|(
name|calc
operator|.
name|program
operator|.
name|getProjectList
argument_list|()
argument_list|)
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|rex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|calc
operator|.
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|projects
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|condition
argument_list|,
name|projects
argument_list|)
return|;
block|}
block|}
comment|/**    * Generate result by merging parent and child if they are both MutableCalc.    * Otherwise result is the child itself.    */
specifier|private
specifier|static
name|UnifyResult
name|tryMergeParentCalcAndGenResult
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|,
name|MutableRel
name|child
parameter_list|)
block|{
specifier|final
name|MutableRel
name|parent
init|=
name|call
operator|.
name|query
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|MutableCalc
operator|&&
name|parent
operator|instanceof
name|MutableCalc
condition|)
block|{
specifier|final
name|MutableCalc
name|mergedCalc
init|=
name|mergeCalc
argument_list|(
name|call
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
operator|(
name|MutableCalc
operator|)
name|parent
argument_list|,
operator|(
name|MutableCalc
operator|)
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergedCalc
operator|!=
literal|null
condition|)
block|{
comment|// Note that property of stopTrying in the result is false
comment|// and this query node deserves further matching iterations.
return|return
name|call
operator|.
name|create
argument_list|(
name|parent
argument_list|)
operator|.
name|result
argument_list|(
name|mergedCalc
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
return|return
name|call
operator|.
name|result
argument_list|(
name|child
argument_list|)
return|;
block|}
comment|/** Merge two MutableCalc together. */
specifier|private
specifier|static
annotation|@
name|Nullable
name|MutableCalc
name|mergeCalc
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|MutableCalc
name|topCalc
parameter_list|,
name|MutableCalc
name|bottomCalc
parameter_list|)
block|{
name|RexProgram
name|topProgram
init|=
name|topCalc
operator|.
name|program
decl_stmt|;
if|if
condition|(
name|RexOver
operator|.
name|containsOver
argument_list|(
name|topProgram
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|RexProgram
name|mergedProgram
init|=
name|RexProgramBuilder
operator|.
name|mergePrograms
argument_list|(
name|topCalc
operator|.
name|program
argument_list|,
name|bottomCalc
operator|.
name|program
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
assert|assert
name|mergedProgram
operator|.
name|getOutputRowType
argument_list|()
operator|==
name|topProgram
operator|.
name|getOutputRowType
argument_list|()
assert|;
return|return
name|MutableCalc
operator|.
name|of
argument_list|(
name|bottomCalc
operator|.
name|getInput
argument_list|()
argument_list|,
name|mergedProgram
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexShuttle
name|getExpandShuttle
parameter_list|(
name|RexProgram
name|rexProgram
parameter_list|)
block|{
return|return
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
return|return
name|rexProgram
operator|.
name|expandLocalRef
argument_list|(
name|localRef
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Check if condition cond0 implies cond1. */
specifier|private
specifier|static
name|boolean
name|implies
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RexNode
name|cond0
parameter_list|,
name|RexNode
name|cond1
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
block|{
name|RexExecutor
name|rexImpl
init|=
name|Util
operator|.
name|first
argument_list|(
name|cluster
operator|.
name|getPlanner
argument_list|()
operator|.
name|getExecutor
argument_list|()
argument_list|,
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
decl_stmt|;
name|RexImplicationChecker
name|rexImplicationChecker
init|=
operator|new
name|RexImplicationChecker
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|rexImpl
argument_list|,
name|rowType
argument_list|)
decl_stmt|;
return|return
name|rexImplicationChecker
operator|.
name|implies
argument_list|(
name|cond0
argument_list|,
name|cond1
argument_list|)
return|;
block|}
comment|/** Check if join condition only references RexInputRef. */
specifier|private
specifier|static
name|boolean
name|referenceByMapping
parameter_list|(
name|RexNode
name|joinCondition
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
modifier|...
name|projectsOfInputs
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|projectsOfInput
range|:
name|projectsOfInputs
control|)
block|{
name|projects
operator|.
name|addAll
argument_list|(
name|projectsOfInput
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|RexVisitor
name|rexVisitor
init|=
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|projects
operator|.
name|get
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
return|return
name|super
operator|.
name|visitInputRef
argument_list|(
name|inputRef
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|joinCondition
operator|.
name|accept
argument_list|(
name|rexVisitor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
annotation|@
name|Nullable
name|JoinRelType
name|sameJoinType
parameter_list|(
name|JoinRelType
name|type0
parameter_list|,
name|JoinRelType
name|type1
parameter_list|)
block|{
if|if
condition|(
name|type0
operator|==
name|type1
condition|)
block|{
return|return
name|type0
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
name|MutableAggregate
name|permute
parameter_list|(
name|MutableAggregate
name|aggregate
parameter_list|,
name|MutableRel
name|input
parameter_list|,
name|Mapping
name|mapping
parameter_list|)
block|{
name|ImmutableBitSet
name|groupSet
init|=
name|Mappings
operator|.
name|apply
argument_list|(
name|mapping
argument_list|,
name|aggregate
operator|.
name|groupSet
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
init|=
name|Mappings
operator|.
name|apply2
argument_list|(
name|mapping
argument_list|,
name|aggregate
operator|.
name|groupSets
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
init|=
name|Util
operator|.
name|transform
argument_list|(
name|aggregate
operator|.
name|aggCalls
argument_list|,
name|call
lambda|->
name|call
operator|.
name|transform
argument_list|(
name|mapping
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|MutableAggregate
operator|.
name|of
argument_list|(
name|input
argument_list|,
name|groupSet
argument_list|,
name|groupSets
argument_list|,
name|aggregateCalls
argument_list|)
return|;
block|}
specifier|public
specifier|static
annotation|@
name|Nullable
name|MutableRel
name|unifyAggregates
parameter_list|(
name|MutableAggregate
name|query
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|targetCond
parameter_list|,
name|MutableAggregate
name|target
parameter_list|)
block|{
name|MutableRel
name|result
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|query
operator|.
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|targetCondConstantMap
init|=
name|RexUtil
operator|.
name|predicateConstants
argument_list|(
name|RexNode
operator|.
name|class
argument_list|,
name|rexBuilder
argument_list|,
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|targetCond
argument_list|)
argument_list|)
decl_stmt|;
comment|// Collect rexInputRef in constant filter condition.
name|Set
argument_list|<
name|Integer
argument_list|>
name|constantCondInputRefs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|targetGroupByIndexList
init|=
name|target
operator|.
name|groupSet
operator|.
name|asList
argument_list|()
decl_stmt|;
name|RexShuttle
name|rexShuttle
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|constantCondInputRefs
operator|.
name|add
argument_list|(
name|targetGroupByIndexList
operator|.
name|get
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|visitInputRef
argument_list|(
name|inputRef
argument_list|)
return|;
block|}
block|}
decl_stmt|;
for|for
control|(
name|RexNode
name|rexNode
range|:
name|targetCondConstantMap
operator|.
name|keySet
argument_list|()
control|)
block|{
name|rexNode
operator|.
name|accept
argument_list|(
name|rexShuttle
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|Integer
argument_list|>
name|compenGroupSet
init|=
literal|null
decl_stmt|;
comment|// Calc the missing group list of query, do not cover grouping sets cases.
if|if
condition|(
name|query
operator|.
name|groupSets
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|target
operator|.
name|groupSets
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|target
operator|.
name|groupSet
operator|.
name|contains
argument_list|(
name|query
operator|.
name|groupSet
argument_list|)
condition|)
block|{
name|compenGroupSet
operator|=
name|target
operator|.
name|groupSets
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|except
argument_list|(
name|query
operator|.
name|groupSets
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|asSet
argument_list|()
expr_stmt|;
block|}
block|}
comment|// If query and target have the same group list,
comment|// or query has constant filter for missing columns in group by list.
if|if
condition|(
name|query
operator|.
name|groupSets
operator|.
name|equals
argument_list|(
name|target
operator|.
name|groupSets
argument_list|)
operator|||
operator|(
name|compenGroupSet
operator|!=
literal|null
operator|&&
name|constantCondInputRefs
operator|.
name|containsAll
argument_list|(
name|compenGroupSet
argument_list|)
operator|)
condition|)
block|{
name|int
name|projOffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|query
operator|.
name|groupSets
operator|.
name|equals
argument_list|(
name|target
operator|.
name|groupSets
argument_list|)
condition|)
block|{
name|projOffset
operator|=
name|requireNonNull
argument_list|(
name|compenGroupSet
argument_list|,
literal|"compenGroupSet"
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|// Same level of aggregation. Generate a project.
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|groupCount
init|=
name|query
operator|.
name|groupSet
operator|.
name|cardinality
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|inputIndex
range|:
name|query
operator|.
name|groupSet
operator|.
name|asList
argument_list|()
control|)
block|{
comment|// Use the index in target group by.
name|int
name|i
init|=
name|targetGroupByIndexList
operator|.
name|indexOf
argument_list|(
name|inputIndex
argument_list|)
decl_stmt|;
name|projects
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|AggregateCall
name|aggregateCall
range|:
name|query
operator|.
name|aggCalls
control|)
block|{
name|int
name|i
init|=
name|target
operator|.
name|aggCalls
operator|.
name|indexOf
argument_list|(
name|aggregateCall
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|projects
operator|.
name|add
argument_list|(
name|groupCount
operator|+
name|i
operator|+
name|projOffset
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|compenProjs
init|=
name|MutableRels
operator|.
name|createProjectExprs
argument_list|(
name|target
argument_list|,
name|projects
argument_list|)
decl_stmt|;
name|RexProgram
name|compenRexProgram
init|=
name|RexProgram
operator|.
name|create
argument_list|(
name|target
operator|.
name|rowType
argument_list|,
name|compenProjs
argument_list|,
name|targetCond
argument_list|,
name|query
operator|.
name|rowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|result
operator|=
name|MutableCalc
operator|.
name|of
argument_list|(
name|target
argument_list|,
name|compenRexProgram
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|target
operator|.
name|getGroupType
argument_list|()
operator|==
name|Aggregate
operator|.
name|Group
operator|.
name|SIMPLE
condition|)
block|{
comment|// Query is coarser level of aggregation. Generate an aggregate.
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|target
operator|.
name|groupSet
operator|.
name|forEach
argument_list|(
name|k
lambda|->
name|map
operator|.
name|put
argument_list|(
name|k
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
range|:
name|query
operator|.
name|groupSet
control|)
block|{
if|if
condition|(
operator|!
name|map
operator|.
name|containsKey
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|final
name|ImmutableBitSet
name|groupSet
init|=
name|query
operator|.
name|groupSet
operator|.
name|permute
argument_list|(
name|map
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|query
operator|.
name|getGroupType
argument_list|()
operator|!=
name|Aggregate
operator|.
name|Group
operator|.
name|SIMPLE
condition|)
block|{
name|groupSets
operator|=
name|ImmutableBitSet
operator|.
name|ORDERING
operator|.
name|immutableSortedCopy
argument_list|(
name|ImmutableBitSet
operator|.
name|permute
argument_list|(
name|query
operator|.
name|groupSets
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|aggregateCall
range|:
name|query
operator|.
name|aggCalls
control|)
block|{
if|if
condition|(
name|aggregateCall
operator|.
name|isDistinct
argument_list|()
operator|&&
name|aggregateCall
operator|.
name|getArgList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
specifier|final
name|int
name|aggIndex
init|=
name|aggregateCall
operator|.
name|getArgList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|int
name|newIndex
init|=
name|targetGroupByIndexList
operator|.
name|indexOf
argument_list|(
name|aggIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|newIndex
operator|>=
literal|0
condition|)
block|{
name|aggregateCalls
operator|.
name|add
argument_list|(
name|AggregateCall
operator|.
name|create
argument_list|(
name|aggregateCall
operator|.
name|getAggregation
argument_list|()
argument_list|,
name|aggregateCall
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|aggregateCall
operator|.
name|isApproximate
argument_list|()
argument_list|,
name|aggregateCall
operator|.
name|ignoreNulls
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|newIndex
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|aggregateCall
operator|.
name|distinctKeys
argument_list|,
name|aggregateCall
operator|.
name|collation
argument_list|,
name|aggregateCall
operator|.
name|type
argument_list|,
name|aggregateCall
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
return|return
literal|null
return|;
block|}
name|int
name|i
init|=
name|target
operator|.
name|aggCalls
operator|.
name|indexOf
argument_list|(
name|aggregateCall
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// When an SqlAggFunction does not support roll up, it will return null, which means that
comment|// it cannot do secondary aggregation and the materialization recognition will fail.
specifier|final
name|SqlAggFunction
name|aggFunction
init|=
name|aggregateCall
operator|.
name|getAggregation
argument_list|()
operator|.
name|getRollup
argument_list|()
decl_stmt|;
if|if
condition|(
name|aggFunction
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|aggregateCalls
operator|.
name|add
argument_list|(
name|AggregateCall
operator|.
name|create
argument_list|(
name|aggFunction
argument_list|,
name|aggregateCall
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|aggregateCall
operator|.
name|isApproximate
argument_list|()
argument_list|,
name|aggregateCall
operator|.
name|ignoreNulls
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|target
operator|.
name|groupSet
operator|.
name|cardinality
argument_list|()
operator|+
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|aggregateCall
operator|.
name|distinctKeys
argument_list|,
name|aggregateCall
operator|.
name|collation
argument_list|,
name|aggregateCall
operator|.
name|type
argument_list|,
name|aggregateCall
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetCond
operator|!=
literal|null
operator|&&
operator|!
name|targetCond
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|RexProgram
name|compenRexProgram
init|=
name|RexProgram
operator|.
name|create
argument_list|(
name|target
operator|.
name|rowType
argument_list|,
name|rexBuilder
operator|.
name|identityProjects
argument_list|(
name|target
operator|.
name|rowType
argument_list|)
argument_list|,
name|targetCond
argument_list|,
name|target
operator|.
name|rowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|result
operator|=
name|MutableAggregate
operator|.
name|of
argument_list|(
name|MutableCalc
operator|.
name|of
argument_list|(
name|target
argument_list|,
name|compenRexProgram
argument_list|)
argument_list|,
name|groupSet
argument_list|,
name|groupSets
argument_list|,
name|aggregateCalls
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|MutableAggregate
operator|.
name|of
argument_list|(
name|target
argument_list|,
name|groupSet
argument_list|,
name|groupSets
argument_list|,
name|aggregateCalls
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
annotation|@
name|Nullable
name|SqlAggFunction
name|getRollup
parameter_list|(
name|SqlAggFunction
name|aggregation
parameter_list|)
block|{
if|if
condition|(
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|SUM
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|MIN
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|MAX
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|SOME
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|EVERY
operator|||
name|aggregation
operator|==
name|SqlLibraryOperators
operator|.
name|BOOL_AND
operator|||
name|aggregation
operator|==
name|SqlLibraryOperators
operator|.
name|BOOL_OR
operator|||
name|aggregation
operator|==
name|SqlLibraryOperators
operator|.
name|LOGICAL_AND
operator|||
name|aggregation
operator|==
name|SqlLibraryOperators
operator|.
name|LOGICAL_OR
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|SUM0
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|ANY_VALUE
condition|)
block|{
return|return
name|aggregation
return|;
block|}
if|else if
condition|(
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|COUNT
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|SUM0
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** Builds a shuttle that stores a list of expressions, and can map incoming    * expressions to references to them. */
specifier|private
specifier|static
name|RexShuttle
name|getRexShuttle
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexNodes
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rexNodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexNode
name|rexNode
init|=
name|rexNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|.
name|containsKey
argument_list|(
name|rexNode
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|map
operator|.
name|put
argument_list|(
name|rexNode
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|ref
parameter_list|)
block|{
specifier|final
name|Integer
name|integer
init|=
name|map
operator|.
name|get
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|integer
argument_list|,
name|ref
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
throw|throw
name|MatchFailed
operator|.
name|INSTANCE
throw|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
specifier|final
name|Integer
name|integer
init|=
name|map
operator|.
name|get
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|integer
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
specifier|final
name|Integer
name|integer
init|=
name|map
operator|.
name|get
argument_list|(
name|literal
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|integer
argument_list|,
name|literal
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|visitLiteral
argument_list|(
name|literal
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Returns if one rel is weaker than another. */
specifier|protected
name|boolean
name|isWeaker
parameter_list|(
name|MutableRel
name|rel0
parameter_list|,
name|MutableRel
name|rel
parameter_list|)
block|{
if|if
condition|(
name|rel0
operator|==
name|rel
operator|||
name|equivalents
operator|.
name|get
argument_list|(
name|rel0
argument_list|)
operator|.
name|contains
argument_list|(
name|rel
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|rel0
operator|instanceof
name|MutableFilter
operator|)
operator|||
operator|!
operator|(
name|rel
operator|instanceof
name|MutableFilter
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|rel
operator|.
name|rowType
operator|.
name|equals
argument_list|(
name|rel0
operator|.
name|rowType
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|MutableRel
name|rel0input
init|=
operator|(
operator|(
name|MutableFilter
operator|)
name|rel0
operator|)
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|MutableRel
name|relinput
init|=
operator|(
operator|(
name|MutableFilter
operator|)
name|rel
operator|)
operator|.
name|getInput
argument_list|()
decl_stmt|;
if|if
condition|(
name|rel0input
operator|!=
name|relinput
operator|&&
operator|!
name|equivalents
operator|.
name|get
argument_list|(
name|rel0input
argument_list|)
operator|.
name|contains
argument_list|(
name|relinput
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|implies
argument_list|(
name|rel0
operator|.
name|cluster
argument_list|,
operator|(
operator|(
name|MutableFilter
operator|)
name|rel0
operator|)
operator|.
name|condition
argument_list|,
operator|(
operator|(
name|MutableFilter
operator|)
name|rel
operator|)
operator|.
name|condition
argument_list|,
name|rel
operator|.
name|rowType
argument_list|)
return|;
block|}
comment|/** Returns whether two relational expressions have the same row-type. */
specifier|public
specifier|static
name|boolean
name|equalType
parameter_list|(
name|String
name|desc0
parameter_list|,
name|MutableRel
name|rel0
parameter_list|,
name|String
name|desc1
parameter_list|,
name|MutableRel
name|rel1
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
return|return
name|RelOptUtil
operator|.
name|equal
argument_list|(
name|desc0
argument_list|,
name|rel0
operator|.
name|rowType
argument_list|,
name|desc1
argument_list|,
name|rel1
operator|.
name|rowType
argument_list|,
name|litmus
argument_list|)
return|;
block|}
comment|/**    * Check if filter under join can be pulled up,    * when meeting JoinOnCalc of query unify to Join of target.    * Working in rules: {@link JoinOnLeftCalcToJoinUnifyRule}<br/>    * {@link JoinOnRightCalcToJoinUnifyRule}<br/>    * {@link JoinOnCalcsToJoinUnifyRule}<br/>    */
specifier|private
specifier|static
name|boolean
name|canPullUpFilterUnderJoin
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|leftFilterRexNode
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|rightFilterRexNode
parameter_list|)
block|{
if|if
condition|(
name|joinType
operator|==
name|JoinRelType
operator|.
name|INNER
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|joinType
operator|==
name|JoinRelType
operator|.
name|LEFT
operator|&&
operator|(
name|rightFilterRexNode
operator|==
literal|null
operator|||
name|rightFilterRexNode
operator|.
name|isAlwaysTrue
argument_list|()
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|joinType
operator|==
name|JoinRelType
operator|.
name|RIGHT
operator|&&
operator|(
name|leftFilterRexNode
operator|==
literal|null
operator|||
name|leftFilterRexNode
operator|.
name|isAlwaysTrue
argument_list|()
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|joinType
operator|==
name|JoinRelType
operator|.
name|FULL
operator|&&
operator|(
operator|(
name|rightFilterRexNode
operator|==
literal|null
operator|||
name|rightFilterRexNode
operator|.
name|isAlwaysTrue
argument_list|()
operator|)
operator|&&
operator|(
name|leftFilterRexNode
operator|==
literal|null
operator|||
name|leftFilterRexNode
operator|.
name|isAlwaysTrue
argument_list|()
operator|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Operand to a {@link UnifyRule}. */
specifier|protected
specifier|abstract
specifier|static
class|class
name|Operand
block|{
specifier|protected
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|MutableRel
argument_list|>
name|clazz
decl_stmt|;
specifier|protected
name|Operand
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|MutableRel
argument_list|>
name|clazz
parameter_list|)
block|{
name|this
operator|.
name|clazz
operator|=
name|clazz
expr_stmt|;
block|}
specifier|public
specifier|abstract
name|boolean
name|matches
parameter_list|(
name|SubstitutionVisitor
name|visitor
parameter_list|,
name|MutableRel
name|rel
parameter_list|)
function_decl|;
specifier|public
name|boolean
name|isWeaker
parameter_list|(
name|SubstitutionVisitor
name|visitor
parameter_list|,
name|MutableRel
name|rel
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/** Operand to a {@link UnifyRule} that matches a relational expression of a    * given type. It has zero or more child operands. */
specifier|private
specifier|static
class|class
name|InternalOperand
extends|extends
name|Operand
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|Operand
argument_list|>
name|inputs
decl_stmt|;
name|InternalOperand
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|MutableRel
argument_list|>
name|clazz
parameter_list|,
name|List
argument_list|<
name|Operand
argument_list|>
name|inputs
parameter_list|)
block|{
name|super
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputs
operator|=
name|inputs
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|SubstitutionVisitor
name|visitor
parameter_list|,
name|MutableRel
name|rel
parameter_list|)
block|{
return|return
name|clazz
operator|.
name|isInstance
argument_list|(
name|rel
argument_list|)
operator|&&
name|allMatch
argument_list|(
name|visitor
argument_list|,
name|inputs
argument_list|,
name|rel
operator|.
name|getInputs
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isWeaker
parameter_list|(
name|SubstitutionVisitor
name|visitor
parameter_list|,
name|MutableRel
name|rel
parameter_list|)
block|{
return|return
name|clazz
operator|.
name|isInstance
argument_list|(
name|rel
argument_list|)
operator|&&
name|allWeaker
argument_list|(
name|visitor
argument_list|,
name|inputs
argument_list|,
name|rel
operator|.
name|getInputs
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|allMatch
parameter_list|(
name|SubstitutionVisitor
name|visitor
parameter_list|,
name|List
argument_list|<
name|Operand
argument_list|>
name|operands
parameter_list|,
name|List
argument_list|<
name|MutableRel
argument_list|>
name|rels
parameter_list|)
block|{
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|!=
name|rels
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|Operand
argument_list|,
name|MutableRel
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|operands
argument_list|,
name|rels
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|pair
operator|.
name|left
operator|.
name|matches
argument_list|(
name|visitor
argument_list|,
name|pair
operator|.
name|right
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|boolean
name|allWeaker
parameter_list|(
name|SubstitutionVisitor
name|visitor
parameter_list|,
name|List
argument_list|<
name|Operand
argument_list|>
name|operands
parameter_list|,
name|List
argument_list|<
name|MutableRel
argument_list|>
name|rels
parameter_list|)
block|{
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|!=
name|rels
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|Operand
argument_list|,
name|MutableRel
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|operands
argument_list|,
name|rels
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|pair
operator|.
name|left
operator|.
name|isWeaker
argument_list|(
name|visitor
argument_list|,
name|pair
operator|.
name|right
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/** Operand to a {@link UnifyRule} that matches a relational expression of a    * given type. */
specifier|private
specifier|static
class|class
name|AnyOperand
extends|extends
name|Operand
block|{
name|AnyOperand
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|MutableRel
argument_list|>
name|clazz
parameter_list|)
block|{
name|super
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|SubstitutionVisitor
name|visitor
parameter_list|,
name|MutableRel
name|rel
parameter_list|)
block|{
return|return
name|clazz
operator|.
name|isInstance
argument_list|(
name|rel
argument_list|)
return|;
block|}
block|}
comment|/** Operand that assigns a particular relational expression to a variable.    *    *<p>It is applied to a descendant of the query, writes the operand into the    * slots array, and always matches.    * There is a corresponding operand of type {@link TargetOperand} that checks    * whether its relational expression, a descendant of the target, is    * equivalent to this {@code QueryOperand}'s relational expression.    */
specifier|private
specifier|static
class|class
name|QueryOperand
extends|extends
name|Operand
block|{
specifier|private
specifier|final
name|int
name|ordinal
decl_stmt|;
specifier|protected
name|QueryOperand
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
name|super
argument_list|(
name|MutableRel
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|SubstitutionVisitor
name|visitor
parameter_list|,
name|MutableRel
name|rel
parameter_list|)
block|{
name|visitor
operator|.
name|slots
index|[
name|ordinal
index|]
operator|=
name|rel
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/** Operand that checks that a relational expression matches the corresponding    * relational expression that was passed to a {@link QueryOperand}. */
specifier|private
specifier|static
class|class
name|TargetOperand
extends|extends
name|Operand
block|{
specifier|private
specifier|final
name|int
name|ordinal
decl_stmt|;
specifier|protected
name|TargetOperand
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
name|super
argument_list|(
name|MutableRel
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|SubstitutionVisitor
name|visitor
parameter_list|,
name|MutableRel
name|rel
parameter_list|)
block|{
specifier|final
name|MutableRel
name|rel0
init|=
name|visitor
operator|.
name|slots
index|[
name|ordinal
index|]
decl_stmt|;
assert|assert
name|rel0
operator|!=
literal|null
operator|:
literal|"QueryOperand should have been called first"
assert|;
return|return
name|rel0
operator|==
name|rel
operator|||
name|visitor
operator|.
name|equivalents
operator|.
name|get
argument_list|(
name|rel0
argument_list|)
operator|.
name|contains
argument_list|(
name|rel
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isWeaker
parameter_list|(
name|SubstitutionVisitor
name|visitor
parameter_list|,
name|MutableRel
name|rel
parameter_list|)
block|{
specifier|final
name|MutableRel
name|rel0
init|=
name|visitor
operator|.
name|slots
index|[
name|ordinal
index|]
decl_stmt|;
assert|assert
name|rel0
operator|!=
literal|null
operator|:
literal|"QueryOperand should have been called first"
assert|;
return|return
name|visitor
operator|.
name|isWeaker
argument_list|(
name|rel0
argument_list|,
name|rel
argument_list|)
return|;
block|}
block|}
comment|/** Visitor that counts how many {@link QueryOperand} and    * {@link TargetOperand} in an operand tree. */
specifier|private
specifier|static
class|class
name|SlotCounter
block|{
name|int
name|queryCount
decl_stmt|;
name|int
name|targetCount
decl_stmt|;
name|void
name|visit
parameter_list|(
name|Operand
name|operand
parameter_list|)
block|{
if|if
condition|(
name|operand
operator|instanceof
name|QueryOperand
condition|)
block|{
operator|++
name|queryCount
expr_stmt|;
block|}
if|else if
condition|(
name|operand
operator|instanceof
name|TargetOperand
condition|)
block|{
operator|++
name|targetCount
expr_stmt|;
block|}
if|else if
condition|(
name|operand
operator|instanceof
name|AnyOperand
condition|)
block|{
comment|// nothing
block|}
else|else
block|{
for|for
control|(
name|Operand
name|input
range|:
operator|(
operator|(
name|InternalOperand
operator|)
name|operand
operator|)
operator|.
name|inputs
control|)
block|{
name|visit
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

