begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|Spaces
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteSystemProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Expressions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|AbstractRelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Convention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|ConventionTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCostFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptLattice
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptMaterialization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptMaterializations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleOperand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTrait
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|convert
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|convert
operator|.
name|ConverterRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|externalize
operator|.
name|RelWriterImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|JaninoRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Hook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|PartiallyOrderedSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedHashMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|SetMultimap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  * VolcanoPlanner optimizes queries by transforming expressions selectively  * according to a dynamic programming algorithm.  */
end_comment

begin_class
specifier|public
class|class
name|VolcanoPlanner
extends|extends
name|AbstractRelOptPlanner
block|{
specifier|protected
specifier|static
specifier|final
name|double
name|COST_IMPROVEMENT
init|=
literal|.5
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|protected
name|RelSubset
name|root
decl_stmt|;
comment|/**    * If true, the planner keeps applying rules as long as they continue to    * reduce the cost. If false, the planner terminates as soon as it has found    * any implementation, no matter how expensive.    */
specifier|protected
name|boolean
name|ambitious
init|=
literal|true
decl_stmt|;
comment|/**    * If true, and if {@link #ambitious} is true, the planner waits a finite    * number of iterations for the cost to improve.    *    *<p>The number of iterations K is equal to the number of iterations    * required to get the first finite plan. After the first finite plan, it    * continues to fire rules to try to improve it. The planner sets a target    * cost of the current best cost multiplied by {@link #COST_IMPROVEMENT}. If    * it does not meet that cost target within K steps, it quits, and uses the    * current best plan. If it meets the cost, it sets a new, lower target, and    * has another K iterations to meet it. And so forth.    *    *<p>If false, the planner continues to fire rules until the rule queue is    * empty.    */
specifier|protected
name|boolean
name|impatient
init|=
literal|false
decl_stmt|;
comment|/**    * Operands that apply to a given class of {@link RelNode}.    *    *<p>Any operand can be an 'entry point' to a rule call, when a RelNode is    * registered which matches the operand. This map allows us to narrow down    * operands based on the class of the RelNode.</p>    */
specifier|private
specifier|final
name|Multimap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|RelOptRuleOperand
argument_list|>
name|classOperands
init|=
name|LinkedListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
comment|/**    * List of all sets. Used only for debugging.    */
specifier|final
name|List
argument_list|<
name|RelSet
argument_list|>
name|allSets
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Canonical map from {@link String digest} to the unique    * {@link RelNode relational expression} with that digest.    *    *<p>Row type is part of the key for the rare occasion that similar    * expressions have different types, e.g. variants of    * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a    * null VARCHAR(10).    */
specifier|private
specifier|final
name|Map
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|,
name|RelNode
argument_list|>
name|mapDigestToRel
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Map each registered expression ({@link RelNode}) to its equivalence set    * ({@link RelSubset}).    *    *<p>We use an {@link IdentityHashMap} to simplify the process of merging    * {@link RelSet} objects. Most {@link RelNode} objects are identified by    * their digest, which involves the set that their child relational    * expressions belong to. If those children belong to the same set, we have    * to be careful, otherwise it gets incestuous.</p>    */
specifier|private
specifier|final
name|IdentityHashMap
argument_list|<
name|RelNode
argument_list|,
name|RelSubset
argument_list|>
name|mapRel2Subset
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * The importance of relational expressions.    *    *<p>The map contains only RelNodes whose importance has been overridden    * using {@link RelOptPlanner#setImportance(RelNode, double)}. Other    * RelNodes are presumed to have 'normal' importance.    *    *<p>If a RelNode has 0 importance, all {@link RelOptRuleCall}s using it    * are ignored, and future RelOptRuleCalls are not queued up.    */
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Double
argument_list|>
name|relImportances
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * List of all schemas which have been registered.    */
specifier|private
specifier|final
name|Set
argument_list|<
name|RelOptSchema
argument_list|>
name|registeredSchemas
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Holds rule calls waiting to be fired.    */
specifier|final
name|RuleQueue
name|ruleQueue
init|=
operator|new
name|RuleQueue
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|/**    * Holds the currently registered RelTraitDefs.    */
specifier|private
specifier|final
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|traitDefs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Set of all registered rules.    */
specifier|protected
specifier|final
name|Set
argument_list|<
name|RelOptRule
argument_list|>
name|ruleSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|int
name|nextSetId
init|=
literal|0
decl_stmt|;
comment|/**    * Incremented every time a relational expression is registered or two sets    * are merged. Tells us whether anything is going on.    */
specifier|private
name|int
name|registerCount
decl_stmt|;
comment|/**    * Listener for this planner, or null if none set.    */
name|RelOptListener
name|listener
decl_stmt|;
specifier|private
name|RelNode
name|originalRoot
decl_stmt|;
comment|/**    * Whether the planner can accept new rules.    */
specifier|private
name|boolean
name|locked
decl_stmt|;
comment|/**    * Whether rels with Convention.NONE has infinite cost.    */
specifier|private
name|boolean
name|noneConventionHasInfiniteCost
init|=
literal|true
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|materializations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Map of lattices by the qualified name of their star table.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|RelOptLattice
argument_list|>
name|latticeByName
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Provenance
argument_list|>
name|provenanceMap
decl_stmt|;
specifier|final
name|Deque
argument_list|<
name|VolcanoRuleCall
argument_list|>
name|ruleCallStack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Zero cost, according to {@link #costFactory}. Not necessarily a    * {@link org.apache.calcite.plan.volcano.VolcanoCost}. */
specifier|private
specifier|final
name|RelOptCost
name|zeroCost
decl_stmt|;
comment|/** Maps rule classes to their name, to ensure that the names are unique and    * conform to rules. */
specifier|private
specifier|final
name|SetMultimap
argument_list|<
name|String
argument_list|,
name|Class
argument_list|>
name|ruleNames
init|=
name|LinkedHashMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a uninitialized<code>VolcanoPlanner</code>. To fully initialize    * it, the caller must register the desired set of relations, rules, and    * calling conventions.    */
specifier|public
name|VolcanoPlanner
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a uninitialized<code>VolcanoPlanner</code>. To fully initialize    * it, the caller must register the desired set of relations, rules, and    * calling conventions.    */
specifier|public
name|VolcanoPlanner
parameter_list|(
name|Context
name|externalContext
parameter_list|)
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|externalContext
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a {@code VolcanoPlanner} with a given cost factory.    */
specifier|public
name|VolcanoPlanner
parameter_list|(
name|RelOptCostFactory
name|costFactory
parameter_list|,
comment|//
name|Context
name|externalContext
parameter_list|)
block|{
name|super
argument_list|(
name|costFactory
operator|==
literal|null
condition|?
name|VolcanoCost
operator|.
name|FACTORY
else|:
name|costFactory
argument_list|,
comment|//
name|externalContext
argument_list|)
expr_stmt|;
name|this
operator|.
name|zeroCost
operator|=
name|this
operator|.
name|costFactory
operator|.
name|makeZeroCost
argument_list|()
expr_stmt|;
comment|// If LOGGER is debug enabled, enable provenance information to be captured
name|this
operator|.
name|provenanceMap
operator|=
name|LOGGER
operator|.
name|isDebugEnabled
argument_list|()
condition|?
operator|new
name|HashMap
argument_list|<>
argument_list|()
else|:
name|Util
operator|.
name|blackholeMap
argument_list|()
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|protected
name|VolcanoPlannerPhaseRuleMappingInitializer
name|getPhaseRuleMappingInitializer
parameter_list|()
block|{
return|return
name|phaseRuleMap
lambda|->
block|{
comment|// Disable all phases except OPTIMIZE by adding one useless rule name.
name|phaseRuleMap
operator|.
name|get
argument_list|(
name|VolcanoPlannerPhase
operator|.
name|PRE_PROCESS_MDR
argument_list|)
operator|.
name|add
argument_list|(
literal|"xxx"
argument_list|)
expr_stmt|;
name|phaseRuleMap
operator|.
name|get
argument_list|(
name|VolcanoPlannerPhase
operator|.
name|PRE_PROCESS
argument_list|)
operator|.
name|add
argument_list|(
literal|"xxx"
argument_list|)
expr_stmt|;
name|phaseRuleMap
operator|.
name|get
argument_list|(
name|VolcanoPlannerPhase
operator|.
name|CLEANUP
argument_list|)
operator|.
name|add
argument_list|(
literal|"xxx"
argument_list|)
expr_stmt|;
block|}
return|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|boolean
name|isRegistered
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|mapRel2Subset
operator|.
name|get
argument_list|(
name|rel
argument_list|)
operator|!=
literal|null
return|;
block|}
specifier|public
name|void
name|setRoot
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
comment|// We're registered all the rules, and therefore RelNode classes,
comment|// we're interested in, and have not yet started calling metadata providers.
comment|// So now is a good time to tell the metadata layer what to expect.
name|registerMetadataRels
argument_list|()
expr_stmt|;
name|this
operator|.
name|root
operator|=
name|registerImpl
argument_list|(
name|rel
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|originalRoot
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|originalRoot
operator|=
name|rel
expr_stmt|;
block|}
comment|// Making a node the root changes its importance.
name|this
operator|.
name|ruleQueue
operator|.
name|recompute
argument_list|(
name|this
operator|.
name|root
argument_list|)
expr_stmt|;
name|ensureRootConverters
argument_list|()
expr_stmt|;
block|}
specifier|public
name|RelNode
name|getRoot
parameter_list|()
block|{
return|return
name|root
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|getMaterializations
parameter_list|()
block|{
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|materializations
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addMaterialization
parameter_list|(
name|RelOptMaterialization
name|materialization
parameter_list|)
block|{
name|materializations
operator|.
name|add
argument_list|(
name|materialization
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addLattice
parameter_list|(
name|RelOptLattice
name|lattice
parameter_list|)
block|{
name|latticeByName
operator|.
name|put
argument_list|(
name|lattice
operator|.
name|starRelOptTable
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|lattice
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RelOptLattice
name|getLattice
parameter_list|(
name|RelOptTable
name|table
parameter_list|)
block|{
return|return
name|latticeByName
operator|.
name|get
argument_list|(
name|table
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|void
name|registerMaterializations
parameter_list|()
block|{
comment|// Avoid using materializations while populating materializations!
specifier|final
name|CalciteConnectionConfig
name|config
init|=
name|context
operator|.
name|unwrap
argument_list|(
name|CalciteConnectionConfig
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
literal|null
operator|||
operator|!
name|config
operator|.
name|materializationsEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Register rels using materialized views.
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
argument_list|>
argument_list|>
name|materializationUses
init|=
name|RelOptMaterializations
operator|.
name|useMaterializedViews
argument_list|(
name|originalRoot
argument_list|,
name|materializations
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
argument_list|>
name|use
range|:
name|materializationUses
control|)
block|{
name|RelNode
name|rel
init|=
name|use
operator|.
name|left
decl_stmt|;
name|Hook
operator|.
name|SUB
operator|.
name|run
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|registerImpl
argument_list|(
name|rel
argument_list|,
name|root
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
comment|// Register table rels of materialized views that cannot find a substitution
comment|// in root rel transformation but can potentially be useful.
specifier|final
name|Set
argument_list|<
name|RelOptMaterialization
argument_list|>
name|applicableMaterializations
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|RelOptMaterializations
operator|.
name|getApplicableMaterializations
argument_list|(
name|originalRoot
argument_list|,
name|materializations
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
argument_list|>
name|use
range|:
name|materializationUses
control|)
block|{
name|applicableMaterializations
operator|.
name|removeAll
argument_list|(
name|use
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RelOptMaterialization
name|materialization
range|:
name|applicableMaterializations
control|)
block|{
name|RelSubset
name|subset
init|=
name|registerImpl
argument_list|(
name|materialization
operator|.
name|queryRel
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|RelNode
name|tableRel2
init|=
name|RelOptUtil
operator|.
name|createCastRel
argument_list|(
name|materialization
operator|.
name|tableRel
argument_list|,
name|materialization
operator|.
name|queryRel
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|registerImpl
argument_list|(
name|tableRel2
argument_list|,
name|subset
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
comment|// Register rels using lattices.
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelOptLattice
argument_list|>
argument_list|>
name|latticeUses
init|=
name|RelOptMaterializations
operator|.
name|useLattices
argument_list|(
name|originalRoot
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|latticeByName
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|latticeUses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|RelNode
name|rel
init|=
name|latticeUses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|left
decl_stmt|;
name|Hook
operator|.
name|SUB
operator|.
name|run
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|registerImpl
argument_list|(
name|rel
argument_list|,
name|root
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Finds an expression's equivalence set. If the expression is not    * registered, returns null.    *    * @param rel Relational expression    * @return Equivalence set that expression belongs to, or null if it is not    * registered    */
specifier|public
name|RelSet
name|getSet
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
assert|assert
name|rel
operator|!=
literal|null
operator|:
literal|"pre: rel != null"
assert|;
specifier|final
name|RelSubset
name|subset
init|=
name|getSubset
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|subset
operator|!=
literal|null
condition|)
block|{
assert|assert
name|subset
operator|.
name|set
operator|!=
literal|null
assert|;
return|return
name|subset
operator|.
name|set
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|addRelTraitDef
parameter_list|(
name|RelTraitDef
name|relTraitDef
parameter_list|)
block|{
return|return
operator|!
name|traitDefs
operator|.
name|contains
argument_list|(
name|relTraitDef
argument_list|)
operator|&&
name|traitDefs
operator|.
name|add
argument_list|(
name|relTraitDef
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clearRelTraitDefs
parameter_list|()
block|{
name|traitDefs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|getRelTraitDefs
parameter_list|()
block|{
return|return
name|traitDefs
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelTraitSet
name|emptyTraitSet
parameter_list|()
block|{
name|RelTraitSet
name|traitSet
init|=
name|super
operator|.
name|emptyTraitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTraitDef
name|traitDef
range|:
name|traitDefs
control|)
block|{
if|if
condition|(
name|traitDef
operator|.
name|multiple
argument_list|()
condition|)
block|{
comment|// TODO: restructure RelTraitSet to allow a list of entries
comment|//  for any given trait
block|}
name|traitSet
operator|=
name|traitSet
operator|.
name|plus
argument_list|(
name|traitDef
operator|.
name|getDefault
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|traitSet
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|super
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|ruleSet
argument_list|)
control|)
block|{
name|removeRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|classOperands
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|allSets
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|mapDigestToRel
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|mapRel2Subset
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|relImportances
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|ruleQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|ruleNames
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|materializations
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|latticeByName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|provenanceMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|RelOptRule
argument_list|>
name|getRules
parameter_list|()
block|{
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|ruleSet
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|addRule
parameter_list|(
name|RelOptRule
name|rule
parameter_list|)
block|{
if|if
condition|(
name|locked
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|ruleSet
operator|.
name|contains
argument_list|(
name|rule
argument_list|)
condition|)
block|{
comment|// Rule already exists.
return|return
literal|false
return|;
block|}
specifier|final
name|boolean
name|added
init|=
name|ruleSet
operator|.
name|add
argument_list|(
name|rule
argument_list|)
decl_stmt|;
assert|assert
name|added
assert|;
specifier|final
name|String
name|ruleName
init|=
name|rule
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|ruleNames
operator|.
name|put
argument_list|(
name|ruleName
argument_list|,
name|rule
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|Class
argument_list|>
name|x
init|=
name|ruleNames
operator|.
name|get
argument_list|(
name|ruleName
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Rule description '"
operator|+
name|ruleName
operator|+
literal|"' is not unique; classes: "
operator|+
name|x
argument_list|)
throw|;
block|}
block|}
name|mapRuleDescription
argument_list|(
name|rule
argument_list|)
expr_stmt|;
comment|// Each of this rule's operands is an 'entry point' for a rule call.
comment|// Register each operand against all concrete sub-classes that could match
comment|// it.
for|for
control|(
name|RelOptRuleOperand
name|operand
range|:
name|rule
operator|.
name|getOperands
argument_list|()
control|)
block|{
for|for
control|(
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|subClass
range|:
name|subClasses
argument_list|(
name|operand
operator|.
name|getMatchedClass
argument_list|()
argument_list|)
control|)
block|{
name|classOperands
operator|.
name|put
argument_list|(
name|subClass
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If this is a converter rule, check that it operates on one of the
comment|// kinds of trait we are interested in, and if so, register the rule
comment|// with the trait.
if|if
condition|(
name|rule
operator|instanceof
name|ConverterRule
condition|)
block|{
name|ConverterRule
name|converterRule
init|=
operator|(
name|ConverterRule
operator|)
name|rule
decl_stmt|;
specifier|final
name|RelTrait
name|ruleTrait
init|=
name|converterRule
operator|.
name|getInTrait
argument_list|()
decl_stmt|;
specifier|final
name|RelTraitDef
name|ruleTraitDef
init|=
name|ruleTrait
operator|.
name|getTraitDef
argument_list|()
decl_stmt|;
if|if
condition|(
name|traitDefs
operator|.
name|contains
argument_list|(
name|ruleTraitDef
argument_list|)
condition|)
block|{
name|ruleTraitDef
operator|.
name|registerConverterRule
argument_list|(
name|this
argument_list|,
name|converterRule
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|removeRule
parameter_list|(
name|RelOptRule
name|rule
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ruleSet
operator|.
name|remove
argument_list|(
name|rule
argument_list|)
condition|)
block|{
comment|// Rule was not present.
return|return
literal|false
return|;
block|}
comment|// Remove description.
name|unmapRuleDescription
argument_list|(
name|rule
argument_list|)
expr_stmt|;
comment|// Remove operands.
name|classOperands
operator|.
name|values
argument_list|()
operator|.
name|removeIf
argument_list|(
name|entry
lambda|->
name|entry
operator|.
name|getRule
argument_list|()
operator|.
name|equals
argument_list|(
name|rule
argument_list|)
argument_list|)
expr_stmt|;
comment|// Remove trait mappings. (In particular, entries from conversion
comment|// graph.)
if|if
condition|(
name|rule
operator|instanceof
name|ConverterRule
condition|)
block|{
name|ConverterRule
name|converterRule
init|=
operator|(
name|ConverterRule
operator|)
name|rule
decl_stmt|;
specifier|final
name|RelTrait
name|ruleTrait
init|=
name|converterRule
operator|.
name|getInTrait
argument_list|()
decl_stmt|;
specifier|final
name|RelTraitDef
name|ruleTraitDef
init|=
name|ruleTrait
operator|.
name|getTraitDef
argument_list|()
decl_stmt|;
if|if
condition|(
name|traitDefs
operator|.
name|contains
argument_list|(
name|ruleTraitDef
argument_list|)
condition|)
block|{
name|ruleTraitDef
operator|.
name|deregisterConverterRule
argument_list|(
name|this
argument_list|,
name|converterRule
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|onNewClass
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
name|super
operator|.
name|onNewClass
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// Create mappings so that instances of this class will match existing
comment|// operands.
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|clazz
init|=
name|node
operator|.
name|getClass
argument_list|()
decl_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|ruleSet
control|)
block|{
for|for
control|(
name|RelOptRuleOperand
name|operand
range|:
name|rule
operator|.
name|getOperands
argument_list|()
control|)
block|{
if|if
condition|(
name|operand
operator|.
name|getMatchedClass
argument_list|()
operator|.
name|isAssignableFrom
argument_list|(
name|clazz
argument_list|)
condition|)
block|{
name|classOperands
operator|.
name|put
argument_list|(
name|clazz
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|RelNode
name|changeTraits
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|toTraits
parameter_list|)
block|{
assert|assert
operator|!
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|toTraits
argument_list|)
assert|;
assert|assert
name|toTraits
operator|.
name|allSimple
argument_list|()
assert|;
name|RelSubset
name|rel2
init|=
name|ensureRegistered
argument_list|(
name|rel
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|rel2
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|toTraits
argument_list|)
condition|)
block|{
return|return
name|rel2
return|;
block|}
return|return
name|rel2
operator|.
name|set
operator|.
name|getOrCreateSubset
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|toTraits
operator|.
name|simplify
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|RelOptPlanner
name|chooseDelegate
parameter_list|()
block|{
return|return
name|this
return|;
block|}
comment|/**    * Finds the most efficient expression to implement the query given via    * {@link org.apache.calcite.plan.RelOptPlanner#setRoot(org.apache.calcite.rel.RelNode)}.    *    *<p>The algorithm executes repeatedly in a series of phases. In each phase    * the exact rules that may be fired varies. The mapping of phases to rule    * sets is maintained in the {@link #ruleQueue}.    *    *<p>In each phase, the planner sets the initial importance of the existing    * RelSubSets ({@link #setInitialImportance()}). The planner then iterates    * over the rule matches presented by the rule queue until:    *    *<ol>    *<li>The rule queue becomes empty.</li>    *<li>For ambitious planners: No improvements to the plan have been made    * recently (specifically within a number of iterations that is 10% of the    * number of iterations necessary to first reach an implementable plan or 25    * iterations whichever is larger).</li>    *<li>For non-ambitious planners: When an implementable plan is found.</li>    *</ol>    *    *<p>Furthermore, after every 10 iterations without an implementable plan,    * RelSubSets that contain only logical RelNodes are given an importance    * boost via {@link #injectImportanceBoost()}. Once an implementable plan is    * found, the artificially raised importance values are cleared (see    * {@link #clearImportanceBoost()}).    *    * @return the most efficient RelNode tree found for implementing the given    * query    */
specifier|public
name|RelNode
name|findBestExp
parameter_list|()
block|{
name|ensureRootConverters
argument_list|()
expr_stmt|;
name|registerMaterializations
argument_list|()
expr_stmt|;
name|int
name|cumulativeTicks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|VolcanoPlannerPhase
name|phase
range|:
name|VolcanoPlannerPhase
operator|.
name|values
argument_list|()
control|)
block|{
name|setInitialImportance
argument_list|()
expr_stmt|;
name|RelOptCost
name|targetCost
init|=
name|costFactory
operator|.
name|makeHugeCost
argument_list|()
decl_stmt|;
name|int
name|tick
init|=
literal|0
decl_stmt|;
name|int
name|firstFiniteTick
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|splitCount
init|=
literal|0
decl_stmt|;
name|int
name|giveUpTick
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
operator|++
name|tick
expr_stmt|;
operator|++
name|cumulativeTicks
expr_stmt|;
if|if
condition|(
name|root
operator|.
name|bestCost
operator|.
name|isLe
argument_list|(
name|targetCost
argument_list|)
condition|)
block|{
if|if
condition|(
name|firstFiniteTick
operator|<
literal|0
condition|)
block|{
name|firstFiniteTick
operator|=
name|cumulativeTicks
expr_stmt|;
name|clearImportanceBoost
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ambitious
condition|)
block|{
comment|// Choose a slightly more ambitious target cost, and
comment|// try again. If it took us 1000 iterations to find our
comment|// first finite plan, give ourselves another 100
comment|// iterations to reduce the cost by 10%.
name|targetCost
operator|=
name|root
operator|.
name|bestCost
operator|.
name|multiplyBy
argument_list|(
literal|0.9
argument_list|)
expr_stmt|;
operator|++
name|splitCount
expr_stmt|;
if|if
condition|(
name|impatient
condition|)
block|{
if|if
condition|(
name|firstFiniteTick
operator|<
literal|10
condition|)
block|{
comment|// It's possible pre-processing can create
comment|// an implementable plan -- give us some time
comment|// to actually optimize it.
name|giveUpTick
operator|=
name|cumulativeTicks
operator|+
literal|25
expr_stmt|;
block|}
else|else
block|{
name|giveUpTick
operator|=
name|cumulativeTicks
operator|+
name|Math
operator|.
name|max
argument_list|(
name|firstFiniteTick
operator|/
literal|10
argument_list|,
literal|25
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
if|else if
condition|(
name|cumulativeTicks
operator|>
name|giveUpTick
condition|)
block|{
comment|// We haven't made progress recently. Take the current best.
break|break;
block|}
if|else if
condition|(
name|root
operator|.
name|bestCost
operator|.
name|isInfinite
argument_list|()
operator|&&
operator|(
operator|(
name|tick
operator|%
literal|10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|injectImportanceBoost
argument_list|()
expr_stmt|;
block|}
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"PLANNER = {}; TICK = {}/{}; PHASE = {}; COST = {}"
argument_list|,
name|this
argument_list|,
name|cumulativeTicks
argument_list|,
name|tick
argument_list|,
name|phase
operator|.
name|toString
argument_list|()
argument_list|,
name|root
operator|.
name|bestCost
argument_list|)
expr_stmt|;
name|VolcanoRuleMatch
name|match
init|=
name|ruleQueue
operator|.
name|popMatch
argument_list|(
name|phase
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|==
literal|null
condition|)
block|{
break|break;
block|}
assert|assert
name|match
operator|.
name|getRule
argument_list|()
operator|.
name|matches
argument_list|(
name|match
argument_list|)
assert|;
name|match
operator|.
name|onMatch
argument_list|()
expr_stmt|;
comment|// The root may have been merged with another
comment|// subset. Find the new root subset.
name|root
operator|=
name|canonize
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
name|ruleQueue
operator|.
name|phaseCompleted
argument_list|(
name|phase
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|dump
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
name|LOGGER
operator|.
name|trace
argument_list|(
name|sw
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|cheapest
init|=
name|root
operator|.
name|buildCheapestPlan
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOGGER
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Cheapest plan:\n{}"
argument_list|,
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|cheapest
argument_list|,
name|SqlExplainLevel
operator|.
name|ALL_ATTRIBUTES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|provenanceMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Provenance:\n{}"
argument_list|,
name|provenance
argument_list|(
name|cheapest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|cheapest
return|;
block|}
comment|/** Informs {@link JaninoRelMetadataProvider} about the different kinds of    * {@link RelNode} that we will be dealing with. It will reduce the number    * of times that we need to re-generate the provider. */
specifier|private
name|void
name|registerMetadataRels
parameter_list|()
block|{
name|JaninoRelMetadataProvider
operator|.
name|DEFAULT
operator|.
name|register
argument_list|(
name|classOperands
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Ensures that the subset that is the root relational expression contains    * converters to all other subsets in its equivalence set.    *    *<p>Thus the planner tries to find cheap implementations of those other    * subsets, which can then be converted to the root. This is the only place    * in the plan where explicit converters are required; elsewhere, a consumer    * will be asking for the result in a particular convention, but the root has    * no consumers. */
name|void
name|ensureRootConverters
parameter_list|()
block|{
specifier|final
name|Set
argument_list|<
name|RelSubset
argument_list|>
name|subsets
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|root
operator|.
name|getRels
argument_list|()
control|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|AbstractConverter
condition|)
block|{
name|subsets
operator|.
name|add
argument_list|(
operator|(
name|RelSubset
operator|)
operator|(
operator|(
name|AbstractConverter
operator|)
name|rel
operator|)
operator|.
name|getInput
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|RelSubset
name|subset
range|:
name|root
operator|.
name|set
operator|.
name|subsets
control|)
block|{
specifier|final
name|ImmutableList
argument_list|<
name|RelTrait
argument_list|>
name|difference
init|=
name|root
operator|.
name|getTraitSet
argument_list|()
operator|.
name|difference
argument_list|(
name|subset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|difference
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|subsets
operator|.
name|add
argument_list|(
name|subset
argument_list|)
condition|)
block|{
name|register
argument_list|(
operator|new
name|AbstractConverter
argument_list|(
name|subset
operator|.
name|getCluster
argument_list|()
argument_list|,
name|subset
argument_list|,
name|difference
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTraitDef
argument_list|()
argument_list|,
name|root
operator|.
name|getTraitSet
argument_list|()
argument_list|)
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns a multi-line string describing the provenance of a tree of    * relational expressions. For each node in the tree, prints the rule that    * created the node, if any. Recursively describes the provenance of the    * relational expressions that are the arguments to that rule.    *    *<p>Thus, every relational expression and rule invocation that affected    * the final outcome is described in the provenance. This can be useful    * when finding the root cause of "mistakes" in a query plan.</p>    *    * @param root Root relational expression in a tree    * @return Multi-line string describing the rules that created the tree    */
specifier|private
name|String
name|provenance
parameter_list|(
name|RelNode
name|root
parameter_list|)
block|{
specifier|final
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
operator|new
name|RelVisitor
argument_list|()
block|{
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// CHECKSTYLE: IGNORE 1
block|}
operator|.
name|go
argument_list|(
name|root
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|RelNode
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|node
range|:
name|nodes
control|)
block|{
name|provenanceRecurse
argument_list|(
name|pw
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
name|visited
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Helper for {@link #provenance(org.apache.calcite.rel.RelNode)}.    */
specifier|private
name|void
name|provenanceRecurse
parameter_list|(
name|PrintWriter
name|pw
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|int
name|i
parameter_list|,
name|Set
argument_list|<
name|RelNode
argument_list|>
name|visited
parameter_list|)
block|{
name|Spaces
operator|.
name|append
argument_list|(
name|pw
argument_list|,
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|visited
operator|.
name|add
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|"rel#"
operator|+
name|node
operator|.
name|getId
argument_list|()
operator|+
literal|" (see above)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pw
operator|.
name|println
argument_list|(
name|node
argument_list|)
expr_stmt|;
specifier|final
name|Provenance
name|o
init|=
name|provenanceMap
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|Spaces
operator|.
name|append
argument_list|(
name|pw
argument_list|,
name|i
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|Provenance
operator|.
name|EMPTY
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|"no parent"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|o
operator|instanceof
name|DirectProvenance
condition|)
block|{
name|RelNode
name|rel
init|=
operator|(
operator|(
name|DirectProvenance
operator|)
name|o
operator|)
operator|.
name|source
decl_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"direct"
argument_list|)
expr_stmt|;
name|provenanceRecurse
argument_list|(
name|pw
argument_list|,
name|rel
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|visited
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|o
operator|instanceof
name|RuleProvenance
condition|)
block|{
name|RuleProvenance
name|rule
init|=
operator|(
name|RuleProvenance
operator|)
name|o
decl_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"call#"
operator|+
name|rule
operator|.
name|callId
operator|+
literal|" rule ["
operator|+
name|rule
operator|.
name|rule
operator|+
literal|"]"
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|rule
operator|.
name|rels
control|)
block|{
name|provenanceRecurse
argument_list|(
name|pw
argument_list|,
name|rel
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|visited
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|o
operator|==
literal|null
operator|&&
name|node
operator|instanceof
name|RelSubset
condition|)
block|{
comment|// A few operands recognize subsets, not individual rels.
comment|// The first rel in the subset is deemed to have created it.
specifier|final
name|RelSubset
name|subset
init|=
operator|(
name|RelSubset
operator|)
name|node
decl_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"subset "
operator|+
name|subset
argument_list|)
expr_stmt|;
name|provenanceRecurse
argument_list|(
name|pw
argument_list|,
name|subset
operator|.
name|getRelList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|visited
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"bad type "
operator|+
name|o
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|setInitialImportance
parameter_list|()
block|{
name|RelVisitor
name|visitor
init|=
operator|new
name|RelVisitor
argument_list|()
block|{
name|int
name|depth
init|=
literal|0
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelSubset
argument_list|>
name|visitedSubsets
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|p
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|p
operator|instanceof
name|RelSubset
condition|)
block|{
name|RelSubset
name|subset
init|=
operator|(
name|RelSubset
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|visitedSubsets
operator|.
name|contains
argument_list|(
name|subset
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|subset
operator|!=
name|root
condition|)
block|{
name|Double
name|importance
init|=
name|Math
operator|.
name|pow
argument_list|(
literal|0.9
argument_list|,
operator|(
name|double
operator|)
name|depth
argument_list|)
decl_stmt|;
name|ruleQueue
operator|.
name|updateImportance
argument_list|(
name|subset
argument_list|,
name|importance
argument_list|)
expr_stmt|;
block|}
name|visitedSubsets
operator|.
name|add
argument_list|(
name|subset
argument_list|)
expr_stmt|;
name|depth
operator|++
expr_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|subset
operator|.
name|getRels
argument_list|()
control|)
block|{
name|visit
argument_list|(
name|rel
argument_list|,
operator|-
literal|1
argument_list|,
name|subset
argument_list|)
expr_stmt|;
block|}
name|depth
operator|--
expr_stmt|;
block|}
else|else
block|{
name|super
operator|.
name|visit
argument_list|(
name|p
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|visitor
operator|.
name|go
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
comment|/**    * Finds RelSubsets in the plan that contain only rels of    * {@link Convention#NONE} and boosts their importance by 25%.    */
specifier|private
name|void
name|injectImportanceBoost
parameter_list|()
block|{
specifier|final
name|Set
argument_list|<
name|RelSubset
argument_list|>
name|requireBoost
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|SUBSET_LOOP
label|:
for|for
control|(
name|RelSubset
name|subset
range|:
name|ruleQueue
operator|.
name|subsetImportances
operator|.
name|keySet
argument_list|()
control|)
block|{
for|for
control|(
name|RelNode
name|rel
range|:
name|subset
operator|.
name|getRels
argument_list|()
control|)
block|{
if|if
condition|(
name|rel
operator|.
name|getConvention
argument_list|()
operator|!=
name|Convention
operator|.
name|NONE
condition|)
block|{
continue|continue
name|SUBSET_LOOP
continue|;
block|}
block|}
name|requireBoost
operator|.
name|add
argument_list|(
name|subset
argument_list|)
expr_stmt|;
block|}
name|ruleQueue
operator|.
name|boostImportance
argument_list|(
name|requireBoost
argument_list|,
literal|1.25
argument_list|)
expr_stmt|;
block|}
comment|/**    * Clear all importance boosts.    */
specifier|private
name|void
name|clearImportanceBoost
parameter_list|()
block|{
name|Collection
argument_list|<
name|RelSubset
argument_list|>
name|empty
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
name|ruleQueue
operator|.
name|boostImportance
argument_list|(
name|empty
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RelSubset
name|register
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|equivRel
parameter_list|)
block|{
assert|assert
operator|!
name|isRegistered
argument_list|(
name|rel
argument_list|)
operator|:
literal|"pre: isRegistered(rel)"
assert|;
specifier|final
name|RelSet
name|set
decl_stmt|;
if|if
condition|(
name|equivRel
operator|==
literal|null
condition|)
block|{
name|set
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|RelOptUtil
operator|.
name|equal
argument_list|(
literal|"rel rowtype"
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|"equivRel rowtype"
argument_list|,
name|equivRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
name|set
operator|=
name|getSet
argument_list|(
name|equivRel
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelSubset
name|subset
init|=
name|registerImpl
argument_list|(
name|rel
argument_list|,
name|set
argument_list|)
decl_stmt|;
comment|// Checking if tree is valid considerably slows down planning
comment|// Only doing it if logger level is debug or finer
if|if
condition|(
name|LOGGER
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
assert|assert
name|isValid
argument_list|(
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
block|}
return|return
name|subset
return|;
block|}
specifier|public
name|RelSubset
name|ensureRegistered
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|equivRel
parameter_list|)
block|{
specifier|final
name|RelSubset
name|subset
init|=
name|getSubset
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|subset
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|equivRel
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RelSubset
name|equivSubset
init|=
name|getSubset
argument_list|(
name|equivRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|subset
operator|.
name|set
operator|!=
name|equivSubset
operator|.
name|set
condition|)
block|{
name|merge
argument_list|(
name|equivSubset
operator|.
name|set
argument_list|,
name|subset
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|subset
return|;
block|}
else|else
block|{
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|equivRel
argument_list|)
return|;
block|}
block|}
comment|/**    * Checks internal consistency.    */
specifier|protected
name|boolean
name|isValid
parameter_list|(
name|Litmus
name|litmus
parameter_list|)
block|{
for|for
control|(
name|RelSet
name|set
range|:
name|allSets
control|)
block|{
if|if
condition|(
name|set
operator|.
name|equivalentSet
operator|!=
literal|null
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"set [{}] has been merged: it should not be in the list"
argument_list|,
name|set
argument_list|)
return|;
block|}
for|for
control|(
name|RelSubset
name|subset
range|:
name|set
operator|.
name|subsets
control|)
block|{
if|if
condition|(
name|subset
operator|.
name|set
operator|!=
name|set
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"subset [{}] is in wrong set [{}]"
argument_list|,
name|subset
operator|.
name|getDescription
argument_list|()
argument_list|,
name|set
argument_list|)
return|;
block|}
for|for
control|(
name|RelNode
name|rel
range|:
name|subset
operator|.
name|getRels
argument_list|()
control|)
block|{
name|RelOptCost
name|relCost
init|=
name|getCost
argument_list|(
name|rel
argument_list|,
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|relCost
operator|.
name|isLt
argument_list|(
name|subset
operator|.
name|bestCost
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"rel [{}] has lower cost {} than best cost {} of subset [{}]"
argument_list|,
name|rel
operator|.
name|getDescription
argument_list|()
argument_list|,
name|relCost
argument_list|,
name|subset
operator|.
name|bestCost
argument_list|,
name|subset
operator|.
name|getDescription
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
specifier|public
name|void
name|registerAbstractRelationalRules
parameter_list|()
block|{
name|RelOptUtil
operator|.
name|registerAbstractRelationalRules
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|registerSchema
parameter_list|(
name|RelOptSchema
name|schema
parameter_list|)
block|{
if|if
condition|(
name|registeredSchemas
operator|.
name|add
argument_list|(
name|schema
argument_list|)
condition|)
block|{
try|try
block|{
name|schema
operator|.
name|registerRules
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"While registering schema "
operator|+
name|schema
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Sets whether this planner should consider rel nodes with Convention.NONE    * to have inifinte cost or not.    * @param infinite Whether to make none convention rel nodes inifite cost    */
specifier|public
name|void
name|setNoneConventionHasInfiniteCost
parameter_list|(
name|boolean
name|infinite
parameter_list|)
block|{
name|this
operator|.
name|noneConventionHasInfiniteCost
operator|=
name|infinite
expr_stmt|;
block|}
specifier|public
name|RelOptCost
name|getCost
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
assert|assert
name|rel
operator|!=
literal|null
operator|:
literal|"pre-condition: rel != null"
assert|;
if|if
condition|(
name|rel
operator|instanceof
name|RelSubset
condition|)
block|{
return|return
operator|(
operator|(
name|RelSubset
operator|)
name|rel
operator|)
operator|.
name|bestCost
return|;
block|}
if|if
condition|(
name|noneConventionHasInfiniteCost
operator|&&
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTrait
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
operator|==
name|Convention
operator|.
name|NONE
condition|)
block|{
return|return
name|costFactory
operator|.
name|makeInfiniteCost
argument_list|()
return|;
block|}
name|RelOptCost
name|cost
init|=
name|mq
operator|.
name|getNonCumulativeCost
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|zeroCost
operator|.
name|isLt
argument_list|(
name|cost
argument_list|)
condition|)
block|{
comment|// cost must be positive, so nudge it
name|cost
operator|=
name|costFactory
operator|.
name|makeTinyCost
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|cost
operator|=
name|cost
operator|.
name|plus
argument_list|(
name|getCost
argument_list|(
name|input
argument_list|,
name|mq
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
comment|/**    * Returns the subset that a relational expression belongs to.    *    * @param rel Relational expression    * @return Subset it belongs to, or null if it is not registered    */
specifier|public
name|RelSubset
name|getSubset
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
assert|assert
name|rel
operator|!=
literal|null
operator|:
literal|"pre: rel != null"
assert|;
if|if
condition|(
name|rel
operator|instanceof
name|RelSubset
condition|)
block|{
return|return
operator|(
name|RelSubset
operator|)
name|rel
return|;
block|}
else|else
block|{
return|return
name|mapRel2Subset
operator|.
name|get
argument_list|(
name|rel
argument_list|)
return|;
block|}
block|}
specifier|public
name|RelSubset
name|getSubset
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|traits
parameter_list|)
block|{
return|return
name|getSubset
argument_list|(
name|rel
argument_list|,
name|traits
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|RelSubset
name|getSubset
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|traits
parameter_list|,
name|boolean
name|createIfMissing
parameter_list|)
block|{
if|if
condition|(
operator|(
name|rel
operator|instanceof
name|RelSubset
operator|)
operator|&&
operator|(
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|traits
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|RelSubset
operator|)
name|rel
return|;
block|}
name|RelSet
name|set
init|=
name|getSet
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|createIfMissing
condition|)
block|{
return|return
name|set
operator|.
name|getOrCreateSubset
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|traits
argument_list|)
return|;
block|}
return|return
name|set
operator|.
name|getSubset
argument_list|(
name|traits
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|changeTraitsUsingConverters
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|toTraits
parameter_list|,
name|boolean
name|allowAbstractConverters
parameter_list|)
block|{
specifier|final
name|RelTraitSet
name|fromTraits
init|=
name|rel
operator|.
name|getTraitSet
argument_list|()
decl_stmt|;
assert|assert
name|fromTraits
operator|.
name|size
argument_list|()
operator|>=
name|toTraits
operator|.
name|size
argument_list|()
assert|;
specifier|final
name|boolean
name|allowInfiniteCostConverters
init|=
name|CalciteSystemProperty
operator|.
name|ALLOW_INFINITE_COST_CONVERTERS
operator|.
name|value
argument_list|()
decl_stmt|;
comment|// Traits may build on top of another...for example a collation trait
comment|// would typically come after a distribution trait since distribution
comment|// destroys collation; so when doing the conversion below we use
comment|// fromTraits as the trait of the just previously converted RelNode.
comment|// Also, toTraits may have fewer traits than fromTraits, excess traits
comment|// will be left as is.  Finally, any null entries in toTraits are
comment|// ignored.
name|RelNode
name|converted
init|=
name|rel
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
operator|(
name|converted
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|i
operator|<
name|toTraits
operator|.
name|size
argument_list|()
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|RelTrait
name|fromTrait
init|=
name|converted
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTrait
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|RelTraitDef
name|traitDef
init|=
name|fromTrait
operator|.
name|getTraitDef
argument_list|()
decl_stmt|;
name|RelTrait
name|toTrait
init|=
name|toTraits
operator|.
name|getTrait
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|toTrait
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
assert|assert
name|traitDef
operator|==
name|toTrait
operator|.
name|getTraitDef
argument_list|()
assert|;
comment|//            if (fromTrait.subsumes(toTrait)) {
if|if
condition|(
name|fromTrait
operator|.
name|equals
argument_list|(
name|toTrait
argument_list|)
condition|)
block|{
comment|// No need to convert; it's already correct.
continue|continue;
block|}
name|rel
operator|=
name|traitDef
operator|.
name|convert
argument_list|(
name|this
argument_list|,
name|converted
argument_list|,
name|toTrait
argument_list|,
name|allowInfiniteCostConverters
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|!=
literal|null
condition|)
block|{
assert|assert
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTrait
argument_list|(
name|traitDef
argument_list|)
operator|.
name|satisfies
argument_list|(
name|toTrait
argument_list|)
assert|;
name|rel
operator|=
name|completeConversion
argument_list|(
name|rel
argument_list|,
name|allowInfiniteCostConverters
argument_list|,
name|toTraits
argument_list|,
name|Expressions
operator|.
name|list
argument_list|(
name|traitDef
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|!=
literal|null
condition|)
block|{
name|register
argument_list|(
name|rel
argument_list|,
name|converted
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|rel
operator|==
literal|null
operator|)
operator|&&
name|allowAbstractConverters
condition|)
block|{
name|RelTraitSet
name|stepTraits
init|=
name|converted
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|toTrait
argument_list|)
decl_stmt|;
name|rel
operator|=
name|getSubset
argument_list|(
name|converted
argument_list|,
name|stepTraits
argument_list|)
expr_stmt|;
block|}
name|converted
operator|=
name|rel
expr_stmt|;
block|}
comment|// make sure final converted traitset subsumes what was required
if|if
condition|(
name|converted
operator|!=
literal|null
condition|)
block|{
assert|assert
name|converted
operator|.
name|getTraitSet
argument_list|()
operator|.
name|satisfies
argument_list|(
name|toTraits
argument_list|)
assert|;
block|}
return|return
name|converted
return|;
block|}
comment|/**    * Converts traits using well-founded induction. We don't require that    * each conversion preserves all traits that have previously been converted,    * but if it changes "locked in" traits we'll try some other conversion.    *    * @param rel                         Relational expression    * @param allowInfiniteCostConverters Whether to allow infinite converters    * @param toTraits                    Target trait set    * @param usedTraits                  Traits that have been locked in    * @return Converted relational expression    */
specifier|private
name|RelNode
name|completeConversion
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|boolean
name|allowInfiniteCostConverters
parameter_list|,
name|RelTraitSet
name|toTraits
parameter_list|,
name|Expressions
operator|.
name|FluentList
argument_list|<
name|RelTraitDef
argument_list|>
name|usedTraits
parameter_list|)
block|{
if|if
condition|(
literal|true
condition|)
block|{
return|return
name|rel
return|;
block|}
for|for
control|(
name|RelTrait
name|trait
range|:
name|rel
operator|.
name|getTraitSet
argument_list|()
control|)
block|{
if|if
condition|(
name|toTraits
operator|.
name|contains
argument_list|(
name|trait
argument_list|)
condition|)
block|{
comment|// We're already a match on this trait type.
continue|continue;
block|}
specifier|final
name|RelTraitDef
name|traitDef
init|=
name|trait
operator|.
name|getTraitDef
argument_list|()
decl_stmt|;
name|RelNode
name|rel2
init|=
name|traitDef
operator|.
name|convert
argument_list|(
name|this
argument_list|,
name|rel
argument_list|,
name|toTraits
operator|.
name|getTrait
argument_list|(
name|traitDef
argument_list|)
argument_list|,
name|allowInfiniteCostConverters
argument_list|)
decl_stmt|;
comment|// if any of the used traits have been knocked out, we could be
comment|// heading for a cycle.
for|for
control|(
name|RelTraitDef
name|usedTrait
range|:
name|usedTraits
control|)
block|{
if|if
condition|(
operator|!
name|rel2
operator|.
name|getTraitSet
argument_list|()
operator|.
name|contains
argument_list|(
name|usedTrait
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
comment|// recursive call, to convert one more trait
name|rel
operator|=
name|completeConversion
argument_list|(
name|rel2
argument_list|,
name|allowInfiniteCostConverters
argument_list|,
name|toTraits
argument_list|,
name|usedTraits
operator|.
name|append
argument_list|(
name|traitDef
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|!=
literal|null
condition|)
block|{
return|return
name|rel
return|;
block|}
block|}
assert|assert
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|toTraits
argument_list|)
assert|;
return|return
name|rel
return|;
block|}
name|RelNode
name|changeTraitsUsingConverters
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|toTraits
parameter_list|)
block|{
return|return
name|changeTraitsUsingConverters
argument_list|(
name|rel
argument_list|,
name|toTraits
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|void
name|checkForSatisfiedConverters
parameter_list|(
name|RelSet
name|set
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|set
operator|.
name|abstractConverters
operator|.
name|size
argument_list|()
condition|)
block|{
name|AbstractConverter
name|converter
init|=
name|set
operator|.
name|abstractConverters
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RelNode
name|converted
init|=
name|changeTraitsUsingConverters
argument_list|(
name|rel
argument_list|,
name|converter
operator|.
name|getTraitSet
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|converted
operator|==
literal|null
condition|)
block|{
name|i
operator|++
expr_stmt|;
comment|// couldn't convert this; move on to the next
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isRegistered
argument_list|(
name|converted
argument_list|)
condition|)
block|{
name|registerImpl
argument_list|(
name|converted
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
name|set
operator|.
name|abstractConverters
operator|.
name|remove
argument_list|(
name|converter
argument_list|)
expr_stmt|;
comment|// success
block|}
block|}
block|}
specifier|public
name|void
name|setImportance
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|double
name|importance
parameter_list|)
block|{
assert|assert
name|rel
operator|!=
literal|null
assert|;
if|if
condition|(
name|importance
operator|==
literal|0d
condition|)
block|{
name|relImportances
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|importance
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Dumps the internal state of this VolcanoPlanner to a writer.    *    * @param pw Print writer    * @see #normalizePlan(String)    */
specifier|public
name|void
name|dump
parameter_list|(
name|PrintWriter
name|pw
parameter_list|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|"Root: "
operator|+
name|root
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"Original rel:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|originalRoot
operator|!=
literal|null
condition|)
block|{
name|originalRoot
operator|.
name|explain
argument_list|(
operator|new
name|RelWriterImpl
argument_list|(
name|pw
argument_list|,
name|SqlExplainLevel
operator|.
name|ALL_ATTRIBUTES
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CalciteSystemProperty
operator|.
name|DUMP_SETS
operator|.
name|value
argument_list|()
condition|)
block|{
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"Sets:"
argument_list|)
expr_stmt|;
name|dumpSets
argument_list|(
name|pw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CalciteSystemProperty
operator|.
name|DUMP_GRAPHVIZ
operator|.
name|value
argument_list|()
condition|)
block|{
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"Graphviz:"
argument_list|)
expr_stmt|;
name|dumpGraphviz
argument_list|(
name|pw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Computes the key for {@link #mapDigestToRel}. */
specifier|private
specifier|static
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|key
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|rel
operator|.
name|getDigest
argument_list|()
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|String
name|toDot
parameter_list|()
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|dumpGraphviz
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|void
name|dumpSets
parameter_list|(
name|PrintWriter
name|pw
parameter_list|)
block|{
name|Ordering
argument_list|<
name|RelSet
argument_list|>
name|ordering
init|=
name|Ordering
operator|.
name|from
argument_list|(
name|Comparator
operator|.
name|comparingInt
argument_list|(
name|o
lambda|->
name|o
operator|.
name|id
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|RelSet
name|set
range|:
name|ordering
operator|.
name|immutableSortedCopy
argument_list|(
name|allSets
argument_list|)
control|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|"Set#"
operator|+
name|set
operator|.
name|id
operator|+
literal|", type: "
operator|+
name|set
operator|.
name|subsets
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|j
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|RelSubset
name|subset
range|:
name|set
operator|.
name|subsets
control|)
block|{
operator|++
name|j
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"\t"
operator|+
name|subset
operator|.
name|getDescription
argument_list|()
operator|+
literal|", best="
operator|+
operator|(
operator|(
name|subset
operator|.
name|best
operator|==
literal|null
operator|)
condition|?
literal|"null"
else|:
operator|(
literal|"rel#"
operator|+
name|subset
operator|.
name|best
operator|.
name|getId
argument_list|()
operator|)
operator|)
operator|+
literal|", importance="
operator|+
name|ruleQueue
operator|.
name|getImportance
argument_list|(
name|subset
argument_list|)
argument_list|)
expr_stmt|;
assert|assert
name|subset
operator|.
name|set
operator|==
name|set
assert|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
assert|assert
operator|!
name|set
operator|.
name|subsets
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|subset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
assert|;
block|}
for|for
control|(
name|RelNode
name|rel
range|:
name|subset
operator|.
name|getRels
argument_list|()
control|)
block|{
comment|// "\t\trel#34:JavaProject(rel#32:JavaFilter(...), ...)"
name|pw
operator|.
name|print
argument_list|(
literal|"\t\t"
operator|+
name|rel
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|RelSubset
name|inputSubset
init|=
name|getSubset
argument_list|(
name|input
argument_list|,
name|input
operator|.
name|getTraitSet
argument_list|()
argument_list|)
decl_stmt|;
name|RelSet
name|inputSet
init|=
name|inputSubset
operator|.
name|set
decl_stmt|;
if|if
condition|(
name|input
operator|instanceof
name|RelSubset
condition|)
block|{
specifier|final
name|Iterator
argument_list|<
name|RelNode
argument_list|>
name|rels
init|=
name|inputSubset
operator|.
name|getRels
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|rels
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|input
operator|=
name|rels
operator|.
name|next
argument_list|()
expr_stmt|;
assert|assert
name|input
operator|.
name|getTraitSet
argument_list|()
operator|.
name|satisfies
argument_list|(
name|inputSubset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
assert|;
assert|assert
name|inputSet
operator|.
name|rels
operator|.
name|contains
argument_list|(
name|input
argument_list|)
assert|;
assert|assert
name|inputSet
operator|.
name|subsets
operator|.
name|contains
argument_list|(
name|inputSubset
argument_list|)
assert|;
block|}
block|}
block|}
name|Double
name|importance
init|=
name|relImportances
operator|.
name|get
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|importance
operator|!=
literal|null
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|", importance="
operator|+
name|importance
argument_list|)
expr_stmt|;
block|}
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|", rowcount="
operator|+
name|mq
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|", cumulative cost="
operator|+
name|getCost
argument_list|(
name|rel
argument_list|,
name|mq
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|dumpGraphviz
parameter_list|(
name|PrintWriter
name|pw
parameter_list|)
block|{
name|Ordering
argument_list|<
name|RelSet
argument_list|>
name|ordering
init|=
name|Ordering
operator|.
name|from
argument_list|(
name|Comparator
operator|.
name|comparingInt
argument_list|(
name|o
lambda|->
name|o
operator|.
name|id
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|RelNode
argument_list|>
name|activeRels
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|VolcanoRuleCall
name|volcanoRuleCall
range|:
name|ruleCallStack
control|)
block|{
name|activeRels
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|volcanoRuleCall
operator|.
name|rels
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|println
argument_list|(
literal|"digraph G {"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"\troot [style=filled,label=\"Root\"];"
argument_list|)
expr_stmt|;
name|PartiallyOrderedSet
argument_list|<
name|RelSubset
argument_list|>
name|subsetPoset
init|=
operator|new
name|PartiallyOrderedSet
argument_list|<>
argument_list|(
parameter_list|(
name|e1
parameter_list|,
name|e2
parameter_list|)
lambda|->
name|e1
operator|.
name|getTraitSet
argument_list|()
operator|.
name|satisfies
argument_list|(
name|e2
operator|.
name|getTraitSet
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|RelSubset
argument_list|>
name|nonEmptySubsets
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelSet
name|set
range|:
name|ordering
operator|.
name|immutableSortedCopy
argument_list|(
name|allSets
argument_list|)
control|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"\tsubgraph cluster"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|set
operator|.
name|id
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"\t\tlabel="
argument_list|)
expr_stmt|;
name|Util
operator|.
name|printJavaString
argument_list|(
name|pw
argument_list|,
literal|"Set "
operator|+
name|set
operator|.
name|id
operator|+
literal|" "
operator|+
name|set
operator|.
name|subsets
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|set
operator|.
name|rels
control|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"\t\trel"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|rel
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" [label="
argument_list|)
expr_stmt|;
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
comment|// Note: rel traitset could be different from its subset.traitset
comment|// It can happen due to RelTraitset#simplify
comment|// If the traits are different, we want to keep them on a graph
name|String
name|traits
init|=
literal|"."
operator|+
name|getSubset
argument_list|(
name|rel
argument_list|)
operator|.
name|getTraitSet
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|title
init|=
name|rel
operator|.
name|getDescription
argument_list|()
operator|.
name|replace
argument_list|(
name|traits
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|title
operator|.
name|endsWith
argument_list|(
literal|")"
argument_list|)
condition|)
block|{
name|int
name|openParen
init|=
name|title
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
decl_stmt|;
if|if
condition|(
name|openParen
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Title is like rel#12:LogicalJoin(left=RelSubset#4,right=RelSubset#3,
comment|// condition==($2, $0),joinType=inner)
comment|// so we remove the parenthesis, and wrap parameters to the second line
comment|// This avoids "too wide" Graphiz boxes, and makes the graph easier to follow
name|title
operator|=
name|title
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|openParen
argument_list|)
operator|+
literal|'\n'
operator|+
name|title
operator|.
name|substring
argument_list|(
name|openParen
operator|+
literal|1
argument_list|,
name|title
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|Util
operator|.
name|printJavaString
argument_list|(
name|pw
argument_list|,
name|title
operator|+
literal|"\nrows="
operator|+
name|mq
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|)
operator|+
literal|", cost="
operator|+
name|getCost
argument_list|(
name|rel
argument_list|,
name|mq
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|RelSubset
name|relSubset
init|=
name|getSubset
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rel
operator|instanceof
name|AbstractConverter
operator|)
condition|)
block|{
name|nonEmptySubsets
operator|.
name|add
argument_list|(
name|relSubset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|relSubset
operator|.
name|best
operator|==
name|rel
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|",color=blue"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|activeRels
operator|.
name|contains
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|",style=dashed"
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|",shape=box"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|subsetPoset
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|RelSubset
name|subset
range|:
name|set
operator|.
name|subsets
control|)
block|{
name|subsetPoset
operator|.
name|add
argument_list|(
name|subset
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"\t\tsubset"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|subset
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" [label="
argument_list|)
expr_stmt|;
name|Util
operator|.
name|printJavaString
argument_list|(
name|pw
argument_list|,
name|subset
operator|.
name|getDescription
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|boolean
name|empty
init|=
operator|!
name|nonEmptySubsets
operator|.
name|contains
argument_list|(
name|subset
argument_list|)
decl_stmt|;
if|if
condition|(
name|empty
condition|)
block|{
comment|// We don't want to iterate over rels when we know the set is not empty
for|for
control|(
name|RelNode
name|rel
range|:
name|subset
operator|.
name|getRels
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|rel
operator|instanceof
name|AbstractConverter
operator|)
condition|)
block|{
name|empty
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|empty
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|",color=red"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|activeRels
operator|.
name|contains
argument_list|(
name|subset
argument_list|)
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|",style=dashed"
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RelSubset
name|subset
range|:
name|subsetPoset
control|)
block|{
for|for
control|(
name|RelSubset
name|parent
range|:
name|subsetPoset
operator|.
name|getChildren
argument_list|(
name|subset
argument_list|)
control|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"\t\tsubset"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|subset
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" -> subset"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|parent
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"\t}\n"
argument_list|)
expr_stmt|;
block|}
comment|// Note: it is important that all the links are declared AFTER declaration of the nodes
comment|// Otherwise Graphviz creates nodes implicitly, and puts them into a wrong cluster
name|pw
operator|.
name|print
argument_list|(
literal|"\troot -> subset"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|root
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
for|for
control|(
name|RelSet
name|set
range|:
name|ordering
operator|.
name|immutableSortedCopy
argument_list|(
name|allSets
argument_list|)
control|)
block|{
for|for
control|(
name|RelNode
name|rel
range|:
name|set
operator|.
name|rels
control|)
block|{
name|RelSubset
name|relSubset
init|=
name|getSubset
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"\tsubset"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|relSubset
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" -> rel"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|rel
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|relSubset
operator|.
name|best
operator|==
name|rel
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"[color=blue]"
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|rel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelNode
name|input
init|=
name|inputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" rel"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|rel
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" -> "
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|input
operator|instanceof
name|RelSubset
condition|?
literal|"subset"
else|:
literal|"rel"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|input
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|relSubset
operator|.
name|best
operator|==
name|rel
operator|||
name|inputs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|char
name|sep
init|=
literal|'['
decl_stmt|;
if|if
condition|(
name|relSubset
operator|.
name|best
operator|==
name|rel
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|sep
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"color=blue"
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|','
expr_stmt|;
block|}
if|if
condition|(
name|inputs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|sep
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"label=\""
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
comment|// sep = ',';
block|}
name|pw
operator|.
name|print
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Draw lines for current rules
for|for
control|(
name|VolcanoRuleCall
name|ruleCall
range|:
name|ruleCallStack
control|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"rule"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|ruleCall
operator|.
name|id
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" [style=dashed,label="
argument_list|)
expr_stmt|;
name|Util
operator|.
name|printJavaString
argument_list|(
name|pw
argument_list|,
name|ruleCall
operator|.
name|rule
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|RelNode
index|[]
name|rels
init|=
name|ruleCall
operator|.
name|rels
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rels
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RelNode
name|rel
init|=
name|rels
index|[
name|i
index|]
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" rule"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|ruleCall
operator|.
name|id
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" -> "
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|rel
operator|instanceof
name|RelSubset
condition|?
literal|"subset"
else|:
literal|"rel"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|rel
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" [style=dashed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rels
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|",label=\""
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Re-computes the digest of a {@link RelNode}.    *    *<p>Since a relational expression's digest contains the identifiers of its    * children, this method needs to be called when the child has been renamed,    * for example if the child's set merges with another.    *    * @param rel Relational expression    */
name|void
name|rename
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|String
name|oldDigest
init|=
name|rel
operator|.
name|getDigest
argument_list|()
decl_stmt|;
if|if
condition|(
name|fixUpInputs
argument_list|(
name|rel
argument_list|)
condition|)
block|{
specifier|final
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|oldKey
init|=
name|Pair
operator|.
name|of
argument_list|(
name|oldDigest
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|removed
init|=
name|mapDigestToRel
operator|.
name|remove
argument_list|(
name|oldKey
argument_list|)
decl_stmt|;
assert|assert
name|removed
operator|==
name|rel
assert|;
specifier|final
name|String
name|newDigest
init|=
name|rel
operator|.
name|recomputeDigest
argument_list|()
decl_stmt|;
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Rename #{} from '{}' to '{}'"
argument_list|,
name|rel
operator|.
name|getId
argument_list|()
argument_list|,
name|oldDigest
argument_list|,
name|newDigest
argument_list|)
expr_stmt|;
specifier|final
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|key
init|=
name|key
argument_list|(
name|rel
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|equivRel
init|=
name|mapDigestToRel
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivRel
operator|!=
literal|null
condition|)
block|{
assert|assert
name|equivRel
operator|!=
name|rel
assert|;
comment|// There's already an equivalent with the same name, and we
comment|// just knocked it out. Put it back, and forget about 'rel'.
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"After renaming rel#{} it is now equivalent to rel#{}"
argument_list|,
name|rel
operator|.
name|getId
argument_list|()
argument_list|,
name|equivRel
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|mapDigestToRel
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|equivRel
argument_list|)
expr_stmt|;
name|RelSubset
name|equivRelSubset
init|=
name|getSubset
argument_list|(
name|equivRel
argument_list|)
decl_stmt|;
name|ruleQueue
operator|.
name|recompute
argument_list|(
name|equivRelSubset
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Remove back-links from children.
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
operator|(
operator|(
name|RelSubset
operator|)
name|input
operator|)
operator|.
name|set
operator|.
name|parents
operator|.
name|remove
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
comment|// Remove rel from its subset. (This may leave the subset
comment|// empty, but if so, that will be dealt with when the sets
comment|// get merged.)
specifier|final
name|RelSubset
name|subset
init|=
name|mapRel2Subset
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|equivRelSubset
argument_list|)
decl_stmt|;
assert|assert
name|subset
operator|!=
literal|null
assert|;
name|boolean
name|existed
init|=
name|subset
operator|.
name|set
operator|.
name|rels
operator|.
name|remove
argument_list|(
name|rel
argument_list|)
decl_stmt|;
assert|assert
name|existed
operator|:
literal|"rel was not known to its set"
assert|;
specifier|final
name|RelSubset
name|equivSubset
init|=
name|getSubset
argument_list|(
name|equivRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivSubset
operator|!=
name|subset
condition|)
block|{
comment|// The equivalent relational expression is in a different
comment|// subset, therefore the sets are equivalent.
assert|assert
name|equivSubset
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|subset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
assert|;
assert|assert
name|equivSubset
operator|.
name|set
operator|!=
name|subset
operator|.
name|set
assert|;
name|merge
argument_list|(
name|equivSubset
operator|.
name|set
argument_list|,
name|subset
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Registers a {@link RelNode}, which has already been registered, in a new    * {@link RelSet}.    *    * @param set Set    * @param rel Relational expression    */
name|void
name|reregister
parameter_list|(
name|RelSet
name|set
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
comment|// Is there an equivalent relational expression? (This might have
comment|// just occurred because the relational expression's child was just
comment|// found to be equivalent to another set.)
specifier|final
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|key
init|=
name|key
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|RelNode
name|equivRel
init|=
name|mapDigestToRel
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivRel
operator|!=
literal|null
operator|&&
name|equivRel
operator|!=
name|rel
condition|)
block|{
assert|assert
name|equivRel
operator|.
name|getClass
argument_list|()
operator|==
name|rel
operator|.
name|getClass
argument_list|()
assert|;
assert|assert
name|equivRel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|rel
operator|.
name|getTraitSet
argument_list|()
argument_list|)
assert|;
name|RelSubset
name|equivRelSubset
init|=
name|getSubset
argument_list|(
name|equivRel
argument_list|)
decl_stmt|;
name|ruleQueue
operator|.
name|recompute
argument_list|(
name|equivRelSubset
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Add the relational expression into the correct set and subset.
name|RelSubset
name|subset2
init|=
name|addRelToSet
argument_list|(
name|rel
argument_list|,
name|set
argument_list|)
decl_stmt|;
block|}
comment|/**    * If a subset has one or more equivalent subsets (owing to a set having    * merged with another), returns the subset which is the leader of the    * equivalence class.    *    * @param subset Subset    * @return Leader of subset's equivalence class    */
specifier|private
name|RelSubset
name|canonize
parameter_list|(
specifier|final
name|RelSubset
name|subset
parameter_list|)
block|{
if|if
condition|(
name|subset
operator|.
name|set
operator|.
name|equivalentSet
operator|==
literal|null
condition|)
block|{
return|return
name|subset
return|;
block|}
name|RelSet
name|set
init|=
name|subset
operator|.
name|set
decl_stmt|;
do|do
block|{
name|set
operator|=
name|set
operator|.
name|equivalentSet
expr_stmt|;
block|}
do|while
condition|(
name|set
operator|.
name|equivalentSet
operator|!=
literal|null
condition|)
do|;
return|return
name|set
operator|.
name|getOrCreateSubset
argument_list|(
name|subset
operator|.
name|getCluster
argument_list|()
argument_list|,
name|subset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Fires all rules matched by a relational expression.    *    * @param rel      Relational expression which has just been created (or maybe    *                 from the queue)    * @param deferred If true, each time a rule matches, just add an entry to    *                 the queue.    */
name|void
name|fireRules
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|boolean
name|deferred
parameter_list|)
block|{
for|for
control|(
name|RelOptRuleOperand
name|operand
range|:
name|classOperands
operator|.
name|get
argument_list|(
name|rel
operator|.
name|getClass
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|operand
operator|.
name|matches
argument_list|(
name|rel
argument_list|)
condition|)
block|{
specifier|final
name|VolcanoRuleCall
name|ruleCall
decl_stmt|;
if|if
condition|(
name|deferred
condition|)
block|{
name|ruleCall
operator|=
operator|new
name|DeferringRuleCall
argument_list|(
name|this
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ruleCall
operator|=
operator|new
name|VolcanoRuleCall
argument_list|(
name|this
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
name|ruleCall
operator|.
name|match
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|fixUpInputs
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|rel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|changeCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|inputs
control|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|input
operator|instanceof
name|RelSubset
condition|)
block|{
specifier|final
name|RelSubset
name|subset
init|=
operator|(
name|RelSubset
operator|)
name|input
decl_stmt|;
name|RelSubset
name|newSubset
init|=
name|canonize
argument_list|(
name|subset
argument_list|)
decl_stmt|;
if|if
condition|(
name|newSubset
operator|!=
name|subset
condition|)
block|{
name|rel
operator|.
name|replaceInput
argument_list|(
name|i
argument_list|,
name|newSubset
argument_list|)
expr_stmt|;
if|if
condition|(
name|subset
operator|.
name|set
operator|!=
name|newSubset
operator|.
name|set
condition|)
block|{
name|subset
operator|.
name|set
operator|.
name|parents
operator|.
name|remove
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|newSubset
operator|.
name|set
operator|.
name|parents
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
name|changeCount
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|changeCount
operator|>
literal|0
return|;
block|}
specifier|private
name|RelSet
name|merge
parameter_list|(
name|RelSet
name|set
parameter_list|,
name|RelSet
name|set2
parameter_list|)
block|{
assert|assert
name|set
operator|!=
name|set2
operator|:
literal|"pre: set != set2"
assert|;
comment|// Find the root of set2's equivalence tree.
name|set
operator|=
name|equivRoot
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|set2
operator|=
name|equivRoot
argument_list|(
name|set2
argument_list|)
expr_stmt|;
comment|// Looks like set2 was already marked as equivalent to set. Nothing
comment|// to do.
if|if
condition|(
name|set2
operator|==
name|set
condition|)
block|{
return|return
name|set
return|;
block|}
comment|// If necessary, swap the sets, so we're always merging the newer set
comment|// into the older.
if|if
condition|(
name|set
operator|.
name|id
operator|>
name|set2
operator|.
name|id
condition|)
block|{
name|RelSet
name|t
init|=
name|set
decl_stmt|;
name|set
operator|=
name|set2
expr_stmt|;
name|set2
operator|=
name|t
expr_stmt|;
block|}
comment|// Merge.
name|set
operator|.
name|mergeWith
argument_list|(
name|this
argument_list|,
name|set2
argument_list|)
expr_stmt|;
comment|// Was the set we merged with the root? If so, the result is the new
comment|// root.
if|if
condition|(
name|set2
operator|==
name|getSet
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|root
operator|=
name|set
operator|.
name|getOrCreateSubset
argument_list|(
name|root
operator|.
name|getCluster
argument_list|()
argument_list|,
name|root
operator|.
name|getTraitSet
argument_list|()
argument_list|)
expr_stmt|;
name|ensureRootConverters
argument_list|()
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
specifier|private
specifier|static
name|RelSet
name|equivRoot
parameter_list|(
name|RelSet
name|s
parameter_list|)
block|{
name|RelSet
name|p
init|=
name|s
decl_stmt|;
comment|// iterates at twice the rate, to detect cycles
while|while
condition|(
name|s
operator|.
name|equivalentSet
operator|!=
literal|null
condition|)
block|{
name|p
operator|=
name|forward2
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|.
name|equivalentSet
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/** Moves forward two links, checking for a cycle at each. */
specifier|private
specifier|static
name|RelSet
name|forward2
parameter_list|(
name|RelSet
name|s
parameter_list|,
name|RelSet
name|p
parameter_list|)
block|{
name|p
operator|=
name|forward1
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|forward1
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/** Moves forward one link, checking for a cycle. */
specifier|private
specifier|static
name|RelSet
name|forward1
parameter_list|(
name|RelSet
name|s
parameter_list|,
name|RelSet
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|p
operator|=
name|p
operator|.
name|equivalentSet
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|s
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"cycle in equivalence tree"
argument_list|)
throw|;
block|}
block|}
return|return
name|p
return|;
block|}
comment|/**    * Registers a new expression<code>exp</code> and queues up rule matches.    * If<code>set</code> is not null, makes the expression part of that    * equivalence set. If an identical expression is already registered, we    * don't need to register this one and nor should we queue up rule matches.    *    * @param rel relational expression to register. Must be either a    *         {@link RelSubset}, or an unregistered {@link RelNode}    * @param set set that rel belongs to, or<code>null</code>    * @return the equivalence-set    */
specifier|private
name|RelSubset
name|registerImpl
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelSet
name|set
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|RelSubset
condition|)
block|{
return|return
name|registerSubset
argument_list|(
name|set
argument_list|,
operator|(
name|RelSubset
operator|)
name|rel
argument_list|)
return|;
block|}
assert|assert
operator|!
name|isRegistered
argument_list|(
name|rel
argument_list|)
operator|:
literal|"already been registered: "
operator|+
name|rel
assert|;
if|if
condition|(
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|!=
name|this
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Relational expression "
operator|+
name|rel
operator|+
literal|" belongs to a different planner than is currently being used."
argument_list|)
throw|;
block|}
comment|// Now is a good time to ensure that the relational expression
comment|// implements the interface required by its calling convention.
specifier|final
name|RelTraitSet
name|traits
init|=
name|rel
operator|.
name|getTraitSet
argument_list|()
decl_stmt|;
specifier|final
name|Convention
name|convention
init|=
name|traits
operator|.
name|getTrait
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
assert|assert
name|convention
operator|!=
literal|null
assert|;
if|if
condition|(
operator|!
name|convention
operator|.
name|getInterface
argument_list|()
operator|.
name|isInstance
argument_list|(
name|rel
argument_list|)
operator|&&
operator|!
operator|(
name|rel
operator|instanceof
name|Converter
operator|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Relational expression "
operator|+
name|rel
operator|+
literal|" has calling-convention "
operator|+
name|convention
operator|+
literal|" but does not implement the required interface '"
operator|+
name|convention
operator|.
name|getInterface
argument_list|()
operator|+
literal|"' of that convention"
argument_list|)
throw|;
block|}
if|if
condition|(
name|traits
operator|.
name|size
argument_list|()
operator|!=
name|traitDefs
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Relational expression "
operator|+
name|rel
operator|+
literal|" does not have the correct number of traits: "
operator|+
name|traits
operator|.
name|size
argument_list|()
operator|+
literal|" != "
operator|+
name|traitDefs
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
comment|// Ensure that its sub-expressions are registered.
name|rel
operator|=
name|rel
operator|.
name|onRegister
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Record its provenance. (Rule call may be null.)
if|if
condition|(
name|ruleCallStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|provenanceMap
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|Provenance
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|VolcanoRuleCall
name|ruleCall
init|=
name|ruleCallStack
operator|.
name|peek
argument_list|()
decl_stmt|;
name|provenanceMap
operator|.
name|put
argument_list|(
name|rel
argument_list|,
operator|new
name|RuleProvenance
argument_list|(
name|ruleCall
operator|.
name|rule
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|ruleCall
operator|.
name|rels
argument_list|)
argument_list|,
name|ruleCall
operator|.
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If it is equivalent to an existing expression, return the set that
comment|// the equivalent expression belongs to.
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|key
init|=
name|key
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|RelNode
name|equivExp
init|=
name|mapDigestToRel
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivExp
operator|==
literal|null
condition|)
block|{
comment|// do nothing
block|}
if|else if
condition|(
name|equivExp
operator|==
name|rel
condition|)
block|{
return|return
name|getSubset
argument_list|(
name|rel
argument_list|)
return|;
block|}
else|else
block|{
assert|assert
name|RelOptUtil
operator|.
name|equal
argument_list|(
literal|"left"
argument_list|,
name|equivExp
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|"right"
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
name|RelSet
name|equivSet
init|=
name|getSet
argument_list|(
name|equivExp
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivSet
operator|!=
literal|null
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Register: rel#{} is equivalent to {}"
argument_list|,
name|rel
operator|.
name|getId
argument_list|()
argument_list|,
name|equivExp
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|registerSubset
argument_list|(
name|set
argument_list|,
name|getSubset
argument_list|(
name|equivExp
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|// Converters are in the same set as their children.
if|if
condition|(
name|rel
operator|instanceof
name|Converter
condition|)
block|{
specifier|final
name|RelNode
name|input
init|=
operator|(
operator|(
name|Converter
operator|)
name|rel
operator|)
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RelSet
name|childSet
init|=
name|getSet
argument_list|(
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|set
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|set
operator|!=
name|childSet
operator|)
operator|&&
operator|(
name|set
operator|.
name|equivalentSet
operator|==
literal|null
operator|)
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Register #{} {} (and merge sets, because it is a conversion)"
argument_list|,
name|rel
operator|.
name|getId
argument_list|()
argument_list|,
name|rel
operator|.
name|getDigest
argument_list|()
argument_list|)
expr_stmt|;
name|merge
argument_list|(
name|set
argument_list|,
name|childSet
argument_list|)
expr_stmt|;
name|registerCount
operator|++
expr_stmt|;
comment|// During the mergers, the child set may have changed, and since
comment|// we're not registered yet, we won't have been informed. So
comment|// check whether we are now equivalent to an existing
comment|// expression.
if|if
condition|(
name|fixUpInputs
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|rel
operator|.
name|recomputeDigest
argument_list|()
expr_stmt|;
name|key
operator|=
name|key
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|RelNode
name|equivRel
init|=
name|mapDigestToRel
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|equivRel
operator|!=
name|rel
operator|)
operator|&&
operator|(
name|equivRel
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// make sure this bad rel didn't get into the
comment|// set in any way (fixupInputs will do this but it
comment|// doesn't know if it should so it does it anyway)
name|set
operator|.
name|obliterateRelNode
argument_list|(
name|rel
argument_list|)
expr_stmt|;
comment|// There is already an equivalent expression. Use that
comment|// one, and forget about this one.
return|return
name|getSubset
argument_list|(
name|equivRel
argument_list|)
return|;
block|}
block|}
block|}
else|else
block|{
name|set
operator|=
name|childSet
expr_stmt|;
block|}
block|}
comment|// Place the expression in the appropriate equivalence set.
if|if
condition|(
name|set
operator|==
literal|null
condition|)
block|{
name|set
operator|=
operator|new
name|RelSet
argument_list|(
name|nextSetId
operator|++
argument_list|,
name|Util
operator|.
name|minus
argument_list|(
name|RelOptUtil
operator|.
name|getVariablesSet
argument_list|(
name|rel
argument_list|)
argument_list|,
name|rel
operator|.
name|getVariablesSet
argument_list|()
argument_list|)
argument_list|,
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|allSets
operator|.
name|add
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
comment|// Chain to find 'live' equivalent set, just in case several sets are
comment|// merging at the same time.
while|while
condition|(
name|set
operator|.
name|equivalentSet
operator|!=
literal|null
condition|)
block|{
name|set
operator|=
name|set
operator|.
name|equivalentSet
expr_stmt|;
block|}
comment|// Allow each rel to register its own rules.
name|registerClass
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|registerCount
operator|++
expr_stmt|;
specifier|final
name|int
name|subsetBeforeCount
init|=
name|set
operator|.
name|subsets
operator|.
name|size
argument_list|()
decl_stmt|;
name|RelSubset
name|subset
init|=
name|addRelToSet
argument_list|(
name|rel
argument_list|,
name|set
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|xx
init|=
name|mapDigestToRel
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|rel
argument_list|)
decl_stmt|;
assert|assert
name|xx
operator|==
literal|null
operator|||
name|xx
operator|==
name|rel
operator|:
name|rel
operator|.
name|getDigest
argument_list|()
assert|;
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Register {} in {}"
argument_list|,
name|rel
operator|.
name|getDescription
argument_list|()
argument_list|,
name|subset
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
comment|// This relational expression may have been registered while we
comment|// recursively registered its children. If this is the case, we're done.
if|if
condition|(
name|xx
operator|!=
literal|null
condition|)
block|{
return|return
name|subset
return|;
block|}
comment|// Create back-links from its children, which makes children more
comment|// important.
if|if
condition|(
name|rel
operator|==
name|this
operator|.
name|root
condition|)
block|{
name|ruleQueue
operator|.
name|subsetImportances
operator|.
name|put
argument_list|(
name|subset
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
comment|// todo: remove
block|}
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|RelSubset
name|childSubset
init|=
operator|(
name|RelSubset
operator|)
name|input
decl_stmt|;
name|childSubset
operator|.
name|set
operator|.
name|parents
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
comment|// Child subset is more important now a new parent uses it.
name|ruleQueue
operator|.
name|recompute
argument_list|(
name|childSubset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rel
operator|==
name|this
operator|.
name|root
condition|)
block|{
name|ruleQueue
operator|.
name|subsetImportances
operator|.
name|remove
argument_list|(
name|subset
argument_list|)
expr_stmt|;
block|}
comment|// Remember abstract converters until they're satisfied
if|if
condition|(
name|rel
operator|instanceof
name|AbstractConverter
condition|)
block|{
name|set
operator|.
name|abstractConverters
operator|.
name|add
argument_list|(
operator|(
name|AbstractConverter
operator|)
name|rel
argument_list|)
expr_stmt|;
block|}
comment|// If this set has any unsatisfied converters, try to satisfy them.
name|checkForSatisfiedConverters
argument_list|(
name|set
argument_list|,
name|rel
argument_list|)
expr_stmt|;
comment|// Make sure this rel's subset importance is updated
name|ruleQueue
operator|.
name|recompute
argument_list|(
name|subset
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Queue up all rules triggered by this relexp's creation.
name|fireRules
argument_list|(
name|rel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// It's a new subset.
if|if
condition|(
name|set
operator|.
name|subsets
operator|.
name|size
argument_list|()
operator|>
name|subsetBeforeCount
condition|)
block|{
name|fireRules
argument_list|(
name|subset
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|subset
return|;
block|}
specifier|private
name|RelSubset
name|addRelToSet
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelSet
name|set
parameter_list|)
block|{
name|RelSubset
name|subset
init|=
name|set
operator|.
name|add
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|mapRel2Subset
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|subset
argument_list|)
expr_stmt|;
comment|// While a tree of RelNodes is being registered, sometimes nodes' costs
comment|// improve and the subset doesn't hear about it. You can end up with
comment|// a subset with a single rel of cost 99 which thinks its best cost is
comment|// 100. We think this happens because the back-links to parents are
comment|// not established. So, give the subset another change to figure out
comment|// its cost.
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|subset
operator|.
name|propagateCostImprovements
argument_list|(
name|this
argument_list|,
name|mq
argument_list|,
name|rel
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|subset
return|;
block|}
specifier|private
name|RelSubset
name|registerSubset
parameter_list|(
name|RelSet
name|set
parameter_list|,
name|RelSubset
name|subset
parameter_list|)
block|{
if|if
condition|(
operator|(
name|set
operator|!=
name|subset
operator|.
name|set
operator|)
operator|&&
operator|(
name|set
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|set
operator|.
name|equivalentSet
operator|==
literal|null
operator|)
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Register #{} {}, and merge sets"
argument_list|,
name|subset
operator|.
name|getId
argument_list|()
argument_list|,
name|subset
argument_list|)
expr_stmt|;
name|merge
argument_list|(
name|set
argument_list|,
name|subset
operator|.
name|set
argument_list|)
expr_stmt|;
name|registerCount
operator|++
expr_stmt|;
block|}
return|return
name|subset
return|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|void
name|addListener
parameter_list|(
name|RelOptListener
name|newListener
parameter_list|)
block|{
comment|// TODO jvs 6-Apr-2006:  new superclass AbstractRelOptPlanner
comment|// now defines a multicast listener; just need to hook it in
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|"multiple VolcanoPlanner listeners"
argument_list|)
throw|;
block|}
name|listener
operator|=
name|newListener
expr_stmt|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|void
name|registerMetadataProviders
parameter_list|(
name|List
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
parameter_list|)
block|{
name|list
operator|.
name|add
argument_list|(
literal|0
argument_list|,
operator|new
name|VolcanoRelMetadataProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|long
name|getRelMetadataTimestamp
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|RelSubset
name|subset
init|=
name|getSubset
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|subset
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|subset
operator|.
name|timestamp
return|;
block|}
block|}
comment|/**    * Normalizes references to subsets within the string representation of a    * plan.    *    *<p>This is useful when writing tests: it helps to ensure that tests don't    * break when an extra rule is introduced that generates a new subset and    * causes subsequent subset numbers to be off by one.    *    *<p>For example,    *    *<blockquote>    * FennelAggRel.FENNEL_EXEC(child=Subset#17.FENNEL_EXEC,groupCount=1,    * EXPR$1=COUNT())<br>    *&nbsp;&nbsp;FennelSortRel.FENNEL_EXEC(child=Subset#2.FENNEL_EXEC,    * key=[0], discardDuplicates=false)<br>    *&nbsp;&nbsp;&nbsp;&nbsp;FennelCalcRel.FENNEL_EXEC(    * child=Subset#4.FENNEL_EXEC, expr#0..8={inputs}, expr#9=3456,    * DEPTNO=$t7, $f0=$t9)<br>    *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MockTableImplRel.FENNEL_EXEC(    * table=[CATALOG, SALES, EMP])</blockquote>    *    *<p>becomes    *    *<blockquote>    * FennelAggRel.FENNEL_EXEC(child=Subset#{0}.FENNEL_EXEC, groupCount=1,    * EXPR$1=COUNT())<br>    *&nbsp;&nbsp;FennelSortRel.FENNEL_EXEC(child=Subset#{1}.FENNEL_EXEC,    * key=[0], discardDuplicates=false)<br>    *&nbsp;&nbsp;&nbsp;&nbsp;FennelCalcRel.FENNEL_EXEC(    * child=Subset#{2}.FENNEL_EXEC,expr#0..8={inputs},expr#9=3456,DEPTNO=$t7,    * $f0=$t9)<br>    *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MockTableImplRel.FENNEL_EXEC(    * table=[CATALOG, SALES, EMP])</blockquote>    *    * @param plan Plan    * @return Normalized plan    */
specifier|public
specifier|static
name|String
name|normalizePlan
parameter_list|(
name|String
name|plan
parameter_list|)
block|{
if|if
condition|(
name|plan
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Pattern
name|poundDigits
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"Subset#[0-9]+\\."
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|Matcher
name|matcher
init|=
name|poundDigits
operator|.
name|matcher
argument_list|(
name|plan
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
return|return
name|plan
return|;
block|}
specifier|final
name|String
name|token
init|=
name|matcher
operator|.
name|group
argument_list|()
decl_stmt|;
comment|// e.g. "Subset#23."
name|plan
operator|=
name|plan
operator|.
name|replace
argument_list|(
name|token
argument_list|,
literal|"Subset#{"
operator|+
name|i
operator|++
operator|+
literal|"}."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Sets whether this planner is locked. A locked planner does not accept    * new rules. {@link #addRule(org.apache.calcite.plan.RelOptRule)} will do    * nothing and return false.    *    * @param locked Whether planner is locked    */
specifier|public
name|void
name|setLocked
parameter_list|(
name|boolean
name|locked
parameter_list|)
block|{
name|this
operator|.
name|locked
operator|=
name|locked
expr_stmt|;
block|}
specifier|public
name|void
name|ensureRegistered
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|equivRel
parameter_list|,
name|VolcanoRuleCall
name|ruleCall
parameter_list|)
block|{
name|ensureRegistered
argument_list|(
name|rel
argument_list|,
name|equivRel
argument_list|)
expr_stmt|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * A rule call which defers its actions. Whereas {@link RelOptRuleCall}    * invokes the rule when it finds a match, a<code>DeferringRuleCall</code>    * creates a {@link VolcanoRuleMatch} which can be invoked later.    */
specifier|private
specifier|static
class|class
name|DeferringRuleCall
extends|extends
name|VolcanoRuleCall
block|{
name|DeferringRuleCall
parameter_list|(
name|VolcanoPlanner
name|planner
parameter_list|,
name|RelOptRuleOperand
name|operand
parameter_list|)
block|{
name|super
argument_list|(
name|planner
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
comment|/**      * Rather than invoking the rule (as the base method does), creates a      * {@link VolcanoRuleMatch} which can be invoked later.      */
specifier|protected
name|void
name|onMatch
parameter_list|()
block|{
specifier|final
name|VolcanoRuleMatch
name|match
init|=
operator|new
name|VolcanoRuleMatch
argument_list|(
name|volcanoPlanner
argument_list|,
name|getOperand0
argument_list|()
argument_list|,
name|rels
argument_list|,
name|nodeInputs
argument_list|)
decl_stmt|;
name|volcanoPlanner
operator|.
name|ruleQueue
operator|.
name|addMatch
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Where a RelNode came from.    */
specifier|private
specifier|abstract
specifier|static
class|class
name|Provenance
block|{
specifier|public
specifier|static
specifier|final
name|Provenance
name|EMPTY
init|=
operator|new
name|UnknownProvenance
argument_list|()
decl_stmt|;
block|}
comment|/**    * We do not know where this RelNode came from. Probably created by hand,    * or by sql-to-rel converter.    */
specifier|private
specifier|static
class|class
name|UnknownProvenance
extends|extends
name|Provenance
block|{   }
comment|/**    * A RelNode that came directly from another RelNode via a copy.    */
specifier|static
class|class
name|DirectProvenance
extends|extends
name|Provenance
block|{
specifier|final
name|RelNode
name|source
decl_stmt|;
name|DirectProvenance
parameter_list|(
name|RelNode
name|source
parameter_list|)
block|{
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
block|}
block|}
comment|/**    * A RelNode that came via the firing of a rule.    */
specifier|static
class|class
name|RuleProvenance
extends|extends
name|Provenance
block|{
specifier|final
name|RelOptRule
name|rule
decl_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|RelNode
argument_list|>
name|rels
decl_stmt|;
specifier|final
name|int
name|callId
decl_stmt|;
name|RuleProvenance
parameter_list|(
name|RelOptRule
name|rule
parameter_list|,
name|ImmutableList
argument_list|<
name|RelNode
argument_list|>
name|rels
parameter_list|,
name|int
name|callId
parameter_list|)
block|{
name|this
operator|.
name|rule
operator|=
name|rule
expr_stmt|;
name|this
operator|.
name|rels
operator|=
name|rels
expr_stmt|;
name|this
operator|.
name|callId
operator|=
name|callId
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End VolcanoPlanner.java
end_comment

end_unit

