begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteSystemProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|AbstractRelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Convention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|ConventionTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCostFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptLattice
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptMaterialization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptMaterializations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleOperand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTrait
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|PhysicalNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|convert
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|convert
operator|.
name|ConverterRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|externalize
operator|.
name|RelWriterImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|CyclicMetadataException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|JaninoRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMdUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|TransformationRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Hook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  * VolcanoPlanner optimizes queries by transforming expressions selectively  * according to a dynamic programming algorithm.  */
end_comment

begin_class
specifier|public
class|class
name|VolcanoPlanner
extends|extends
name|AbstractRelOptPlanner
block|{
comment|//~ Instance fields --------------------------------------------------------
specifier|protected
name|RelSubset
name|root
decl_stmt|;
comment|/**    * Operands that apply to a given class of {@link RelNode}.    *    *<p>Any operand can be an 'entry point' to a rule call, when a RelNode is    * registered which matches the operand. This map allows us to narrow down    * operands based on the class of the RelNode.</p>    */
specifier|private
specifier|final
name|Multimap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|RelOptRuleOperand
argument_list|>
name|classOperands
init|=
name|LinkedListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
comment|/**    * List of all sets. Used only for debugging.    */
specifier|final
name|List
argument_list|<
name|RelSet
argument_list|>
name|allSets
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Canonical map from {@link String digest} to the unique    * {@link RelNode relational expression} with that digest.    *    *<p>Row type is part of the key for the rare occasion that similar    * expressions have different types, e.g. variants of    * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a    * null VARCHAR(10).</p>    *<p>Row type is represented as fieldTypes only, so {@code RelNode} that differ    * with field names only are treated equal.    * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}    * are equal</p>    */
specifier|private
specifier|final
name|Map
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
argument_list|>
argument_list|,
name|RelNode
argument_list|>
name|mapDigestToRel
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Map each registered expression ({@link RelNode}) to its equivalence set    * ({@link RelSubset}).    *    *<p>We use an {@link IdentityHashMap} to simplify the process of merging    * {@link RelSet} objects. Most {@link RelNode} objects are identified by    * their digest, which involves the set that their child relational    * expressions belong to. If those children belong to the same set, we have    * to be careful, otherwise it gets incestuous.</p>    */
specifier|private
specifier|final
name|IdentityHashMap
argument_list|<
name|RelNode
argument_list|,
name|RelSubset
argument_list|>
name|mapRel2Subset
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * The nodes to be pruned.    *    *<p>If a RelNode is pruned, all {@link RelOptRuleCall}s using it    * are ignored, and future RelOptRuleCalls are not queued up.    */
specifier|final
name|Set
argument_list|<
name|RelNode
argument_list|>
name|prunedNodes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * List of all schemas which have been registered.    */
specifier|private
specifier|final
name|Set
argument_list|<
name|RelOptSchema
argument_list|>
name|registeredSchemas
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Holds rule calls waiting to be fired.    */
specifier|final
name|RuleQueue
name|ruleQueue
init|=
operator|new
name|RuleQueue
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|/**    * Holds the currently registered RelTraitDefs.    */
specifier|private
specifier|final
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|traitDefs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|int
name|nextSetId
init|=
literal|0
decl_stmt|;
specifier|private
name|RelNode
name|originalRoot
decl_stmt|;
comment|/**    * Whether the planner can accept new rules.    */
specifier|private
name|boolean
name|locked
decl_stmt|;
comment|/**    * Whether rels with Convention.NONE has infinite cost.    */
specifier|private
name|boolean
name|noneConventionHasInfiniteCost
init|=
literal|true
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|materializations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Map of lattices by the qualified name of their star table.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|RelOptLattice
argument_list|>
name|latticeByName
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Provenance
argument_list|>
name|provenanceMap
decl_stmt|;
specifier|final
name|Deque
argument_list|<
name|VolcanoRuleCall
argument_list|>
name|ruleCallStack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Zero cost, according to {@link #costFactory}. Not necessarily a    * {@link org.apache.calcite.plan.volcano.VolcanoCost}. */
specifier|private
specifier|final
name|RelOptCost
name|zeroCost
decl_stmt|;
comment|/**    * Optimization tasks including trait propagation, enforcement.    */
specifier|final
name|Deque
argument_list|<
name|OptimizeTask
argument_list|>
name|tasks
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * The id generator for optimization tasks.    */
name|int
name|nextTaskId
init|=
literal|0
decl_stmt|;
comment|/**    * Whether to enable top-down optimization or not.    */
name|boolean
name|topDownOpt
init|=
name|CalciteSystemProperty
operator|.
name|TOPDOWN_OPT
operator|.
name|value
argument_list|()
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a uninitialized<code>VolcanoPlanner</code>. To fully initialize    * it, the caller must register the desired set of relations, rules, and    * calling conventions.    */
specifier|public
name|VolcanoPlanner
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a uninitialized<code>VolcanoPlanner</code>. To fully initialize    * it, the caller must register the desired set of relations, rules, and    * calling conventions.    */
specifier|public
name|VolcanoPlanner
parameter_list|(
name|Context
name|externalContext
parameter_list|)
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|externalContext
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a {@code VolcanoPlanner} with a given cost factory.    */
specifier|public
name|VolcanoPlanner
parameter_list|(
name|RelOptCostFactory
name|costFactory
parameter_list|,
name|Context
name|externalContext
parameter_list|)
block|{
name|super
argument_list|(
name|costFactory
operator|==
literal|null
condition|?
name|VolcanoCost
operator|.
name|FACTORY
else|:
name|costFactory
argument_list|,
name|externalContext
argument_list|)
expr_stmt|;
name|this
operator|.
name|zeroCost
operator|=
name|this
operator|.
name|costFactory
operator|.
name|makeZeroCost
argument_list|()
expr_stmt|;
comment|// If LOGGER is debug enabled, enable provenance information to be captured
name|this
operator|.
name|provenanceMap
operator|=
name|LOGGER
operator|.
name|isDebugEnabled
argument_list|()
condition|?
operator|new
name|HashMap
argument_list|<>
argument_list|()
else|:
name|Util
operator|.
name|blackholeMap
argument_list|()
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|protected
name|VolcanoPlannerPhaseRuleMappingInitializer
name|getPhaseRuleMappingInitializer
parameter_list|()
block|{
return|return
name|phaseRuleMap
lambda|->
block|{
comment|// Disable all phases except OPTIMIZE by adding one useless rule name.
name|phaseRuleMap
operator|.
name|get
argument_list|(
name|VolcanoPlannerPhase
operator|.
name|PRE_PROCESS_MDR
argument_list|)
operator|.
name|add
argument_list|(
literal|"xxx"
argument_list|)
expr_stmt|;
name|phaseRuleMap
operator|.
name|get
argument_list|(
name|VolcanoPlannerPhase
operator|.
name|PRE_PROCESS
argument_list|)
operator|.
name|add
argument_list|(
literal|"xxx"
argument_list|)
expr_stmt|;
name|phaseRuleMap
operator|.
name|get
argument_list|(
name|VolcanoPlannerPhase
operator|.
name|CLEANUP
argument_list|)
operator|.
name|add
argument_list|(
literal|"xxx"
argument_list|)
expr_stmt|;
block|}
return|;
block|}
comment|/**    * Enable or disable top-down optimization.    *    *<p>Note: Enabling top-down optimization will automatically disable    * the use of AbstractConverter and related rules.</p>    */
specifier|public
name|void
name|setTopDownOpt
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|topDownOpt
operator|=
name|value
expr_stmt|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|boolean
name|isRegistered
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|mapRel2Subset
operator|.
name|get
argument_list|(
name|rel
argument_list|)
operator|!=
literal|null
return|;
block|}
specifier|public
name|void
name|setRoot
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
comment|// We've registered all the rules, and therefore RelNode classes,
comment|// we're interested in, and have not yet started calling metadata providers.
comment|// So now is a good time to tell the metadata layer what to expect.
name|registerMetadataRels
argument_list|()
expr_stmt|;
name|this
operator|.
name|root
operator|=
name|registerImpl
argument_list|(
name|rel
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|originalRoot
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|originalRoot
operator|=
name|rel
expr_stmt|;
block|}
name|ensureRootConverters
argument_list|()
expr_stmt|;
block|}
specifier|public
name|RelNode
name|getRoot
parameter_list|()
block|{
return|return
name|root
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|getMaterializations
parameter_list|()
block|{
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|materializations
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addMaterialization
parameter_list|(
name|RelOptMaterialization
name|materialization
parameter_list|)
block|{
name|materializations
operator|.
name|add
argument_list|(
name|materialization
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addLattice
parameter_list|(
name|RelOptLattice
name|lattice
parameter_list|)
block|{
name|latticeByName
operator|.
name|put
argument_list|(
name|lattice
operator|.
name|starRelOptTable
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|lattice
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RelOptLattice
name|getLattice
parameter_list|(
name|RelOptTable
name|table
parameter_list|)
block|{
return|return
name|latticeByName
operator|.
name|get
argument_list|(
name|table
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|void
name|registerMaterializations
parameter_list|()
block|{
comment|// Avoid using materializations while populating materializations!
specifier|final
name|CalciteConnectionConfig
name|config
init|=
name|context
operator|.
name|unwrap
argument_list|(
name|CalciteConnectionConfig
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
literal|null
operator|||
operator|!
name|config
operator|.
name|materializationsEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Register rels using materialized views.
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
argument_list|>
argument_list|>
name|materializationUses
init|=
name|RelOptMaterializations
operator|.
name|useMaterializedViews
argument_list|(
name|originalRoot
argument_list|,
name|materializations
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
argument_list|>
name|use
range|:
name|materializationUses
control|)
block|{
name|RelNode
name|rel
init|=
name|use
operator|.
name|left
decl_stmt|;
name|Hook
operator|.
name|SUB
operator|.
name|run
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|registerImpl
argument_list|(
name|rel
argument_list|,
name|root
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
comment|// Register table rels of materialized views that cannot find a substitution
comment|// in root rel transformation but can potentially be useful.
specifier|final
name|Set
argument_list|<
name|RelOptMaterialization
argument_list|>
name|applicableMaterializations
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|RelOptMaterializations
operator|.
name|getApplicableMaterializations
argument_list|(
name|originalRoot
argument_list|,
name|materializations
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
argument_list|>
name|use
range|:
name|materializationUses
control|)
block|{
name|applicableMaterializations
operator|.
name|removeAll
argument_list|(
name|use
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RelOptMaterialization
name|materialization
range|:
name|applicableMaterializations
control|)
block|{
name|RelSubset
name|subset
init|=
name|registerImpl
argument_list|(
name|materialization
operator|.
name|queryRel
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|RelNode
name|tableRel2
init|=
name|RelOptUtil
operator|.
name|createCastRel
argument_list|(
name|materialization
operator|.
name|tableRel
argument_list|,
name|materialization
operator|.
name|queryRel
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|registerImpl
argument_list|(
name|tableRel2
argument_list|,
name|subset
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
comment|// Register rels using lattices.
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelOptLattice
argument_list|>
argument_list|>
name|latticeUses
init|=
name|RelOptMaterializations
operator|.
name|useLattices
argument_list|(
name|originalRoot
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|latticeByName
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|latticeUses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|RelNode
name|rel
init|=
name|latticeUses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|left
decl_stmt|;
name|Hook
operator|.
name|SUB
operator|.
name|run
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|registerImpl
argument_list|(
name|rel
argument_list|,
name|root
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Finds an expression's equivalence set. If the expression is not    * registered, returns null.    *    * @param rel Relational expression    * @return Equivalence set that expression belongs to, or null if it is not    * registered    */
specifier|public
name|RelSet
name|getSet
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
assert|assert
name|rel
operator|!=
literal|null
operator|:
literal|"pre: rel != null"
assert|;
specifier|final
name|RelSubset
name|subset
init|=
name|getSubset
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|subset
operator|!=
literal|null
condition|)
block|{
assert|assert
name|subset
operator|.
name|set
operator|!=
literal|null
assert|;
return|return
name|subset
operator|.
name|set
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|addRelTraitDef
parameter_list|(
name|RelTraitDef
name|relTraitDef
parameter_list|)
block|{
return|return
operator|!
name|traitDefs
operator|.
name|contains
argument_list|(
name|relTraitDef
argument_list|)
operator|&&
name|traitDefs
operator|.
name|add
argument_list|(
name|relTraitDef
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clearRelTraitDefs
parameter_list|()
block|{
name|traitDefs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|getRelTraitDefs
parameter_list|()
block|{
return|return
name|traitDefs
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelTraitSet
name|emptyTraitSet
parameter_list|()
block|{
name|RelTraitSet
name|traitSet
init|=
name|super
operator|.
name|emptyTraitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTraitDef
name|traitDef
range|:
name|traitDefs
control|)
block|{
if|if
condition|(
name|traitDef
operator|.
name|multiple
argument_list|()
condition|)
block|{
comment|// TODO: restructure RelTraitSet to allow a list of entries
comment|//  for any given trait
block|}
name|traitSet
operator|=
name|traitSet
operator|.
name|plus
argument_list|(
name|traitDef
operator|.
name|getDefault
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|traitSet
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|super
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|getRules
argument_list|()
control|)
block|{
name|removeRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|classOperands
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|allSets
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|mapDigestToRel
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|mapRel2Subset
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|prunedNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|ruleQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|materializations
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|latticeByName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|provenanceMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|addRule
parameter_list|(
name|RelOptRule
name|rule
parameter_list|)
block|{
if|if
condition|(
name|locked
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|super
operator|.
name|addRule
argument_list|(
name|rule
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Each of this rule's operands is an 'entry point' for a rule call.
comment|// Register each operand against all concrete sub-classes that could match
comment|// it.
for|for
control|(
name|RelOptRuleOperand
name|operand
range|:
name|rule
operator|.
name|getOperands
argument_list|()
control|)
block|{
for|for
control|(
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|subClass
range|:
name|subClasses
argument_list|(
name|operand
operator|.
name|getMatchedClass
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|PhysicalNode
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|subClass
argument_list|)
operator|&&
name|rule
operator|instanceof
name|TransformationRule
condition|)
block|{
continue|continue;
block|}
name|classOperands
operator|.
name|put
argument_list|(
name|subClass
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If this is a converter rule, check that it operates on one of the
comment|// kinds of trait we are interested in, and if so, register the rule
comment|// with the trait.
if|if
condition|(
name|rule
operator|instanceof
name|ConverterRule
condition|)
block|{
name|ConverterRule
name|converterRule
init|=
operator|(
name|ConverterRule
operator|)
name|rule
decl_stmt|;
specifier|final
name|RelTrait
name|ruleTrait
init|=
name|converterRule
operator|.
name|getInTrait
argument_list|()
decl_stmt|;
specifier|final
name|RelTraitDef
name|ruleTraitDef
init|=
name|ruleTrait
operator|.
name|getTraitDef
argument_list|()
decl_stmt|;
if|if
condition|(
name|traitDefs
operator|.
name|contains
argument_list|(
name|ruleTraitDef
argument_list|)
condition|)
block|{
name|ruleTraitDef
operator|.
name|registerConverterRule
argument_list|(
name|this
argument_list|,
name|converterRule
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|removeRule
parameter_list|(
name|RelOptRule
name|rule
parameter_list|)
block|{
comment|// Remove description.
if|if
condition|(
operator|!
name|super
operator|.
name|removeRule
argument_list|(
name|rule
argument_list|)
condition|)
block|{
comment|// Rule was not present.
return|return
literal|false
return|;
block|}
comment|// Remove operands.
name|classOperands
operator|.
name|values
argument_list|()
operator|.
name|removeIf
argument_list|(
name|entry
lambda|->
name|entry
operator|.
name|getRule
argument_list|()
operator|.
name|equals
argument_list|(
name|rule
argument_list|)
argument_list|)
expr_stmt|;
comment|// Remove trait mappings. (In particular, entries from conversion
comment|// graph.)
if|if
condition|(
name|rule
operator|instanceof
name|ConverterRule
condition|)
block|{
name|ConverterRule
name|converterRule
init|=
operator|(
name|ConverterRule
operator|)
name|rule
decl_stmt|;
specifier|final
name|RelTrait
name|ruleTrait
init|=
name|converterRule
operator|.
name|getInTrait
argument_list|()
decl_stmt|;
specifier|final
name|RelTraitDef
name|ruleTraitDef
init|=
name|ruleTrait
operator|.
name|getTraitDef
argument_list|()
decl_stmt|;
if|if
condition|(
name|traitDefs
operator|.
name|contains
argument_list|(
name|ruleTraitDef
argument_list|)
condition|)
block|{
name|ruleTraitDef
operator|.
name|deregisterConverterRule
argument_list|(
name|this
argument_list|,
name|converterRule
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|onNewClass
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
name|super
operator|.
name|onNewClass
argument_list|(
name|node
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|isPhysical
init|=
name|node
operator|instanceof
name|PhysicalNode
decl_stmt|;
comment|// Create mappings so that instances of this class will match existing
comment|// operands.
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|clazz
init|=
name|node
operator|.
name|getClass
argument_list|()
decl_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|mapDescToRule
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|isPhysical
operator|&&
name|rule
operator|instanceof
name|TransformationRule
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|RelOptRuleOperand
name|operand
range|:
name|rule
operator|.
name|getOperands
argument_list|()
control|)
block|{
if|if
condition|(
name|operand
operator|.
name|getMatchedClass
argument_list|()
operator|.
name|isAssignableFrom
argument_list|(
name|clazz
argument_list|)
condition|)
block|{
name|classOperands
operator|.
name|put
argument_list|(
name|clazz
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|RelNode
name|changeTraits
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|toTraits
parameter_list|)
block|{
assert|assert
operator|!
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|toTraits
argument_list|)
assert|;
assert|assert
name|toTraits
operator|.
name|allSimple
argument_list|()
assert|;
name|RelSubset
name|rel2
init|=
name|ensureRegistered
argument_list|(
name|rel
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|rel2
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|toTraits
argument_list|)
condition|)
block|{
return|return
name|rel2
return|;
block|}
return|return
name|rel2
operator|.
name|set
operator|.
name|getOrCreateSubset
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|toTraits
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
name|RelOptPlanner
name|chooseDelegate
parameter_list|()
block|{
return|return
name|this
return|;
block|}
comment|/**    * Finds the most efficient expression to implement the query given via    * {@link org.apache.calcite.plan.RelOptPlanner#setRoot(org.apache.calcite.rel.RelNode)}.    *    *<p>The algorithm executes repeatedly in a series of phases. In each phase    * the exact rules that may be fired varies. The mapping of phases to rule    * sets is maintained in the {@link #ruleQueue}.    *    *<p>In each phase, the planner then iterates over the rule matches presented    * by the rule queue until the rule queue becomes empty.    *    * @return the most efficient RelNode tree found for implementing the given    * query    */
specifier|public
name|RelNode
name|findBestExp
parameter_list|()
block|{
name|ensureRootConverters
argument_list|()
expr_stmt|;
name|registerMaterializations
argument_list|()
expr_stmt|;
name|PLANNING
label|:
for|for
control|(
name|VolcanoPlannerPhase
name|phase
range|:
name|VolcanoPlannerPhase
operator|.
name|values
argument_list|()
control|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"PLANNER = {}; PHASE = {}; COST = {}"
argument_list|,
name|this
argument_list|,
name|phase
operator|.
name|toString
argument_list|()
argument_list|,
name|root
operator|.
name|bestCost
argument_list|)
expr_stmt|;
name|VolcanoRuleMatch
name|match
init|=
name|ruleQueue
operator|.
name|popMatch
argument_list|(
name|phase
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|==
literal|null
condition|)
block|{
break|break;
block|}
assert|assert
name|match
operator|.
name|getRule
argument_list|()
operator|.
name|matches
argument_list|(
name|match
argument_list|)
assert|;
try|try
block|{
name|match
operator|.
name|onMatch
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|VolcanoTimeoutException
name|e
parameter_list|)
block|{
name|root
operator|=
name|canonize
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|ruleQueue
operator|.
name|phaseCompleted
argument_list|(
name|phase
argument_list|)
expr_stmt|;
break|break
name|PLANNING
break|;
block|}
comment|// The root may have been merged with another
comment|// subset. Find the new root subset.
name|root
operator|=
name|canonize
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
name|ruleQueue
operator|.
name|phaseCompleted
argument_list|(
name|phase
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|topDownOpt
condition|)
block|{
name|tasks
operator|.
name|push
argument_list|(
name|OptimizeTask
operator|.
name|create
argument_list|(
name|root
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|tasks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|OptimizeTask
name|task
init|=
name|tasks
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|task
operator|.
name|hasSubTask
argument_list|()
condition|)
block|{
name|tasks
operator|.
name|push
argument_list|(
name|task
operator|.
name|nextSubTask
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|task
operator|=
name|tasks
operator|.
name|pop
argument_list|()
expr_stmt|;
name|task
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|dump
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
name|LOGGER
operator|.
name|trace
argument_list|(
name|sw
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|dumpRuleAttemptsInfo
argument_list|()
expr_stmt|;
name|RelNode
name|cheapest
init|=
name|root
operator|.
name|buildCheapestPlan
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOGGER
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Cheapest plan:\n{}"
argument_list|,
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|cheapest
argument_list|,
name|SqlExplainLevel
operator|.
name|ALL_ATTRIBUTES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|provenanceMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Provenance:\n{}"
argument_list|,
name|Dumpers
operator|.
name|provenance
argument_list|(
name|provenanceMap
argument_list|,
name|cheapest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|cheapest
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkCancel
parameter_list|()
block|{
if|if
condition|(
name|cancelFlag
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|VolcanoTimeoutException
argument_list|()
throw|;
block|}
block|}
comment|/** Informs {@link JaninoRelMetadataProvider} about the different kinds of    * {@link RelNode} that we will be dealing with. It will reduce the number    * of times that we need to re-generate the provider. */
specifier|private
name|void
name|registerMetadataRels
parameter_list|()
block|{
name|JaninoRelMetadataProvider
operator|.
name|DEFAULT
operator|.
name|register
argument_list|(
name|classOperands
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Ensures that the subset that is the root relational expression contains    * converters to all other subsets in its equivalence set.    *    *<p>Thus the planner tries to find cheap implementations of those other    * subsets, which can then be converted to the root. This is the only place    * in the plan where explicit converters are required; elsewhere, a consumer    * will be asking for the result in a particular convention, but the root has    * no consumers. */
name|void
name|ensureRootConverters
parameter_list|()
block|{
specifier|final
name|Set
argument_list|<
name|RelSubset
argument_list|>
name|subsets
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|root
operator|.
name|getRels
argument_list|()
control|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|AbstractConverter
condition|)
block|{
name|subsets
operator|.
name|add
argument_list|(
operator|(
name|RelSubset
operator|)
operator|(
operator|(
name|AbstractConverter
operator|)
name|rel
operator|)
operator|.
name|getInput
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|RelSubset
name|subset
range|:
name|root
operator|.
name|set
operator|.
name|subsets
control|)
block|{
specifier|final
name|ImmutableList
argument_list|<
name|RelTrait
argument_list|>
name|difference
init|=
name|root
operator|.
name|getTraitSet
argument_list|()
operator|.
name|difference
argument_list|(
name|subset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|difference
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|subsets
operator|.
name|add
argument_list|(
name|subset
argument_list|)
condition|)
block|{
name|register
argument_list|(
operator|new
name|AbstractConverter
argument_list|(
name|subset
operator|.
name|getCluster
argument_list|()
argument_list|,
name|subset
argument_list|,
name|difference
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTraitDef
argument_list|()
argument_list|,
name|root
operator|.
name|getTraitSet
argument_list|()
argument_list|)
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|RelSubset
name|register
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|equivRel
parameter_list|)
block|{
assert|assert
operator|!
name|isRegistered
argument_list|(
name|rel
argument_list|)
operator|:
literal|"pre: isRegistered(rel)"
assert|;
specifier|final
name|RelSet
name|set
decl_stmt|;
if|if
condition|(
name|equivRel
operator|==
literal|null
condition|)
block|{
name|set
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|RelOptUtil
operator|.
name|equal
argument_list|(
literal|"rel rowtype"
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|"equivRel rowtype"
argument_list|,
name|equivRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
name|set
operator|=
name|getSet
argument_list|(
name|equivRel
argument_list|)
expr_stmt|;
block|}
return|return
name|registerImpl
argument_list|(
name|rel
argument_list|,
name|set
argument_list|)
return|;
block|}
specifier|public
name|RelSubset
name|ensureRegistered
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|equivRel
parameter_list|)
block|{
name|RelSubset
name|result
decl_stmt|;
specifier|final
name|RelSubset
name|subset
init|=
name|getSubset
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|subset
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|equivRel
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RelSubset
name|equivSubset
init|=
name|getSubset
argument_list|(
name|equivRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|subset
operator|.
name|set
operator|!=
name|equivSubset
operator|.
name|set
condition|)
block|{
name|merge
argument_list|(
name|equivSubset
operator|.
name|set
argument_list|,
name|subset
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
name|subset
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|register
argument_list|(
name|rel
argument_list|,
name|equivRel
argument_list|)
expr_stmt|;
block|}
comment|// Checking if tree is valid considerably slows down planning
comment|// Only doing it if logger level is debug or finer
if|if
condition|(
name|LOGGER
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
assert|assert
name|isValid
argument_list|(
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Checks internal consistency.    */
specifier|protected
name|boolean
name|isValid
parameter_list|(
name|Litmus
name|litmus
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|getRoot
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
name|RelMetadataQuery
name|metaQuery
init|=
name|this
operator|.
name|getRoot
argument_list|()
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuerySupplier
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
for|for
control|(
name|RelSet
name|set
range|:
name|allSets
control|)
block|{
if|if
condition|(
name|set
operator|.
name|equivalentSet
operator|!=
literal|null
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"set [{}] has been merged: it should not be in the list"
argument_list|,
name|set
argument_list|)
return|;
block|}
for|for
control|(
name|RelSubset
name|subset
range|:
name|set
operator|.
name|subsets
control|)
block|{
if|if
condition|(
name|subset
operator|.
name|set
operator|!=
name|set
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"subset [{}] is in wrong set [{}]"
argument_list|,
name|subset
argument_list|,
name|set
argument_list|)
return|;
block|}
if|if
condition|(
name|subset
operator|.
name|best
operator|!=
literal|null
condition|)
block|{
comment|// Make sure best RelNode is valid
if|if
condition|(
operator|!
name|subset
operator|.
name|set
operator|.
name|rels
operator|.
name|contains
argument_list|(
name|subset
operator|.
name|best
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"RelSubset [{}] does not contain its best RelNode [{}]"
argument_list|,
name|subset
argument_list|,
name|subset
operator|.
name|best
argument_list|)
return|;
block|}
comment|// Make sure bestCost is up-to-date
try|try
block|{
name|RelOptCost
name|bestCost
init|=
name|getCost
argument_list|(
name|subset
operator|.
name|best
argument_list|,
name|metaQuery
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|subset
operator|.
name|bestCost
operator|.
name|equals
argument_list|(
name|bestCost
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"RelSubset ["
operator|+
name|subset
operator|+
literal|"] has wrong best cost "
operator|+
name|subset
operator|.
name|bestCost
operator|+
literal|". Correct cost is "
operator|+
name|bestCost
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|CyclicMetadataException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
for|for
control|(
name|RelNode
name|rel
range|:
name|subset
operator|.
name|getRels
argument_list|()
control|)
block|{
try|try
block|{
name|RelOptCost
name|relCost
init|=
name|getCost
argument_list|(
name|rel
argument_list|,
name|metaQuery
argument_list|)
decl_stmt|;
if|if
condition|(
name|relCost
operator|.
name|isLt
argument_list|(
name|subset
operator|.
name|bestCost
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"rel [{}] has lower cost {} than "
operator|+
literal|"best cost {} of subset [{}]"
argument_list|,
name|rel
argument_list|,
name|relCost
argument_list|,
name|subset
operator|.
name|bestCost
argument_list|,
name|subset
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|CyclicMetadataException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
specifier|public
name|void
name|registerAbstractRelationalRules
parameter_list|()
block|{
name|RelOptUtil
operator|.
name|registerAbstractRelationalRules
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|registerSchema
parameter_list|(
name|RelOptSchema
name|schema
parameter_list|)
block|{
if|if
condition|(
name|registeredSchemas
operator|.
name|add
argument_list|(
name|schema
argument_list|)
condition|)
block|{
try|try
block|{
name|schema
operator|.
name|registerRules
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"While registering schema "
operator|+
name|schema
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Sets whether this planner should consider rel nodes with Convention.NONE    * to have infinite cost or not.    * @param infinite Whether to make none convention rel nodes infinite cost    */
specifier|public
name|void
name|setNoneConventionHasInfiniteCost
parameter_list|(
name|boolean
name|infinite
parameter_list|)
block|{
name|this
operator|.
name|noneConventionHasInfiniteCost
operator|=
name|infinite
expr_stmt|;
block|}
specifier|public
name|RelOptCost
name|getCost
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
assert|assert
name|rel
operator|!=
literal|null
operator|:
literal|"pre-condition: rel != null"
assert|;
if|if
condition|(
name|rel
operator|instanceof
name|RelSubset
condition|)
block|{
return|return
operator|(
operator|(
name|RelSubset
operator|)
name|rel
operator|)
operator|.
name|bestCost
return|;
block|}
if|if
condition|(
name|noneConventionHasInfiniteCost
operator|&&
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTrait
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
operator|==
name|Convention
operator|.
name|NONE
condition|)
block|{
return|return
name|costFactory
operator|.
name|makeInfiniteCost
argument_list|()
return|;
block|}
name|RelOptCost
name|cost
init|=
name|mq
operator|.
name|getNonCumulativeCost
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|zeroCost
operator|.
name|isLt
argument_list|(
name|cost
argument_list|)
condition|)
block|{
comment|// cost must be positive, so nudge it
name|cost
operator|=
name|costFactory
operator|.
name|makeTinyCost
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|cost
operator|=
name|cost
operator|.
name|plus
argument_list|(
name|getCost
argument_list|(
name|input
argument_list|,
name|mq
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
comment|/**    * Returns the subset that a relational expression belongs to.    *    * @param rel Relational expression    * @return Subset it belongs to, or null if it is not registered    */
specifier|public
name|RelSubset
name|getSubset
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
assert|assert
name|rel
operator|!=
literal|null
operator|:
literal|"pre: rel != null"
assert|;
if|if
condition|(
name|rel
operator|instanceof
name|RelSubset
condition|)
block|{
return|return
operator|(
name|RelSubset
operator|)
name|rel
return|;
block|}
else|else
block|{
return|return
name|mapRel2Subset
operator|.
name|get
argument_list|(
name|rel
argument_list|)
return|;
block|}
block|}
specifier|public
name|RelSubset
name|getSubset
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|traits
parameter_list|)
block|{
return|return
name|getSubset
argument_list|(
name|rel
argument_list|,
name|traits
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|RelSubset
name|getSubset
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|traits
parameter_list|,
name|boolean
name|createIfMissing
parameter_list|)
block|{
if|if
condition|(
operator|(
name|rel
operator|instanceof
name|RelSubset
operator|)
operator|&&
operator|(
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|traits
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|RelSubset
operator|)
name|rel
return|;
block|}
name|RelSet
name|set
init|=
name|getSet
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|createIfMissing
condition|)
block|{
return|return
name|set
operator|.
name|getOrCreateSubset
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|traits
argument_list|)
return|;
block|}
return|return
name|set
operator|.
name|getSubset
argument_list|(
name|traits
argument_list|)
return|;
block|}
name|boolean
name|isSeedNode
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
specifier|final
name|RelSet
name|set
init|=
name|getSubset
argument_list|(
name|node
argument_list|)
operator|.
name|set
decl_stmt|;
return|return
name|set
operator|.
name|seeds
operator|.
name|contains
argument_list|(
name|node
argument_list|)
return|;
block|}
name|RelNode
name|changeTraitsUsingConverters
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|toTraits
parameter_list|)
block|{
specifier|final
name|RelTraitSet
name|fromTraits
init|=
name|rel
operator|.
name|getTraitSet
argument_list|()
decl_stmt|;
assert|assert
name|fromTraits
operator|.
name|size
argument_list|()
operator|>=
name|toTraits
operator|.
name|size
argument_list|()
assert|;
specifier|final
name|boolean
name|allowInfiniteCostConverters
init|=
name|CalciteSystemProperty
operator|.
name|ALLOW_INFINITE_COST_CONVERTERS
operator|.
name|value
argument_list|()
decl_stmt|;
comment|// Traits may build on top of another...for example a collation trait
comment|// would typically come after a distribution trait since distribution
comment|// destroys collation; so when doing the conversion below we use
comment|// fromTraits as the trait of the just previously converted RelNode.
comment|// Also, toTraits may have fewer traits than fromTraits, excess traits
comment|// will be left as is.  Finally, any null entries in toTraits are
comment|// ignored.
name|RelNode
name|converted
init|=
name|rel
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
operator|(
name|converted
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|i
operator|<
name|toTraits
operator|.
name|size
argument_list|()
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|RelTrait
name|fromTrait
init|=
name|converted
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTrait
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|RelTraitDef
name|traitDef
init|=
name|fromTrait
operator|.
name|getTraitDef
argument_list|()
decl_stmt|;
name|RelTrait
name|toTrait
init|=
name|toTraits
operator|.
name|getTrait
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|toTrait
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
assert|assert
name|traitDef
operator|==
name|toTrait
operator|.
name|getTraitDef
argument_list|()
assert|;
if|if
condition|(
name|fromTrait
operator|.
name|equals
argument_list|(
name|toTrait
argument_list|)
condition|)
block|{
comment|// No need to convert; it's already correct.
continue|continue;
block|}
name|rel
operator|=
name|traitDef
operator|.
name|convert
argument_list|(
name|this
argument_list|,
name|converted
argument_list|,
name|toTrait
argument_list|,
name|allowInfiniteCostConverters
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|!=
literal|null
condition|)
block|{
assert|assert
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTrait
argument_list|(
name|traitDef
argument_list|)
operator|.
name|satisfies
argument_list|(
name|toTrait
argument_list|)
assert|;
name|register
argument_list|(
name|rel
argument_list|,
name|converted
argument_list|)
expr_stmt|;
block|}
name|converted
operator|=
name|rel
expr_stmt|;
block|}
comment|// make sure final converted traitset subsumes what was required
if|if
condition|(
name|converted
operator|!=
literal|null
condition|)
block|{
assert|assert
name|converted
operator|.
name|getTraitSet
argument_list|()
operator|.
name|satisfies
argument_list|(
name|toTraits
argument_list|)
assert|;
block|}
return|return
name|converted
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|prune
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|prunedNodes
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
comment|/**    * Dumps the internal state of this VolcanoPlanner to a writer.    *    * @param pw Print writer    * @see #normalizePlan(String)    */
specifier|public
name|void
name|dump
parameter_list|(
name|PrintWriter
name|pw
parameter_list|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|"Root: "
operator|+
name|root
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"Original rel:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|originalRoot
operator|!=
literal|null
condition|)
block|{
name|originalRoot
operator|.
name|explain
argument_list|(
operator|new
name|RelWriterImpl
argument_list|(
name|pw
argument_list|,
name|SqlExplainLevel
operator|.
name|ALL_ATTRIBUTES
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|CalciteSystemProperty
operator|.
name|DUMP_SETS
operator|.
name|value
argument_list|()
condition|)
block|{
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"Sets:"
argument_list|)
expr_stmt|;
name|Dumpers
operator|.
name|dumpSets
argument_list|(
name|this
argument_list|,
name|pw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CalciteSystemProperty
operator|.
name|DUMP_GRAPHVIZ
operator|.
name|value
argument_list|()
condition|)
block|{
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"Graphviz:"
argument_list|)
expr_stmt|;
name|Dumpers
operator|.
name|dumpGraphviz
argument_list|(
name|this
argument_list|,
name|pw
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
decl||
name|AssertionError
name|e
parameter_list|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|"Error when dumping plan state: \n"
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|String
name|toDot
parameter_list|()
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|Dumpers
operator|.
name|dumpGraphviz
argument_list|(
name|this
argument_list|,
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Re-computes the digest of a {@link RelNode}.    *    *<p>Since a relational expression's digest contains the identifiers of its    * children, this method needs to be called when the child has been renamed,    * for example if the child's set merges with another.    *    * @param rel Relational expression    */
name|void
name|rename
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|String
name|oldDigest
init|=
name|rel
operator|.
name|getDigest
argument_list|()
decl_stmt|;
if|if
condition|(
name|fixUpInputs
argument_list|(
name|rel
argument_list|)
condition|)
block|{
specifier|final
name|Pair
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
argument_list|>
name|oldKey
init|=
name|key
argument_list|(
name|oldDigest
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|removed
init|=
name|mapDigestToRel
operator|.
name|remove
argument_list|(
name|oldKey
argument_list|)
decl_stmt|;
assert|assert
name|removed
operator|==
name|rel
assert|;
specifier|final
name|String
name|newDigest
init|=
name|rel
operator|.
name|recomputeDigest
argument_list|()
decl_stmt|;
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Rename #{} from '{}' to '{}'"
argument_list|,
name|rel
operator|.
name|getId
argument_list|()
argument_list|,
name|oldDigest
argument_list|,
name|newDigest
argument_list|)
expr_stmt|;
specifier|final
name|Pair
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
argument_list|>
name|key
init|=
name|key
argument_list|(
name|rel
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|equivRel
init|=
name|mapDigestToRel
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivRel
operator|!=
literal|null
condition|)
block|{
assert|assert
name|equivRel
operator|!=
name|rel
assert|;
comment|// There's already an equivalent with the same name, and we
comment|// just knocked it out. Put it back, and forget about 'rel'.
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"After renaming rel#{} it is now equivalent to rel#{}"
argument_list|,
name|rel
operator|.
name|getId
argument_list|()
argument_list|,
name|equivRel
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|mapDigestToRel
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|equivRel
argument_list|)
expr_stmt|;
name|checkPruned
argument_list|(
name|equivRel
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|RelSubset
name|equivRelSubset
init|=
name|getSubset
argument_list|(
name|equivRel
argument_list|)
decl_stmt|;
comment|// Remove back-links from children.
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
operator|(
operator|(
name|RelSubset
operator|)
name|input
operator|)
operator|.
name|set
operator|.
name|parents
operator|.
name|remove
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
comment|// Remove rel from its subset. (This may leave the subset
comment|// empty, but if so, that will be dealt with when the sets
comment|// get merged.)
specifier|final
name|RelSubset
name|subset
init|=
name|mapRel2Subset
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|equivRelSubset
argument_list|)
decl_stmt|;
assert|assert
name|subset
operator|!=
literal|null
assert|;
name|boolean
name|existed
init|=
name|subset
operator|.
name|set
operator|.
name|rels
operator|.
name|remove
argument_list|(
name|rel
argument_list|)
decl_stmt|;
assert|assert
name|existed
operator|:
literal|"rel was not known to its set"
assert|;
specifier|final
name|RelSubset
name|equivSubset
init|=
name|getSubset
argument_list|(
name|equivRel
argument_list|)
decl_stmt|;
for|for
control|(
name|RelSubset
name|s
range|:
name|subset
operator|.
name|set
operator|.
name|subsets
control|)
block|{
if|if
condition|(
name|s
operator|.
name|best
operator|==
name|rel
condition|)
block|{
name|Set
argument_list|<
name|RelSubset
argument_list|>
name|activeSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|s
operator|.
name|best
operator|=
name|equivRel
expr_stmt|;
comment|// Propagate cost improvement since this potentially would change the subset's best cost
name|s
operator|.
name|propagateCostImprovements
argument_list|(
name|this
argument_list|,
name|equivRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
argument_list|,
name|equivRel
argument_list|,
name|activeSet
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|equivSubset
operator|!=
name|subset
condition|)
block|{
comment|// The equivalent relational expression is in a different
comment|// subset, therefore the sets are equivalent.
assert|assert
name|equivSubset
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|subset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
assert|;
assert|assert
name|equivSubset
operator|.
name|set
operator|!=
name|subset
operator|.
name|set
assert|;
name|merge
argument_list|(
name|equivSubset
operator|.
name|set
argument_list|,
name|subset
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Registers a {@link RelNode}, which has already been registered, in a new    * {@link RelSet}.    *    * @param set Set    * @param rel Relational expression    */
name|void
name|reregister
parameter_list|(
name|RelSet
name|set
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
comment|// Is there an equivalent relational expression? (This might have
comment|// just occurred because the relational expression's child was just
comment|// found to be equivalent to another set.)
specifier|final
name|Pair
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
argument_list|>
name|key
init|=
name|key
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|RelNode
name|equivRel
init|=
name|mapDigestToRel
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivRel
operator|!=
literal|null
operator|&&
name|equivRel
operator|!=
name|rel
condition|)
block|{
assert|assert
name|equivRel
operator|.
name|getClass
argument_list|()
operator|==
name|rel
operator|.
name|getClass
argument_list|()
assert|;
assert|assert
name|equivRel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|rel
operator|.
name|getTraitSet
argument_list|()
argument_list|)
assert|;
name|checkPruned
argument_list|(
name|equivRel
argument_list|,
name|rel
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Add the relational expression into the correct set and subset.
if|if
condition|(
operator|!
name|prunedNodes
operator|.
name|contains
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|addRelToSet
argument_list|(
name|rel
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Prune rel node if the latter one (identical with rel node)    * is already pruned.    */
specifier|private
name|void
name|checkPruned
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|duplicateRel
parameter_list|)
block|{
if|if
condition|(
name|prunedNodes
operator|.
name|contains
argument_list|(
name|duplicateRel
argument_list|)
condition|)
block|{
name|prunedNodes
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * If a subset has one or more equivalent subsets (owing to a set having    * merged with another), returns the subset which is the leader of the    * equivalence class.    *    * @param subset Subset    * @return Leader of subset's equivalence class    */
specifier|private
name|RelSubset
name|canonize
parameter_list|(
specifier|final
name|RelSubset
name|subset
parameter_list|)
block|{
if|if
condition|(
name|subset
operator|.
name|set
operator|.
name|equivalentSet
operator|==
literal|null
condition|)
block|{
return|return
name|subset
return|;
block|}
name|RelSet
name|set
init|=
name|subset
operator|.
name|set
decl_stmt|;
do|do
block|{
name|set
operator|=
name|set
operator|.
name|equivalentSet
expr_stmt|;
block|}
do|while
condition|(
name|set
operator|.
name|equivalentSet
operator|!=
literal|null
condition|)
do|;
return|return
name|set
operator|.
name|getOrCreateSubset
argument_list|(
name|subset
operator|.
name|getCluster
argument_list|()
argument_list|,
name|subset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Fires all rules matched by a relational expression.    *    * @param rel      Relational expression which has just been created (or maybe    *                 from the queue)    */
name|void
name|fireRules
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
name|RelOptRuleOperand
name|operand
range|:
name|classOperands
operator|.
name|get
argument_list|(
name|rel
operator|.
name|getClass
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|operand
operator|.
name|matches
argument_list|(
name|rel
argument_list|)
condition|)
block|{
specifier|final
name|VolcanoRuleCall
name|ruleCall
decl_stmt|;
name|ruleCall
operator|=
operator|new
name|DeferringRuleCall
argument_list|(
name|this
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|ruleCall
operator|.
name|match
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|fixUpInputs
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|rel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|changeCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|inputs
control|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|input
operator|instanceof
name|RelSubset
condition|)
block|{
specifier|final
name|RelSubset
name|subset
init|=
operator|(
name|RelSubset
operator|)
name|input
decl_stmt|;
name|RelSubset
name|newSubset
init|=
name|canonize
argument_list|(
name|subset
argument_list|)
decl_stmt|;
if|if
condition|(
name|newSubset
operator|!=
name|subset
condition|)
block|{
name|rel
operator|.
name|replaceInput
argument_list|(
name|i
argument_list|,
name|newSubset
argument_list|)
expr_stmt|;
if|if
condition|(
name|subset
operator|.
name|set
operator|!=
name|newSubset
operator|.
name|set
condition|)
block|{
name|subset
operator|.
name|set
operator|.
name|parents
operator|.
name|remove
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|newSubset
operator|.
name|set
operator|.
name|parents
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
name|changeCount
operator|++
expr_stmt|;
block|}
block|}
block|}
name|RelMdUtil
operator|.
name|clearCache
argument_list|(
name|rel
argument_list|)
expr_stmt|;
return|return
name|changeCount
operator|>
literal|0
return|;
block|}
specifier|private
name|RelSet
name|merge
parameter_list|(
name|RelSet
name|set
parameter_list|,
name|RelSet
name|set2
parameter_list|)
block|{
assert|assert
name|set
operator|!=
name|set2
operator|:
literal|"pre: set != set2"
assert|;
comment|// Find the root of set2's equivalence tree.
name|set
operator|=
name|equivRoot
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|set2
operator|=
name|equivRoot
argument_list|(
name|set2
argument_list|)
expr_stmt|;
comment|// Looks like set2 was already marked as equivalent to set. Nothing
comment|// to do.
if|if
condition|(
name|set2
operator|==
name|set
condition|)
block|{
return|return
name|set
return|;
block|}
comment|// If necessary, swap the sets, so we're always merging the newer set
comment|// into the older or merging parent set into child set.
if|if
condition|(
name|set2
operator|.
name|getChildSets
argument_list|(
name|this
argument_list|)
operator|.
name|contains
argument_list|(
name|set
argument_list|)
condition|)
block|{
comment|// No-op
block|}
if|else if
condition|(
name|set
operator|.
name|getChildSets
argument_list|(
name|this
argument_list|)
operator|.
name|contains
argument_list|(
name|set2
argument_list|)
operator|||
name|set
operator|.
name|id
operator|>
name|set2
operator|.
name|id
condition|)
block|{
name|RelSet
name|t
init|=
name|set
decl_stmt|;
name|set
operator|=
name|set2
expr_stmt|;
name|set2
operator|=
name|t
expr_stmt|;
block|}
comment|// Merge.
name|set
operator|.
name|mergeWith
argument_list|(
name|this
argument_list|,
name|set2
argument_list|)
expr_stmt|;
comment|// Was the set we merged with the root? If so, the result is the new
comment|// root.
if|if
condition|(
name|set2
operator|==
name|getSet
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|root
operator|=
name|set
operator|.
name|getOrCreateSubset
argument_list|(
name|root
operator|.
name|getCluster
argument_list|()
argument_list|,
name|root
operator|.
name|getTraitSet
argument_list|()
argument_list|)
expr_stmt|;
name|ensureRootConverters
argument_list|()
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
specifier|static
name|RelSet
name|equivRoot
parameter_list|(
name|RelSet
name|s
parameter_list|)
block|{
name|RelSet
name|p
init|=
name|s
decl_stmt|;
comment|// iterates at twice the rate, to detect cycles
while|while
condition|(
name|s
operator|.
name|equivalentSet
operator|!=
literal|null
condition|)
block|{
name|p
operator|=
name|forward2
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|.
name|equivalentSet
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/** Moves forward two links, checking for a cycle at each. */
specifier|private
specifier|static
name|RelSet
name|forward2
parameter_list|(
name|RelSet
name|s
parameter_list|,
name|RelSet
name|p
parameter_list|)
block|{
name|p
operator|=
name|forward1
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|forward1
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/** Moves forward one link, checking for a cycle. */
specifier|private
specifier|static
name|RelSet
name|forward1
parameter_list|(
name|RelSet
name|s
parameter_list|,
name|RelSet
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|p
operator|=
name|p
operator|.
name|equivalentSet
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|s
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"cycle in equivalence tree"
argument_list|)
throw|;
block|}
block|}
return|return
name|p
return|;
block|}
comment|/**    * Registers a new expression<code>exp</code> and queues up rule matches.    * If<code>set</code> is not null, makes the expression part of that    * equivalence set. If an identical expression is already registered, we    * don't need to register this one and nor should we queue up rule matches.    *    * @param rel relational expression to register. Must be either a    *         {@link RelSubset}, or an unregistered {@link RelNode}    * @param set set that rel belongs to, or<code>null</code>    * @return the equivalence-set    */
specifier|private
name|RelSubset
name|registerImpl
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelSet
name|set
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|RelSubset
condition|)
block|{
return|return
name|registerSubset
argument_list|(
name|set
argument_list|,
operator|(
name|RelSubset
operator|)
name|rel
argument_list|)
return|;
block|}
assert|assert
operator|!
name|isRegistered
argument_list|(
name|rel
argument_list|)
operator|:
literal|"already been registered: "
operator|+
name|rel
assert|;
if|if
condition|(
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|!=
name|this
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Relational expression "
operator|+
name|rel
operator|+
literal|" belongs to a different planner than is currently being used."
argument_list|)
throw|;
block|}
comment|// Now is a good time to ensure that the relational expression
comment|// implements the interface required by its calling convention.
specifier|final
name|RelTraitSet
name|traits
init|=
name|rel
operator|.
name|getTraitSet
argument_list|()
decl_stmt|;
specifier|final
name|Convention
name|convention
init|=
name|traits
operator|.
name|getTrait
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
assert|assert
name|convention
operator|!=
literal|null
assert|;
if|if
condition|(
operator|!
name|convention
operator|.
name|getInterface
argument_list|()
operator|.
name|isInstance
argument_list|(
name|rel
argument_list|)
operator|&&
operator|!
operator|(
name|rel
operator|instanceof
name|Converter
operator|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Relational expression "
operator|+
name|rel
operator|+
literal|" has calling-convention "
operator|+
name|convention
operator|+
literal|" but does not implement the required interface '"
operator|+
name|convention
operator|.
name|getInterface
argument_list|()
operator|+
literal|"' of that convention"
argument_list|)
throw|;
block|}
if|if
condition|(
name|traits
operator|.
name|size
argument_list|()
operator|!=
name|traitDefs
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Relational expression "
operator|+
name|rel
operator|+
literal|" does not have the correct number of traits: "
operator|+
name|traits
operator|.
name|size
argument_list|()
operator|+
literal|" != "
operator|+
name|traitDefs
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
comment|// Ensure that its sub-expressions are registered.
name|rel
operator|=
name|rel
operator|.
name|onRegister
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Record its provenance. (Rule call may be null.)
if|if
condition|(
name|ruleCallStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|provenanceMap
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|Provenance
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|VolcanoRuleCall
name|ruleCall
init|=
name|ruleCallStack
operator|.
name|peek
argument_list|()
decl_stmt|;
name|provenanceMap
operator|.
name|put
argument_list|(
name|rel
argument_list|,
operator|new
name|RuleProvenance
argument_list|(
name|ruleCall
operator|.
name|rule
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|ruleCall
operator|.
name|rels
argument_list|)
argument_list|,
name|ruleCall
operator|.
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If it is equivalent to an existing expression, return the set that
comment|// the equivalent expression belongs to.
name|Pair
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
argument_list|>
name|key
init|=
name|key
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|RelNode
name|equivExp
init|=
name|mapDigestToRel
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivExp
operator|==
literal|null
condition|)
block|{
comment|// do nothing
block|}
if|else if
condition|(
name|equivExp
operator|==
name|rel
condition|)
block|{
return|return
name|getSubset
argument_list|(
name|rel
argument_list|)
return|;
block|}
else|else
block|{
assert|assert
name|RelOptUtil
operator|.
name|equal
argument_list|(
literal|"left"
argument_list|,
name|equivExp
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|"right"
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
name|checkPruned
argument_list|(
name|equivExp
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|RelSet
name|equivSet
init|=
name|getSet
argument_list|(
name|equivExp
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivSet
operator|!=
literal|null
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Register: rel#{} is equivalent to {}"
argument_list|,
name|rel
operator|.
name|getId
argument_list|()
argument_list|,
name|equivExp
argument_list|)
expr_stmt|;
return|return
name|registerSubset
argument_list|(
name|set
argument_list|,
name|getSubset
argument_list|(
name|equivExp
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|// Converters are in the same set as their children.
if|if
condition|(
name|rel
operator|instanceof
name|Converter
condition|)
block|{
specifier|final
name|RelNode
name|input
init|=
operator|(
operator|(
name|Converter
operator|)
name|rel
operator|)
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RelSet
name|childSet
init|=
name|getSet
argument_list|(
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|set
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|set
operator|!=
name|childSet
operator|)
operator|&&
operator|(
name|set
operator|.
name|equivalentSet
operator|==
literal|null
operator|)
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Register #{} {} (and merge sets, because it is a conversion)"
argument_list|,
name|rel
operator|.
name|getId
argument_list|()
argument_list|,
name|rel
operator|.
name|getDigest
argument_list|()
argument_list|)
expr_stmt|;
name|merge
argument_list|(
name|set
argument_list|,
name|childSet
argument_list|)
expr_stmt|;
comment|// During the mergers, the child set may have changed, and since
comment|// we're not registered yet, we won't have been informed. So
comment|// check whether we are now equivalent to an existing
comment|// expression.
if|if
condition|(
name|fixUpInputs
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|rel
operator|.
name|recomputeDigest
argument_list|()
expr_stmt|;
name|key
operator|=
name|key
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|RelNode
name|equivRel
init|=
name|mapDigestToRel
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|equivRel
operator|!=
name|rel
operator|)
operator|&&
operator|(
name|equivRel
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// make sure this bad rel didn't get into the
comment|// set in any way (fixupInputs will do this but it
comment|// doesn't know if it should so it does it anyway)
name|set
operator|.
name|obliterateRelNode
argument_list|(
name|rel
argument_list|)
expr_stmt|;
comment|// There is already an equivalent expression. Use that
comment|// one, and forget about this one.
return|return
name|getSubset
argument_list|(
name|equivRel
argument_list|)
return|;
block|}
block|}
block|}
else|else
block|{
name|set
operator|=
name|childSet
expr_stmt|;
block|}
block|}
comment|// Place the expression in the appropriate equivalence set.
if|if
condition|(
name|set
operator|==
literal|null
condition|)
block|{
name|set
operator|=
operator|new
name|RelSet
argument_list|(
name|nextSetId
operator|++
argument_list|,
name|Util
operator|.
name|minus
argument_list|(
name|RelOptUtil
operator|.
name|getVariablesSet
argument_list|(
name|rel
argument_list|)
argument_list|,
name|rel
operator|.
name|getVariablesSet
argument_list|()
argument_list|)
argument_list|,
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|allSets
operator|.
name|add
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
comment|// Chain to find 'live' equivalent set, just in case several sets are
comment|// merging at the same time.
while|while
condition|(
name|set
operator|.
name|equivalentSet
operator|!=
literal|null
condition|)
block|{
name|set
operator|=
name|set
operator|.
name|equivalentSet
expr_stmt|;
block|}
comment|// Allow each rel to register its own rules.
name|registerClass
argument_list|(
name|rel
argument_list|)
expr_stmt|;
specifier|final
name|int
name|subsetBeforeCount
init|=
name|set
operator|.
name|subsets
operator|.
name|size
argument_list|()
decl_stmt|;
name|RelSubset
name|subset
init|=
name|addRelToSet
argument_list|(
name|rel
argument_list|,
name|set
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|xx
init|=
name|mapDigestToRel
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|rel
argument_list|)
decl_stmt|;
assert|assert
name|xx
operator|==
literal|null
operator|||
name|xx
operator|==
name|rel
operator|:
name|rel
operator|.
name|getDigest
argument_list|()
assert|;
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Register {} in {}"
argument_list|,
name|rel
argument_list|,
name|subset
argument_list|)
expr_stmt|;
comment|// This relational expression may have been registered while we
comment|// recursively registered its children. If this is the case, we're done.
if|if
condition|(
name|xx
operator|!=
literal|null
condition|)
block|{
return|return
name|subset
return|;
block|}
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|RelSubset
name|childSubset
init|=
operator|(
name|RelSubset
operator|)
name|input
decl_stmt|;
name|childSubset
operator|.
name|set
operator|.
name|parents
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
comment|// Queue up all rules triggered by this relexp's creation.
name|fireRules
argument_list|(
name|rel
argument_list|)
expr_stmt|;
comment|// It's a new subset.
if|if
condition|(
name|set
operator|.
name|subsets
operator|.
name|size
argument_list|()
operator|>
name|subsetBeforeCount
operator|||
name|subset
operator|.
name|triggerRule
condition|)
block|{
name|fireRules
argument_list|(
name|subset
argument_list|)
expr_stmt|;
block|}
return|return
name|subset
return|;
block|}
specifier|private
name|RelSubset
name|addRelToSet
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelSet
name|set
parameter_list|)
block|{
name|RelSubset
name|subset
init|=
name|set
operator|.
name|add
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|mapRel2Subset
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|subset
argument_list|)
expr_stmt|;
comment|// While a tree of RelNodes is being registered, sometimes nodes' costs
comment|// improve and the subset doesn't hear about it. You can end up with
comment|// a subset with a single rel of cost 99 which thinks its best cost is
comment|// 100. We think this happens because the back-links to parents are
comment|// not established. So, give the subset another chance to figure out
comment|// its cost.
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
try|try
block|{
name|subset
operator|.
name|propagateCostImprovements
argument_list|(
name|this
argument_list|,
name|mq
argument_list|,
name|rel
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CyclicMetadataException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
return|return
name|subset
return|;
block|}
specifier|private
name|RelSubset
name|registerSubset
parameter_list|(
name|RelSet
name|set
parameter_list|,
name|RelSubset
name|subset
parameter_list|)
block|{
if|if
condition|(
operator|(
name|set
operator|!=
name|subset
operator|.
name|set
operator|)
operator|&&
operator|(
name|set
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|set
operator|.
name|equivalentSet
operator|==
literal|null
operator|)
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Register #{} {}, and merge sets"
argument_list|,
name|subset
operator|.
name|getId
argument_list|()
argument_list|,
name|subset
argument_list|)
expr_stmt|;
name|merge
argument_list|(
name|set
argument_list|,
name|subset
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
return|return
name|subset
return|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|void
name|registerMetadataProviders
parameter_list|(
name|List
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
parameter_list|)
block|{
name|list
operator|.
name|add
argument_list|(
literal|0
argument_list|,
operator|new
name|VolcanoRelMetadataProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|long
name|getRelMetadataTimestamp
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|RelSubset
name|subset
init|=
name|getSubset
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|subset
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|subset
operator|.
name|timestamp
return|;
block|}
block|}
comment|/**    * Normalizes references to subsets within the string representation of a    * plan.    *    *<p>This is useful when writing tests: it helps to ensure that tests don't    * break when an extra rule is introduced that generates a new subset and    * causes subsequent subset numbers to be off by one.    *    *<p>For example,    *    *<blockquote>    * FennelAggRel.FENNEL_EXEC(child=Subset#17.FENNEL_EXEC,groupCount=1,    * EXPR$1=COUNT())<br>    *&nbsp;&nbsp;FennelSortRel.FENNEL_EXEC(child=Subset#2.FENNEL_EXEC,    * key=[0], discardDuplicates=false)<br>    *&nbsp;&nbsp;&nbsp;&nbsp;FennelCalcRel.FENNEL_EXEC(    * child=Subset#4.FENNEL_EXEC, expr#0..8={inputs}, expr#9=3456,    * DEPTNO=$t7, $f0=$t9)<br>    *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MockTableImplRel.FENNEL_EXEC(    * table=[CATALOG, SALES, EMP])</blockquote>    *    *<p>becomes    *    *<blockquote>    * FennelAggRel.FENNEL_EXEC(child=Subset#{0}.FENNEL_EXEC, groupCount=1,    * EXPR$1=COUNT())<br>    *&nbsp;&nbsp;FennelSortRel.FENNEL_EXEC(child=Subset#{1}.FENNEL_EXEC,    * key=[0], discardDuplicates=false)<br>    *&nbsp;&nbsp;&nbsp;&nbsp;FennelCalcRel.FENNEL_EXEC(    * child=Subset#{2}.FENNEL_EXEC,expr#0..8={inputs},expr#9=3456,DEPTNO=$t7,    * $f0=$t9)<br>    *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MockTableImplRel.FENNEL_EXEC(    * table=[CATALOG, SALES, EMP])</blockquote>    *    * @param plan Plan    * @return Normalized plan    */
specifier|public
specifier|static
name|String
name|normalizePlan
parameter_list|(
name|String
name|plan
parameter_list|)
block|{
if|if
condition|(
name|plan
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Pattern
name|poundDigits
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"Subset#[0-9]+\\."
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|Matcher
name|matcher
init|=
name|poundDigits
operator|.
name|matcher
argument_list|(
name|plan
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
return|return
name|plan
return|;
block|}
specifier|final
name|String
name|token
init|=
name|matcher
operator|.
name|group
argument_list|()
decl_stmt|;
comment|// e.g. "Subset#23."
name|plan
operator|=
name|plan
operator|.
name|replace
argument_list|(
name|token
argument_list|,
literal|"Subset#{"
operator|+
name|i
operator|++
operator|+
literal|"}."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Sets whether this planner is locked. A locked planner does not accept    * new rules. {@link #addRule(org.apache.calcite.plan.RelOptRule)} will do    * nothing and return false.    *    * @param locked Whether planner is locked    */
specifier|public
name|void
name|setLocked
parameter_list|(
name|boolean
name|locked
parameter_list|)
block|{
name|this
operator|.
name|locked
operator|=
name|locked
expr_stmt|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * A rule call which defers its actions. Whereas {@link RelOptRuleCall}    * invokes the rule when it finds a match, a<code>DeferringRuleCall</code>    * creates a {@link VolcanoRuleMatch} which can be invoked later.    */
specifier|private
specifier|static
class|class
name|DeferringRuleCall
extends|extends
name|VolcanoRuleCall
block|{
name|DeferringRuleCall
parameter_list|(
name|VolcanoPlanner
name|planner
parameter_list|,
name|RelOptRuleOperand
name|operand
parameter_list|)
block|{
name|super
argument_list|(
name|planner
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
comment|/**      * Rather than invoking the rule (as the base method does), creates a      * {@link VolcanoRuleMatch} which can be invoked later.      */
specifier|protected
name|void
name|onMatch
parameter_list|()
block|{
specifier|final
name|VolcanoRuleMatch
name|match
init|=
operator|new
name|VolcanoRuleMatch
argument_list|(
name|volcanoPlanner
argument_list|,
name|getOperand0
argument_list|()
argument_list|,
name|rels
argument_list|,
name|nodeInputs
argument_list|)
decl_stmt|;
name|volcanoPlanner
operator|.
name|ruleQueue
operator|.
name|addMatch
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Where a RelNode came from.    */
specifier|abstract
specifier|static
class|class
name|Provenance
block|{
specifier|public
specifier|static
specifier|final
name|Provenance
name|EMPTY
init|=
operator|new
name|UnknownProvenance
argument_list|()
decl_stmt|;
block|}
comment|/**    * We do not know where this RelNode came from. Probably created by hand,    * or by sql-to-rel converter.    */
specifier|private
specifier|static
class|class
name|UnknownProvenance
extends|extends
name|Provenance
block|{   }
comment|/**    * A RelNode that came directly from another RelNode via a copy.    */
specifier|static
class|class
name|DirectProvenance
extends|extends
name|Provenance
block|{
specifier|final
name|RelNode
name|source
decl_stmt|;
name|DirectProvenance
parameter_list|(
name|RelNode
name|source
parameter_list|)
block|{
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
block|}
block|}
comment|/**    * A RelNode that came via the firing of a rule.    */
specifier|static
class|class
name|RuleProvenance
extends|extends
name|Provenance
block|{
specifier|final
name|RelOptRule
name|rule
decl_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|RelNode
argument_list|>
name|rels
decl_stmt|;
specifier|final
name|int
name|callId
decl_stmt|;
name|RuleProvenance
parameter_list|(
name|RelOptRule
name|rule
parameter_list|,
name|ImmutableList
argument_list|<
name|RelNode
argument_list|>
name|rels
parameter_list|,
name|int
name|callId
parameter_list|)
block|{
name|this
operator|.
name|rule
operator|=
name|rule
expr_stmt|;
name|this
operator|.
name|rels
operator|=
name|rels
expr_stmt|;
name|this
operator|.
name|callId
operator|=
name|callId
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

