begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|prepare
operator|.
name|CalcitePrepareImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DefaultDirectedGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DefaultEdge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DirectedGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|Graphs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|TopologicalOrderIterator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Suppliers
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Utility methods for using  * materialized views and lattices for queries.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|RelOptMaterializations
block|{
comment|/**    * Returns a list of RelNode transformed from all possible combination of    * materialized view uses. Big queries will likely have more than one    * transformed RelNode, e.g., (t1 group by c1) join (t2 group by c2).    * @param rel               the original RelNode    * @param materializations  the materialized view list    * @return the list of transformed RelNode together with their corresponding    *         materialized views used in the transformation.    */
specifier|public
specifier|static
name|List
argument_list|<
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
argument_list|>
argument_list|>
name|useMaterializedViews
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|materializations
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|applicableMaterializations
init|=
name|getApplicableMaterializations
argument_list|(
name|rel
argument_list|,
name|materializations
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
argument_list|>
argument_list|>
name|applied
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|applied
operator|.
name|add
argument_list|(
name|Pair
operator|.
expr|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
operator|>
name|of
argument_list|(
name|rel
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RelOptMaterialization
operator|>
name|of
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|RelOptMaterialization
name|m
range|:
name|applicableMaterializations
control|)
block|{
name|int
name|count
init|=
name|applied
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
argument_list|>
name|current
init|=
name|applied
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|sub
init|=
name|substitute
argument_list|(
name|current
operator|.
name|left
argument_list|,
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sub
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RelOptMaterialization
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addAll
argument_list|(
name|current
operator|.
name|right
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|uses
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|rel2
range|:
name|sub
control|)
block|{
name|applied
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|rel2
argument_list|,
name|uses
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|applied
operator|.
name|subList
argument_list|(
literal|1
argument_list|,
name|applied
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a list of RelNode transformed from all possible lattice uses.    * @param rel       the original RelNode    * @param lattices  the lattice list    * @return the list of transformed RelNode together with their corresponding    *         lattice used in the transformation.    */
specifier|public
specifier|static
name|List
argument_list|<
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelOptLattice
argument_list|>
argument_list|>
name|useLattices
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
name|List
argument_list|<
name|RelOptLattice
argument_list|>
name|lattices
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|RelOptTable
argument_list|>
name|queryTables
init|=
name|RelOptUtil
operator|.
name|findTables
argument_list|(
name|rel
argument_list|)
decl_stmt|;
comment|// Use a lattice if the query uses at least the central (fact) table of the
comment|// lattice.
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelOptLattice
argument_list|>
argument_list|>
name|latticeUses
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|queryTableNames
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|Iterables
operator|.
name|transform
argument_list|(
name|queryTables
argument_list|,
name|GET_QUALIFIED_NAME
argument_list|)
argument_list|)
decl_stmt|;
comment|// Remember leaf-join form of root so we convert at most once.
specifier|final
name|Supplier
argument_list|<
name|RelNode
argument_list|>
name|leafJoinRoot
init|=
name|Suppliers
operator|.
name|memoize
argument_list|(
operator|new
name|Supplier
argument_list|<
name|RelNode
argument_list|>
argument_list|()
block|{
specifier|public
name|RelNode
name|get
parameter_list|()
block|{
return|return
name|RelOptMaterialization
operator|.
name|toLeafJoinForm
argument_list|(
name|rel
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
for|for
control|(
name|RelOptLattice
name|lattice
range|:
name|lattices
control|)
block|{
if|if
condition|(
name|queryTableNames
operator|.
name|contains
argument_list|(
name|lattice
operator|.
name|rootTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
condition|)
block|{
name|RelNode
name|rel2
init|=
name|lattice
operator|.
name|rewrite
argument_list|(
name|leafJoinRoot
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rel2
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|CalcitePrepareImpl
operator|.
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"use lattice:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|rel2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|latticeUses
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|rel2
argument_list|,
name|lattice
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|latticeUses
return|;
block|}
comment|/**    * Returns a list of materializations that can potentially be used by the query.    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|getApplicableMaterializations
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|materializations
parameter_list|)
block|{
name|DirectedGraph
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|DefaultEdge
argument_list|>
name|usesGraph
init|=
name|DefaultDirectedGraph
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|RelOptMaterialization
argument_list|>
name|qnameMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelOptMaterialization
name|materialization
range|:
name|materializations
control|)
block|{
comment|// If materialization is a tile in a lattice, we will deal with it shortly.
if|if
condition|(
name|materialization
operator|.
name|qualifiedTableName
operator|!=
literal|null
operator|&&
name|materialization
operator|.
name|starTable
operator|==
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|qname
init|=
name|materialization
operator|.
name|qualifiedTableName
decl_stmt|;
name|qnameMap
operator|.
name|put
argument_list|(
name|qname
argument_list|,
name|materialization
argument_list|)
expr_stmt|;
for|for
control|(
name|RelOptTable
name|usedTable
range|:
name|RelOptUtil
operator|.
name|findTables
argument_list|(
name|materialization
operator|.
name|queryRel
argument_list|)
control|)
block|{
name|usesGraph
operator|.
name|addVertex
argument_list|(
name|qname
argument_list|)
expr_stmt|;
name|usesGraph
operator|.
name|addVertex
argument_list|(
name|usedTable
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
expr_stmt|;
name|usesGraph
operator|.
name|addEdge
argument_list|(
name|usedTable
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|qname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Use a materialization if uses at least one of the tables are used by
comment|// the query. (Simple rule that includes some materializations we won't
comment|// actually use.)
comment|// For example, given materializations:
comment|//   T = Emps Join Depts
comment|//   T2 = T Group by C1
comment|// the graph will contain
comment|//   (T, Emps), (T, Depts), (T2, T)
comment|// and therefore we can deduce T2 uses Emps.
specifier|final
name|Graphs
operator|.
name|FrozenGraph
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|DefaultEdge
argument_list|>
name|frozenGraph
init|=
name|Graphs
operator|.
name|makeImmutable
argument_list|(
name|usesGraph
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelOptTable
argument_list|>
name|queryTablesUsed
init|=
name|RelOptUtil
operator|.
name|findTables
argument_list|(
name|rel
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|applicableMaterializations
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|qname
range|:
name|TopologicalOrderIterator
operator|.
name|of
argument_list|(
name|usesGraph
argument_list|)
control|)
block|{
name|RelOptMaterialization
name|materialization
init|=
name|qnameMap
operator|.
name|get
argument_list|(
name|qname
argument_list|)
decl_stmt|;
if|if
condition|(
name|materialization
operator|!=
literal|null
operator|&&
name|usesTable
argument_list|(
name|materialization
operator|.
name|qualifiedTableName
argument_list|,
name|queryTablesUsed
argument_list|,
name|frozenGraph
argument_list|)
condition|)
block|{
name|applicableMaterializations
operator|.
name|add
argument_list|(
name|materialization
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|applicableMaterializations
return|;
block|}
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|RelOptTable
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|GET_QUALIFIED_NAME
init|=
operator|new
name|Function
argument_list|<
name|RelOptTable
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|apply
parameter_list|(
name|RelOptTable
name|relOptTable
parameter_list|)
block|{
return|return
name|relOptTable
operator|.
name|getQualifiedName
argument_list|()
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
name|List
argument_list|<
name|RelNode
argument_list|>
name|substitute
parameter_list|(
name|RelNode
name|root
parameter_list|,
name|RelOptMaterialization
name|materialization
parameter_list|)
block|{
comment|// First, if the materialization is in terms of a star table, rewrite
comment|// the query in terms of the star table.
if|if
condition|(
name|materialization
operator|.
name|starTable
operator|!=
literal|null
condition|)
block|{
name|RelNode
name|newRoot
init|=
name|RelOptMaterialization
operator|.
name|tryUseStar
argument_list|(
name|root
argument_list|,
name|materialization
operator|.
name|starRelOptTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|newRoot
operator|!=
literal|null
condition|)
block|{
name|root
operator|=
name|newRoot
expr_stmt|;
block|}
block|}
comment|// Push filters to the bottom, and combine projects on top.
name|RelNode
name|target
init|=
name|materialization
operator|.
name|queryRel
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|target
operator|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
return|return
operator|new
name|MaterializedViewSubstitutionVisitor
argument_list|(
name|target
argument_list|,
name|root
argument_list|)
operator|.
name|go
argument_list|(
name|materialization
operator|.
name|tableRel
argument_list|)
return|;
block|}
comment|/**    * Returns whether {@code table} uses one or more of the tables in    * {@code usedTables}.    */
specifier|private
specifier|static
name|boolean
name|usesTable
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|qualifiedName
parameter_list|,
name|Set
argument_list|<
name|RelOptTable
argument_list|>
name|usedTables
parameter_list|,
name|Graphs
operator|.
name|FrozenGraph
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|DefaultEdge
argument_list|>
name|usesGraph
parameter_list|)
block|{
for|for
control|(
name|RelOptTable
name|queryTable
range|:
name|usedTables
control|)
block|{
if|if
condition|(
name|usesGraph
operator|.
name|getShortestPath
argument_list|(
name|queryTable
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|qualifiedName
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

begin_comment
comment|// End RelOptMaterializations.java
end_comment

end_unit

