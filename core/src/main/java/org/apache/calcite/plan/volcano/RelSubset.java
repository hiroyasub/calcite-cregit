begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Linq4j
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTrait
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|AbstractRelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|externalize
operator|.
name|RelWriterImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|trace
operator|.
name|CalciteTrace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apiguardian
operator|.
name|api
operator|.
name|API
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_comment
comment|/**  * Subset of an equivalence class where all relational expressions have the  * same physical properties.  *  *<p>Physical properties are instances of the {@link RelTraitSet}, and consist  * of traits such as calling convention and collation (sort-order).  *  *<p>For some traits, a relational expression can have more than one instance.  * For example, R can be sorted on both [X] and [Y, Z]. In which case, R would  * belong to the sub-sets for [X] and [Y, Z]; and also the leading edges [Y] and  * [].  *  * @see RelNode  * @see RelSet  * @see RelTrait  */
end_comment

begin_class
specifier|public
class|class
name|RelSubset
extends|extends
name|AbstractRelNode
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|CalciteTrace
operator|.
name|getPlannerTracer
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DELIVERED
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|REQUIRED
init|=
literal|2
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|/**    * Optimization task state    */
name|OptimizeTask
operator|.
name|State
name|taskState
decl_stmt|;
comment|/**    * cost of best known plan (it may have improved since)    */
name|RelOptCost
name|bestCost
decl_stmt|;
comment|/**    * The set this subset belongs to.    */
specifier|final
name|RelSet
name|set
decl_stmt|;
comment|/**    * best known plan    */
name|RelNode
name|best
decl_stmt|;
comment|/**    * Timestamp for metadata validity    */
name|long
name|timestamp
decl_stmt|;
comment|/**    * Physical property state of current subset    * 0: logical operators, NONE convention is neither DELIVERED nor REQUIRED    * 1: traitSet DELIVERED from child operators or itself    * 2: traitSet REQUIRED from parent operators    * 3: both DELIVERED and REQUIRED    */
specifier|private
name|int
name|state
init|=
literal|0
decl_stmt|;
comment|/**    * This subset should trigger rules when it becomes delivered.    */
name|boolean
name|triggerRule
init|=
literal|false
decl_stmt|;
comment|/**    * When the subset state is REQUIRED, whether enable property enforcing    * between this subset and other delivered subsets. When it is true,    * no enforcer operators will be added even if the other subset can't    * satisfy current subset's required traitSet.    */
specifier|private
name|boolean
name|enforceDisabled
init|=
literal|false
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
name|RelSubset
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelSet
name|set
parameter_list|,
name|RelTraitSet
name|traits
parameter_list|)
block|{
name|super
argument_list|(
name|cluster
argument_list|,
name|traits
argument_list|)
expr_stmt|;
name|this
operator|.
name|set
operator|=
name|set
expr_stmt|;
assert|assert
name|traits
operator|.
name|allSimple
argument_list|()
assert|;
name|computeBestCost
argument_list|(
name|cluster
operator|.
name|getPlanner
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Computes the best {@link RelNode} in this subset.    *    *<p>Only necessary when a subset is created in a set that has subsets that    * subsume it. Rationale:</p>    *    *<ol>    *<li>If the are no subsuming subsets, the subset is initially empty.</li>    *<li>After creation, {@code best} and {@code bestCost} are maintained    *    incrementally by {@link #propagateCostImprovements0} and    *    {@link RelSet#mergeWith(VolcanoPlanner, RelSet)}.</li>    *</ol>    */
specifier|private
name|void
name|computeBestCost
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|bestCost
operator|=
name|planner
operator|.
name|getCostFactory
argument_list|()
operator|.
name|makeInfiniteCost
argument_list|()
expr_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|getRels
argument_list|()
control|)
block|{
specifier|final
name|RelOptCost
name|cost
init|=
name|planner
operator|.
name|getCost
argument_list|(
name|rel
argument_list|,
name|mq
argument_list|)
decl_stmt|;
if|if
condition|(
name|cost
operator|.
name|isLt
argument_list|(
name|bestCost
argument_list|)
condition|)
block|{
name|bestCost
operator|=
name|cost
expr_stmt|;
name|best
operator|=
name|rel
expr_stmt|;
block|}
block|}
block|}
name|void
name|setDelivered
parameter_list|()
block|{
name|triggerRule
operator|=
operator|!
name|isDelivered
argument_list|()
expr_stmt|;
name|state
operator||=
name|DELIVERED
expr_stmt|;
block|}
name|void
name|setRequired
parameter_list|()
block|{
name|triggerRule
operator|=
literal|false
expr_stmt|;
name|state
operator||=
name|REQUIRED
expr_stmt|;
block|}
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.23"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
name|boolean
name|isDelivered
parameter_list|()
block|{
return|return
operator|(
name|state
operator|&
name|DELIVERED
operator|)
operator|==
name|DELIVERED
return|;
block|}
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.23"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
name|boolean
name|isRequired
parameter_list|()
block|{
return|return
operator|(
name|state
operator|&
name|REQUIRED
operator|)
operator|==
name|REQUIRED
return|;
block|}
name|void
name|disableEnforcing
parameter_list|()
block|{
assert|assert
name|isDelivered
argument_list|()
assert|;
name|enforceDisabled
operator|=
literal|true
expr_stmt|;
block|}
name|boolean
name|isEnforceDisabled
parameter_list|()
block|{
return|return
name|enforceDisabled
return|;
block|}
specifier|public
name|RelNode
name|getBest
parameter_list|()
block|{
return|return
name|best
return|;
block|}
specifier|public
name|RelNode
name|getOriginal
parameter_list|()
block|{
return|return
name|set
operator|.
name|rel
return|;
block|}
specifier|public
name|RelNode
name|copy
parameter_list|(
name|RelTraitSet
name|traitSet
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|)
block|{
if|if
condition|(
name|inputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|RelTraitSet
name|traitSet1
init|=
name|traitSet
operator|.
name|simplify
argument_list|()
decl_stmt|;
if|if
condition|(
name|traitSet1
operator|.
name|equals
argument_list|(
name|this
operator|.
name|traitSet
argument_list|)
condition|)
block|{
return|return
name|this
return|;
block|}
return|return
name|set
operator|.
name|getOrCreateSubset
argument_list|(
name|getCluster
argument_list|()
argument_list|,
name|traitSet1
argument_list|,
name|isRequired
argument_list|()
argument_list|)
return|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|RelOptCost
name|computeSelfCost
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
return|return
name|planner
operator|.
name|getCostFactory
argument_list|()
operator|.
name|makeZeroCost
argument_list|()
return|;
block|}
specifier|public
name|double
name|estimateRowCount
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
if|if
condition|(
name|best
operator|!=
literal|null
condition|)
block|{
return|return
name|mq
operator|.
name|getRowCount
argument_list|(
name|best
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|mq
operator|.
name|getRowCount
argument_list|(
name|set
operator|.
name|rel
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|explain
parameter_list|(
name|RelWriter
name|pw
parameter_list|)
block|{
comment|// Not a typical implementation of "explain". We don't gather terms&
comment|// values to be printed later. We actually do the work.
name|pw
operator|.
name|item
argument_list|(
literal|"subset"
argument_list|,
name|toString
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|AbstractRelNode
name|input
init|=
operator|(
name|AbstractRelNode
operator|)
name|Util
operator|.
name|first
argument_list|(
name|getBest
argument_list|()
argument_list|,
name|getOriginal
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|input
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|input
operator|.
name|explainTerms
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|done
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|digestEquals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|this
operator|==
name|obj
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|digestHash
parameter_list|()
block|{
return|return
name|this
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelDataType
name|deriveRowType
parameter_list|()
block|{
return|return
name|set
operator|.
name|rel
operator|.
name|getRowType
argument_list|()
return|;
block|}
comment|/**    * Returns the collection of RelNodes one of whose inputs is in this    * subset.    */
name|Set
argument_list|<
name|RelNode
argument_list|>
name|getParents
parameter_list|()
block|{
specifier|final
name|Set
argument_list|<
name|RelNode
argument_list|>
name|list
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|parent
range|:
name|set
operator|.
name|getParentRels
argument_list|()
control|)
block|{
for|for
control|(
name|RelSubset
name|rel
range|:
name|inputSubsets
argument_list|(
name|parent
argument_list|)
control|)
block|{
comment|// see usage of this method in propagateCostImprovements0()
if|if
condition|(
name|rel
operator|==
name|this
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**    * Returns the collection of distinct subsets that contain a RelNode one    * of whose inputs is in this subset.    */
name|Set
argument_list|<
name|RelSubset
argument_list|>
name|getParentSubsets
parameter_list|(
name|VolcanoPlanner
name|planner
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|RelSubset
argument_list|>
name|list
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|parent
range|:
name|set
operator|.
name|getParentRels
argument_list|()
control|)
block|{
for|for
control|(
name|RelSubset
name|rel
range|:
name|inputSubsets
argument_list|(
name|parent
argument_list|)
control|)
block|{
if|if
condition|(
name|rel
operator|.
name|set
operator|==
name|set
operator|&&
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|traitSet
argument_list|)
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|planner
operator|.
name|getSubset
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|list
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|RelSubset
argument_list|>
name|inputSubsets
parameter_list|(
name|RelNode
name|parent
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|List
argument_list|<
name|RelSubset
argument_list|>
operator|)
operator|(
name|List
operator|)
name|parent
operator|.
name|getInputs
argument_list|()
return|;
block|}
comment|/**    * Returns a list of relational expressions one of whose children is this    * subset. The elements of the list are distinct.    */
specifier|public
name|Collection
argument_list|<
name|RelNode
argument_list|>
name|getParentRels
parameter_list|()
block|{
specifier|final
name|Set
argument_list|<
name|RelNode
argument_list|>
name|list
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|parentLoop
label|:
for|for
control|(
name|RelNode
name|parent
range|:
name|set
operator|.
name|getParentRels
argument_list|()
control|)
block|{
for|for
control|(
name|RelSubset
name|rel
range|:
name|inputSubsets
argument_list|(
name|parent
argument_list|)
control|)
block|{
if|if
condition|(
name|rel
operator|.
name|set
operator|==
name|set
operator|&&
name|traitSet
operator|.
name|satisfies
argument_list|(
name|rel
operator|.
name|getTraitSet
argument_list|()
argument_list|)
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
continue|continue
name|parentLoop
continue|;
block|}
block|}
block|}
return|return
name|list
return|;
block|}
name|RelSet
name|getSet
parameter_list|()
block|{
return|return
name|set
return|;
block|}
comment|/**    * Adds expression<code>rel</code> to this subset.    */
name|void
name|add
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
name|set
operator|.
name|rels
operator|.
name|contains
argument_list|(
name|rel
argument_list|)
condition|)
block|{
return|return;
block|}
name|VolcanoPlanner
name|planner
init|=
operator|(
name|VolcanoPlanner
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
decl_stmt|;
if|if
condition|(
name|planner
operator|.
name|getListener
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|RelOptListener
operator|.
name|RelEquivalenceEvent
name|event
init|=
operator|new
name|RelOptListener
operator|.
name|RelEquivalenceEvent
argument_list|(
name|planner
argument_list|,
name|rel
argument_list|,
name|this
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|planner
operator|.
name|getListener
argument_list|()
operator|.
name|relEquivalenceFound
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
comment|// If this isn't the first rel in the set, it must have compatible
comment|// row type.
if|if
condition|(
name|set
operator|.
name|rel
operator|!=
literal|null
condition|)
block|{
name|RelOptUtil
operator|.
name|equal
argument_list|(
literal|"rowtype of new rel"
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|"rowtype of set"
argument_list|,
name|getRowType
argument_list|()
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
expr_stmt|;
block|}
name|set
operator|.
name|addInternal
argument_list|(
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|variablesSet
init|=
name|RelOptUtil
operator|.
name|getVariablesSet
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|variablesStopped
init|=
name|rel
operator|.
name|getVariablesSet
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|variablesPropagated
init|=
name|Util
operator|.
name|minus
argument_list|(
name|variablesSet
argument_list|,
name|variablesStopped
argument_list|)
decl_stmt|;
assert|assert
name|set
operator|.
name|variablesPropagated
operator|.
name|containsAll
argument_list|(
name|variablesPropagated
argument_list|)
assert|;
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|variablesUsed
init|=
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|rel
argument_list|)
decl_stmt|;
assert|assert
name|set
operator|.
name|variablesUsed
operator|.
name|containsAll
argument_list|(
name|variablesUsed
argument_list|)
assert|;
block|}
block|}
comment|/**    * Recursively builds a tree consisting of the cheapest plan at each node.    */
name|RelNode
name|buildCheapestPlan
parameter_list|(
name|VolcanoPlanner
name|planner
parameter_list|)
block|{
name|CheapestPlanReplacer
name|replacer
init|=
operator|new
name|CheapestPlanReplacer
argument_list|(
name|planner
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|cheapest
init|=
name|replacer
operator|.
name|visit
argument_list|(
name|this
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|planner
operator|.
name|getListener
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|RelOptListener
operator|.
name|RelChosenEvent
name|event
init|=
operator|new
name|RelOptListener
operator|.
name|RelChosenEvent
argument_list|(
name|planner
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|planner
operator|.
name|getListener
argument_list|()
operator|.
name|relChosen
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
return|return
name|cheapest
return|;
block|}
comment|/**    * Checks whether a relexp has made its subset cheaper, and if it so,    * propagate new cost to parent rel nodes using breadth first manner.    *    * @param planner   Planner    * @param mq        Metadata query    * @param rel       Relational expression whose cost has improved    * @param activeSet Set of active subsets, for cycle detection    */
name|void
name|propagateCostImprovements
parameter_list|(
name|VolcanoPlanner
name|planner
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|Set
argument_list|<
name|RelSubset
argument_list|>
name|activeSet
parameter_list|)
block|{
name|Queue
argument_list|<
name|Pair
argument_list|<
name|RelSubset
argument_list|,
name|RelNode
argument_list|>
argument_list|>
name|propagationQueue
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelSubset
name|subset
range|:
name|set
operator|.
name|subsets
control|)
block|{
if|if
condition|(
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|satisfies
argument_list|(
name|subset
operator|.
name|traitSet
argument_list|)
condition|)
block|{
name|propagationQueue
operator|.
name|offer
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|subset
argument_list|,
name|rel
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|propagationQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Pair
argument_list|<
name|RelSubset
argument_list|,
name|RelNode
argument_list|>
name|p
init|=
name|propagationQueue
operator|.
name|poll
argument_list|()
decl_stmt|;
name|p
operator|.
name|left
operator|.
name|propagateCostImprovements0
argument_list|(
name|planner
argument_list|,
name|mq
argument_list|,
name|p
operator|.
name|right
argument_list|,
name|activeSet
argument_list|,
name|propagationQueue
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|propagateCostImprovements0
parameter_list|(
name|VolcanoPlanner
name|planner
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|Set
argument_list|<
name|RelSubset
argument_list|>
name|activeSet
parameter_list|,
name|Queue
argument_list|<
name|Pair
argument_list|<
name|RelSubset
argument_list|,
name|RelNode
argument_list|>
argument_list|>
name|propagationQueue
parameter_list|)
block|{
operator|++
name|timestamp
expr_stmt|;
if|if
condition|(
operator|!
name|activeSet
operator|.
name|add
argument_list|(
name|this
argument_list|)
condition|)
block|{
comment|// This subset is already in the chain being propagated to. This
comment|// means that the graph is cyclic, and therefore the cost of this
comment|// relational expression - not this subset - must be infinite.
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"cyclic: {}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|RelOptCost
name|cost
init|=
name|planner
operator|.
name|getCost
argument_list|(
name|rel
argument_list|,
name|mq
argument_list|)
decl_stmt|;
comment|// Update subset best cost when we find a cheaper rel or the current
comment|// best's cost is changed
if|if
condition|(
name|cost
operator|.
name|isLt
argument_list|(
name|bestCost
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Subset cost changed: subset [{}] cost was {} now {}"
argument_list|,
name|this
argument_list|,
name|bestCost
argument_list|,
name|cost
argument_list|)
expr_stmt|;
name|bestCost
operator|=
name|cost
expr_stmt|;
name|best
operator|=
name|rel
expr_stmt|;
comment|// since best was changed, cached metadata for this subset should be removed
name|mq
operator|.
name|clearCache
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Propagate cost change to parents
for|for
control|(
name|RelNode
name|parent
range|:
name|getParents
argument_list|()
control|)
block|{
comment|// removes parent cached metadata since its input was changed
name|mq
operator|.
name|clearCache
argument_list|(
name|parent
argument_list|)
expr_stmt|;
specifier|final
name|RelSubset
name|parentSubset
init|=
name|planner
operator|.
name|getSubset
argument_list|(
name|parent
argument_list|)
decl_stmt|;
comment|// parent subset will clear its cache in propagateCostImprovements0 method itself
for|for
control|(
name|RelSubset
name|subset
range|:
name|parentSubset
operator|.
name|set
operator|.
name|subsets
control|)
block|{
if|if
condition|(
name|parent
operator|.
name|getTraitSet
argument_list|()
operator|.
name|satisfies
argument_list|(
name|subset
operator|.
name|traitSet
argument_list|)
condition|)
block|{
name|propagationQueue
operator|.
name|offer
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|subset
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
name|activeSet
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|collectVariablesUsed
parameter_list|(
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|variableSet
parameter_list|)
block|{
name|variableSet
operator|.
name|addAll
argument_list|(
name|set
operator|.
name|variablesUsed
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|collectVariablesSet
parameter_list|(
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|variableSet
parameter_list|)
block|{
name|variableSet
operator|.
name|addAll
argument_list|(
name|set
operator|.
name|variablesPropagated
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the rel nodes in this rel subset.  All rels must have the same    * traits and are logically equivalent.    *    * @return all the rels in the subset    */
specifier|public
name|Iterable
argument_list|<
name|RelNode
argument_list|>
name|getRels
parameter_list|()
block|{
return|return
parameter_list|()
lambda|->
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set
operator|.
name|rels
argument_list|)
operator|.
name|where
argument_list|(
name|v1
lambda|->
name|v1
operator|.
name|getTraitSet
argument_list|()
operator|.
name|satisfies
argument_list|(
name|traitSet
argument_list|)
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/**    * As {@link #getRels()} but returns a list.    */
specifier|public
name|List
argument_list|<
name|RelNode
argument_list|>
name|getRelList
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|set
operator|.
name|rels
control|)
block|{
if|if
condition|(
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|satisfies
argument_list|(
name|traitSet
argument_list|)
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**    * Returns stream of subsets whose traitset satisfies    * current subset's traitset.    */
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.23"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
name|Stream
argument_list|<
name|RelSubset
argument_list|>
name|getSubsetsSatisfyingThis
parameter_list|()
block|{
return|return
name|set
operator|.
name|subsets
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|s
lambda|->
name|s
operator|.
name|getTraitSet
argument_list|()
operator|.
name|satisfies
argument_list|(
name|traitSet
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns stream of subsets whose traitset is satisfied    * by current subset's traitset.    */
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.23"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
name|Stream
argument_list|<
name|RelSubset
argument_list|>
name|getSatisfyingSubsets
parameter_list|()
block|{
return|return
name|set
operator|.
name|subsets
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|s
lambda|->
name|traitSet
operator|.
name|satisfies
argument_list|(
name|s
operator|.
name|getTraitSet
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Identifies the leaf-most non-implementable nodes.    */
specifier|static
class|class
name|DeadEndFinder
block|{
specifier|final
name|Set
argument_list|<
name|RelSubset
argument_list|>
name|deadEnds
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// To save time
specifier|private
specifier|final
name|Set
argument_list|<
name|RelNode
argument_list|>
name|visitedNodes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// For cycle detection
specifier|private
specifier|final
name|Set
argument_list|<
name|RelNode
argument_list|>
name|activeNodes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|visit
parameter_list|(
name|RelNode
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|instanceof
name|RelSubset
condition|)
block|{
name|visitSubset
argument_list|(
operator|(
name|RelSubset
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|visitRel
argument_list|(
name|p
argument_list|)
return|;
block|}
specifier|private
name|void
name|visitSubset
parameter_list|(
name|RelSubset
name|subset
parameter_list|)
block|{
name|RelNode
name|cheapest
init|=
name|subset
operator|.
name|getBest
argument_list|()
decl_stmt|;
if|if
condition|(
name|cheapest
operator|!=
literal|null
condition|)
block|{
comment|// Subset is implementable, and we are looking for bad ones, so stop here
return|return;
block|}
name|boolean
name|isEmpty
init|=
literal|true
decl_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|subset
operator|.
name|getRels
argument_list|()
control|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|AbstractConverter
condition|)
block|{
comment|// Converters are not implementable
continue|continue;
block|}
if|if
condition|(
operator|!
name|activeNodes
operator|.
name|add
argument_list|(
name|rel
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|boolean
name|res
init|=
name|visit
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|isEmpty
operator|&=
name|res
expr_stmt|;
name|activeNodes
operator|.
name|remove
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isEmpty
condition|)
block|{
name|deadEnds
operator|.
name|add
argument_list|(
name|subset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns true when input {@code RelNode} is cyclic.      */
specifier|private
name|boolean
name|visitRel
parameter_list|(
name|RelNode
name|p
parameter_list|)
block|{
comment|// If one of the inputs is in "active" set, that means the rel forms a cycle,
comment|// then we just ignore it. Cyclic rels are not implementable.
for|for
control|(
name|RelNode
name|oldInput
range|:
name|p
operator|.
name|getInputs
argument_list|()
control|)
block|{
if|if
condition|(
name|activeNodes
operator|.
name|contains
argument_list|(
name|oldInput
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// The same subset can be used multiple times (e.g. union all with the same inputs),
comment|// so it is important to perform "contains" and "add" in different loops
name|activeNodes
operator|.
name|addAll
argument_list|(
name|p
operator|.
name|getInputs
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|oldInput
range|:
name|p
operator|.
name|getInputs
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|visitedNodes
operator|.
name|add
argument_list|(
name|oldInput
argument_list|)
condition|)
block|{
comment|// We don't want to explore the same subset twice
continue|continue;
block|}
name|visit
argument_list|(
name|oldInput
argument_list|)
expr_stmt|;
block|}
name|activeNodes
operator|.
name|removeAll
argument_list|(
name|p
operator|.
name|getInputs
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|getDigest
parameter_list|()
block|{
return|return
literal|"RelSubset#"
operator|+
name|set
operator|.
name|id
operator|+
literal|'.'
operator|+
name|getTraitSet
argument_list|()
return|;
block|}
comment|/**    * Visitor which walks over a tree of {@link RelSet}s, replacing each node    * with the cheapest implementation of the expression.    */
specifier|static
class|class
name|CheapestPlanReplacer
block|{
name|VolcanoPlanner
name|planner
decl_stmt|;
name|CheapestPlanReplacer
parameter_list|(
name|VolcanoPlanner
name|planner
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|planner
operator|=
name|planner
expr_stmt|;
block|}
specifier|private
specifier|static
name|String
name|traitDiff
parameter_list|(
name|RelTraitSet
name|original
parameter_list|,
name|RelTraitSet
name|desired
parameter_list|)
block|{
return|return
name|Pair
operator|.
name|zip
argument_list|(
name|original
argument_list|,
name|desired
argument_list|)
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|p
lambda|->
operator|!
name|p
operator|.
name|left
operator|.
name|satisfies
argument_list|(
name|p
operator|.
name|right
argument_list|)
argument_list|)
operator|.
name|map
argument_list|(
name|p
lambda|->
name|p
operator|.
name|left
operator|.
name|getTraitDef
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": "
operator|+
name|p
operator|.
name|left
operator|+
literal|" -> "
operator|+
name|p
operator|.
name|right
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|", "
argument_list|,
literal|"["
argument_list|,
literal|"]"
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|RelNode
name|visit
parameter_list|(
name|RelNode
name|p
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|p
operator|instanceof
name|RelSubset
condition|)
block|{
name|RelSubset
name|subset
init|=
operator|(
name|RelSubset
operator|)
name|p
decl_stmt|;
name|RelNode
name|cheapest
init|=
name|subset
operator|.
name|best
decl_stmt|;
if|if
condition|(
name|cheapest
operator|==
literal|null
condition|)
block|{
comment|// Dump the planner's expression pool so we can figure
comment|// out why we reached impasse.
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"There are not enough rules to produce a node with desired properties"
argument_list|)
expr_stmt|;
name|RelTraitSet
name|desiredTraits
init|=
name|subset
operator|.
name|getTraitSet
argument_list|()
decl_stmt|;
name|String
name|sep
init|=
literal|": "
decl_stmt|;
for|for
control|(
name|RelTrait
name|trait
range|:
name|desiredTraits
control|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|sep
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|trait
operator|.
name|getTraitDef
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|trait
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|DeadEndFinder
name|finder
init|=
operator|new
name|DeadEndFinder
argument_list|()
decl_stmt|;
name|finder
operator|.
name|visit
argument_list|(
name|subset
argument_list|)
expr_stmt|;
if|if
condition|(
name|finder
operator|.
name|deadEnds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|" All the inputs have relevant nodes, however the cost is still infinite."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|problemCounts
init|=
name|finder
operator|.
name|deadEnds
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|deadSubset
lambda|->
name|deadSubset
operator|.
name|getOriginal
argument_list|()
operator|!=
literal|null
argument_list|)
operator|.
name|map
argument_list|(
name|x
lambda|->
name|x
operator|.
name|getOriginal
argument_list|()
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
name|traitDiff
argument_list|(
name|x
operator|.
name|getOriginal
argument_list|()
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|x
operator|.
name|getTraitSet
argument_list|()
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|groupingBy
argument_list|(
name|Function
operator|.
name|identity
argument_list|()
argument_list|,
name|Collectors
operator|.
name|counting
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// Sort problems from most often to less often ones
name|String
name|problems
init|=
name|problemCounts
operator|.
name|entrySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|sorted
argument_list|(
name|Comparator
operator|.
name|comparingLong
argument_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
operator|::
name|getValue
argument_list|)
operator|.
name|reversed
argument_list|()
argument_list|)
operator|.
name|map
argument_list|(
name|e
lambda|->
name|e
operator|.
name|getKey
argument_list|()
operator|+
operator|(
name|e
operator|.
name|getValue
argument_list|()
operator|>
literal|1
condition|?
literal|" ("
operator|+
name|e
operator|.
name|getValue
argument_list|()
operator|+
literal|" cases)"
else|:
literal|""
operator|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|", "
argument_list|)
argument_list|)
decl_stmt|;
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"Missing conversion"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|finder
operator|.
name|deadEnds
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|?
literal|" is "
else|:
literal|"s are "
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|problems
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
if|if
condition|(
name|finder
operator|.
name|deadEnds
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"There is 1 empty subset: "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finder
operator|.
name|deadEnds
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|"There are "
operator|+
name|finder
operator|.
name|deadEnds
operator|.
name|size
argument_list|()
operator|+
literal|" empty subsets:"
argument_list|)
expr_stmt|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|rest
init|=
name|finder
operator|.
name|deadEnds
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|RelSubset
name|deadEnd
range|:
name|finder
operator|.
name|deadEnds
control|)
block|{
if|if
condition|(
name|finder
operator|.
name|deadEnds
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"Empty subset "
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
name|deadEnd
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|", the relevant part of the original plan is as follows"
argument_list|)
expr_stmt|;
name|RelNode
name|original
init|=
name|deadEnd
operator|.
name|getOriginal
argument_list|()
decl_stmt|;
name|original
operator|.
name|explain
argument_list|(
operator|new
name|RelWriterImpl
argument_list|(
name|pw
argument_list|,
name|SqlExplainLevel
operator|.
name|EXPPLAN_ATTRIBUTES
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|rest
operator|--
expr_stmt|;
if|if
condition|(
name|rest
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
literal|10
operator|&&
name|rest
operator|>
literal|1
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"The rest "
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|" leafs are omitted."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
name|planner
operator|.
name|dump
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
specifier|final
name|String
name|dump
init|=
name|sw
operator|.
name|toString
argument_list|()
decl_stmt|;
name|RuntimeException
name|e
init|=
operator|new
name|RelOptPlanner
operator|.
name|CannotPlanException
argument_list|(
name|dump
argument_list|)
decl_stmt|;
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Caught exception in class={}, method=visit"
argument_list|,
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|p
operator|=
name|cheapest
expr_stmt|;
block|}
if|if
condition|(
name|ordinal
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|planner
operator|.
name|getListener
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|RelOptListener
operator|.
name|RelChosenEvent
name|event
init|=
operator|new
name|RelOptListener
operator|.
name|RelChosenEvent
argument_list|(
name|planner
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|planner
operator|.
name|getListener
argument_list|()
operator|.
name|relChosen
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|RelNode
argument_list|>
name|oldInputs
init|=
name|p
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldInputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelNode
name|oldInput
init|=
name|oldInputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RelNode
name|input
init|=
name|visit
argument_list|(
name|oldInput
argument_list|,
name|i
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|inputs
operator|.
name|add
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inputs
operator|.
name|equals
argument_list|(
name|oldInputs
argument_list|)
condition|)
block|{
specifier|final
name|RelNode
name|pOld
init|=
name|p
decl_stmt|;
name|p
operator|=
name|p
operator|.
name|copy
argument_list|(
name|p
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
name|planner
operator|.
name|provenanceMap
operator|.
name|put
argument_list|(
name|p
argument_list|,
operator|new
name|VolcanoPlanner
operator|.
name|DirectProvenance
argument_list|(
name|pOld
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
block|}
block|}
end_class

end_unit

