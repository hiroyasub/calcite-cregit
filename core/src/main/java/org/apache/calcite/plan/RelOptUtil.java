begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|AvaticaConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteSystemProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|interpreter
operator|.
name|Bindables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Experimental
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelHomogeneousShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Calc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|externalize
operator|.
name|RelDotWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|externalize
operator|.
name|RelJsonWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|externalize
operator|.
name|RelWriterImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|externalize
operator|.
name|RelXmlWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|hint
operator|.
name|HintStrategyTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|hint
operator|.
name|Hintable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|hint
operator|.
name|RelHint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalCalc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|CoreRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|MultiJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|stream
operator|.
name|StreamRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFieldImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|LogicVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCorrelVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexExecutorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLocalRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexOver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSqlStandardConvertletTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSubQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexToSqlNodeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexToSqlNodeConverterImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|CalciteContextException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|ModifiableView
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|MultisetSqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Permutation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|MappingType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedHashMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|initialization
operator|.
name|qual
operator|.
name|NotOnlyInitialized
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|initialization
operator|.
name|qual
operator|.
name|UnknownInitialization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|PolyNull
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeImpl
operator|.
name|NON_NULLABLE_SUFFIX
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  *<code>RelOptUtil</code> defines static utility methods for use in optimizing  * {@link RelNode}s.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|RelOptUtil
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|public
specifier|static
specifier|final
name|double
name|EPSILON
init|=
literal|1.0e-5
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"Guava"
argument_list|)
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
specifier|final
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
argument_list|<
name|Filter
argument_list|>
name|FILTER_PREDICATE
init|=
name|f
lambda|->
operator|!
name|f
operator|.
name|containsOver
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"Guava"
argument_list|)
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
specifier|final
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
argument_list|<
name|Project
argument_list|>
name|PROJECT_PREDICATE
init|=
name|RelOptUtil
operator|::
name|notContainsWindowedAgg
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"Guava"
argument_list|)
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
specifier|final
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
argument_list|<
name|Calc
argument_list|>
name|CALC_PREDICATE
init|=
name|RelOptUtil
operator|::
name|notContainsWindowedAgg
decl_stmt|;
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Whether this node is a limit without sort specification.    */
specifier|public
specifier|static
name|boolean
name|isPureLimit
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|isLimit
argument_list|(
name|rel
argument_list|)
operator|&&
operator|!
name|isOrder
argument_list|(
name|rel
argument_list|)
return|;
block|}
comment|/**    * Whether this node is a sort without limit specification.    */
specifier|public
specifier|static
name|boolean
name|isPureOrder
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
operator|!
name|isLimit
argument_list|(
name|rel
argument_list|)
operator|&&
name|isOrder
argument_list|(
name|rel
argument_list|)
return|;
block|}
comment|/**    * Whether this node contains a limit specification.    */
specifier|public
specifier|static
name|boolean
name|isLimit
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
operator|(
name|rel
operator|instanceof
name|Sort
operator|)
operator|&&
operator|(
operator|(
name|Sort
operator|)
name|rel
operator|)
operator|.
name|fetch
operator|!=
literal|null
return|;
block|}
comment|/**    * Whether this node contains a sort specification.    */
specifier|public
specifier|static
name|boolean
name|isOrder
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
operator|(
name|rel
operator|instanceof
name|Sort
operator|)
operator|&&
operator|!
operator|(
operator|(
name|Sort
operator|)
name|rel
operator|)
operator|.
name|getCollation
argument_list|()
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * Returns a set of tables used by this expression or its children.    */
specifier|public
specifier|static
name|Set
argument_list|<
name|RelOptTable
argument_list|>
name|findTables
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|findAllTables
argument_list|(
name|rel
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a list of all tables used by this expression or its children.    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelOptTable
argument_list|>
name|findAllTables
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|Multimap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|RelNode
argument_list|>
name|nodes
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
operator|.
name|getNodeTypes
argument_list|(
name|rel
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelOptTable
argument_list|>
name|usedTables
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodes
operator|==
literal|null
condition|)
block|{
return|return
name|usedTables
return|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Collection
argument_list|<
name|RelNode
argument_list|>
argument_list|>
name|e
range|:
name|nodes
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|TableScan
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
for|for
control|(
name|RelNode
name|node
range|:
name|e
operator|.
name|getValue
argument_list|()
control|)
block|{
name|TableScan
name|scan
init|=
operator|(
name|TableScan
operator|)
name|node
decl_stmt|;
name|usedTables
operator|.
name|add
argument_list|(
name|scan
operator|.
name|getTable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|usedTables
return|;
block|}
comment|/**    * Returns a list of all table qualified names used by this expression    * or its children.    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|findAllTableQualifiedNames
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|findAllTables
argument_list|(
name|rel
argument_list|)
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|table
lambda|->
name|table
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a list of variables set by a relational expression or its    * descendants.    */
specifier|public
specifier|static
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|getVariablesSet
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|VariableSetVisitor
name|visitor
init|=
operator|new
name|VariableSetVisitor
argument_list|()
decl_stmt|;
name|go
argument_list|(
name|visitor
argument_list|,
name|rel
argument_list|)
expr_stmt|;
return|return
name|visitor
operator|.
name|variables
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
annotation|@
name|SuppressWarnings
argument_list|(
literal|"MixedMutabilityReturnType"
argument_list|)
specifier|public
specifier|static
name|List
argument_list|<
name|CorrelationId
argument_list|>
name|getVariablesSetAndUsed
parameter_list|(
name|RelNode
name|rel0
parameter_list|,
name|RelNode
name|rel1
parameter_list|)
block|{
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|set
init|=
name|getVariablesSet
argument_list|(
name|rel0
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|used
init|=
name|getVariablesUsed
argument_list|(
name|rel1
argument_list|)
decl_stmt|;
if|if
condition|(
name|used
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
specifier|final
name|List
argument_list|<
name|CorrelationId
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|CorrelationId
name|s
range|:
name|set
control|)
block|{
if|if
condition|(
name|used
operator|.
name|contains
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|result
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns a set of variables used by a relational expression or its    * descendants.    *    *<p>The set may contain "duplicates" (variables with different ids that,    * when resolved, will reference the same source relational expression).    *    *<p>The item type is the same as    * {@link org.apache.calcite.rex.RexCorrelVariable#id}.    */
specifier|public
specifier|static
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|getVariablesUsed
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|CorrelationCollector
name|visitor
init|=
operator|new
name|CorrelationCollector
argument_list|()
decl_stmt|;
name|rel
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
return|return
name|visitor
operator|.
name|vuv
operator|.
name|variables
return|;
block|}
comment|/** Finds which columns of a correlation variable are used within a    * relational expression. */
specifier|public
specifier|static
name|ImmutableBitSet
name|correlationColumns
parameter_list|(
name|CorrelationId
name|id
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|CorrelationCollector
name|collector
init|=
operator|new
name|CorrelationCollector
argument_list|()
decl_stmt|;
name|rel
operator|.
name|accept
argument_list|(
name|collector
argument_list|)
expr_stmt|;
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|builder
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|field
range|:
name|collector
operator|.
name|vuv
operator|.
name|variableFields
operator|.
name|get
argument_list|(
name|id
argument_list|)
control|)
block|{
if|if
condition|(
name|field
operator|>=
literal|0
condition|)
block|{
name|builder
operator|.
name|set
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns true, and calls {@link Litmus#succeed()} if a given relational    * expression does not contain a given correlation. */
specifier|public
specifier|static
name|boolean
name|notContainsCorrelation
parameter_list|(
name|RelNode
name|r
parameter_list|,
name|CorrelationId
name|correlationId
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|set
init|=
name|getVariablesUsed
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|set
operator|.
name|contains
argument_list|(
name|correlationId
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"contains {}"
argument_list|,
name|correlationId
argument_list|)
return|;
block|}
block|}
comment|/**    * Sets a {@link RelVisitor} going on a given relational expression, and    * returns the result.    */
specifier|public
specifier|static
name|void
name|go
parameter_list|(
name|RelVisitor
name|visitor
parameter_list|,
name|RelNode
name|p
parameter_list|)
block|{
try|try
block|{
name|visitor
operator|.
name|go
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"while visiting tree"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns a list of the types of the fields in a given struct type. The    * list is immutable.    *    * @param type Struct type    * @return List of field types    * @see org.apache.calcite.rel.type.RelDataType#getFieldNames()    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataType
argument_list|>
name|getFieldTypeList
parameter_list|(
specifier|final
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|Util
operator|.
name|transform
argument_list|(
name|type
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|RelDataTypeField
operator|::
name|getType
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|areRowTypesEqual
parameter_list|(
name|RelDataType
name|rowType1
parameter_list|,
name|RelDataType
name|rowType2
parameter_list|,
name|boolean
name|compareNames
parameter_list|)
block|{
if|if
condition|(
name|rowType1
operator|==
name|rowType2
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|compareNames
condition|)
block|{
comment|// if types are not identity-equal, then either the names or
comment|// the types must be different
return|return
literal|false
return|;
block|}
if|if
condition|(
name|rowType2
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|rowType1
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|f1
init|=
name|rowType1
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|f2
init|=
name|rowType2
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|f1
argument_list|,
name|f2
argument_list|)
control|)
block|{
specifier|final
name|RelDataType
name|type1
init|=
name|pair
operator|.
name|left
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type2
init|=
name|pair
operator|.
name|right
operator|.
name|getType
argument_list|()
decl_stmt|;
comment|// If one of the types is ANY comparison should succeed
if|if
condition|(
name|type1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
operator|||
name|type2
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|type1
operator|.
name|equals
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Verifies that a row type being added to an equivalence class matches the    * existing type, raising an assertion if this is not the case.    *    * @param originalRel      canonical rel for equivalence class    * @param newRel           rel being added to equivalence class    * @param equivalenceClass object representing equivalence class    */
specifier|public
specifier|static
name|void
name|verifyTypeEquivalence
parameter_list|(
name|RelNode
name|originalRel
parameter_list|,
name|RelNode
name|newRel
parameter_list|,
name|Object
name|equivalenceClass
parameter_list|)
block|{
name|RelDataType
name|expectedRowType
init|=
name|originalRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|RelDataType
name|actualRowType
init|=
name|newRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
comment|// Row types must be the same, except for field names.
if|if
condition|(
name|areRowTypesEqual
argument_list|(
name|expectedRowType
argument_list|,
name|actualRowType
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|String
name|s
init|=
literal|"Cannot add expression of different type to set:\n"
operator|+
literal|"set type is "
operator|+
name|expectedRowType
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\nexpression type is "
operator|+
name|actualRowType
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\nset is "
operator|+
name|equivalenceClass
operator|.
name|toString
argument_list|()
operator|+
literal|"\nexpression is "
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|newRel
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
name|s
argument_list|)
throw|;
block|}
comment|/**    * Copy the {@link org.apache.calcite.rel.hint.RelHint}s from {@code originalRel}    * to {@code newRel} if both of them are {@link Hintable}.    *    *<p>The two relational expressions are assumed as semantically equivalent,    * that means the hints should be attached to the relational expression    * that expects to have them.    *    *<p>Try to propagate the hints to the first relational expression that matches,    * this is needed because many planner rules would generate a sub-tree whose    * root rel type is different with the original matched rel.    *    *<p>For the worst case, there is no relational expression that can apply these hints,    * and the whole sub-tree would be visited. We add a protection here:    * if the visiting depth is over than 3, just returns, because there are rare cases    * the new created sub-tree has layers bigger than that.    *    *<p>This is a best effort, we do not know exactly how the nodes are transformed    * in all kinds of planner rules, so for some complex relational expressions,    * the hints would very probably lost.    *    *<p>This function is experimental and would change without any notes.    *    * @param originalRel Original relational expression    * @param equiv       New equivalent relational expression    * @return A copy of {@code newRel} with attached qualified hints from {@code originalRel},    * or {@code newRel} directly if one of them are not {@link Hintable}    */
annotation|@
name|Experimental
specifier|public
specifier|static
name|RelNode
name|propagateRelHints
parameter_list|(
name|RelNode
name|originalRel
parameter_list|,
name|RelNode
name|equiv
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|originalRel
operator|instanceof
name|Hintable
operator|)
operator|||
operator|(
operator|(
name|Hintable
operator|)
name|originalRel
operator|)
operator|.
name|getHints
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|equiv
return|;
block|}
specifier|final
name|RelShuttle
name|shuttle
init|=
operator|new
name|SubTreeHintPropagateShuttle
argument_list|(
name|originalRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getHintStrategies
argument_list|()
argument_list|,
operator|(
operator|(
name|Hintable
operator|)
name|originalRel
operator|)
operator|.
name|getHints
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|equiv
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
comment|/**    * Propagates the relational expression hints from root node to leaf node.    *    * @param rel   The relational expression    * @param reset Flag saying if to reset the existing hints before the propagation    * @return New relational expression with hints propagated    */
specifier|public
specifier|static
name|RelNode
name|propagateRelHints
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|boolean
name|reset
parameter_list|)
block|{
if|if
condition|(
name|reset
condition|)
block|{
name|rel
operator|=
name|rel
operator|.
name|accept
argument_list|(
operator|new
name|ResetHintsShuttle
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelShuttle
name|shuttle
init|=
operator|new
name|RelHintPropagateShuttle
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getHintStrategies
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rel
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
comment|/**    * Copy the {@link org.apache.calcite.rel.hint.RelHint}s from {@code originalRel}    * to {@code newRel} if both of them are {@link Hintable}.    *    *<p>The hints would be attached directly(e.g. without any filtering).    *    * @param originalRel Original relational expression    * @param newRel      New relational expression    * @return A copy of {@code newRel} with attached hints from {@code originalRel},    * or {@code newRel} directly if one of them are not {@link Hintable}    */
specifier|public
specifier|static
name|RelNode
name|copyRelHints
parameter_list|(
name|RelNode
name|originalRel
parameter_list|,
name|RelNode
name|newRel
parameter_list|)
block|{
return|return
name|copyRelHints
argument_list|(
name|originalRel
argument_list|,
name|newRel
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Copy the {@link org.apache.calcite.rel.hint.RelHint}s from {@code originalRel}    * to {@code newRel} if both of them are {@link Hintable}.    *    *<p>The hints would be filtered by the specified hint strategies    * if {@code filterHints} is true.    *    * @param originalRel Original relational expression    * @param newRel      New relational expression    * @param filterHints Flag saying if to filter out unqualified hints for {@code newRel}    * @return A copy of {@code newRel} with attached hints from {@code originalRel},    * or {@code newRel} directly if one of them are not {@link Hintable}    */
specifier|public
specifier|static
name|RelNode
name|copyRelHints
parameter_list|(
name|RelNode
name|originalRel
parameter_list|,
name|RelNode
name|newRel
parameter_list|,
name|boolean
name|filterHints
parameter_list|)
block|{
if|if
condition|(
name|originalRel
operator|instanceof
name|Hintable
operator|&&
name|newRel
operator|instanceof
name|Hintable
operator|&&
operator|(
operator|(
name|Hintable
operator|)
name|originalRel
operator|)
operator|.
name|getHints
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|hints
init|=
operator|(
operator|(
name|Hintable
operator|)
name|originalRel
operator|)
operator|.
name|getHints
argument_list|()
decl_stmt|;
if|if
condition|(
name|filterHints
condition|)
block|{
name|HintStrategyTable
name|hintStrategies
init|=
name|originalRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getHintStrategies
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|Hintable
operator|)
name|newRel
operator|)
operator|.
name|attachHints
argument_list|(
name|hintStrategies
operator|.
name|apply
argument_list|(
name|hints
argument_list|,
name|newRel
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|// Keep all the hints if filterHints is false for 2 reasons:
comment|// 1. Keep sync with the hints propagation logic,
comment|// see RelHintPropagateShuttle for details.
comment|// 2. We may re-propagate these hints when decorrelating a query.
return|return
operator|(
operator|(
name|Hintable
operator|)
name|newRel
operator|)
operator|.
name|attachHints
argument_list|(
name|hints
argument_list|)
return|;
block|}
block|}
return|return
name|newRel
return|;
block|}
comment|/**    * Returns a permutation describing where output fields come from. In    * the returned map, value of {@code map.getTargetOpt(i)} is {@code n} if    * field {@code i} projects input field {@code n} or applies a cast on    * {@code n}, -1 if it is another expression.    */
specifier|public
specifier|static
name|Mappings
operator|.
name|TargetMapping
name|permutationIgnoreCast
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|)
block|{
specifier|final
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|PARTIAL_FUNCTION
argument_list|,
name|nodes
operator|.
name|size
argument_list|()
argument_list|,
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RexNode
argument_list|>
name|node
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|nodes
argument_list|)
control|)
block|{
if|if
condition|(
name|node
operator|.
name|e
operator|instanceof
name|RexInputRef
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|node
operator|.
name|i
argument_list|,
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|.
name|e
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|node
operator|.
name|e
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
condition|)
block|{
specifier|final
name|RexNode
name|operand
init|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|.
name|e
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand
operator|instanceof
name|RexInputRef
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|node
operator|.
name|i
argument_list|,
operator|(
operator|(
name|RexInputRef
operator|)
name|operand
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|mapping
return|;
block|}
comment|/**    * Returns a permutation describing where output fields come from. In    * the returned map, value of {@code map.getTargetOpt(i)} is {@code n} if    * field {@code i} projects input field {@code n}, -1 if it is an    * expression.    */
specifier|public
specifier|static
name|Mappings
operator|.
name|TargetMapping
name|permutation
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|)
block|{
specifier|final
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|PARTIAL_FUNCTION
argument_list|,
name|nodes
operator|.
name|size
argument_list|()
argument_list|,
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RexNode
argument_list|>
name|node
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|nodes
argument_list|)
control|)
block|{
if|if
condition|(
name|node
operator|.
name|e
operator|instanceof
name|RexInputRef
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|node
operator|.
name|i
argument_list|,
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|.
name|e
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|mapping
return|;
block|}
comment|/**    * Returns a permutation describing where the Project's fields come from    * after the Project is pushed down.    */
specifier|public
specifier|static
name|Mappings
operator|.
name|TargetMapping
name|permutationPushDownProject
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|,
name|int
name|sourceOffset
parameter_list|,
name|int
name|targetOffset
parameter_list|)
block|{
specifier|final
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|PARTIAL_FUNCTION
argument_list|,
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
operator|+
name|sourceOffset
argument_list|,
name|nodes
operator|.
name|size
argument_list|()
operator|+
name|targetOffset
argument_list|)
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RexNode
argument_list|>
name|node
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|nodes
argument_list|)
control|)
block|{
if|if
condition|(
name|node
operator|.
name|e
operator|instanceof
name|RexInputRef
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|.
name|e
operator|)
operator|.
name|getIndex
argument_list|()
operator|+
name|sourceOffset
argument_list|,
name|node
operator|.
name|i
operator|+
name|targetOffset
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|mapping
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createExistsPlan
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelNode
name|seekRel
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|RexNode
argument_list|>
name|conditions
parameter_list|,
annotation|@
name|Nullable
name|RexLiteral
name|extraExpr
parameter_list|,
annotation|@
name|Nullable
name|String
name|extraName
parameter_list|)
block|{
assert|assert
name|extraExpr
operator|==
literal|null
operator|||
name|extraName
operator|!=
literal|null
assert|;
name|RelNode
name|ret
init|=
name|seekRel
decl_stmt|;
if|if
condition|(
operator|(
name|conditions
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|conditions
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|RexNode
name|conditionExp
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|conditions
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|conditionExp
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RelFactories
operator|.
name|FilterFactory
name|factory
init|=
name|RelFactories
operator|.
name|DEFAULT_FILTER_FACTORY
decl_stmt|;
name|ret
operator|=
name|factory
operator|.
name|createFilter
argument_list|(
name|ret
argument_list|,
name|conditionExp
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|extraExpr
operator|!=
literal|null
condition|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
assert|assert
name|extraExpr
operator|==
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
assert|;
comment|// this should only be called for the exists case
comment|// first stick an Agg on top of the sub-query
comment|// agg does not like no agg functions so just pretend it is
comment|// doing a min(TRUE)
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|ret
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|ret
argument_list|)
operator|.
name|project
argument_list|(
name|extraExpr
argument_list|)
operator|.
name|aggregate
argument_list|(
name|relBuilder
operator|.
name|groupKey
argument_list|()
argument_list|,
name|relBuilder
operator|.
name|min
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
name|extraName
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|Exists
name|createExistsPlan
parameter_list|(
name|RelNode
name|seekRel
parameter_list|,
name|SubQueryType
name|subQueryType
parameter_list|,
name|Logic
name|logic
parameter_list|,
name|boolean
name|notIn
parameter_list|)
block|{
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|seekRel
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|createExistsPlan
argument_list|(
name|seekRel
argument_list|,
name|subQueryType
argument_list|,
name|logic
argument_list|,
name|notIn
argument_list|,
name|relBuilder
argument_list|)
return|;
block|}
comment|/**    * Creates a plan suitable for use in<code>EXISTS</code> or<code>IN</code>    * statements.    *    * @see org.apache.calcite.sql2rel.SqlToRelConverter    * SqlToRelConverter#convertExists    *    * @param seekRel    A query rel, for example the resulting rel from 'select *    *                   from emp' or 'values (1,2,3)' or '('Foo', 34)'.    * @param subQueryType Sub-query type    * @param logic  Whether to use 2- or 3-valued boolean logic    * @param notIn Whether the operator is NOT IN    * @param relBuilder Builder for relational expressions    *    * @return A pair of a relational expression which outer joins a boolean    * condition column, and a numeric offset. The offset is 2 if column 0 is    * the number of rows and column 1 is the number of rows with not-null keys;    * 0 otherwise.    */
specifier|public
specifier|static
name|Exists
name|createExistsPlan
parameter_list|(
name|RelNode
name|seekRel
parameter_list|,
name|SubQueryType
name|subQueryType
parameter_list|,
name|Logic
name|logic
parameter_list|,
name|boolean
name|notIn
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|)
block|{
switch|switch
condition|(
name|subQueryType
condition|)
block|{
case|case
name|SCALAR
case|:
return|return
operator|new
name|Exists
argument_list|(
name|seekRel
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|logic
condition|)
block|{
case|case
name|TRUE_FALSE_UNKNOWN
case|:
case|case
name|UNKNOWN_AS_TRUE
case|:
if|if
condition|(
name|notIn
operator|&&
operator|!
name|containsNullableFields
argument_list|(
name|seekRel
argument_list|)
condition|)
block|{
name|logic
operator|=
name|Logic
operator|.
name|TRUE_FALSE
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|RelNode
name|ret
init|=
name|seekRel
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|seekRel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|int
name|keyCount
init|=
name|ret
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|outerJoin
init|=
name|notIn
operator|||
name|logic
operator|==
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
decl_stmt|;
if|if
condition|(
operator|!
name|outerJoin
condition|)
block|{
specifier|final
name|LogicalAggregate
name|aggregate
init|=
name|LogicalAggregate
operator|.
name|create
argument_list|(
name|ret
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|keyCount
argument_list|)
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|Exists
argument_list|(
name|aggregate
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// for IN/NOT IN, it needs to output the fields
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|subQueryType
operator|==
name|SubQueryType
operator|.
name|IN
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyCount
condition|;
name|i
operator|++
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|ret
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|projectedKeyCount
init|=
name|exprs
operator|.
name|size
argument_list|()
decl_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|ret
argument_list|)
operator|.
name|project
argument_list|(
name|exprs
argument_list|)
operator|.
name|aggregate
argument_list|(
name|relBuilder
operator|.
name|groupKey
argument_list|(
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|projectedKeyCount
argument_list|)
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|min
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
name|projectedKeyCount
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|logic
condition|)
block|{
case|case
name|TRUE_FALSE_UNKNOWN
case|:
case|case
name|UNKNOWN_AS_TRUE
case|:
return|return
operator|new
name|Exists
argument_list|(
name|ret
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
default|default:
return|return
operator|new
name|Exists
argument_list|(
name|ret
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createRenameRel
parameter_list|(
name|RelDataType
name|outputType
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
name|RelDataType
name|inputType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputFields
init|=
name|inputType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|inputFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|outputFields
init|=
name|outputType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|outputFields
operator|.
name|size
argument_list|()
operator|==
name|n
operator|:
literal|"rename: field count mismatch: in="
operator|+
name|inputType
operator|+
literal|", out"
operator|+
name|outputType
assert|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|renames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|inputFields
argument_list|,
name|outputFields
argument_list|)
control|)
block|{
specifier|final
name|RelDataTypeField
name|inputField
init|=
name|pair
operator|.
name|left
decl_stmt|;
specifier|final
name|RelDataTypeField
name|outputField
init|=
name|pair
operator|.
name|right
decl_stmt|;
assert|assert
name|inputField
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|outputField
operator|.
name|getType
argument_list|()
argument_list|)
assert|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|renames
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|inputField
operator|.
name|getType
argument_list|()
argument_list|,
name|inputField
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|,
name|outputField
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|rel
argument_list|)
operator|.
name|project
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|renames
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|renames
argument_list|)
argument_list|,
literal|true
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createFilter
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
specifier|final
name|RelFactories
operator|.
name|FilterFactory
name|factory
init|=
name|RelFactories
operator|.
name|DEFAULT_FILTER_FACTORY
decl_stmt|;
return|return
name|factory
operator|.
name|createFilter
argument_list|(
name|child
argument_list|,
name|condition
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createFilter
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|RelFactories
operator|.
name|FilterFactory
name|filterFactory
parameter_list|)
block|{
return|return
name|filterFactory
operator|.
name|createFilter
argument_list|(
name|child
argument_list|,
name|condition
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a filter, using the default filter factory,    * or returns the original relational expression if the    * condition is trivial. */
specifier|public
specifier|static
name|RelNode
name|createFilter
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|conditions
parameter_list|)
block|{
return|return
name|createFilter
argument_list|(
name|child
argument_list|,
name|conditions
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_FILTER_FACTORY
argument_list|)
return|;
block|}
comment|/** Creates a filter using the default factory,    * or returns the original relational expression if the    * condition is trivial. */
specifier|public
specifier|static
name|RelNode
name|createFilter
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|conditions
parameter_list|,
name|RelFactories
operator|.
name|FilterFactory
name|filterFactory
parameter_list|)
block|{
specifier|final
name|RelOptCluster
name|cluster
init|=
name|child
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|condition
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|conditions
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
return|return
name|child
return|;
block|}
else|else
block|{
return|return
name|filterFactory
operator|.
name|createFilter
argument_list|(
name|child
argument_list|,
name|condition
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createNullFilter
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Integer
index|[]
name|fieldOrdinals
parameter_list|)
block|{
name|RexNode
name|condition
init|=
literal|null
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|fieldOrdinals
operator|!=
literal|null
condition|)
block|{
name|n
operator|=
name|fieldOrdinals
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|int
name|iField
decl_stmt|;
if|if
condition|(
name|fieldOrdinals
operator|!=
literal|null
condition|)
block|{
name|iField
operator|=
name|fieldOrdinals
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|iField
operator|=
name|i
expr_stmt|;
block|}
name|RelDataType
name|type
init|=
name|fields
operator|.
name|get
argument_list|(
name|iField
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|RexNode
name|newCondition
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|type
argument_list|,
name|iField
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
name|condition
operator|=
name|newCondition
expr_stmt|;
block|}
else|else
block|{
name|condition
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|condition
argument_list|,
name|newCondition
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
comment|// no filtering required
return|return
name|rel
return|;
block|}
specifier|final
name|RelFactories
operator|.
name|FilterFactory
name|factory
init|=
name|RelFactories
operator|.
name|DEFAULT_FILTER_FACTORY
decl_stmt|;
return|return
name|factory
operator|.
name|createFilter
argument_list|(
name|rel
argument_list|,
name|condition
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a projection which casts a rel's output to a desired row type.    *    *<p>No need to create new projection if {@code rel} is already a project,    * instead, create a projection with the input of {@code rel} and the new    * cast expressions.    *    *<p>The desired row type and the row type to be converted must have the    * same number of fields.    *    * @param rel         producer of rows to be converted    * @param castRowType row type after cast    * @param rename      if true, use field names from castRowType; if false,    *                    preserve field names from rel    * @return conversion rel    */
specifier|public
specifier|static
name|RelNode
name|createCastRel
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
name|RelDataType
name|castRowType
parameter_list|,
name|boolean
name|rename
parameter_list|)
block|{
return|return
name|createCastRel
argument_list|(
name|rel
argument_list|,
name|castRowType
argument_list|,
name|rename
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|)
return|;
block|}
comment|/**    * Creates a projection which casts a rel's output to a desired row type.    *    *<p>No need to create new projection if {@code rel} is already a project,    * instead, create a projection with the input of {@code rel} and the new    * cast expressions.    *    *<p>The desired row type and the row type to be converted must have the    * same number of fields.    *    * @param rel         producer of rows to be converted    * @param castRowType row type after cast    * @param rename      if true, use field names from castRowType; if false,    *                    preserve field names from rel    * @param projectFactory Project Factory    * @return conversion rel    */
specifier|public
specifier|static
name|RelNode
name|createCastRel
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
name|RelDataType
name|castRowType
parameter_list|,
name|boolean
name|rename
parameter_list|,
name|RelFactories
operator|.
name|ProjectFactory
name|projectFactory
parameter_list|)
block|{
assert|assert
name|projectFactory
operator|!=
literal|null
assert|;
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|areRowTypesEqual
argument_list|(
name|rowType
argument_list|,
name|castRowType
argument_list|,
name|rename
argument_list|)
condition|)
block|{
comment|// nothing to do
return|return
name|rel
return|;
block|}
if|if
condition|(
name|rowType
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|castRowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Field counts are not equal: "
operator|+
literal|"rowType ["
operator|+
name|rowType
operator|+
literal|"] castRowType ["
operator|+
name|castRowType
operator|+
literal|"]"
argument_list|)
throw|;
block|}
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|castExps
decl_stmt|;
name|RelNode
name|input
decl_stmt|;
name|List
argument_list|<
name|RelHint
argument_list|>
name|hints
init|=
name|ImmutableList
operator|.
name|of
argument_list|()
decl_stmt|;
if|if
condition|(
name|rel
operator|instanceof
name|Project
condition|)
block|{
comment|// No need to create another project node if the rel
comment|// is already a project.
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|rel
decl_stmt|;
name|castExps
operator|=
name|RexUtil
operator|.
name|generateCastExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|castRowType
argument_list|,
operator|(
operator|(
name|Project
operator|)
name|rel
operator|)
operator|.
name|getProjects
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|=
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hints
operator|=
name|project
operator|.
name|getHints
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|castExps
operator|=
name|RexUtil
operator|.
name|generateCastExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|castRowType
argument_list|,
name|rowType
argument_list|)
expr_stmt|;
name|input
operator|=
name|rel
expr_stmt|;
block|}
if|if
condition|(
name|rename
condition|)
block|{
comment|// Use names and types from castRowType.
return|return
name|projectFactory
operator|.
name|createProject
argument_list|(
name|input
argument_list|,
name|hints
argument_list|,
name|castExps
argument_list|,
name|castRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// Use names from rowType, types from castRowType.
return|return
name|projectFactory
operator|.
name|createProject
argument_list|(
name|input
argument_list|,
name|hints
argument_list|,
name|castExps
argument_list|,
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Gets all fields in an aggregate. */
specifier|public
specifier|static
name|Set
argument_list|<
name|Integer
argument_list|>
name|getAllFields
parameter_list|(
name|Aggregate
name|aggregate
parameter_list|)
block|{
return|return
name|getAllFields2
argument_list|(
name|aggregate
operator|.
name|getGroupSet
argument_list|()
argument_list|,
name|aggregate
operator|.
name|getAggCallList
argument_list|()
argument_list|)
return|;
block|}
comment|/** Gets all fields in an aggregate. */
specifier|public
specifier|static
name|Set
argument_list|<
name|Integer
argument_list|>
name|getAllFields2
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCallList
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|allFields
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|allFields
operator|.
name|addAll
argument_list|(
name|groupSet
operator|.
name|asList
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|AggregateCall
name|aggregateCall
range|:
name|aggCallList
control|)
block|{
name|allFields
operator|.
name|addAll
argument_list|(
name|aggregateCall
operator|.
name|getArgList
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|aggregateCall
operator|.
name|filterArg
operator|>=
literal|0
condition|)
block|{
name|allFields
operator|.
name|add
argument_list|(
name|aggregateCall
operator|.
name|filterArg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aggregateCall
operator|.
name|distinctKeys
operator|!=
literal|null
condition|)
block|{
name|allFields
operator|.
name|addAll
argument_list|(
name|aggregateCall
operator|.
name|distinctKeys
operator|.
name|asList
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|allFields
operator|.
name|addAll
argument_list|(
name|RelCollations
operator|.
name|ordinals
argument_list|(
name|aggregateCall
operator|.
name|collation
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|allFields
return|;
block|}
comment|/**    * Creates a LogicalAggregate that removes all duplicates from the result of    * an underlying relational expression.    *    * @param rel underlying rel    * @return rel implementing SingleValueAgg    */
specifier|public
specifier|static
name|RelNode
name|createSingleValueAggRel
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|int
name|aggCallCnt
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggCallCnt
condition|;
name|i
operator|++
control|)
block|{
name|aggCalls
operator|.
name|add
argument_list|(
name|AggregateCall
operator|.
name|create
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SINGLE_VALUE
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|RelCollations
operator|.
name|EMPTY
argument_list|,
literal|0
argument_list|,
name|rel
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|LogicalAggregate
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|()
argument_list|,
literal|null
argument_list|,
name|aggCalls
argument_list|)
return|;
block|}
comment|// CHECKSTYLE: IGNORE 1
comment|/** @deprecated Use {@link RelBuilder#distinct()}. */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createDistinctRel
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|LogicalAggregate
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|boolean
name|analyzeSimpleEquiJoin
parameter_list|(
name|LogicalJoin
name|join
parameter_list|,
name|int
index|[]
name|joinFieldOrdinals
parameter_list|)
block|{
name|RexNode
name|joinExp
init|=
name|join
operator|.
name|getCondition
argument_list|()
decl_stmt|;
if|if
condition|(
name|joinExp
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RexCall
name|binaryExpression
init|=
operator|(
name|RexCall
operator|)
name|joinExp
decl_stmt|;
name|RexNode
name|leftComparand
init|=
name|binaryExpression
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|rightComparand
init|=
name|binaryExpression
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|leftComparand
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|rightComparand
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|leftFieldCount
init|=
name|join
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|RexInputRef
name|leftFieldAccess
init|=
operator|(
name|RexInputRef
operator|)
name|leftComparand
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|leftFieldAccess
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|)
condition|)
block|{
comment|// left field must access left side of join
return|return
literal|false
return|;
block|}
name|RexInputRef
name|rightFieldAccess
init|=
operator|(
name|RexInputRef
operator|)
name|rightComparand
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rightFieldAccess
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
operator|)
condition|)
block|{
comment|// right field must access right side of join
return|return
literal|false
return|;
block|}
name|joinFieldOrdinals
index|[
literal|0
index|]
operator|=
name|leftFieldAccess
operator|.
name|getIndex
argument_list|()
expr_stmt|;
name|joinFieldOrdinals
index|[
literal|1
index|]
operator|=
name|rightFieldAccess
operator|.
name|getIndex
argument_list|()
operator|-
name|leftFieldCount
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Splits out the equi-join components of a join condition, and returns    * what's left. For example, given the condition    *    *<blockquote><code>L.A = R.X AND L.B = L.C AND (L.D = 5 OR L.E =    * R.Y)</code></blockquote>    *    *<p>returns    *    *<ul>    *<li>leftKeys = {A}    *<li>rightKeys = {X}    *<li>rest = L.B = L.C AND (L.D = 5 OR L.E = R.Y)</li>    *</ul>    *    * @param left      left input to join    * @param right     right input to join    * @param condition join condition    * @param leftKeys  The ordinals of the fields from the left input which are    *                  equi-join keys    * @param rightKeys The ordinals of the fields from the right input which    *                  are equi-join keys    * @param filterNulls List of boolean values for each join key position    *                    indicating whether the operator filters out nulls or not.    *                    Value is true if the operator is EQUALS and false if the    *                    operator is IS NOT DISTINCT FROM (or an expanded version).    *                    If<code>filterNulls</code> is null, only join conditions    *                    with EQUALS operators are considered equi-join components.    *                    Rest (including IS NOT DISTINCT FROM) are returned in    *                    remaining join condition.    *    * @return remaining join filters that are not equijoins; may return a    * {@link RexLiteral} true, but never null    */
specifier|public
specifier|static
name|RexNode
name|splitJoinCondition
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|RelNode
name|right
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|Boolean
argument_list|>
name|filterNulls
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|splitJoinCondition
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|condition
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|filterNulls
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|left
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|)
return|;
block|}
comment|/** As    * {@link #splitJoinCondition(RelNode, RelNode, RexNode, List, List, List)},    * but writes non-equi conditions to a conjunctive list. */
specifier|public
specifier|static
name|void
name|splitJoinCondition
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|RelNode
name|right
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|Boolean
argument_list|>
name|filterNulls
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|)
block|{
name|splitJoinCondition
argument_list|(
name|left
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|condition
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|filterNulls
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|boolean
name|isEqui
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|RelNode
name|right
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Boolean
argument_list|>
name|filterNulls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|splitJoinCondition
argument_list|(
name|left
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|condition
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|filterNulls
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
return|return
name|nonEquiList
operator|.
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/**    * Splits out the equi-join (and optionally, a single non-equi) components    * of a join condition, and returns what's left. Projection might be    * required by the caller to provide join keys that are not direct field    * references.    *    * @param sysFieldList  list of system fields    * @param leftRel       left join input    * @param rightRel      right join input    * @param condition     join condition    * @param leftJoinKeys  The join keys from the left input which are equi-join    *                      keys    * @param rightJoinKeys The join keys from the right input which are    *                      equi-join keys    * @param filterNulls   The join key positions for which null values will not    *                      match. null values only match for the "is not distinct    *                      from" condition.    * @param rangeOp       if null, only locate equi-joins; otherwise, locate a    *                      single non-equi join predicate and return its operator    *                      in this list; join keys associated with the non-equi    *                      join predicate are at the end of the key lists    *                      returned    * @return What's left, never null    */
specifier|public
specifier|static
name|RexNode
name|splitJoinCondition
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sysFieldList
parameter_list|,
name|RelNode
name|leftRel
parameter_list|,
name|RelNode
name|rightRel
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|Integer
argument_list|>
name|filterNulls
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|rangeOp
parameter_list|)
block|{
return|return
name|splitJoinCondition
argument_list|(
name|sysFieldList
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|leftRel
argument_list|,
name|rightRel
argument_list|)
argument_list|,
name|condition
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|leftJoinKeys
argument_list|,
name|rightJoinKeys
argument_list|)
argument_list|,
name|filterNulls
argument_list|,
name|rangeOp
argument_list|)
return|;
block|}
comment|/**    * Splits out the equi-join (and optionally, a single non-equi) components    * of a join condition, and returns what's left. Projection might be    * required by the caller to provide join keys that are not direct field    * references.    *    * @param sysFieldList  list of system fields    * @param inputs        join inputs    * @param condition     join condition    * @param joinKeys      The join keys from the inputs which are equi-join    *                      keys    * @param filterNulls   The join key positions for which null values will not    *                      match. null values only match for the "is not distinct    *                      from" condition.    * @param rangeOp       if null, only locate equi-joins; otherwise, locate a    *                      single non-equi join predicate and return its operator    *                      in this list; join keys associated with the non-equi    *                      join predicate are at the end of the key lists    *                      returned    * @return What's left, never null    */
specifier|public
specifier|static
name|RexNode
name|splitJoinCondition
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sysFieldList
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|joinKeys
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|Integer
argument_list|>
name|filterNulls
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|rangeOp
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|splitJoinCondition
argument_list|(
name|sysFieldList
argument_list|,
name|inputs
argument_list|,
name|condition
argument_list|,
name|joinKeys
argument_list|,
name|filterNulls
argument_list|,
name|rangeOp
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
comment|// Convert the remainders into a list that are AND'ed together.
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
annotation|@
name|Nullable
name|RexNode
name|splitCorrelatedFilterCondition
parameter_list|(
name|LogicalFilter
name|filter
parameter_list|,
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|splitCorrelatedFilterCondition
argument_list|(
name|filter
argument_list|,
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
comment|// Convert the remainders into a list that are AND'ed together.
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|filter
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
specifier|static
annotation|@
name|Nullable
name|RexNode
name|splitCorrelatedFilterCondition
parameter_list|(
name|LogicalFilter
name|filter
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|boolean
name|extractCorrelatedFieldAccess
parameter_list|)
block|{
return|return
name|splitCorrelatedFilterCondition
argument_list|(
operator|(
name|Filter
operator|)
name|filter
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|extractCorrelatedFieldAccess
argument_list|)
return|;
block|}
specifier|public
specifier|static
annotation|@
name|Nullable
name|RexNode
name|splitCorrelatedFilterCondition
parameter_list|(
name|Filter
name|filter
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|boolean
name|extractCorrelatedFieldAccess
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|splitCorrelatedFilterCondition
argument_list|(
name|filter
argument_list|,
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|,
name|extractCorrelatedFieldAccess
argument_list|)
expr_stmt|;
comment|// Convert the remainders into a list that are AND'ed together.
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|filter
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|splitJoinCondition
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sysFieldList
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|joinKeys
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|Integer
argument_list|>
name|filterNulls
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|rangeOp
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|)
block|{
specifier|final
name|int
name|sysFieldCount
init|=
name|sysFieldList
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableBitSet
index|[]
name|inputsRange
init|=
operator|new
name|ImmutableBitSet
index|[
name|inputs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|totalFieldCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|firstField
init|=
name|totalFieldCount
operator|+
name|sysFieldCount
decl_stmt|;
name|totalFieldCount
operator|=
name|firstField
operator|+
name|inputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
name|inputsRange
index|[
name|i
index|]
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|firstField
argument_list|,
name|totalFieldCount
argument_list|)
expr_stmt|;
block|}
comment|// adjustment array
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|totalFieldCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|adjustment
init|=
name|inputsRange
index|[
name|i
index|]
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|adjustment
init|;
name|j
operator|<
name|inputsRange
index|[
name|i
index|]
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|adjustments
index|[
name|j
index|]
operator|=
operator|-
name|adjustment
expr_stmt|;
block|}
block|}
if|if
condition|(
name|condition
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|condition
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitJoinCondition
argument_list|(
name|sysFieldList
argument_list|,
name|inputs
argument_list|,
name|operand
argument_list|,
name|joinKeys
argument_list|,
name|filterNulls
argument_list|,
name|rangeOp
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexNode
name|leftKey
init|=
literal|null
decl_stmt|;
name|RexNode
name|rightKey
init|=
literal|null
decl_stmt|;
name|int
name|leftInput
init|=
literal|0
decl_stmt|;
name|int
name|rightInput
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftFields
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightFields
init|=
literal|null
decl_stmt|;
name|boolean
name|reverse
init|=
literal|false
decl_stmt|;
specifier|final
name|RexCall
name|call
init|=
name|collapseExpandedIsNotDistinctFromExpr
argument_list|(
operator|(
name|RexCall
operator|)
name|condition
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|SqlKind
name|kind
init|=
name|call
operator|.
name|getKind
argument_list|()
decl_stmt|;
comment|// Only consider range operators if we haven't already seen one
if|if
condition|(
operator|(
name|kind
operator|==
name|SqlKind
operator|.
name|EQUALS
operator|)
operator|||
operator|(
name|filterNulls
operator|!=
literal|null
operator|&&
name|kind
operator|==
name|SqlKind
operator|.
name|IS_NOT_DISTINCT_FROM
operator|)
operator|||
operator|(
name|rangeOp
operator|!=
literal|null
operator|&&
name|rangeOp
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|kind
operator|==
name|SqlKind
operator|.
name|GREATER_THAN
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|GREATER_THAN_OR_EQUAL
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|LESS_THAN
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|LESS_THAN_OR_EQUAL
operator|)
operator|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|op0
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|op1
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|projRefs0
init|=
name|InputFinder
operator|.
name|bits
argument_list|(
name|op0
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|projRefs1
init|=
name|InputFinder
operator|.
name|bits
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|boolean
name|foundBothInputs
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|foundBothInputs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|projRefs0
operator|.
name|intersects
argument_list|(
name|inputsRange
index|[
name|i
index|]
argument_list|)
operator|&&
name|projRefs0
operator|.
name|union
argument_list|(
name|inputsRange
index|[
name|i
index|]
argument_list|)
operator|.
name|equals
argument_list|(
name|inputsRange
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|leftKey
operator|==
literal|null
condition|)
block|{
name|leftKey
operator|=
name|op0
expr_stmt|;
name|leftInput
operator|=
name|i
expr_stmt|;
name|leftFields
operator|=
name|inputs
operator|.
name|get
argument_list|(
name|leftInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rightKey
operator|=
name|op0
expr_stmt|;
name|rightInput
operator|=
name|i
expr_stmt|;
name|rightFields
operator|=
name|inputs
operator|.
name|get
argument_list|(
name|rightInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
expr_stmt|;
name|reverse
operator|=
literal|true
expr_stmt|;
name|foundBothInputs
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|projRefs1
operator|.
name|intersects
argument_list|(
name|inputsRange
index|[
name|i
index|]
argument_list|)
operator|&&
name|projRefs1
operator|.
name|union
argument_list|(
name|inputsRange
index|[
name|i
index|]
argument_list|)
operator|.
name|equals
argument_list|(
name|inputsRange
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|leftKey
operator|==
literal|null
condition|)
block|{
name|leftKey
operator|=
name|op1
expr_stmt|;
name|leftInput
operator|=
name|i
expr_stmt|;
name|leftFields
operator|=
name|inputs
operator|.
name|get
argument_list|(
name|leftInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rightKey
operator|=
name|op1
expr_stmt|;
name|rightInput
operator|=
name|i
expr_stmt|;
name|rightFields
operator|=
name|inputs
operator|.
name|get
argument_list|(
name|rightInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
expr_stmt|;
name|foundBothInputs
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|leftKey
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|rightKey
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// replace right Key input ref
name|rightKey
operator|=
name|rightKey
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|rightFields
argument_list|,
name|rightFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
comment|// left key only needs to be adjusted if there are system
comment|// fields, but do it for uniformity
name|leftKey
operator|=
name|leftKey
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|leftFields
argument_list|,
name|leftFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
name|RelDataType
name|leftKeyType
init|=
name|leftKey
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|rightKeyType
init|=
name|rightKey
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftKeyType
operator|!=
name|rightKeyType
condition|)
block|{
comment|// perform casting
name|RelDataType
name|targetKeyType
init|=
name|typeFactory
operator|.
name|leastRestrictive
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|leftKeyType
argument_list|,
name|rightKeyType
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetKeyType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Cannot find common type for join keys "
operator|+
name|leftKey
operator|+
literal|" (type "
operator|+
name|leftKeyType
operator|+
literal|") and "
operator|+
name|rightKey
operator|+
literal|" (type "
operator|+
name|rightKeyType
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|leftKeyType
operator|!=
name|targetKeyType
condition|)
block|{
name|leftKey
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|targetKeyType
argument_list|,
name|leftKey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rightKeyType
operator|!=
name|targetKeyType
condition|)
block|{
name|rightKey
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|targetKeyType
argument_list|,
name|rightKey
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|rangeOp
operator|==
literal|null
operator|)
operator|&&
operator|(
operator|(
name|leftKey
operator|==
literal|null
operator|)
operator|||
operator|(
name|rightKey
operator|==
literal|null
operator|)
operator|)
condition|)
block|{
comment|// no equality join keys found yet:
comment|// try transforming the condition to
comment|// equality "join" conditions, e.g.
comment|//     f(LHS)> 0 ===> ( f(LHS)> 0 ) = TRUE,
comment|// and make the RHS produce TRUE, but only if we're strictly
comment|// looking for equi-joins
specifier|final
name|ImmutableBitSet
name|projRefs
init|=
name|InputFinder
operator|.
name|bits
argument_list|(
name|condition
argument_list|)
decl_stmt|;
name|leftKey
operator|=
literal|null
expr_stmt|;
name|rightKey
operator|=
literal|null
expr_stmt|;
name|boolean
name|foundInput
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|foundInput
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inputsRange
index|[
name|i
index|]
operator|.
name|contains
argument_list|(
name|projRefs
argument_list|)
condition|)
block|{
name|leftInput
operator|=
name|i
expr_stmt|;
name|leftFields
operator|=
name|inputs
operator|.
name|get
argument_list|(
name|leftInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
expr_stmt|;
name|leftKey
operator|=
name|condition
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|leftFields
argument_list|,
name|leftFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
name|rightKey
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// effectively performing an equality comparison
name|kind
operator|=
name|SqlKind
operator|.
name|EQUALS
expr_stmt|;
name|foundInput
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|leftKey
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|rightKey
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// found suitable join keys
comment|// add them to key list, ensuring that if there is a
comment|// non-equi join predicate, it appears at the end of the
comment|// key list; also mark the null filtering property
name|addJoinKey
argument_list|(
name|joinKeys
operator|.
name|get
argument_list|(
name|leftInput
argument_list|)
argument_list|,
name|leftKey
argument_list|,
operator|(
name|rangeOp
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|rangeOp
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|addJoinKey
argument_list|(
name|joinKeys
operator|.
name|get
argument_list|(
name|rightInput
argument_list|)
argument_list|,
name|rightKey
argument_list|,
operator|(
name|rangeOp
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|rangeOp
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|filterNulls
operator|!=
literal|null
operator|&&
name|kind
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
comment|// nulls are considered not matching for equality comparison
comment|// add the position of the most recently inserted key
name|filterNulls
operator|.
name|add
argument_list|(
name|joinKeys
operator|.
name|get
argument_list|(
name|leftInput
argument_list|)
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rangeOp
operator|!=
literal|null
operator|&&
name|kind
operator|!=
name|SqlKind
operator|.
name|EQUALS
operator|&&
name|kind
operator|!=
name|SqlKind
operator|.
name|IS_DISTINCT_FROM
condition|)
block|{
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|reverse
condition|)
block|{
name|op
operator|=
name|requireNonNull
argument_list|(
name|op
operator|.
name|reverse
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|rangeOp
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// else fall through and add this condition as nonEqui condition
block|}
comment|// The operator is not of RexCall type
comment|// So we fail. Fall through.
comment|// Add this condition to the list of non-equi-join conditions.
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
comment|/** Builds an equi-join condition from a set of left and right keys. */
specifier|public
specifier|static
name|RexNode
name|createEquiJoinCondition
parameter_list|(
specifier|final
name|RelNode
name|left
parameter_list|,
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
specifier|final
name|RelNode
name|right
parameter_list|,
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|leftTypes
init|=
name|RelOptUtil
operator|.
name|getFieldTypeList
argument_list|(
name|left
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|rightTypes
init|=
name|RelOptUtil
operator|.
name|getFieldTypeList
argument_list|(
name|right
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
operator|new
name|AbstractList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
specifier|final
name|int
name|leftKey
init|=
name|leftKeys
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|final
name|int
name|rightKey
init|=
name|rightKeys
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|leftTypes
operator|.
name|get
argument_list|(
name|leftKey
argument_list|)
argument_list|,
name|leftKey
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|rightTypes
operator|.
name|get
argument_list|(
name|rightKey
argument_list|)
argument_list|,
name|leftTypes
operator|.
name|size
argument_list|()
operator|+
name|rightKey
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|leftKeys
operator|.
name|size
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Returns {@link SqlOperator} for given {@link SqlKind} or returns {@code operator}    * when {@link SqlKind} is not known.    * @param kind input kind    * @param operator default operator value    * @return SqlOperator for the given kind    * @see RexUtil#op(SqlKind)    */
specifier|public
specifier|static
name|SqlOperator
name|op
parameter_list|(
name|SqlKind
name|kind
parameter_list|,
name|SqlOperator
name|operator
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|EQUALS
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|EQUALS
return|;
case|case
name|NOT_EQUALS
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
return|;
case|case
name|GREATER_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
return|;
case|case
name|LESS_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
return|;
case|case
name|IS_DISTINCT_FROM
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_DISTINCT_FROM
return|;
case|case
name|IS_NOT_DISTINCT_FROM
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
return|;
default|default:
return|return
name|operator
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|addJoinKey
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeyList
parameter_list|,
name|RexNode
name|key
parameter_list|,
name|boolean
name|preserveLastElementInList
parameter_list|)
block|{
if|if
condition|(
operator|!
name|joinKeyList
operator|.
name|isEmpty
argument_list|()
operator|&&
name|preserveLastElementInList
condition|)
block|{
name|joinKeyList
operator|.
name|add
argument_list|(
name|joinKeyList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|joinKeyList
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|splitCorrelatedFilterCondition
parameter_list|(
name|LogicalFilter
name|filter
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitCorrelatedFilterCondition
argument_list|(
name|filter
argument_list|,
name|operand
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|op0
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|op1
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op0
argument_list|)
operator|&&
name|op1
operator|instanceof
name|RexInputRef
condition|)
block|{
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|joinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexInputRef
operator|)
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
if|else if
condition|(
name|op0
operator|instanceof
name|RexInputRef
operator|&&
operator|!
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|joinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexInputRef
operator|)
name|op0
argument_list|)
expr_stmt|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// The operator is not of RexCall type
comment|// So we fail. Fall through.
comment|// Add this condition to the list of non-equi-join conditions.
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
specifier|static
name|void
name|splitCorrelatedFilterCondition
parameter_list|(
name|LogicalFilter
name|filter
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|,
name|boolean
name|extractCorrelatedFieldAccess
parameter_list|)
block|{
name|splitCorrelatedFilterCondition
argument_list|(
operator|(
name|Filter
operator|)
name|filter
argument_list|,
name|condition
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|,
name|extractCorrelatedFieldAccess
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|splitCorrelatedFilterCondition
parameter_list|(
name|Filter
name|filter
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|,
name|boolean
name|extractCorrelatedFieldAccess
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitCorrelatedFilterCondition
argument_list|(
name|filter
argument_list|,
name|operand
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|,
name|extractCorrelatedFieldAccess
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|op0
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|op1
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|extractCorrelatedFieldAccess
condition|)
block|{
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|containsFieldAccess
argument_list|(
name|op0
argument_list|)
operator|&&
name|op1
operator|instanceof
name|RexFieldAccess
condition|)
block|{
name|joinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
if|else if
condition|(
name|op0
operator|instanceof
name|RexFieldAccess
operator|&&
operator|!
name|RexUtil
operator|.
name|containsFieldAccess
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|joinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op0
argument_list|)
operator|&&
name|op1
operator|instanceof
name|RexInputRef
condition|)
block|{
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|joinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
if|else if
condition|(
name|op0
operator|instanceof
name|RexInputRef
operator|&&
operator|!
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|joinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|// The operator is not of RexCall type
comment|// So we fail. Fall through.
comment|// Add this condition to the list of non-equi-join conditions.
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|splitJoinCondition
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|int
name|leftFieldCount
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|Boolean
argument_list|>
name|filterNulls
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
name|SqlKind
name|kind
init|=
name|call
operator|.
name|getKind
argument_list|()
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|SqlKind
operator|.
name|AND
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitJoinCondition
argument_list|(
name|rexBuilder
argument_list|,
name|leftFieldCount
argument_list|,
name|operand
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|filterNulls
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|filterNulls
operator|!=
literal|null
condition|)
block|{
name|call
operator|=
name|collapseExpandedIsNotDistinctFromExpr
argument_list|(
name|call
argument_list|,
name|rexBuilder
argument_list|)
expr_stmt|;
name|kind
operator|=
name|call
operator|.
name|getKind
argument_list|()
expr_stmt|;
block|}
comment|// "=" and "IS NOT DISTINCT FROM" are the same except for how they
comment|// treat nulls.
if|if
condition|(
name|kind
operator|==
name|SqlKind
operator|.
name|EQUALS
operator|||
operator|(
name|filterNulls
operator|!=
literal|null
operator|&&
name|kind
operator|==
name|SqlKind
operator|.
name|IS_NOT_DISTINCT_FROM
operator|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
operator|&&
operator|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|RexInputRef
name|op0
init|=
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexInputRef
name|op1
init|=
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|RexInputRef
name|leftField
decl_stmt|;
name|RexInputRef
name|rightField
decl_stmt|;
if|if
condition|(
operator|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|)
operator|&&
operator|(
name|op1
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
operator|)
condition|)
block|{
comment|// Arguments were of form 'op0 = op1'
name|leftField
operator|=
name|op0
expr_stmt|;
name|rightField
operator|=
name|op1
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|op1
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|)
operator|&&
operator|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
operator|)
condition|)
block|{
comment|// Arguments were of form 'op1 = op0'
name|leftField
operator|=
name|op1
expr_stmt|;
name|rightField
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
return|return;
block|}
name|leftKeys
operator|.
name|add
argument_list|(
name|leftField
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|rightKeys
operator|.
name|add
argument_list|(
name|rightField
operator|.
name|getIndex
argument_list|()
operator|-
name|leftFieldCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|filterNulls
operator|!=
literal|null
condition|)
block|{
name|filterNulls
operator|.
name|add
argument_list|(
name|kind
operator|==
name|SqlKind
operator|.
name|EQUALS
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Arguments were not field references, one from each side, so
comment|// we fail. Fall through.
block|}
block|}
comment|// Add this condition to the list of non-equi-join conditions.
if|if
condition|(
operator|!
name|condition
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Collapses an expanded version of {@code IS NOT DISTINCT FROM} expression.    *    *<p>Helper method for    * {@link #splitJoinCondition(RexBuilder, int, RexNode, List, List, List, List)}    * and    * {@link #splitJoinCondition(List, List, RexNode, List, List, List, List)}.    *    *<p>If the given expr<code>call</code> is an expanded version of    * {@code IS NOT DISTINCT FROM} function call, collapses it and return a    * {@code IS NOT DISTINCT FROM} function call.    *    *<p>For example: {@code t1.key IS NOT DISTINCT FROM t2.key}    * can rewritten in expanded form as    * {@code t1.key = t2.key OR (t1.key IS NULL AND t2.key IS NULL)}.    *    * @param call       Function expression to try collapsing    * @param rexBuilder {@link RexBuilder} instance to create new {@link RexCall} instances.    * @return If the given function is an expanded IS NOT DISTINCT FROM function call,    *         return a IS NOT DISTINCT FROM function call. Otherwise return the input    *         function call as it is.    */
specifier|public
specifier|static
name|RexCall
name|collapseExpandedIsNotDistinctFromExpr
parameter_list|(
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|OR
case|:
return|return
name|doCollapseExpandedIsNotDistinctFromOrExpr
argument_list|(
name|call
argument_list|,
name|rexBuilder
argument_list|)
return|;
case|case
name|CASE
case|:
return|return
name|doCollapseExpandedIsNotDistinctFromCaseExpr
argument_list|(
name|call
argument_list|,
name|rexBuilder
argument_list|)
return|;
default|default:
return|return
name|call
return|;
block|}
block|}
specifier|private
specifier|static
name|RexCall
name|doCollapseExpandedIsNotDistinctFromOrExpr
parameter_list|(
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|OR
operator|||
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|2
condition|)
block|{
return|return
name|call
return|;
block|}
specifier|final
name|RexNode
name|op0
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op1
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|op0
operator|instanceof
name|RexCall
operator|)
operator|||
operator|!
operator|(
name|op1
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
return|return
name|call
return|;
block|}
name|RexCall
name|opEqCall
init|=
operator|(
name|RexCall
operator|)
name|op0
decl_stmt|;
name|RexCall
name|opNullEqCall
init|=
operator|(
name|RexCall
operator|)
name|op1
decl_stmt|;
comment|// Swapping the operands if necessary
if|if
condition|(
name|opEqCall
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
operator|&&
operator|(
name|opNullEqCall
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|EQUALS
operator|||
name|opNullEqCall
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|IS_TRUE
operator|)
condition|)
block|{
name|RexCall
name|temp
init|=
name|opEqCall
decl_stmt|;
name|opEqCall
operator|=
name|opNullEqCall
expr_stmt|;
name|opNullEqCall
operator|=
name|temp
expr_stmt|;
block|}
comment|// Check if EQUALS is actually wrapped in IS TRUE expression
if|if
condition|(
name|opEqCall
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|IS_TRUE
condition|)
block|{
name|RexNode
name|tmp
init|=
name|opEqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
return|return
name|call
return|;
block|}
name|opEqCall
operator|=
operator|(
name|RexCall
operator|)
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|opNullEqCall
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|AND
operator|||
name|opNullEqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|2
operator|||
name|opEqCall
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
return|return
name|call
return|;
block|}
specifier|final
name|RexNode
name|op10
init|=
name|opNullEqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op11
init|=
name|opNullEqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|op10
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|IS_NULL
operator|||
name|op11
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|IS_NULL
condition|)
block|{
return|return
name|call
return|;
block|}
return|return
name|doCollapseExpandedIsNotDistinctFrom
argument_list|(
name|rexBuilder
argument_list|,
name|call
argument_list|,
operator|(
name|RexCall
operator|)
name|op10
argument_list|,
operator|(
name|RexCall
operator|)
name|op11
argument_list|,
name|opEqCall
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexCall
name|doCollapseExpandedIsNotDistinctFromCaseExpr
parameter_list|(
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|CASE
operator|||
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|5
condition|)
block|{
return|return
name|call
return|;
block|}
specifier|final
name|RexNode
name|op0
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op1
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op2
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op3
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op4
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|op0
operator|instanceof
name|RexCall
operator|)
operator|||
operator|!
operator|(
name|op1
operator|instanceof
name|RexCall
operator|)
operator|||
operator|!
operator|(
name|op2
operator|instanceof
name|RexCall
operator|)
operator|||
operator|!
operator|(
name|op3
operator|instanceof
name|RexCall
operator|)
operator|||
operator|!
operator|(
name|op4
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
return|return
name|call
return|;
block|}
name|RexCall
name|ifCall
init|=
operator|(
name|RexCall
operator|)
name|op0
decl_stmt|;
name|RexCall
name|thenCall
init|=
operator|(
name|RexCall
operator|)
name|op1
decl_stmt|;
name|RexCall
name|elseIfCall
init|=
operator|(
name|RexCall
operator|)
name|op2
decl_stmt|;
name|RexCall
name|elseIfThenCall
init|=
operator|(
name|RexCall
operator|)
name|op3
decl_stmt|;
name|RexCall
name|elseCall
init|=
operator|(
name|RexCall
operator|)
name|op4
decl_stmt|;
if|if
condition|(
name|ifCall
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|IS_NULL
operator|||
name|thenCall
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|IS_NULL
operator|||
name|elseIfCall
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|IS_NULL
operator|||
name|elseIfThenCall
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|IS_NULL
operator|||
name|elseCall
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
return|return
name|call
return|;
block|}
if|if
condition|(
operator|!
name|ifCall
operator|.
name|equals
argument_list|(
name|elseIfThenCall
argument_list|)
operator|||
operator|!
name|thenCall
operator|.
name|equals
argument_list|(
name|elseIfCall
argument_list|)
condition|)
block|{
return|return
name|call
return|;
block|}
return|return
name|doCollapseExpandedIsNotDistinctFrom
argument_list|(
name|rexBuilder
argument_list|,
name|call
argument_list|,
name|ifCall
argument_list|,
name|elseIfCall
argument_list|,
name|elseCall
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexCall
name|doCollapseExpandedIsNotDistinctFrom
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
name|RexCall
name|ifNull0Call
parameter_list|,
name|RexCall
name|ifNull1Call
parameter_list|,
name|RexCall
name|equalsCall
parameter_list|)
block|{
specifier|final
name|RexNode
name|isNullInput0
init|=
name|ifNull0Call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|isNullInput1
init|=
name|ifNull1Call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|equalsInput0
init|=
name|RexUtil
operator|.
name|removeNullabilityCast
argument_list|(
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|equalsCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|equalsInput1
init|=
name|RexUtil
operator|.
name|removeNullabilityCast
argument_list|(
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|equalsCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|isNullInput0
operator|.
name|equals
argument_list|(
name|equalsInput0
argument_list|)
operator|&&
name|isNullInput1
operator|.
name|equals
argument_list|(
name|equalsInput1
argument_list|)
operator|)
operator|||
operator|(
name|isNullInput1
operator|.
name|equals
argument_list|(
name|equalsInput0
argument_list|)
operator|&&
name|isNullInput0
operator|.
name|equals
argument_list|(
name|equalsInput1
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|RexCall
operator|)
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|isNullInput0
argument_list|,
name|isNullInput1
argument_list|)
argument_list|)
return|;
block|}
return|return
name|call
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|void
name|projectJoinInputs
parameter_list|(
name|RelNode
index|[]
name|inputRels
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
parameter_list|,
name|int
name|systemColCount
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|outputProj
parameter_list|)
block|{
name|RelNode
name|leftRel
init|=
name|inputRels
index|[
literal|0
index|]
decl_stmt|;
name|RelNode
name|rightRel
init|=
name|inputRels
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|leftRel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|int
name|origLeftInputSize
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|origRightInputSize
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newLeftFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
annotation|@
name|Nullable
name|String
argument_list|>
name|newLeftFieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newRightFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
annotation|@
name|Nullable
name|String
argument_list|>
name|newRightFieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|leftKeyCount
init|=
name|leftJoinKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|rightKeyCount
init|=
name|rightJoinKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|systemColCount
condition|;
name|i
operator|++
control|)
block|{
name|outputProj
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origLeftInputSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newLeftFields
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|newLeftFieldNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|outputProj
operator|.
name|add
argument_list|(
name|systemColCount
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|newLeftKeyCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leftKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|leftKey
init|=
name|leftJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftKey
operator|instanceof
name|RexInputRef
condition|)
block|{
comment|// already added to the projected left fields
comment|// only need to remember the index in the join key list
name|leftKeys
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|leftKey
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newLeftFields
operator|.
name|add
argument_list|(
name|leftKey
argument_list|)
expr_stmt|;
name|newLeftFieldNames
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|leftKeys
operator|.
name|add
argument_list|(
name|origLeftInputSize
operator|+
name|newLeftKeyCount
argument_list|)
expr_stmt|;
name|newLeftKeyCount
operator|++
expr_stmt|;
block|}
block|}
name|int
name|leftFieldCount
init|=
name|origLeftInputSize
operator|+
name|newLeftKeyCount
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origRightInputSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newRightFields
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|newRightFieldNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|outputProj
operator|.
name|add
argument_list|(
name|systemColCount
operator|+
name|leftFieldCount
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|newRightKeyCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rightKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|rightKey
init|=
name|rightJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightKey
operator|instanceof
name|RexInputRef
condition|)
block|{
comment|// already added to the projected left fields
comment|// only need to remember the index in the join key list
name|rightKeys
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|rightKey
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newRightFields
operator|.
name|add
argument_list|(
name|rightKey
argument_list|)
expr_stmt|;
name|newRightFieldNames
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|rightKeys
operator|.
name|add
argument_list|(
name|origRightInputSize
operator|+
name|newRightKeyCount
argument_list|)
expr_stmt|;
name|newRightKeyCount
operator|++
expr_stmt|;
block|}
block|}
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// added project if need to produce new keys than the original input
comment|// fields
if|if
condition|(
name|newLeftKeyCount
operator|>
literal|0
condition|)
block|{
name|leftRel
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|leftRel
argument_list|)
operator|.
name|project
argument_list|(
name|newLeftFields
argument_list|,
name|newLeftFieldNames
argument_list|,
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|newRightKeyCount
operator|>
literal|0
condition|)
block|{
name|rightRel
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|rightRel
argument_list|)
operator|.
name|project
argument_list|(
name|newRightFields
argument_list|,
name|newRightFieldNames
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|inputRels
index|[
literal|0
index|]
operator|=
name|leftRel
expr_stmt|;
name|inputRels
index|[
literal|1
index|]
operator|=
name|rightRel
expr_stmt|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createProjectJoinRel
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|outputProj
parameter_list|,
name|RelNode
name|joinRel
parameter_list|)
block|{
name|int
name|newProjectOutputSize
init|=
name|outputProj
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|joinOutputFields
init|=
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
comment|// If no projection was passed in, or the number of desired projection
comment|// columns is the same as the number of columns returned from the
comment|// join, then no need to create a projection
if|if
condition|(
operator|(
name|newProjectOutputSize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|newProjectOutputSize
operator|<
name|joinOutputFields
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|newProjects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|joinRel
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|fieldIndex
range|:
name|outputProj
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|joinOutputFields
operator|.
name|get
argument_list|(
name|fieldIndex
argument_list|)
decl_stmt|;
name|newProjects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|fieldIndex
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Create a project rel on the output of the join.
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|joinRel
argument_list|)
operator|.
name|project
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|newProjects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|newProjects
argument_list|)
argument_list|,
literal|true
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
return|return
name|joinRel
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|void
name|registerAbstractRels
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|registerAbstractRules
argument_list|(
name|planner
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Experimental
specifier|public
specifier|static
name|void
name|registerAbstractRules
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|RelOptRules
operator|.
name|ABSTRACT_RULES
operator|.
name|forEach
argument_list|(
name|planner
operator|::
name|addRule
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Experimental
specifier|public
specifier|static
name|void
name|registerAbstractRelationalRules
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|RelOptRules
operator|.
name|ABSTRACT_RELATIONAL_RULES
operator|.
name|forEach
argument_list|(
name|planner
operator|::
name|addRule
argument_list|)
expr_stmt|;
if|if
condition|(
name|CalciteSystemProperty
operator|.
name|COMMUTE
operator|.
name|value
argument_list|()
condition|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_ASSOCIATE
argument_list|)
expr_stmt|;
block|}
comment|// todo: rule which makes Project({OrdinalRef}) disappear
block|}
specifier|private
specifier|static
name|void
name|registerEnumerableRules
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|EnumerableRules
operator|.
name|ENUMERABLE_RULES
operator|.
name|forEach
argument_list|(
name|planner
operator|::
name|addRule
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|registerBaseRules
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|RelOptRules
operator|.
name|BASE_RULES
operator|.
name|forEach
argument_list|(
name|planner
operator|::
name|addRule
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
specifier|static
name|void
name|registerReductionRules
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|RelOptRules
operator|.
name|CONSTANT_REDUCTION_RULES
operator|.
name|forEach
argument_list|(
name|planner
operator|::
name|addRule
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|registerMaterializationRules
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|RelOptRules
operator|.
name|MATERIALIZATION_RULES
operator|.
name|forEach
argument_list|(
name|planner
operator|::
name|addRule
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
specifier|static
name|void
name|registerCalcRules
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|RelOptRules
operator|.
name|CALC_RULES
operator|.
name|forEach
argument_list|(
name|planner
operator|::
name|addRule
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Experimental
specifier|public
specifier|static
name|void
name|registerDefaultRules
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|,
name|boolean
name|enableMaterializations
parameter_list|,
name|boolean
name|enableBindable
parameter_list|)
block|{
if|if
condition|(
name|CalciteSystemProperty
operator|.
name|ENABLE_COLLATION_TRAIT
operator|.
name|value
argument_list|()
condition|)
block|{
name|registerAbstractRelationalRules
argument_list|(
name|planner
argument_list|)
expr_stmt|;
block|}
name|registerAbstractRules
argument_list|(
name|planner
argument_list|)
expr_stmt|;
name|registerBaseRules
argument_list|(
name|planner
argument_list|)
expr_stmt|;
if|if
condition|(
name|enableMaterializations
condition|)
block|{
name|registerMaterializationRules
argument_list|(
name|planner
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enableBindable
condition|)
block|{
for|for
control|(
name|RelOptRule
name|rule
range|:
name|Bindables
operator|.
name|RULES
control|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Registers this rule for default ENUMERABLE convention
comment|// because:
comment|// 1. ScannableTable can bind data directly;
comment|// 2. Only BindableTable supports project push down now.
comment|// EnumerableInterpreterRule.INSTANCE would then transform
comment|// the BindableTableScan to
comment|// EnumerableInterpreter + BindableTableScan.
comment|// Note: the cost of EnumerableInterpreter + BindableTableScan
comment|// is always bigger that EnumerableTableScan because of the additional
comment|// EnumerableInterpreter node, but if there are pushing projects or filter,
comment|// we prefer BindableTableScan instead,
comment|// see BindableTableScan#computeSelfCost.
name|planner
operator|.
name|addRule
argument_list|(
name|Bindables
operator|.
name|BINDABLE_TABLE_SCAN_RULE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TABLE_SCAN
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_INTERPRETER_TABLE_SCAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|CalciteSystemProperty
operator|.
name|ENABLE_ENUMERABLE
operator|.
name|value
argument_list|()
condition|)
block|{
name|registerEnumerableRules
argument_list|(
name|planner
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|TO_INTERPRETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enableBindable
operator|&&
name|CalciteSystemProperty
operator|.
name|ENABLE_ENUMERABLE
operator|.
name|value
argument_list|()
condition|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|TO_BINDABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CalciteSystemProperty
operator|.
name|ENABLE_STREAM
operator|.
name|value
argument_list|()
condition|)
block|{
for|for
control|(
name|RelOptRule
name|rule
range|:
name|StreamRules
operator|.
name|RULES
control|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
name|planner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
expr_stmt|;
block|}
comment|/**    * Dumps a plan as a string.    *    * @param header      Header to print before the plan. Ignored if the format    *                    is XML    * @param rel         Relational expression to explain    * @param format      Output format    * @param detailLevel Detail level    * @return Plan    */
specifier|public
specifier|static
name|String
name|dumpPlan
parameter_list|(
name|String
name|header
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|SqlExplainFormat
name|format
parameter_list|,
name|SqlExplainLevel
name|detailLevel
parameter_list|)
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|header
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
name|RelWriter
name|planWriter
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|XML
case|:
name|planWriter
operator|=
operator|new
name|RelXmlWriter
argument_list|(
name|pw
argument_list|,
name|detailLevel
argument_list|)
expr_stmt|;
break|break;
case|case
name|JSON
case|:
name|planWriter
operator|=
operator|new
name|RelJsonWriter
argument_list|()
expr_stmt|;
name|rel
operator|.
name|explain
argument_list|(
name|planWriter
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|RelJsonWriter
operator|)
name|planWriter
operator|)
operator|.
name|asString
argument_list|()
return|;
case|case
name|DOT
case|:
name|planWriter
operator|=
operator|new
name|RelDotWriter
argument_list|(
name|pw
argument_list|,
name|detailLevel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|planWriter
operator|=
operator|new
name|RelWriterImpl
argument_list|(
name|pw
argument_list|,
name|detailLevel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|rel
operator|.
name|explain
argument_list|(
name|planWriter
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|String
name|dumpPlan
parameter_list|(
name|String
name|header
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|boolean
name|asXml
parameter_list|,
name|SqlExplainLevel
name|detailLevel
parameter_list|)
block|{
return|return
name|dumpPlan
argument_list|(
name|header
argument_list|,
name|rel
argument_list|,
name|asXml
condition|?
name|SqlExplainFormat
operator|.
name|XML
else|:
name|SqlExplainFormat
operator|.
name|TEXT
argument_list|,
name|detailLevel
argument_list|)
return|;
block|}
comment|/**    * Creates the row type descriptor for the result of a DML operation, which    * is a single column named ROWCOUNT of type BIGINT for INSERT;    * a single column named PLAN for EXPLAIN.    *    * @param kind        Kind of node    * @param typeFactory factory to use for creating type descriptor    * @return created type    */
specifier|public
specifier|static
name|RelDataType
name|createDmlRowType
parameter_list|(
name|SqlKind
name|kind
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|INSERT
case|:
case|case
name|DELETE
case|:
case|case
name|UPDATE
case|:
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|AvaticaConnection
operator|.
name|ROWCOUNT_COLUMN_NAME
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|EXPLAIN
case|:
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|AvaticaConnection
operator|.
name|PLAN_COLUMN_NAME
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|kind
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns whether two types are equal using 'equals'.    *    * @param desc1 Description of first type    * @param type1 First type    * @param desc2 Description of second type    * @param type2 Second type    * @param litmus What to do if an error is detected (types are not equal)    * @return Whether the types are equal    */
specifier|public
specifier|static
name|boolean
name|eq
parameter_list|(
specifier|final
name|String
name|desc1
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
specifier|final
name|String
name|desc2
parameter_list|,
name|RelDataType
name|type2
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
comment|// if any one of the types is ANY return true
if|if
condition|(
name|type1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
operator|||
name|type2
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
condition|)
block|{
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|type1
operator|.
name|equals
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"type mismatch:\n{}:\n{}\n{}:\n{}"
argument_list|,
name|desc1
argument_list|,
name|type1
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|desc2
argument_list|,
name|type2
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
return|;
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Returns whether two types are equal using    * {@link #areRowTypesEqual(RelDataType, RelDataType, boolean)}. Both types    * must not be null.    *    * @param desc1 Description of role of first type    * @param type1 First type    * @param desc2 Description of role of second type    * @param type2 Second type    * @param litmus Whether to assert if they are not equal    * @return Whether the types are equal    */
specifier|public
specifier|static
name|boolean
name|equal
parameter_list|(
specifier|final
name|String
name|desc1
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
specifier|final
name|String
name|desc2
parameter_list|,
name|RelDataType
name|type2
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
if|if
condition|(
operator|!
name|areRowTypesEqual
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
name|getFullTypeDifferenceString
argument_list|(
name|desc1
argument_list|,
name|type1
argument_list|,
name|desc2
argument_list|,
name|type2
argument_list|)
argument_list|)
return|;
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Returns the detailed difference of two types.    *    * @param sourceDesc description of role of source type    * @param sourceType source type    * @param targetDesc description of role of target type    * @param targetType target type    * @return the detailed difference of two types    */
specifier|public
specifier|static
name|String
name|getFullTypeDifferenceString
parameter_list|(
specifier|final
name|String
name|sourceDesc
parameter_list|,
name|RelDataType
name|sourceType
parameter_list|,
specifier|final
name|String
name|targetDesc
parameter_list|,
name|RelDataType
name|targetType
parameter_list|)
block|{
if|if
condition|(
name|sourceType
operator|==
name|targetType
condition|)
block|{
return|return
literal|""
return|;
block|}
specifier|final
name|int
name|sourceFieldCount
init|=
name|sourceType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|targetFieldCount
init|=
name|targetType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|sourceFieldCount
operator|!=
name|targetFieldCount
condition|)
block|{
return|return
literal|"Type mismatch: the field sizes are not equal.\n"
operator|+
name|sourceDesc
operator|+
literal|": "
operator|+
name|sourceType
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\n"
operator|+
name|targetDesc
operator|+
literal|": "
operator|+
name|targetType
operator|.
name|getFullTypeString
argument_list|()
return|;
block|}
specifier|final
name|StringBuilder
name|stringBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|f1
init|=
name|sourceType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|f2
init|=
name|targetType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|f1
argument_list|,
name|f2
argument_list|)
control|)
block|{
specifier|final
name|RelDataType
name|t1
init|=
name|pair
operator|.
name|left
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|t2
init|=
name|pair
operator|.
name|right
operator|.
name|getType
argument_list|()
decl_stmt|;
comment|// If one of the types is ANY comparison should succeed
if|if
condition|(
name|sourceType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
operator|||
name|targetType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|t1
operator|.
name|equals
argument_list|(
name|t2
argument_list|)
condition|)
block|{
name|stringBuilder
operator|.
name|append
argument_list|(
name|pair
operator|.
name|left
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|stringBuilder
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|stringBuilder
operator|.
name|append
argument_list|(
name|t1
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
expr_stmt|;
name|stringBuilder
operator|.
name|append
argument_list|(
literal|" -> "
argument_list|)
expr_stmt|;
name|stringBuilder
operator|.
name|append
argument_list|(
name|t2
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
expr_stmt|;
name|stringBuilder
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|String
name|difference
init|=
name|stringBuilder
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|difference
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|"Type mismatch:\n"
operator|+
name|sourceDesc
operator|+
literal|": "
operator|+
name|sourceType
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\n"
operator|+
name|targetDesc
operator|+
literal|": "
operator|+
name|targetType
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"Difference:\n"
operator|+
name|difference
return|;
block|}
else|else
block|{
return|return
literal|""
return|;
block|}
block|}
comment|/** Returns whether two relational expressions have the same row-type. */
specifier|public
specifier|static
name|boolean
name|equalType
parameter_list|(
name|String
name|desc0
parameter_list|,
name|RelNode
name|rel0
parameter_list|,
name|String
name|desc1
parameter_list|,
name|RelNode
name|rel1
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
comment|// TODO: change 'equal' to 'eq', which is stronger.
return|return
name|equal
argument_list|(
name|desc0
argument_list|,
name|rel0
operator|.
name|getRowType
argument_list|()
argument_list|,
name|desc1
argument_list|,
name|rel1
operator|.
name|getRowType
argument_list|()
argument_list|,
name|litmus
argument_list|)
return|;
block|}
comment|/**    * Returns a translation of the<code>IS DISTINCT FROM</code> (or<code>IS    * NOT DISTINCT FROM</code>) sql operator.    *    * @param neg if false, returns a translation of IS NOT DISTINCT FROM    */
specifier|public
specifier|static
name|RexNode
name|isDistinctFrom
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|x
parameter_list|,
name|RexNode
name|y
parameter_list|,
name|boolean
name|neg
parameter_list|)
block|{
name|RexNode
name|ret
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|x
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
assert|assert
name|y
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
assert|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|xFields
init|=
name|x
operator|.
name|getType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|yFields
init|=
name|y
operator|.
name|getType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|xFields
operator|.
name|size
argument_list|()
operator|==
name|yFields
operator|.
name|size
argument_list|()
assert|;
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|xFields
argument_list|,
name|yFields
argument_list|)
control|)
block|{
name|RelDataTypeField
name|xField
init|=
name|pair
operator|.
name|left
decl_stmt|;
name|RelDataTypeField
name|yField
init|=
name|pair
operator|.
name|right
decl_stmt|;
name|RexNode
name|newX
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|x
argument_list|,
name|xField
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|newY
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|y
argument_list|,
name|yField
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|newCall
init|=
name|isDistinctFromInternal
argument_list|(
name|rexBuilder
argument_list|,
name|newX
argument_list|,
name|newY
argument_list|,
name|neg
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
name|ret
operator|=
name|newCall
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|ret
argument_list|,
name|newCall
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ret
operator|=
name|isDistinctFromInternal
argument_list|(
name|rexBuilder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|neg
argument_list|)
expr_stmt|;
block|}
comment|// The result of IS DISTINCT FROM is NOT NULL because it can
comment|// only return TRUE or FALSE.
assert|assert
name|ret
operator|!=
literal|null
assert|;
assert|assert
operator|!
name|ret
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
assert|;
return|return
name|ret
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|isDistinctFromInternal
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|x
parameter_list|,
name|RexNode
name|y
parameter_list|,
name|boolean
name|neg
parameter_list|)
block|{
if|if
condition|(
name|neg
condition|)
block|{
comment|// x is not distinct from y
comment|// x=y IS TRUE or ((x is null) and (y is null)),
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|x
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|// x is distinct from y
comment|// x=y IS NOT TRUE and ((x is not null) or (y is not null)),
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|x
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_TRUE
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * Converts a relational expression to a string, showing just basic    * attributes.    */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|toString
argument_list|(
name|rel
argument_list|,
name|SqlExplainLevel
operator|.
name|EXPPLAN_ATTRIBUTES
argument_list|)
return|;
block|}
comment|/**    * Converts a relational expression to a string;    * returns null if and only if {@code rel} is null.    */
specifier|public
specifier|static
annotation|@
name|PolyNull
name|String
name|toString
parameter_list|(
specifier|final
annotation|@
name|PolyNull
name|RelNode
name|rel
parameter_list|,
name|SqlExplainLevel
name|detailLevel
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|RelWriter
name|planWriter
init|=
operator|new
name|RelWriterImpl
argument_list|(
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
argument_list|,
name|detailLevel
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|rel
operator|.
name|explain
argument_list|(
name|planWriter
argument_list|)
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|renameIfNecessary
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelDataType
name|desiredRowType
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|rowType
operator|==
name|desiredRowType
condition|)
block|{
comment|// Nothing to do.
return|return
name|rel
return|;
block|}
assert|assert
operator|!
name|rowType
operator|.
name|equals
argument_list|(
name|desiredRowType
argument_list|)
assert|;
if|if
condition|(
operator|!
name|areRowTypesEqual
argument_list|(
name|rowType
argument_list|,
name|desiredRowType
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// The row types are different ignoring names. Nothing we can do.
return|return
name|rel
return|;
block|}
name|rel
operator|=
name|createRename
argument_list|(
name|rel
argument_list|,
name|desiredRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rel
return|;
block|}
specifier|public
specifier|static
name|String
name|dumpType
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
specifier|final
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
specifier|final
name|TypeDumper
name|typeDumper
init|=
operator|new
name|TypeDumper
argument_list|(
name|pw
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|typeDumper
operator|.
name|acceptFields
argument_list|(
name|type
operator|.
name|getFieldList
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|typeDumper
operator|.
name|accept
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns the set of columns with unique names, with prior columns taking    * precedence over columns that appear later in the list.    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|deduplicateColumns
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|baseColumns
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|extendedColumns
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|dedupedFieldNames
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RelDataTypeField
argument_list|>
name|dedupedFields
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|f
range|:
name|Iterables
operator|.
name|concat
argument_list|(
name|baseColumns
argument_list|,
name|extendedColumns
argument_list|)
control|)
block|{
if|if
condition|(
name|dedupedFieldNames
operator|.
name|add
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|dedupedFields
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dedupedFields
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Decomposes a predicate into a list of expressions that are AND'ed    * together.    *    * @param rexPredicate predicate to be analyzed    * @param rexList      list of decomposed RexNodes    */
specifier|public
specifier|static
name|void
name|decomposeConjunction
parameter_list|(
annotation|@
name|Nullable
name|RexNode
name|rexPredicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexList
parameter_list|)
block|{
if|if
condition|(
name|rexPredicate
operator|==
literal|null
operator|||
name|rexPredicate
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|rexPredicate
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|AND
argument_list|)
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexPredicate
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|decomposeConjunction
argument_list|(
name|operand
argument_list|,
name|rexList
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rexList
operator|.
name|add
argument_list|(
name|rexPredicate
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Decomposes a predicate into a list of expressions that are AND'ed    * together, and a list of expressions that are preceded by NOT.    *    *<p>For example, {@code a AND NOT b AND NOT (c and d) AND TRUE AND NOT    * FALSE} returns {@code rexList = [a], notList = [b, c AND d]}.</p>    *    *<p>TRUE and NOT FALSE expressions are ignored. FALSE and NOT TRUE    * expressions are placed on {@code rexList} and {@code notList} as other    * expressions.</p>    *    *<p>For example, {@code a AND TRUE AND NOT TRUE} returns    * {@code rexList = [a], notList = [TRUE]}.</p>    *    * @param rexPredicate predicate to be analyzed    * @param rexList      list of decomposed RexNodes (except those with NOT)    * @param notList      list of decomposed RexNodes that were prefixed NOT    */
specifier|public
specifier|static
name|void
name|decomposeConjunction
parameter_list|(
annotation|@
name|Nullable
name|RexNode
name|rexPredicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexList
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|notList
parameter_list|)
block|{
if|if
condition|(
name|rexPredicate
operator|==
literal|null
operator|||
name|rexPredicate
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return;
block|}
switch|switch
condition|(
name|rexPredicate
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexPredicate
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|decomposeConjunction
argument_list|(
name|operand
argument_list|,
name|rexList
argument_list|,
name|notList
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NOT
case|:
specifier|final
name|RexNode
name|e
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rexPredicate
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return;
block|}
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|OR
case|:
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|ors
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|decomposeDisjunction
argument_list|(
name|e
argument_list|,
name|ors
argument_list|)
expr_stmt|;
for|for
control|(
name|RexNode
name|or
range|:
name|ors
control|)
block|{
switch|switch
condition|(
name|or
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|NOT
case|:
name|rexList
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|or
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|notList
operator|.
name|add
argument_list|(
name|or
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|notList
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LITERAL
case|:
if|if
condition|(
operator|!
name|RexLiteral
operator|.
name|isNullLiteral
argument_list|(
name|rexPredicate
argument_list|)
operator|&&
name|RexLiteral
operator|.
name|booleanValue
argument_list|(
name|rexPredicate
argument_list|)
condition|)
block|{
return|return;
comment|// ignore TRUE
block|}
comment|// fall through
default|default:
name|rexList
operator|.
name|add
argument_list|(
name|rexPredicate
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/**    * Decomposes a predicate into a list of expressions that are OR'ed    * together.    *    * @param rexPredicate predicate to be analyzed    * @param rexList      list of decomposed RexNodes    */
specifier|public
specifier|static
name|void
name|decomposeDisjunction
parameter_list|(
annotation|@
name|Nullable
name|RexNode
name|rexPredicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexList
parameter_list|)
block|{
if|if
condition|(
name|rexPredicate
operator|==
literal|null
operator|||
name|rexPredicate
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|rexPredicate
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|OR
argument_list|)
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexPredicate
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|decomposeDisjunction
argument_list|(
name|operand
argument_list|,
name|rexList
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rexList
operator|.
name|add
argument_list|(
name|rexPredicate
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns a condition decomposed by AND.    *    *<p>For example, {@code conjunctions(TRUE)} returns the empty list;    * {@code conjunctions(FALSE)} returns list {@code {FALSE}}.</p>    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|conjunctions
parameter_list|(
annotation|@
name|Nullable
name|RexNode
name|rexPredicate
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|decomposeConjunction
argument_list|(
name|rexPredicate
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|/**    * Returns a condition decomposed by OR.    *    *<p>For example, {@code disjunctions(FALSE)} returns the empty list.</p>    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|disjunctions
parameter_list|(
name|RexNode
name|rexPredicate
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|decomposeDisjunction
argument_list|(
name|rexPredicate
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|/**    * Ands two sets of join filters together, either of which can be null.    *    * @param rexBuilder rexBuilder to create AND expression    * @param left       filter on the left that the right will be AND'd to    * @param right      filter on the right    * @return AND'd filter    *    * @see org.apache.calcite.rex.RexUtil#composeConjunction    */
specifier|public
specifier|static
name|RexNode
name|andJoinFilters
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|left
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|right
parameter_list|)
block|{
comment|// don't bother AND'ing in expressions that always evaluate to
comment|// true
if|if
condition|(
operator|(
name|left
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|left
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|right
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|right
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|left
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|left
operator|=
name|right
expr_stmt|;
block|}
comment|// Joins must have some filter
if|if
condition|(
name|left
operator|==
literal|null
condition|)
block|{
name|left
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|left
return|;
block|}
comment|/** Decomposes the WHERE clause of a view into predicates that constraint    * a column to a particular value.    *    *<p>This method is key to the validation of a modifiable view. Columns that    * are constrained to a single value can be omitted from the    * SELECT clause of a modifiable view.    *    * @param projectMap Mapping from column ordinal to the expression that    * populate that column, to be populated by this method    * @param filters List of remaining filters, to be populated by this method    * @param constraint Constraint to be analyzed    */
specifier|public
specifier|static
name|void
name|inferViewPredicates
parameter_list|(
name|Map
argument_list|<
name|Integer
argument_list|,
name|RexNode
argument_list|>
name|projectMap
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
parameter_list|,
name|RexNode
name|constraint
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|node
range|:
name|conjunctions
argument_list|(
name|constraint
argument_list|)
control|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|o0
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|o1
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|o0
operator|instanceof
name|RexLiteral
condition|)
block|{
name|o0
operator|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|o1
operator|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o0
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
condition|)
block|{
name|o0
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|o0
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o0
operator|instanceof
name|RexInputRef
operator|&&
name|o1
operator|instanceof
name|RexLiteral
condition|)
block|{
specifier|final
name|int
name|index
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|o0
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|projectMap
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|==
literal|null
condition|)
block|{
name|projectMap
operator|.
name|put
argument_list|(
name|index
argument_list|,
name|o1
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
default|default:
break|break;
block|}
name|filters
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns a mapping of the column ordinal in the underlying table to a column    * constraint of the modifiable view.    *    * @param modifiableViewTable The modifiable view which has a constraint    * @param targetRowType       The target type    */
specifier|public
specifier|static
name|Map
argument_list|<
name|Integer
argument_list|,
name|RexNode
argument_list|>
name|getColumnConstraints
parameter_list|(
name|ModifiableView
name|modifiableViewTable
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
operator|new
name|RexBuilder
argument_list|(
name|typeFactory
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|constraint
init|=
name|modifiableViewTable
operator|.
name|getConstraint
argument_list|(
name|rexBuilder
argument_list|,
name|targetRowType
argument_list|)
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|RexNode
argument_list|>
name|projectMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|RelOptUtil
operator|.
name|inferViewPredicates
argument_list|(
name|projectMap
argument_list|,
name|filters
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
assert|assert
name|filters
operator|.
name|isEmpty
argument_list|()
assert|;
return|return
name|projectMap
return|;
block|}
comment|/**    * Ensures that a source value does not violate the constraint of the target    * column.    *    * @param sourceValue      The insert value being validated    * @param targetConstraint The constraint applied to sourceValue for validation    * @param errorSupplier    The function to apply when validation fails    */
specifier|public
specifier|static
name|void
name|validateValueAgainstConstraint
parameter_list|(
name|SqlNode
name|sourceValue
parameter_list|,
name|RexNode
name|targetConstraint
parameter_list|,
name|Supplier
argument_list|<
name|CalciteContextException
argument_list|>
name|errorSupplier
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|sourceValue
operator|instanceof
name|SqlLiteral
operator|)
condition|)
block|{
comment|// We cannot guarantee that the value satisfies the constraint.
throw|throw
name|errorSupplier
operator|.
name|get
argument_list|()
throw|;
block|}
specifier|final
name|SqlLiteral
name|insertValue
init|=
operator|(
name|SqlLiteral
operator|)
name|sourceValue
decl_stmt|;
specifier|final
name|RexLiteral
name|columnConstraint
init|=
operator|(
name|RexLiteral
operator|)
name|targetConstraint
decl_stmt|;
specifier|final
name|RexSqlStandardConvertletTable
name|convertletTable
init|=
operator|new
name|RexSqlStandardConvertletTable
argument_list|()
decl_stmt|;
specifier|final
name|RexToSqlNodeConverter
name|sqlNodeToRexConverter
init|=
operator|new
name|RexToSqlNodeConverterImpl
argument_list|(
name|convertletTable
argument_list|)
decl_stmt|;
specifier|final
name|SqlLiteral
name|constraintValue
init|=
operator|(
name|SqlLiteral
operator|)
name|sqlNodeToRexConverter
operator|.
name|convertLiteral
argument_list|(
name|columnConstraint
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|insertValue
operator|.
name|equals
argument_list|(
name|constraintValue
argument_list|)
condition|)
block|{
comment|// The value does not satisfy the constraint.
throw|throw
name|errorSupplier
operator|.
name|get
argument_list|()
throw|;
block|}
block|}
comment|/**    * Adjusts key values in a list by some fixed amount.    *    * @param keys       list of key values    * @param adjustment the amount to adjust the key values by    * @return modified list    */
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|adjustKeys
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|keys
parameter_list|,
name|int
name|adjustment
parameter_list|)
block|{
if|if
condition|(
name|adjustment
operator|==
literal|0
condition|)
block|{
return|return
name|keys
return|;
block|}
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|newKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|key
range|:
name|keys
control|)
block|{
name|newKeys
operator|.
name|add
argument_list|(
name|key
operator|+
name|adjustment
argument_list|)
expr_stmt|;
block|}
return|return
name|newKeys
return|;
block|}
comment|/**    * Simplifies outer joins if filter above would reject nulls.    *    * @param joinRel Join    * @param aboveFilters Filters from above    * @param joinType Join type, can not be inner join    */
specifier|public
specifier|static
name|JoinRelType
name|simplifyJoin
parameter_list|(
name|RelNode
name|joinRel
parameter_list|,
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|aboveFilters
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|)
block|{
comment|// No need to simplify if the join only outputs left side.
if|if
condition|(
operator|!
name|joinType
operator|.
name|projectsRight
argument_list|()
condition|)
block|{
return|return
name|joinType
return|;
block|}
specifier|final
name|int
name|nTotalFields
init|=
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nSysFields
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|nFieldsLeft
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nFieldsRight
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
name|nTotalFields
operator|==
name|nSysFields
operator|+
name|nFieldsLeft
operator|+
name|nFieldsRight
assert|;
comment|// set the reference bitmaps for the left and right children
name|ImmutableBitSet
name|leftBitmap
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
argument_list|,
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|rightBitmap
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
name|nTotalFields
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|filter
range|:
name|aboveFilters
control|)
block|{
if|if
condition|(
name|joinType
operator|.
name|generatesNullsOnLeft
argument_list|()
operator|&&
name|Strong
operator|.
name|isNotTrue
argument_list|(
name|filter
argument_list|,
name|leftBitmap
argument_list|)
condition|)
block|{
name|joinType
operator|=
name|joinType
operator|.
name|cancelNullsOnLeft
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
operator|&&
name|Strong
operator|.
name|isNotTrue
argument_list|(
name|filter
argument_list|,
name|rightBitmap
argument_list|)
condition|)
block|{
name|joinType
operator|=
name|joinType
operator|.
name|cancelNullsOnRight
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|joinType
operator|.
name|isOuterJoin
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
return|return
name|joinType
return|;
block|}
comment|/**    * Classifies filters according to where they should be processed. They    * either stay where they are, are pushed to the join (if they originated    * from above the join), or are pushed to one of the children. Filters that    * are pushed are added to list passed in as input parameters.    *    * @param joinRel      join node    * @param filters      filters to be classified    * @param pushInto     whether filters can be pushed into the join    * @param pushLeft     true if filters can be pushed to the left    * @param pushRight    true if filters can be pushed to the right    * @param joinFilters  list of filters to push to the join    * @param leftFilters  list of filters to push to the left child    * @param rightFilters list of filters to push to the right child    * @return whether at least one filter was pushed    */
specifier|public
specifier|static
name|boolean
name|classifyFilters
parameter_list|(
name|RelNode
name|joinRel
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
parameter_list|,
name|boolean
name|pushInto
parameter_list|,
name|boolean
name|pushLeft
parameter_list|,
name|boolean
name|pushRight
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilters
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftFilters
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightFilters
parameter_list|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|joinFields
init|=
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nSysFields
init|=
literal|0
decl_stmt|;
comment|// joinRel.getSystemFieldList().size();
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftFields
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nFieldsLeft
init|=
name|leftFields
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightFields
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nFieldsRight
init|=
name|rightFields
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nTotalFields
init|=
name|nFieldsLeft
operator|+
name|nFieldsRight
decl_stmt|;
comment|// set the reference bitmaps for the left and right children
name|ImmutableBitSet
name|leftBitmap
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
argument_list|,
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|rightBitmap
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
name|nTotalFields
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToRemove
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|filter
range|:
name|filters
control|)
block|{
specifier|final
name|InputFinder
name|inputFinder
init|=
name|InputFinder
operator|.
name|analyze
argument_list|(
name|filter
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|inputBits
init|=
name|inputFinder
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// REVIEW - are there any expressions that need special handling
comment|// and therefore cannot be pushed?
if|if
condition|(
name|pushLeft
operator|&&
name|leftBitmap
operator|.
name|contains
argument_list|(
name|inputBits
argument_list|)
condition|)
block|{
comment|// ignore filters that always evaluate to true
if|if
condition|(
operator|!
name|filter
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// adjust the field references in the filter to reflect
comment|// that fields in the left now shift over by the number
comment|// of system fields
specifier|final
name|RexNode
name|shiftedFilter
init|=
name|shiftFilter
argument_list|(
name|nSysFields
argument_list|,
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
operator|-
name|nSysFields
argument_list|,
name|rexBuilder
argument_list|,
name|joinFields
argument_list|,
name|nTotalFields
argument_list|,
name|leftFields
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|leftFilters
operator|.
name|add
argument_list|(
name|shiftedFilter
argument_list|)
expr_stmt|;
block|}
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|pushRight
operator|&&
name|rightBitmap
operator|.
name|contains
argument_list|(
name|inputBits
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|filter
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// adjust the field references in the filter to reflect
comment|// that fields in the right now shift over to the left
specifier|final
name|RexNode
name|shiftedFilter
init|=
name|shiftFilter
argument_list|(
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
name|nTotalFields
argument_list|,
operator|-
operator|(
name|nSysFields
operator|+
name|nFieldsLeft
operator|)
argument_list|,
name|rexBuilder
argument_list|,
name|joinFields
argument_list|,
name|nTotalFields
argument_list|,
name|rightFields
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|rightFilters
operator|.
name|add
argument_list|(
name|shiftedFilter
argument_list|)
expr_stmt|;
block|}
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If the filter can't be pushed to either child, we may push them into the join
if|if
condition|(
name|pushInto
condition|)
block|{
if|if
condition|(
operator|!
name|joinFilters
operator|.
name|contains
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|joinFilters
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Remove filters after the loop, to prevent concurrent modification.
if|if
condition|(
operator|!
name|filtersToRemove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|filters
operator|.
name|removeAll
argument_list|(
name|filtersToRemove
argument_list|)
expr_stmt|;
block|}
comment|// Did anything change?
return|return
operator|!
name|filtersToRemove
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * Classifies filters according to where they should be processed. They    * either stay where they are, are pushed to the join (if they originated    * from above the join), or are pushed to one of the children. Filters that    * are pushed are added to list passed in as input parameters.    *    * @param joinRel      join node    * @param filters      filters to be classified    * @param joinType     join type    * @param pushInto     whether filters can be pushed into the ON clause    * @param pushLeft     true if filters can be pushed to the left    * @param pushRight    true if filters can be pushed to the right    * @param joinFilters  list of filters to push to the join    * @param leftFilters  list of filters to push to the left child    * @param rightFilters list of filters to push to the right child    * @return whether at least one filter was pushed    *    * @deprecated Use    * {@link RelOptUtil#classifyFilters(RelNode, List, boolean, boolean, boolean, List, List, List)}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|boolean
name|classifyFilters
parameter_list|(
name|RelNode
name|joinRel
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|,
name|boolean
name|pushInto
parameter_list|,
name|boolean
name|pushLeft
parameter_list|,
name|boolean
name|pushRight
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilters
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftFilters
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightFilters
parameter_list|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|joinFields
init|=
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nTotalFields
init|=
name|joinFields
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nSysFields
init|=
literal|0
decl_stmt|;
comment|// joinRel.getSystemFieldList().size();
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftFields
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nFieldsLeft
init|=
name|leftFields
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightFields
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nFieldsRight
init|=
name|rightFields
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// SemiJoin, CorrelateSemiJoin, CorrelateAntiJoin: right fields are not returned
assert|assert
name|nTotalFields
operator|==
operator|(
operator|!
name|joinType
operator|.
name|projectsRight
argument_list|()
condition|?
name|nSysFields
operator|+
name|nFieldsLeft
else|:
name|nSysFields
operator|+
name|nFieldsLeft
operator|+
name|nFieldsRight
operator|)
assert|;
comment|// set the reference bitmaps for the left and right children
name|ImmutableBitSet
name|leftBitmap
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
argument_list|,
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|rightBitmap
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
name|nTotalFields
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToRemove
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|filter
range|:
name|filters
control|)
block|{
specifier|final
name|InputFinder
name|inputFinder
init|=
name|InputFinder
operator|.
name|analyze
argument_list|(
name|filter
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|inputBits
init|=
name|inputFinder
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// REVIEW - are there any expressions that need special handling
comment|// and therefore cannot be pushed?
comment|// filters can be pushed to the left child if the left child
comment|// does not generate NULLs and the only columns referenced in
comment|// the filter originate from the left child
if|if
condition|(
name|pushLeft
operator|&&
name|leftBitmap
operator|.
name|contains
argument_list|(
name|inputBits
argument_list|)
condition|)
block|{
comment|// ignore filters that always evaluate to true
if|if
condition|(
operator|!
name|filter
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// adjust the field references in the filter to reflect
comment|// that fields in the left now shift over by the number
comment|// of system fields
specifier|final
name|RexNode
name|shiftedFilter
init|=
name|shiftFilter
argument_list|(
name|nSysFields
argument_list|,
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
operator|-
name|nSysFields
argument_list|,
name|rexBuilder
argument_list|,
name|joinFields
argument_list|,
name|nTotalFields
argument_list|,
name|leftFields
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|leftFilters
operator|.
name|add
argument_list|(
name|shiftedFilter
argument_list|)
expr_stmt|;
block|}
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
comment|// filters can be pushed to the right child if the right child
comment|// does not generate NULLs and the only columns referenced in
comment|// the filter originate from the right child
block|}
if|else if
condition|(
name|pushRight
operator|&&
name|rightBitmap
operator|.
name|contains
argument_list|(
name|inputBits
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|filter
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// adjust the field references in the filter to reflect
comment|// that fields in the right now shift over to the left;
comment|// since we never push filters to a NULL generating
comment|// child, the types of the source should match the dest
comment|// so we don't need to explicitly pass the destination
comment|// fields to RexInputConverter
specifier|final
name|RexNode
name|shiftedFilter
init|=
name|shiftFilter
argument_list|(
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
name|nTotalFields
argument_list|,
operator|-
operator|(
name|nSysFields
operator|+
name|nFieldsLeft
operator|)
argument_list|,
name|rexBuilder
argument_list|,
name|joinFields
argument_list|,
name|nTotalFields
argument_list|,
name|rightFields
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|rightFilters
operator|.
name|add
argument_list|(
name|shiftedFilter
argument_list|)
expr_stmt|;
block|}
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If the filter can't be pushed to either child and the join
comment|// is an inner join, push them to the join if they originated
comment|// from above the join
if|if
condition|(
operator|!
name|joinType
operator|.
name|isOuterJoin
argument_list|()
operator|&&
name|pushInto
condition|)
block|{
if|if
condition|(
operator|!
name|joinFilters
operator|.
name|contains
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|joinFilters
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Remove filters after the loop, to prevent concurrent modification.
if|if
condition|(
operator|!
name|filtersToRemove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|filters
operator|.
name|removeAll
argument_list|(
name|filtersToRemove
argument_list|)
expr_stmt|;
block|}
comment|// Did anything change?
return|return
operator|!
name|filtersToRemove
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|shiftFilter
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|offset
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|joinFields
parameter_list|,
name|int
name|nTotalFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightFields
parameter_list|,
name|RexNode
name|filter
parameter_list|)
block|{
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|nTotalFields
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
block|}
return|return
name|filter
operator|.
name|accept
argument_list|(
operator|new
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|joinFields
argument_list|,
name|rightFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Splits a filter into two lists, depending on whether or not the filter    * only references its child input.    *    * @param childBitmap Fields in the child    * @param predicate   filters that will be split    * @param pushable    returns the list of filters that can be pushed to the    *                    child input    * @param notPushable returns the list of filters that cannot be pushed to    *                    the child input    */
specifier|public
specifier|static
name|void
name|splitFilters
parameter_list|(
name|ImmutableBitSet
name|childBitmap
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|predicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|pushable
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|notPushable
parameter_list|)
block|{
comment|// for each filter, if the filter only references the child inputs,
comment|// then it can be pushed
for|for
control|(
name|RexNode
name|filter
range|:
name|conjunctions
argument_list|(
name|predicate
argument_list|)
control|)
block|{
name|ImmutableBitSet
name|filterRefs
init|=
name|InputFinder
operator|.
name|bits
argument_list|(
name|filter
argument_list|)
decl_stmt|;
if|if
condition|(
name|childBitmap
operator|.
name|contains
argument_list|(
name|filterRefs
argument_list|)
condition|)
block|{
name|pushable
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notPushable
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|boolean
name|checkProjAndChildInputs
parameter_list|(
name|Project
name|project
parameter_list|,
name|boolean
name|checkNames
parameter_list|)
block|{
name|int
name|n
init|=
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|RelDataType
name|inputType
init|=
name|project
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputType
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|n
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|projFields
init|=
name|project
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputFields
init|=
name|inputType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|boolean
name|namesDifferent
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|RexNode
name|exp
init|=
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|exp
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RexInputRef
name|fieldAccess
init|=
operator|(
name|RexInputRef
operator|)
name|exp
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|fieldAccess
operator|.
name|getIndex
argument_list|()
condition|)
block|{
comment|// can't support reorder yet
return|return
literal|false
return|;
block|}
if|if
condition|(
name|checkNames
condition|)
block|{
name|String
name|inputFieldName
init|=
name|inputFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|projFieldName
init|=
name|projFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|projFieldName
operator|.
name|equals
argument_list|(
name|inputFieldName
argument_list|)
condition|)
block|{
name|namesDifferent
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// inputs are the same; return value depends on the checkNames
comment|// parameter
return|return
operator|!
name|checkNames
operator|||
name|namesDifferent
return|;
block|}
comment|/**    * Creates projection expressions reflecting the swapping of a join's input.    *    * @param newJoin   the RelNode corresponding to the join with its inputs    *                  swapped    * @param origJoin  original LogicalJoin    * @param origOrder if true, create the projection expressions to reflect    *                  the original (pre-swapped) join projection; otherwise,    *                  create the projection to reflect the order of the swapped    *                  projection    * @return array of expression representing the swapped join inputs    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|createSwappedJoinExprs
parameter_list|(
name|RelNode
name|newJoin
parameter_list|,
name|Join
name|origJoin
parameter_list|,
name|boolean
name|origOrder
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|newJoinFields
init|=
name|newJoin
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|newJoin
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nFields
init|=
name|origOrder
condition|?
name|origJoin
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
else|:
name|origJoin
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newJoinFields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|source
init|=
operator|(
name|i
operator|+
name|nFields
operator|)
operator|%
name|newJoinFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|RelDataTypeField
name|field
init|=
name|origOrder
condition|?
name|newJoinFields
operator|.
name|get
argument_list|(
name|source
argument_list|)
else|:
name|newJoinFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|exps
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|exps
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RexNode
name|pushFilterPastProject
parameter_list|(
name|RexNode
name|filter
parameter_list|,
specifier|final
name|Project
name|projRel
parameter_list|)
block|{
return|return
name|pushPastProject
argument_list|(
name|filter
argument_list|,
name|projRel
argument_list|)
return|;
block|}
comment|/**    * Converts an expression that is based on the output fields of a    * {@link Project} to an equivalent expression on the Project's    * input fields.    *    * @param node The expression to be converted    * @param project Project underneath the expression    * @return converted expression    */
specifier|public
specifier|static
name|RexNode
name|pushPastProject
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|Project
name|project
parameter_list|)
block|{
return|return
name|node
operator|.
name|accept
argument_list|(
name|pushShuttle
argument_list|(
name|project
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Converts a list of expressions that are based on the output fields of a    * {@link Project} to equivalent expressions on the Project's    * input fields.    *    * @param nodes The expressions to be converted    * @param project Project underneath the expression    * @return converted expressions    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|pushPastProject
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|Project
name|project
parameter_list|)
block|{
return|return
name|pushShuttle
argument_list|(
name|project
argument_list|)
operator|.
name|visitList
argument_list|(
name|nodes
argument_list|)
return|;
block|}
comment|/** As {@link #pushPastProject}, but returns null if the resulting expressions    * are significantly more complex.    *    * @param bloat Maximum allowable increase in complexity */
specifier|public
specifier|static
annotation|@
name|Nullable
name|List
argument_list|<
name|RexNode
argument_list|>
name|pushPastProjectUnlessBloat
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|Project
name|project
parameter_list|,
name|int
name|bloat
parameter_list|)
block|{
if|if
condition|(
name|bloat
operator|<
literal|0
condition|)
block|{
comment|// If bloat is negative never merge.
return|return
literal|null
return|;
block|}
if|if
condition|(
name|RexOver
operator|.
name|containsOver
argument_list|(
name|nodes
argument_list|,
literal|null
argument_list|)
operator|&&
name|project
operator|.
name|containsOver
argument_list|()
condition|)
block|{
comment|// Is it valid relational algebra to apply windowed function to a windowed
comment|// function? Possibly. But it's invalid SQL, so don't go there.
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|pushPastProject
argument_list|(
name|nodes
argument_list|,
name|project
argument_list|)
decl_stmt|;
specifier|final
name|int
name|bottomCount
init|=
name|RexUtil
operator|.
name|nodeCount
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|topCount
init|=
name|RexUtil
operator|.
name|nodeCount
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
specifier|final
name|int
name|mergedCount
init|=
name|RexUtil
operator|.
name|nodeCount
argument_list|(
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergedCount
operator|>
name|bottomCount
operator|+
name|topCount
operator|+
name|bloat
condition|)
block|{
comment|// The merged expression is more complex than the input expressions.
comment|// Do not merge.
return|return
literal|null
return|;
block|}
return|return
name|list
return|;
block|}
specifier|private
specifier|static
name|RexShuttle
name|pushShuttle
parameter_list|(
specifier|final
name|Project
name|project
parameter_list|)
block|{
return|return
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|ref
parameter_list|)
block|{
return|return
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Converts an expression that is based on the output fields of a    * {@link Calc} to an equivalent expression on the Calc's input fields.    *    * @param node The expression to be converted    * @param calc Calc underneath the expression    * @return converted expression    */
specifier|public
specifier|static
name|RexNode
name|pushPastCalc
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|Calc
name|calc
parameter_list|)
block|{
return|return
name|node
operator|.
name|accept
argument_list|(
name|pushShuttle
argument_list|(
name|calc
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexShuttle
name|pushShuttle
parameter_list|(
specifier|final
name|Calc
name|calc
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
name|Util
operator|.
name|transform
argument_list|(
name|calc
operator|.
name|getProgram
argument_list|()
operator|.
name|getProjectList
argument_list|()
argument_list|,
name|calc
operator|.
name|getProgram
argument_list|()
operator|::
name|expandLocalRef
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|ref
parameter_list|)
block|{
return|return
name|projects
operator|.
name|get
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Creates a new {@link org.apache.calcite.rel.rules.MultiJoin} to reflect    * projection references from a    * {@link Project} that is on top of the    * {@link org.apache.calcite.rel.rules.MultiJoin}.    *    * @param multiJoin the original MultiJoin    * @param project   the Project on top of the MultiJoin    * @return the new MultiJoin    */
specifier|public
specifier|static
name|MultiJoin
name|projectMultiJoin
parameter_list|(
name|MultiJoin
name|multiJoin
parameter_list|,
name|Project
name|project
parameter_list|)
block|{
comment|// Locate all input references in the projection expressions as well
comment|// the post-join filter.  Since the filter effectively sits in
comment|// between the LogicalProject and the MultiJoin, the projection needs
comment|// to include those filter references.
name|ImmutableBitSet
name|inputRefs
init|=
name|InputFinder
operator|.
name|bits
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getPostJoinFilter
argument_list|()
argument_list|)
decl_stmt|;
comment|// create new copies of the bitmaps
name|List
argument_list|<
name|RelNode
argument_list|>
name|multiJoinInputs
init|=
name|multiJoin
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|BitSet
argument_list|>
name|newProjFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|multiJoinInput
range|:
name|multiJoinInputs
control|)
block|{
name|newProjFields
operator|.
name|add
argument_list|(
operator|new
name|BitSet
argument_list|(
name|multiJoinInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// set the bits found in the expressions
name|int
name|currInput
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|startField
init|=
literal|0
decl_stmt|;
name|int
name|nFields
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|bit
range|:
name|inputRefs
control|)
block|{
while|while
condition|(
name|bit
operator|>=
operator|(
name|startField
operator|+
name|nFields
operator|)
condition|)
block|{
name|startField
operator|+=
name|nFields
expr_stmt|;
name|currInput
operator|++
expr_stmt|;
assert|assert
name|currInput
operator|<
name|multiJoinInputs
operator|.
name|size
argument_list|()
assert|;
name|nFields
operator|=
name|multiJoinInputs
operator|.
name|get
argument_list|(
name|currInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
name|newProjFields
operator|.
name|get
argument_list|(
name|currInput
argument_list|)
operator|.
name|set
argument_list|(
name|bit
operator|-
name|startField
argument_list|)
expr_stmt|;
block|}
comment|// create a new MultiJoin containing the new field bitmaps
comment|// for each input
return|return
operator|new
name|MultiJoin
argument_list|(
name|multiJoin
operator|.
name|getCluster
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getInputs
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getJoinFilter
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getRowType
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|isFullOuterJoin
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getOuterJoinConditions
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getJoinTypes
argument_list|()
argument_list|,
name|Util
operator|.
name|transform
argument_list|(
name|newProjFields
argument_list|,
name|ImmutableBitSet
operator|::
name|fromBitSet
argument_list|)
argument_list|,
name|multiJoin
operator|.
name|getJoinFieldRefCountsMap
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getPostJoinFilter
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|RelNode
parameter_list|>
name|T
name|addTrait
parameter_list|(
name|T
name|rel
parameter_list|,
name|RelTrait
name|trait
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|T
operator|)
name|rel
operator|.
name|copy
argument_list|(
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|trait
argument_list|)
argument_list|,
name|rel
operator|.
name|getInputs
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a shallow copy of a relational expression with a particular    * input replaced.    */
specifier|public
specifier|static
name|RelNode
name|replaceInput
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|newInput
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|parent
operator|.
name|getInputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputs
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
operator|==
name|newInput
condition|)
block|{
return|return
name|parent
return|;
block|}
name|inputs
operator|.
name|set
argument_list|(
name|ordinal
argument_list|,
name|newInput
argument_list|)
expr_stmt|;
return|return
name|parent
operator|.
name|copy
argument_list|(
name|parent
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|inputs
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link org.apache.calcite.rel.logical.LogicalProject} that    * projects particular fields of its input, according to a mapping.    */
specifier|public
specifier|static
name|RelNode
name|createProject
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|)
block|{
return|return
name|createProject
argument_list|(
name|child
argument_list|,
name|Mappings
operator|.
name|asListNonNull
argument_list|(
name|mapping
operator|.
name|inverse
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RelNode
name|createProject
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|RelFactories
operator|.
name|ProjectFactory
name|projectFactory
parameter_list|)
block|{
return|return
name|createProject
argument_list|(
name|projectFactory
argument_list|,
name|child
argument_list|,
name|Mappings
operator|.
name|asListNonNull
argument_list|(
name|mapping
operator|.
name|inverse
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns whether relational expression {@code target} occurs within a    * relational expression {@code ancestor}. */
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|RelNode
name|ancestor
parameter_list|,
specifier|final
name|RelNode
name|target
parameter_list|)
block|{
if|if
condition|(
name|ancestor
operator|==
name|target
condition|)
block|{
comment|// Short-cut common case.
return|return
literal|true
return|;
block|}
try|try
block|{
operator|new
name|RelVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
annotation|@
name|Nullable
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
name|target
condition|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// CHECKSTYLE: IGNORE 1
block|}
operator|.
name|go
argument_list|(
name|ancestor
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/** Within a relational expression {@code query}, replaces occurrences of    * {@code find} with {@code replace}. */
specifier|public
specifier|static
name|RelNode
name|replace
parameter_list|(
name|RelNode
name|query
parameter_list|,
name|RelNode
name|find
parameter_list|,
name|RelNode
name|replace
parameter_list|)
block|{
if|if
condition|(
name|find
operator|==
name|replace
condition|)
block|{
comment|// Short-cut common case.
return|return
name|query
return|;
block|}
assert|assert
name|equalType
argument_list|(
literal|"find"
argument_list|,
name|find
argument_list|,
literal|"replace"
argument_list|,
name|replace
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
if|if
condition|(
name|query
operator|==
name|find
condition|)
block|{
comment|// Short-cut another common case.
return|return
name|replace
return|;
block|}
return|return
name|replaceRecurse
argument_list|(
name|query
argument_list|,
name|find
argument_list|,
name|replace
argument_list|)
return|;
block|}
comment|/** Helper for {@link #replace}. */
specifier|private
specifier|static
name|RelNode
name|replaceRecurse
parameter_list|(
name|RelNode
name|query
parameter_list|,
name|RelNode
name|find
parameter_list|,
name|RelNode
name|replace
parameter_list|)
block|{
if|if
condition|(
name|query
operator|==
name|find
condition|)
block|{
return|return
name|replace
return|;
block|}
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|query
operator|.
name|getInputs
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|inputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|newInputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|inputs
control|)
block|{
name|newInputs
operator|.
name|add
argument_list|(
name|replaceRecurse
argument_list|(
name|input
argument_list|,
name|find
argument_list|,
name|replace
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newInputs
operator|.
name|equals
argument_list|(
name|inputs
argument_list|)
condition|)
block|{
return|return
name|query
operator|.
name|copy
argument_list|(
name|query
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newInputs
argument_list|)
return|;
block|}
block|}
return|return
name|query
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelOptTable
operator|.
name|ToRelContext
name|getContext
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|)
block|{
return|return
name|ViewExpanders
operator|.
name|simpleContext
argument_list|(
name|cluster
argument_list|)
return|;
block|}
comment|/** Returns the number of {@link org.apache.calcite.rel.core.Join} nodes in a    * tree. */
specifier|public
specifier|static
name|int
name|countJoins
parameter_list|(
name|RelNode
name|rootRel
parameter_list|)
block|{
comment|/** Visitor that counts join nodes. */
class|class
name|JoinCounter
extends|extends
name|RelVisitor
block|{
name|int
name|joinCount
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
annotation|@
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|Join
condition|)
block|{
operator|++
name|joinCount
expr_stmt|;
block|}
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
name|int
name|run
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
name|go
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|joinCount
return|;
block|}
block|}
return|return
operator|new
name|JoinCounter
argument_list|()
operator|.
name|run
argument_list|(
name|rootRel
argument_list|)
return|;
block|}
comment|/** Permutes a record type according to a mapping. */
specifier|public
specifier|static
name|RelDataType
name|permute
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|Mapping
name|mapping
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|Mappings
operator|.
name|apply3
argument_list|(
name|mapping
argument_list|,
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createProject
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprList
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
parameter_list|)
block|{
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|child
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|child
argument_list|)
operator|.
name|project
argument_list|(
name|exprList
argument_list|,
name|fieldNameList
argument_list|,
literal|true
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createProject
argument_list|(
name|RelNode
name|child
argument_list|,
name|List
operator|<
name|Pair
operator|<
name|RexNode
argument_list|,
operator|?
expr|extends @
name|Nullable
name|String
operator|>>
name|projectList
argument_list|,
name|boolean
name|optimize
argument_list|)
block|{
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|child
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|child
argument_list|)
operator|.
name|projectNamed
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|projectList
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|projectList
argument_list|)
argument_list|,
operator|!
name|optimize
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Creates a relational expression that projects the given fields of the    * input.    *    *<p>Optimizes if the fields are the identity projection.</p>    *    * @param child   Input relational expression    * @param posList Source of each projected field    * @return Relational expression that projects given fields    */
specifier|public
specifier|static
name|RelNode
name|createProject
parameter_list|(
specifier|final
name|RelNode
name|child
parameter_list|,
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|posList
parameter_list|)
block|{
return|return
name|createProject
argument_list|(
name|RelFactories
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|,
name|child
argument_list|,
name|posList
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createProject
argument_list|(
name|RelNode
name|child
argument_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
argument_list|,
name|List
operator|<
condition|?
then|extends @
name|Nullable
name|String
operator|>
name|fieldNames
argument_list|,
name|boolean
name|optimize
argument_list|)
block|{
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|child
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|child
argument_list|)
operator|.
name|projectNamed
argument_list|(
name|exprs
argument_list|,
name|fieldNames
argument_list|,
operator|!
name|optimize
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|// CHECKSTYLE: IGNORE 1
comment|/** @deprecated Use    * {@link RelBuilder#projectNamed(Iterable, Iterable, boolean)} */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createProject
argument_list|(
name|RelNode
name|child
argument_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
argument_list|,
name|List
operator|<
condition|?
then|extends @
name|Nullable
name|String
operator|>
name|fieldNames
argument_list|,
name|boolean
name|optimize
argument_list|,
name|RelBuilder
name|relBuilder
argument_list|)
block|{
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|child
argument_list|)
operator|.
name|projectNamed
argument_list|(
name|exprs
argument_list|,
name|fieldNames
argument_list|,
operator|!
name|optimize
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createRename
argument_list|(
name|RelNode
name|rel
argument_list|,
name|List
operator|<
condition|?
then|extends @
name|Nullable
name|String
operator|>
name|fieldNames
argument_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|fieldNames
operator|.
name|size
argument_list|()
operator|==
name|fields
operator|.
name|size
argument_list|()
assert|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|refs
init|=
operator|new
name|AbstractList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fields
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|RexInputRef
operator|.
name|of
argument_list|(
name|index
argument_list|,
name|fields
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|rel
argument_list|)
operator|.
name|projectNamed
argument_list|(
name|refs
argument_list|,
name|fieldNames
argument_list|,
literal|false
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Creates a relational expression which permutes the output fields of a    * relational expression according to a permutation.    *    *<p>Optimizations:</p>    *    *<ul>    *<li>If the relational expression is a    * {@link org.apache.calcite.rel.logical.LogicalCalc} or    * {@link org.apache.calcite.rel.logical.LogicalProject} that is already    * acting as a permutation, combines the new permutation with the old;</li>    *    *<li>If the permutation is the identity, returns the original relational    * expression.</li>    *</ul>    *    *<p>If a permutation is combined with its inverse, these optimizations    * would combine to remove them both.    *    * @param rel         Relational expression    * @param permutation Permutation to apply to fields    * @param fieldNames  Field names; if null, or if a particular entry is null,    *                    the name of the permuted field is used    * @return relational expression which permutes its input fields    */
specifier|public
specifier|static
name|RelNode
name|permute
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Permutation
name|permutation
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
if|if
condition|(
name|permutation
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
return|return
name|rel
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|LogicalCalc
condition|)
block|{
name|LogicalCalc
name|calc
init|=
operator|(
name|LogicalCalc
operator|)
name|rel
decl_stmt|;
name|Permutation
name|permutation1
init|=
name|calc
operator|.
name|getProgram
argument_list|()
operator|.
name|getPermutation
argument_list|()
decl_stmt|;
if|if
condition|(
name|permutation1
operator|!=
literal|null
condition|)
block|{
name|Permutation
name|permutation2
init|=
name|permutation
operator|.
name|product
argument_list|(
name|permutation1
argument_list|)
decl_stmt|;
return|return
name|permute
argument_list|(
name|rel
argument_list|,
name|permutation2
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|rel
operator|instanceof
name|LogicalProject
condition|)
block|{
name|Permutation
name|permutation1
init|=
operator|(
operator|(
name|LogicalProject
operator|)
name|rel
operator|)
operator|.
name|getPermutation
argument_list|()
decl_stmt|;
if|if
condition|(
name|permutation1
operator|!=
literal|null
condition|)
block|{
name|Permutation
name|permutation2
init|=
name|permutation
operator|.
name|product
argument_list|(
name|permutation1
argument_list|)
decl_stmt|;
return|return
name|permute
argument_list|(
name|rel
argument_list|,
name|permutation2
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|outputTypeList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|outputNameList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|rel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|permutation
operator|.
name|getTargetCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|target
init|=
name|permutation
operator|.
name|getTarget
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeField
name|targetField
init|=
name|fields
operator|.
name|get
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|outputTypeList
operator|.
name|add
argument_list|(
name|targetField
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|outputNameList
operator|.
name|add
argument_list|(
operator|(
operator|(
name|fieldNames
operator|==
literal|null
operator|)
operator|||
operator|(
name|fieldNames
operator|.
name|size
argument_list|()
operator|<=
name|i
operator|)
operator|||
operator|(
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
operator|)
operator|)
condition|?
name|targetField
operator|.
name|getName
argument_list|()
else|:
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|exprList
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|int
name|source
init|=
name|permutation
operator|.
name|getSource
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|projectRefList
operator|.
name|add
argument_list|(
operator|new
name|RexLocalRef
argument_list|(
name|source
argument_list|,
name|fields
operator|.
name|get
argument_list|(
name|source
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RexProgram
name|program
init|=
operator|new
name|RexProgram
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|exprList
argument_list|,
name|projectRefList
argument_list|,
literal|null
argument_list|,
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|outputTypeList
argument_list|,
name|outputNameList
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|LogicalCalc
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|program
argument_list|)
return|;
block|}
comment|/**    * Creates a relational expression that projects the given fields of the    * input.    *    *<p>Optimizes if the fields are the identity projection.    *    * @param factory ProjectFactory    * @param child Input relational expression    * @param posList Source of each projected field    * @return Relational expression that projects given fields    */
specifier|public
specifier|static
name|RelNode
name|createProject
parameter_list|(
specifier|final
name|RelFactories
operator|.
name|ProjectFactory
name|factory
parameter_list|,
specifier|final
name|RelNode
name|child
parameter_list|,
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|posList
parameter_list|)
block|{
name|RelDataType
name|rowType
init|=
name|child
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|rowType
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelBuilder
operator|.
name|proto
argument_list|(
name|factory
argument_list|)
operator|.
name|create
argument_list|(
name|child
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|AbstractList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|posList
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
specifier|final
name|int
name|pos
init|=
name|posList
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|child
argument_list|,
name|pos
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|Util
operator|.
name|select
argument_list|(
name|fieldNames
argument_list|,
name|posList
argument_list|)
decl_stmt|;
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|child
argument_list|)
operator|.
name|projectNamed
argument_list|(
name|exprs
argument_list|,
name|names
argument_list|,
literal|false
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|projectMapping
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Mapping
name|mapping
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|,
name|RelFactories
operator|.
name|ProjectFactory
name|projectFactory
parameter_list|)
block|{
assert|assert
name|mapping
operator|.
name|getMappingType
argument_list|()
operator|.
name|isSingleSource
argument_list|()
assert|;
assert|assert
name|mapping
operator|.
name|getMappingType
argument_list|()
operator|.
name|isMandatorySource
argument_list|()
assert|;
if|if
condition|(
name|mapping
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
return|return
name|rel
return|;
block|}
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|outputNameList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mapping
operator|.
name|getTargetCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|source
init|=
name|mapping
operator|.
name|getSource
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeField
name|sourceField
init|=
name|fields
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|outputNameList
operator|.
name|add
argument_list|(
operator|(
operator|(
name|fieldNames
operator|==
literal|null
operator|)
operator|||
operator|(
name|fieldNames
operator|.
name|size
argument_list|()
operator|<=
name|i
operator|)
operator|||
operator|(
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
operator|)
operator|)
condition|?
name|sourceField
operator|.
name|getName
argument_list|()
else|:
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|exprList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|rel
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|projectFactory
operator|.
name|createProject
argument_list|(
name|rel
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|exprList
argument_list|,
name|outputNameList
argument_list|)
return|;
block|}
comment|/** Predicate for if a {@link Calc} does not contain windowed aggregates. */
specifier|public
specifier|static
name|boolean
name|notContainsWindowedAgg
parameter_list|(
name|Calc
name|calc
parameter_list|)
block|{
return|return
operator|!
name|calc
operator|.
name|containsOver
argument_list|()
return|;
block|}
comment|/** Predicate for if a {@link Filter} does not windowed aggregates. */
specifier|public
specifier|static
name|boolean
name|notContainsWindowedAgg
parameter_list|(
name|Filter
name|filter
parameter_list|)
block|{
return|return
operator|!
name|filter
operator|.
name|containsOver
argument_list|()
return|;
block|}
comment|/** Predicate for if a {@link Project} does not contain windowed aggregates. */
specifier|public
specifier|static
name|boolean
name|notContainsWindowedAgg
parameter_list|(
name|Project
name|project
parameter_list|)
block|{
return|return
operator|!
name|project
operator|.
name|containsOver
argument_list|()
return|;
block|}
comment|/** Policies for handling two- and three-valued boolean logic. */
specifier|public
enum|enum
name|Logic
block|{
comment|/** Three-valued boolean logic. */
name|TRUE_FALSE_UNKNOWN
block|,
comment|/** Nulls are not possible. */
name|TRUE_FALSE
block|,
comment|/** Two-valued logic where UNKNOWN is treated as FALSE.      *      *<p>"x IS TRUE" produces the same result, and "WHERE x", "JOIN ... ON x"      * and "HAVING x" have the same effect. */
name|UNKNOWN_AS_FALSE
block|,
comment|/** Two-valued logic where UNKNOWN is treated as TRUE.      *      *<p>"x IS FALSE" produces the same result, as does "WHERE NOT x", etc.      *      *<p>In particular, this is the mode used by "WHERE k NOT IN q". If      * "k IN q" produces TRUE or UNKNOWN, "NOT k IN q" produces FALSE or      * UNKNOWN and the row is eliminated; if "k IN q" it returns FALSE, the      * row is retained by the WHERE clause. */
name|UNKNOWN_AS_TRUE
block|,
comment|/** A semi-join will have been applied, so that only rows for which the      * value is TRUE will have been returned. */
name|TRUE
block|,
comment|/** An anti-semi-join will have been applied, so that only rows for which      * the value is FALSE will have been returned.      *      *<p>Currently only used within {@link LogicVisitor}, to ensure that      * 'NOT (NOT EXISTS (q))' behaves the same as 'EXISTS (q)') */
name|FALSE
block|;
specifier|public
name|Logic
name|negate
parameter_list|()
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|UNKNOWN_AS_FALSE
case|:
case|case
name|TRUE
case|:
return|return
name|UNKNOWN_AS_TRUE
return|;
case|case
name|UNKNOWN_AS_TRUE
case|:
return|return
name|UNKNOWN_AS_FALSE
return|;
default|default:
return|return
name|this
return|;
block|}
block|}
comment|/** Variant of {@link #negate()} to be used within {@link LogicVisitor},      * where FALSE values may exist. */
specifier|public
name|Logic
name|negate2
parameter_list|()
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|FALSE
case|:
return|return
name|TRUE
return|;
case|case
name|TRUE
case|:
return|return
name|FALSE
return|;
case|case
name|UNKNOWN_AS_FALSE
case|:
return|return
name|UNKNOWN_AS_TRUE
return|;
case|case
name|UNKNOWN_AS_TRUE
case|:
return|return
name|UNKNOWN_AS_FALSE
return|;
default|default:
return|return
name|this
return|;
block|}
block|}
block|}
comment|/**    * Pushes down expressions in "equal" join condition.    *    *<p>For example, given    * "emp JOIN dept ON emp.deptno + 1 = dept.deptno", adds a project above    * "emp" that computes the expression    * "emp.deptno + 1". The resulting join condition is a simple combination    * of AND, equals, and input fields, plus the remaining non-equal conditions.    *    * @param originalJoin Join whose condition is to be pushed down    * @param relBuilder Factory to create project operator    */
specifier|public
specifier|static
name|RelNode
name|pushDownJoinConditions
parameter_list|(
name|Join
name|originalJoin
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|)
block|{
name|RexNode
name|joinCond
init|=
name|originalJoin
operator|.
name|getCondition
argument_list|()
decl_stmt|;
specifier|final
name|JoinRelType
name|joinType
init|=
name|originalJoin
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraLeftExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraRightExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|leftCount
init|=
name|originalJoin
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|rightCount
init|=
name|originalJoin
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
comment|// You cannot push a 'get' because field names might change.
comment|//
comment|// Pushing sub-queries is OK in principle (if they don't reference both
comment|// sides of the join via correlating variables) but we'd rather not do it
comment|// yet.
if|if
condition|(
operator|!
name|containsGet
argument_list|(
name|joinCond
argument_list|)
operator|&&
name|RexUtil
operator|.
name|SubQueryFinder
operator|.
name|find
argument_list|(
name|joinCond
argument_list|)
operator|==
literal|null
condition|)
block|{
name|joinCond
operator|=
name|pushDownEqualJoinConditions
argument_list|(
name|joinCond
argument_list|,
name|leftCount
argument_list|,
name|rightCount
argument_list|,
name|extraLeftExprs
argument_list|,
name|extraRightExprs
argument_list|,
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|push
argument_list|(
name|originalJoin
operator|.
name|getLeft
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extraLeftExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
annotation|@
name|Nullable
name|String
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|AbstractList
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
annotation|@
name|Nullable
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|RexNode
argument_list|,
annotation|@
name|Nullable
name|String
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
name|leftCount
condition|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|index
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|extraLeftExprs
operator|.
name|get
argument_list|(
name|index
operator|-
name|leftCount
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
block|}
decl_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|pairs
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|pairs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|push
argument_list|(
name|originalJoin
operator|.
name|getRight
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extraRightExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|newLeftCount
init|=
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
annotation|@
name|Nullable
name|String
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|AbstractList
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
annotation|@
name|Nullable
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rightCount
operator|+
name|extraRightExprs
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|RexNode
argument_list|,
annotation|@
name|Nullable
name|String
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
name|rightCount
condition|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|index
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|RexUtil
operator|.
name|shift
argument_list|(
name|extraRightExprs
operator|.
name|get
argument_list|(
name|index
operator|-
name|rightCount
argument_list|)
argument_list|,
operator|-
name|newLeftCount
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
block|}
decl_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|pairs
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|pairs
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|right
init|=
name|relBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|left
init|=
name|relBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|originalJoin
operator|.
name|copy
argument_list|(
name|originalJoin
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|joinCond
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|joinType
argument_list|,
name|originalJoin
operator|.
name|isSemiJoinDone
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extraLeftExprs
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|extraRightExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|int
name|totalFields
init|=
name|joinType
operator|.
name|projectsRight
argument_list|()
condition|?
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
operator|+
name|rightCount
operator|+
name|extraRightExprs
operator|.
name|size
argument_list|()
else|:
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
index|[]
name|mappingRanges
init|=
name|joinType
operator|.
name|projectsRight
argument_list|()
condition|?
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|,
name|leftCount
block|,
name|leftCount
block|,
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
block|,
name|rightCount
block|}
else|:
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|,
name|leftCount
block|}
decl_stmt|;
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Mappings
operator|.
name|createShiftMapping
argument_list|(
name|totalFields
argument_list|,
name|mappingRanges
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|fields
argument_list|(
name|mapping
operator|.
name|inverse
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|relBuilder
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|pushDownJoinConditions
parameter_list|(
name|Join
name|originalJoin
parameter_list|)
block|{
return|return
name|pushDownJoinConditions
argument_list|(
name|originalJoin
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|pushDownJoinConditions
parameter_list|(
name|Join
name|originalJoin
parameter_list|,
name|RelFactories
operator|.
name|ProjectFactory
name|projectFactory
parameter_list|)
block|{
return|return
name|pushDownJoinConditions
argument_list|(
name|originalJoin
argument_list|,
name|RelBuilder
operator|.
name|proto
argument_list|(
name|projectFactory
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RelNode
name|pushDownJoinConditions
parameter_list|(
name|Join
name|originalJoin
parameter_list|,
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
return|return
name|pushDownJoinConditions
argument_list|(
name|originalJoin
argument_list|,
name|relBuilderFactory
operator|.
name|create
argument_list|(
name|originalJoin
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|containsGet
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
try|try
block|{
name|node
operator|.
name|accept
argument_list|(
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|RexBuilder
operator|.
name|GET_OPERATOR
condition|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Pushes down parts of a join condition.    *    *<p>For example, given    * "emp JOIN dept ON emp.deptno + 1 = dept.deptno", adds a project above    * "emp" that computes the expression    * "emp.deptno + 1". The resulting join condition is a simple combination    * of AND, equals, and input fields.    */
specifier|private
specifier|static
name|RexNode
name|pushDownEqualJoinConditions
parameter_list|(
name|RexNode
name|condition
parameter_list|,
name|int
name|leftCount
parameter_list|,
name|int
name|rightCount
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraLeftExprs
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraRightExprs
parameter_list|,
name|RexBuilder
name|builder
parameter_list|)
block|{
comment|// Normalize the condition first
name|RexNode
name|node
init|=
operator|(
name|condition
operator|instanceof
name|RexCall
operator|)
condition|?
name|collapseExpandedIsNotDistinctFromExpr
argument_list|(
operator|(
name|RexCall
operator|)
name|condition
argument_list|,
name|builder
argument_list|)
else|:
name|condition
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
case|case
name|IS_NOT_DISTINCT_FROM
case|:
specifier|final
name|RexCall
name|call0
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
specifier|final
name|RexNode
name|leftRex
init|=
name|call0
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|rightRex
init|=
name|call0
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|leftBits
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|leftRex
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|rightBits
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|rightRex
argument_list|)
decl_stmt|;
specifier|final
name|int
name|pivot
init|=
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
name|Side
name|lside
init|=
name|Side
operator|.
name|of
argument_list|(
name|leftBits
argument_list|,
name|pivot
argument_list|)
decl_stmt|;
name|Side
name|rside
init|=
name|Side
operator|.
name|of
argument_list|(
name|rightBits
argument_list|,
name|pivot
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lside
operator|.
name|opposite
argument_list|(
name|rside
argument_list|)
condition|)
block|{
return|return
name|call0
return|;
block|}
comment|// fall through
case|case
name|AND
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|operand
init|=
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand
operator|instanceof
name|RexCall
condition|)
block|{
name|operand
operator|=
name|collapseExpandedIsNotDistinctFromExpr
argument_list|(
operator|(
name|RexCall
operator|)
name|operand
argument_list|,
name|builder
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
operator|&&
name|operand
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|EQUALS
operator|&&
name|operand
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|IS_NOT_DISTINCT_FROM
condition|)
block|{
comment|// one of the join condition is neither EQ nor INDF
name|list
operator|.
name|add
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|left2
init|=
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|e
init|=
name|pushDownEqualJoinConditions
argument_list|(
name|operand
argument_list|,
name|leftCount
argument_list|,
name|rightCount
argument_list|,
name|extraLeftExprs
argument_list|,
name|extraRightExprs
argument_list|,
name|builder
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|e
operator|.
name|equals
argument_list|(
name|operand
argument_list|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|remainingOperands
init|=
name|Util
operator|.
name|skip
argument_list|(
name|operands
argument_list|,
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|int
name|left3
init|=
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
name|fix
argument_list|(
name|remainingOperands
argument_list|,
name|left2
argument_list|,
name|left3
argument_list|)
expr_stmt|;
name|fix
argument_list|(
name|list
argument_list|,
name|left2
argument_list|,
name|left3
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|list
operator|.
name|equals
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|call
operator|.
name|clone
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|list
argument_list|)
return|;
block|}
return|return
name|call
return|;
case|case
name|OR
case|:
case|case
name|INPUT_REF
case|:
case|case
name|LITERAL
case|:
case|case
name|NOT
case|:
return|return
name|node
return|;
default|default:
specifier|final
name|ImmutableBitSet
name|bits
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|final
name|int
name|mid
init|=
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|Side
operator|.
name|of
argument_list|(
name|bits
argument_list|,
name|mid
argument_list|)
condition|)
block|{
case|case
name|LEFT
case|:
name|fix
argument_list|(
name|extraRightExprs
argument_list|,
name|mid
argument_list|,
name|mid
operator|+
literal|1
argument_list|)
expr_stmt|;
name|extraLeftExprs
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|mid
argument_list|,
name|node
operator|.
name|getType
argument_list|()
argument_list|)
return|;
case|case
name|RIGHT
case|:
specifier|final
name|int
name|index2
init|=
name|mid
operator|+
name|rightCount
operator|+
name|extraRightExprs
operator|.
name|size
argument_list|()
decl_stmt|;
name|extraRightExprs
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|index2
argument_list|,
name|node
operator|.
name|getType
argument_list|()
argument_list|)
return|;
case|case
name|BOTH
case|:
case|case
name|EMPTY
case|:
default|default:
return|return
name|node
return|;
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|fix
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|,
name|int
name|before
parameter_list|,
name|int
name|after
parameter_list|)
block|{
if|if
condition|(
name|before
operator|==
name|after
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|node
init|=
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|operands
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|RexUtil
operator|.
name|shift
argument_list|(
name|node
argument_list|,
name|before
argument_list|,
name|after
operator|-
name|before
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Determines whether any of the fields in a given relational expression may    * contain null values, taking into account constraints on the field types and    * also deduced predicates.    *    *<p>The method is cautious: It may sometimes return {@code true} when the    * actual answer is {@code false}. In particular, it does this when there    * is no executor, or the executor is not a sub-class of    * {@link RexExecutorImpl}.    */
specifier|private
specifier|static
name|boolean
name|containsNullableFields
parameter_list|(
name|RelNode
name|r
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|r
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|r
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|r
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// All columns are declared NOT NULL.
return|return
literal|false
return|;
block|}
specifier|final
name|RelOptPredicateList
name|predicates
init|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|RelOptPredicateList
operator|.
name|isEmpty
argument_list|(
name|predicates
argument_list|)
condition|)
block|{
comment|// We have no predicates, so cannot deduce that any of the fields
comment|// declared NULL are really NOT NULL.
return|return
literal|true
return|;
block|}
specifier|final
name|RexExecutor
name|executor
init|=
name|r
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|.
name|getExecutor
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|executor
operator|instanceof
name|RexExecutorImpl
operator|)
condition|)
block|{
comment|// Cannot proceed without an executor.
return|return
literal|true
return|;
block|}
specifier|final
name|RexImplicationChecker
name|checker
init|=
operator|new
name|RexImplicationChecker
argument_list|(
name|rexBuilder
argument_list|,
name|executor
argument_list|,
name|rowType
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|first
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|predicates
operator|.
name|pulledUpPredicates
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|second
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|list
argument_list|)
decl_stmt|;
comment|// Suppose we have EMP(empno INT NOT NULL, mgr INT),
comment|// and predicates [empno> 0, mgr> 0].
comment|// We make first: "empno> 0 AND mgr> 0"
comment|// and second: "mgr IS NOT NULL"
comment|// and ask whether first implies second.
comment|// It does, so we have no nullable columns.
return|return
operator|!
name|checker
operator|.
name|implies
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * A {@code RelShuttle} which propagates all the hints of relational expression to    * their children nodes.    *    *<p>Given a plan:    *    *<blockquote><pre>    *            Filter (Hint1)    *                |    *               Join    *              /    \    *            Scan  Project (Hint2)    *                     |    *                    Scan2    *</pre></blockquote>    *    *<p>Every hint has a {@code inheritPath} (integers list) which records its propagate path,    * number `0` represents the hint is propagated from the first(left) child,    * number `1` represents the hint is propagated from the second(right) child,    * so the plan would have hints path as follows    * (assumes each hint can be propagated to all child nodes):    *    *<ul>    *<li>Filter would have hints {Hint1[]}</li>    *<li>Join would have hints {Hint1[0]}</li>    *<li>Scan would have hints {Hint1[0, 0]}</li>    *<li>Project would have hints {Hint1[0,1], Hint2[]}</li>    *<li>Scan2 would have hints {[Hint1[0, 1, 0], Hint2[0]}</li>    *</ul>    */
specifier|private
specifier|static
class|class
name|RelHintPropagateShuttle
extends|extends
name|RelHomogeneousShuttle
block|{
comment|/**      * Stack recording the hints and its current inheritPath.      */
specifier|private
specifier|final
name|Deque
argument_list|<
name|Pair
argument_list|<
name|List
argument_list|<
name|RelHint
argument_list|>
argument_list|,
name|Deque
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|>
name|inheritPaths
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * The hint strategies to decide if a hint should be attached to      * a relational expression.      */
specifier|private
specifier|final
name|HintStrategyTable
name|hintStrategies
decl_stmt|;
name|RelHintPropagateShuttle
parameter_list|(
name|HintStrategyTable
name|hintStrategies
parameter_list|)
block|{
name|this
operator|.
name|hintStrategies
operator|=
name|hintStrategies
expr_stmt|;
block|}
comment|/**      * Visits a particular child of a parent.      */
annotation|@
name|Override
specifier|protected
name|RelNode
name|visitChild
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|i
parameter_list|,
name|RelNode
name|child
parameter_list|)
block|{
name|inheritPaths
operator|.
name|forEach
argument_list|(
name|inheritPath
lambda|->
name|inheritPath
operator|.
name|right
operator|.
name|push
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|RelNode
name|child2
init|=
name|child
operator|.
name|accept
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|child2
operator|!=
name|child
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|newInputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|parent
operator|.
name|getInputs
argument_list|()
argument_list|)
decl_stmt|;
name|newInputs
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|child2
argument_list|)
expr_stmt|;
return|return
name|parent
operator|.
name|copy
argument_list|(
name|parent
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newInputs
argument_list|)
return|;
block|}
return|return
name|parent
return|;
block|}
finally|finally
block|{
name|inheritPaths
operator|.
name|forEach
argument_list|(
name|inheritPath
lambda|->
name|inheritPath
operator|.
name|right
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|visit
parameter_list|(
name|RelNode
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|instanceof
name|Hintable
condition|)
block|{
return|return
name|visitHintable
argument_list|(
name|other
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|visitChildren
argument_list|(
name|other
argument_list|)
return|;
block|}
block|}
comment|/**      * Handle the {@link Hintable}s.      *      *<p>There are two cases to handle hints:      *      *<ul>      *<li>For TableScan: table scan is always a leaf node,      *   attach the hints of the propagation path directly;</li>      *<li>For other {@link Hintable}s: if the node has hints itself, that means,      *   these hints are query hints that need to propagate to its children,      *   so we do these things:      *<ol>      *<li>push the hints with empty inheritPath to the stack</li>      *<li>visit the children nodes and propagate the hints</li>      *<li>pop the hints pushed in step1</li>      *<li>attach the hints of the propagation path</li>      *</ol>      *   if the node does not have hints, attach the hints of the propagation path directly.      *</li>      *</ul>      *      * @param node {@link Hintable} to handle      * @return New copy of the {@code hintable} with propagated hints attached      */
specifier|private
name|RelNode
name|visitHintable
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|topHints
init|=
operator|(
operator|(
name|Hintable
operator|)
name|node
operator|)
operator|.
name|getHints
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|hasHints
init|=
name|topHints
operator|!=
literal|null
operator|&&
name|topHints
operator|.
name|size
argument_list|()
operator|>
literal|0
decl_stmt|;
specifier|final
name|boolean
name|hasQueryHints
init|=
name|hasHints
operator|&&
operator|!
operator|(
name|node
operator|instanceof
name|TableScan
operator|)
decl_stmt|;
if|if
condition|(
name|hasQueryHints
condition|)
block|{
name|inheritPaths
operator|.
name|push
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|topHints
argument_list|,
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|node1
init|=
name|visitChildren
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasQueryHints
condition|)
block|{
name|inheritPaths
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
return|return
name|attachHints
argument_list|(
name|node1
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|attachHints
parameter_list|(
name|RelNode
name|original
parameter_list|)
block|{
assert|assert
name|original
operator|instanceof
name|Hintable
assert|;
if|if
condition|(
name|inheritPaths
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|hints
init|=
name|inheritPaths
operator|.
name|stream
argument_list|()
operator|.
name|sorted
argument_list|(
name|Comparator
operator|.
name|comparingInt
argument_list|(
name|o
lambda|->
name|o
operator|.
name|right
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
operator|.
name|map
argument_list|(
name|path
lambda|->
name|copyWithInheritPath
argument_list|(
name|path
operator|.
name|left
argument_list|,
name|path
operator|.
name|right
argument_list|)
argument_list|)
operator|.
name|reduce
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|,
parameter_list|(
name|acc
parameter_list|,
name|hints1
parameter_list|)
lambda|->
block|{
name|acc
operator|.
name|addAll
argument_list|(
name|hints1
argument_list|)
argument_list|;
return|return
name|acc
return|;
block|}
block_content|)
function|;
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|filteredHints
init|=
name|hintStrategies
operator|.
name|apply
argument_list|(
name|hints
argument_list|,
name|original
argument_list|)
decl_stmt|;
if|if
condition|(
name|filteredHints
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
operator|(
operator|(
name|Hintable
operator|)
name|original
operator|)
operator|.
name|attachHints
argument_list|(
name|filteredHints
argument_list|)
return|;
block|}
block|}
return|return
name|original
return|;
block|}
end_class

begin_function
specifier|private
specifier|static
name|List
argument_list|<
name|RelHint
argument_list|>
name|copyWithInheritPath
parameter_list|(
name|List
argument_list|<
name|RelHint
argument_list|>
name|hints
parameter_list|,
name|Deque
argument_list|<
name|Integer
argument_list|>
name|inheritPath
parameter_list|)
block|{
comment|// Copy the Dequeue in reverse order.
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|path
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
init|=
name|inheritPath
operator|.
name|descendingIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|path
operator|.
name|add
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|hints
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|hint
lambda|->
name|hint
operator|.
name|copy
argument_list|(
name|path
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
unit|}
comment|/**    * A {@code RelShuttle} which propagates the given hints to the sub-tree from the root node.    * It stops the search of current path if the node already has hints or the whole propagation    * if there is already a matched node.    *    *<p>Given a plan:    *    *<blockquote><pre>    *            Filter    *                |    *               Join    *              /    \    *            Scan  Project (Hint2)    *                     |    *                    Scan2    *</pre></blockquote>    *    *<p>The [Filter, Join, Scan] are the candidates(in sequence) to propagate,    * the whole propagation ends if we append the given hints to a node successfully.    */
end_comment

begin_class
unit|private
specifier|static
class|class
name|SubTreeHintPropagateShuttle
extends|extends
name|RelHomogeneousShuttle
block|{
comment|/** Stack recording the appended inheritPath. */
specifier|private
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|appendPath
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * The hint strategies to decide if a hint should be attached to      * a relational expression.      */
specifier|private
specifier|final
name|HintStrategyTable
name|hintStrategies
decl_stmt|;
comment|/** Hints to propagate. */
specifier|private
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|hints
decl_stmt|;
name|SubTreeHintPropagateShuttle
parameter_list|(
name|HintStrategyTable
name|hintStrategies
parameter_list|,
name|List
argument_list|<
name|RelHint
argument_list|>
name|hints
parameter_list|)
block|{
name|this
operator|.
name|hintStrategies
operator|=
name|hintStrategies
expr_stmt|;
name|this
operator|.
name|hints
operator|=
name|hints
expr_stmt|;
block|}
comment|/**      * Visits a particular child of a parent.      */
annotation|@
name|Override
specifier|protected
name|RelNode
name|visitChild
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|i
parameter_list|,
name|RelNode
name|child
parameter_list|)
block|{
name|appendPath
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
try|try
block|{
name|RelNode
name|child2
init|=
name|child
operator|.
name|accept
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|child2
operator|!=
name|child
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|newInputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|parent
operator|.
name|getInputs
argument_list|()
argument_list|)
decl_stmt|;
name|newInputs
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|child2
argument_list|)
expr_stmt|;
return|return
name|parent
operator|.
name|copy
argument_list|(
name|parent
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newInputs
argument_list|)
return|;
block|}
return|return
name|parent
return|;
block|}
finally|finally
block|{
comment|// Remove the last element.
name|appendPath
operator|.
name|remove
argument_list|(
name|appendPath
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|visit
parameter_list|(
name|RelNode
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|appendPath
operator|.
name|size
argument_list|()
operator|>
literal|3
condition|)
block|{
comment|// Returns early if the visiting depth is bigger than 3
return|return
name|other
return|;
block|}
if|if
condition|(
name|other
operator|instanceof
name|Hintable
condition|)
block|{
return|return
name|visitHintable
argument_list|(
name|other
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|visitChildren
argument_list|(
name|other
argument_list|)
return|;
block|}
block|}
comment|/**      * Handle the {@link Hintable}s.      *      *<p>Try to propagate the given hints to the node, the propagation finishes if:      *      *<ul>      *<li>This hintable already has hints, that means, the rel is definitely      *   not created by a planner rule(or copied by the planner rule)</li>      *<li>This hintable appended the hints successfully</li>      *</ul>      *      * @param node {@link Hintable} to handle      * @return New copy of the {@code hintable} with propagated hints attached      */
specifier|private
name|RelNode
name|visitHintable
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|topHints
init|=
operator|(
operator|(
name|Hintable
operator|)
name|node
operator|)
operator|.
name|getHints
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|hasHints
init|=
name|topHints
operator|!=
literal|null
operator|&&
name|topHints
operator|.
name|size
argument_list|()
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|hasHints
condition|)
block|{
comment|// This node is definitely not created by the planner, returns early.
return|return
name|node
return|;
block|}
specifier|final
name|RelNode
name|node1
init|=
name|attachHints
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|node1
operator|!=
name|node
condition|)
block|{
return|return
name|node1
return|;
block|}
return|return
name|visitChildren
argument_list|(
name|node
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|attachHints
parameter_list|(
name|RelNode
name|original
parameter_list|)
block|{
assert|assert
name|original
operator|instanceof
name|Hintable
assert|;
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|hints
init|=
name|this
operator|.
name|hints
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|hint
lambda|->
name|copyWithAppendPath
argument_list|(
name|hint
argument_list|,
name|appendPath
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|filteredHints
init|=
name|hintStrategies
operator|.
name|apply
argument_list|(
name|hints
argument_list|,
name|original
argument_list|)
decl_stmt|;
if|if
condition|(
name|filteredHints
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
operator|(
operator|(
name|Hintable
operator|)
name|original
operator|)
operator|.
name|attachHints
argument_list|(
name|filteredHints
argument_list|)
return|;
block|}
return|return
name|original
return|;
block|}
specifier|private
specifier|static
name|RelHint
name|copyWithAppendPath
parameter_list|(
name|RelHint
name|hint
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|appendPaths
parameter_list|)
block|{
if|if
condition|(
name|appendPaths
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|hint
return|;
block|}
else|else
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|newPath
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|hint
operator|.
name|inheritPath
argument_list|)
decl_stmt|;
name|newPath
operator|.
name|addAll
argument_list|(
name|appendPaths
argument_list|)
expr_stmt|;
return|return
name|hint
operator|.
name|copy
argument_list|(
name|newPath
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|/**    * A {@code RelShuttle} which resets all the hints of a relational expression to    * what they are originally like.    *    *<p>This would trigger a reverse transformation of what    * {@link RelHintPropagateShuttle} does.    *    *<p>Transformation rules:    *    *<ul>    *<li>Project: remove the hints that have non-empty inherit path    *   (which means the hint was not originally declared from it);    *<li>Aggregate: remove the hints that have non-empty inherit path;    *<li>Join: remove all the hints;    *<li>TableScan: remove the hints that have non-empty inherit path.    *</ul>    */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|ResetHintsShuttle
extends|extends
name|RelHomogeneousShuttle
block|{
annotation|@
name|Override
specifier|public
name|RelNode
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
name|node
operator|=
name|visitChildren
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|Hintable
condition|)
block|{
name|node
operator|=
name|resetHints
argument_list|(
operator|(
name|Hintable
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
specifier|private
specifier|static
name|RelNode
name|resetHints
parameter_list|(
name|Hintable
name|hintable
parameter_list|)
block|{
if|if
condition|(
name|hintable
operator|.
name|getHints
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|resetHints
init|=
name|hintable
operator|.
name|getHints
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|hint
lambda|->
name|hint
operator|.
name|inheritPath
operator|.
name|size
argument_list|()
operator|==
literal|0
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|hintable
operator|.
name|withHints
argument_list|(
name|resetHints
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|RelNode
operator|)
name|hintable
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|/** Visitor that finds all variables used but not stopped in an expression. */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|VariableSetVisitor
extends|extends
name|RelVisitor
block|{
specifier|final
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|variables
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// implement RelVisitor
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|p
parameter_list|,
name|int
name|ordinal
parameter_list|,
annotation|@
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
name|RelNode
name|parent
parameter_list|)
block|{
name|super
operator|.
name|visit
argument_list|(
name|p
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|p
operator|.
name|collectVariablesUsed
argument_list|(
name|variables
argument_list|)
expr_stmt|;
comment|// Important! Remove stopped variables AFTER we visit children
comment|// (which what super.visit() does)
name|variables
operator|.
name|removeAll
argument_list|(
name|p
operator|.
name|getVariablesSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/** Visitor that finds all variables used in an expression. */
end_comment

begin_class
specifier|public
specifier|static
class|class
name|VariableUsedVisitor
extends|extends
name|RexShuttle
block|{
specifier|public
specifier|final
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|variables
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
specifier|final
name|Multimap
argument_list|<
name|CorrelationId
argument_list|,
name|Integer
argument_list|>
name|variableFields
init|=
name|LinkedHashMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|NotOnlyInitialized
specifier|private
specifier|final
annotation|@
name|Nullable
name|RelShuttle
name|relShuttle
decl_stmt|;
specifier|public
name|VariableUsedVisitor
parameter_list|(
annotation|@
name|UnknownInitialization
annotation|@
name|Nullable
name|RelShuttle
name|relShuttle
parameter_list|)
block|{
name|this
operator|.
name|relShuttle
operator|=
name|relShuttle
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|p
parameter_list|)
block|{
name|variables
operator|.
name|add
argument_list|(
name|p
operator|.
name|id
argument_list|)
expr_stmt|;
name|variableFields
operator|.
name|put
argument_list|(
name|p
operator|.
name|id
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
if|if
condition|(
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
operator|instanceof
name|RexCorrelVariable
condition|)
block|{
specifier|final
name|RexCorrelVariable
name|v
init|=
operator|(
name|RexCorrelVariable
operator|)
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
decl_stmt|;
name|variableFields
operator|.
name|put
argument_list|(
name|v
operator|.
name|id
argument_list|,
name|fieldAccess
operator|.
name|getField
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|visitFieldAccess
argument_list|(
name|fieldAccess
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitSubQuery
parameter_list|(
name|RexSubQuery
name|subQuery
parameter_list|)
block|{
if|if
condition|(
name|relShuttle
operator|!=
literal|null
condition|)
block|{
name|subQuery
operator|.
name|rel
operator|.
name|accept
argument_list|(
name|relShuttle
argument_list|)
expr_stmt|;
comment|// look inside sub-queries
block|}
return|return
name|super
operator|.
name|visitSubQuery
argument_list|(
name|subQuery
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/** Shuttle that finds the set of inputs that are used. */
end_comment

begin_class
specifier|public
specifier|static
class|class
name|InputReferencedVisitor
extends|extends
name|RexShuttle
block|{
specifier|public
specifier|final
name|NavigableSet
argument_list|<
name|Integer
argument_list|>
name|inputPosReferenced
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|inputPosReferenced
operator|.
name|add
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|inputRef
return|;
block|}
block|}
end_class

begin_comment
comment|/** Converts types to descriptive strings. */
end_comment

begin_class
specifier|public
specifier|static
class|class
name|TypeDumper
block|{
specifier|private
name|String
name|indent
decl_stmt|;
specifier|private
specifier|final
name|PrintWriter
name|pw
decl_stmt|;
name|TypeDumper
parameter_list|(
name|PrintWriter
name|pw
parameter_list|)
block|{
name|this
operator|.
name|pw
operator|=
name|pw
expr_stmt|;
name|this
operator|.
name|indent
operator|=
literal|""
expr_stmt|;
block|}
name|void
name|accept
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|type
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
comment|// RECORD (
comment|//   I INTEGER NOT NULL,
comment|//   J VARCHAR(240))
name|pw
operator|.
name|println
argument_list|(
literal|"RECORD ("
argument_list|)
expr_stmt|;
name|String
name|prevIndent
init|=
name|indent
decl_stmt|;
name|String
name|extraIndent
init|=
literal|"  "
decl_stmt|;
name|this
operator|.
name|indent
operator|=
name|indent
operator|+
name|extraIndent
expr_stmt|;
name|acceptFields
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|this
operator|.
name|indent
operator|=
name|prevIndent
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|NON_NULLABLE_SUFFIX
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|type
operator|instanceof
name|MultisetSqlType
condition|)
block|{
comment|// E.g. "INTEGER NOT NULL MULTISET NOT NULL"
name|RelDataType
name|componentType
init|=
name|requireNonNull
argument_list|(
name|type
operator|.
name|getComponentType
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"type.getComponentType() for "
operator|+
name|type
argument_list|)
decl_stmt|;
name|accept
argument_list|(
name|componentType
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" MULTISET"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|NON_NULLABLE_SUFFIX
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// E.g. "INTEGER" E.g. "VARCHAR(240) CHARACTER SET "ISO-8859-1"
comment|// COLLATE "ISO-8859-1$en_US$primary" NOT NULL"
name|pw
operator|.
name|print
argument_list|(
name|type
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|acceptFields
parameter_list|(
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|accept
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|/**    * Visitor which builds a bitmap of the inputs used by an expression.    */
end_comment

begin_class
specifier|public
specifier|static
class|class
name|InputFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|bitBuilder
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
decl_stmt|;
specifier|private
name|InputFinder
parameter_list|(
annotation|@
name|Nullable
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|,
name|ImmutableBitSet
operator|.
name|Builder
name|bitBuilder
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|bitBuilder
operator|=
name|bitBuilder
expr_stmt|;
name|this
operator|.
name|extraFields
operator|=
name|extraFields
expr_stmt|;
block|}
specifier|public
name|InputFinder
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|InputFinder
parameter_list|(
annotation|@
name|Nullable
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
name|this
argument_list|(
name|extraFields
argument_list|,
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|InputFinder
parameter_list|(
annotation|@
name|Nullable
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|,
name|ImmutableBitSet
name|initialBits
parameter_list|)
block|{
name|this
argument_list|(
name|extraFields
argument_list|,
name|initialBits
operator|.
name|rebuild
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Returns an input finder that has analyzed a given expression. */
specifier|public
specifier|static
name|InputFinder
name|analyze
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
specifier|final
name|InputFinder
name|inputFinder
init|=
operator|new
name|InputFinder
argument_list|()
decl_stmt|;
name|node
operator|.
name|accept
argument_list|(
name|inputFinder
argument_list|)
expr_stmt|;
return|return
name|inputFinder
return|;
block|}
comment|/**      * Returns a bit set describing the inputs used by an expression.      */
specifier|public
specifier|static
name|ImmutableBitSet
name|bits
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|analyze
argument_list|(
name|node
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**      * Returns a bit set describing the inputs used by a collection of      * project expressions and an optional condition.      */
specifier|public
specifier|static
name|ImmutableBitSet
name|bits
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|expr
parameter_list|)
block|{
specifier|final
name|InputFinder
name|inputFinder
init|=
operator|new
name|InputFinder
argument_list|()
decl_stmt|;
name|RexUtil
operator|.
name|apply
argument_list|(
name|inputFinder
argument_list|,
name|exprs
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|inputFinder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns the bit set.      *      *<p>After calling this method, you cannot do any more visits or call this      * method again. */
specifier|public
name|ImmutableBitSet
name|build
parameter_list|()
block|{
return|return
name|bitBuilder
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|bitBuilder
operator|.
name|set
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|RexBuilder
operator|.
name|GET_OPERATOR
condition|)
block|{
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|extraFields
operator|!=
literal|null
condition|)
block|{
name|requireNonNull
argument_list|(
name|literal
argument_list|,
parameter_list|()
lambda|->
literal|"first operand in "
operator|+
name|call
argument_list|)
expr_stmt|;
name|String
name|value2
init|=
operator|(
name|String
operator|)
name|literal
operator|.
name|getValue2
argument_list|()
decl_stmt|;
name|requireNonNull
argument_list|(
name|value2
argument_list|,
parameter_list|()
lambda|->
literal|"value of the first operand in "
operator|+
name|call
argument_list|)
expr_stmt|;
name|extraFields
operator|.
name|add
argument_list|(
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|value2
argument_list|,
operator|-
literal|1
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Walks an expression tree, converting the index of RexInputRefs based on    * some adjustment factor.    */
end_comment

begin_class
specifier|public
specifier|static
class|class
name|RexInputConverter
extends|extends
name|RexShuttle
block|{
specifier|protected
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
decl_stmt|;
specifier|protected
specifier|final
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|destFields
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftDestFields
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightDestFields
decl_stmt|;
specifier|private
specifier|final
name|int
name|nLeftDestFields
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|adjustments
decl_stmt|;
comment|/**      * Creates a RexInputConverter.      *      * @param rexBuilder      builder for creating new RexInputRefs      * @param srcFields       fields where the RexInputRefs originated      *                        from; if null, a new RexInputRef is always      *                        created, referencing the input from destFields      *                        corresponding to its current index value      * @param destFields      fields that the new RexInputRefs will be      *                        referencing; if null, use the type information      *                        from the source field when creating the new      *                        RexInputRef      * @param leftDestFields  in the case where the destination is a join,      *                        these are the fields from the left join input      * @param rightDestFields in the case where the destination is a join,      *                        these are the fields from the right join input      * @param adjustments     the amount to adjust each field by      */
specifier|private
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|destFields
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftDestFields
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightDestFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
name|this
operator|.
name|srcFields
operator|=
name|srcFields
expr_stmt|;
name|this
operator|.
name|destFields
operator|=
name|destFields
expr_stmt|;
name|this
operator|.
name|adjustments
operator|=
name|adjustments
expr_stmt|;
name|this
operator|.
name|leftDestFields
operator|=
name|leftDestFields
expr_stmt|;
name|this
operator|.
name|rightDestFields
operator|=
name|rightDestFields
expr_stmt|;
if|if
condition|(
name|leftDestFields
operator|==
literal|null
condition|)
block|{
name|nLeftDestFields
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|destFields
operator|==
literal|null
assert|;
name|nLeftDestFields
operator|=
name|leftDestFields
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftDestFields
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightDestFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|srcFields
argument_list|,
literal|null
argument_list|,
name|leftDestFields
argument_list|,
name|rightDestFields
argument_list|,
name|adjustments
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|destFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|srcFields
argument_list|,
name|destFields
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|adjustments
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|srcFields
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|adjustments
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|var
parameter_list|)
block|{
name|int
name|srcIndex
init|=
name|var
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|int
name|destIndex
init|=
name|srcIndex
operator|+
name|adjustments
index|[
name|srcIndex
index|]
decl_stmt|;
name|RelDataType
name|type
decl_stmt|;
if|if
condition|(
name|destFields
operator|!=
literal|null
condition|)
block|{
name|type
operator|=
name|destFields
operator|.
name|get
argument_list|(
name|destIndex
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|leftDestFields
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|destIndex
operator|<
name|nLeftDestFields
condition|)
block|{
name|type
operator|=
name|leftDestFields
operator|.
name|get
argument_list|(
name|destIndex
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|requireNonNull
argument_list|(
name|rightDestFields
argument_list|,
literal|"rightDestFields"
argument_list|)
operator|.
name|get
argument_list|(
name|destIndex
operator|-
name|nLeftDestFields
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|type
operator|=
name|requireNonNull
argument_list|(
name|srcFields
argument_list|,
literal|"srcFields"
argument_list|)
operator|.
name|get
argument_list|(
name|srcIndex
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|adjustments
index|[
name|srcIndex
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|srcFields
operator|==
literal|null
operator|)
operator|||
operator|(
name|type
operator|!=
name|srcFields
operator|.
name|get
argument_list|(
name|srcIndex
argument_list|)
operator|.
name|getType
argument_list|()
operator|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|type
argument_list|,
name|destIndex
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|var
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|/** What kind of sub-query. */
end_comment

begin_enum
specifier|public
enum|enum
name|SubQueryType
block|{
name|EXISTS
block|,
name|IN
block|,
name|SCALAR
block|}
end_enum

begin_comment
comment|/**    * Categorizes whether a bit set contains bits left and right of a    * line.    */
end_comment

begin_enum
enum|enum
name|Side
block|{
name|LEFT
block|,
name|RIGHT
block|,
name|BOTH
block|,
name|EMPTY
block|;
specifier|static
name|Side
name|of
parameter_list|(
name|ImmutableBitSet
name|bitSet
parameter_list|,
name|int
name|middle
parameter_list|)
block|{
specifier|final
name|int
name|firstBit
init|=
name|bitSet
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstBit
operator|<
literal|0
condition|)
block|{
return|return
name|EMPTY
return|;
block|}
if|if
condition|(
name|firstBit
operator|>=
name|middle
condition|)
block|{
return|return
name|RIGHT
return|;
block|}
if|if
condition|(
name|bitSet
operator|.
name|nextSetBit
argument_list|(
name|middle
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|LEFT
return|;
block|}
return|return
name|BOTH
return|;
block|}
specifier|public
name|boolean
name|opposite
parameter_list|(
name|Side
name|side
parameter_list|)
block|{
return|return
operator|(
name|this
operator|==
name|LEFT
operator|&&
name|side
operator|==
name|RIGHT
operator|)
operator|||
operator|(
name|this
operator|==
name|RIGHT
operator|&&
name|side
operator|==
name|LEFT
operator|)
return|;
block|}
block|}
end_enum

begin_comment
comment|/** Shuttle that finds correlation variables inside a given relational    * expression, including those that are inside    * {@link RexSubQuery sub-queries}. */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|CorrelationCollector
extends|extends
name|RelHomogeneousShuttle
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"assignment.type.incompatible"
argument_list|)
specifier|private
specifier|final
name|VariableUsedVisitor
name|vuv
init|=
operator|new
name|VariableUsedVisitor
argument_list|(
name|this
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|RelNode
name|visit
parameter_list|(
name|RelNode
name|other
parameter_list|)
block|{
name|other
operator|.
name|collectVariablesUsed
argument_list|(
name|vuv
operator|.
name|variables
argument_list|)
expr_stmt|;
name|other
operator|.
name|accept
argument_list|(
name|vuv
argument_list|)
expr_stmt|;
name|RelNode
name|result
init|=
name|super
operator|.
name|visit
argument_list|(
name|other
argument_list|)
decl_stmt|;
comment|// Important! Remove stopped variables AFTER we visit
comment|// children. (which what super.visit() does)
name|vuv
operator|.
name|variables
operator|.
name|removeAll
argument_list|(
name|other
operator|.
name|getVariablesSet
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_class

begin_comment
comment|/** Result of calling    * {@link org.apache.calcite.plan.RelOptUtil#createExistsPlan}. */
end_comment

begin_class
specifier|public
specifier|static
class|class
name|Exists
block|{
specifier|public
specifier|final
name|RelNode
name|r
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|indicator
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|outerJoin
decl_stmt|;
specifier|private
name|Exists
parameter_list|(
name|RelNode
name|r
parameter_list|,
name|boolean
name|indicator
parameter_list|,
name|boolean
name|outerJoin
parameter_list|)
block|{
name|this
operator|.
name|r
operator|=
name|r
expr_stmt|;
name|this
operator|.
name|indicator
operator|=
name|indicator
expr_stmt|;
name|this
operator|.
name|outerJoin
operator|=
name|outerJoin
expr_stmt|;
block|}
block|}
end_class

unit|}
end_unit

