begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|AvaticaConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelHomogeneousShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelRoot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Calc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|SemiJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|externalize
operator|.
name|RelJsonWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|externalize
operator|.
name|RelWriterImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|externalize
operator|.
name|RelXmlWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalCalc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateProjectPullUpConstantsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|DateRangeRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|IntersectToDistinctRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|MultiJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectToWindowRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|PruneEmptyRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|UnionMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|UnionPullUpConstantsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFieldImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|LogicVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCorrelVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexExecutorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLocalRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexMultisetUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexOver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSubQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|MultisetSqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Permutation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|MappingType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedHashMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_comment
comment|/**  *<code>RelOptUtil</code> defines static utility methods for use in optimizing  * {@link RelNode}s.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|RelOptUtil
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|public
specifier|static
specifier|final
name|double
name|EPSILON
init|=
literal|1.0e-5
decl_stmt|;
comment|/** Predicate for whether a filter contains multisets or windowed    * aggregates. */
specifier|public
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Filter
argument_list|>
name|FILTER_PREDICATE
init|=
operator|new
name|Predicate
argument_list|<
name|Filter
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|apply
parameter_list|(
name|Filter
name|filter
parameter_list|)
block|{
return|return
operator|!
operator|(
name|B
operator|&&
name|RexMultisetUtil
operator|.
name|containsMultiset
argument_list|(
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|||
name|RexOver
operator|.
name|containsOver
argument_list|(
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|)
operator|)
return|;
block|}
block|}
decl_stmt|;
comment|/** Predicate for whether a project contains multisets or windowed    * aggregates. */
specifier|public
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Project
argument_list|>
name|PROJECT_PREDICATE
init|=
operator|new
name|Predicate
argument_list|<
name|Project
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|apply
parameter_list|(
name|Project
name|project
parameter_list|)
block|{
return|return
operator|!
operator|(
name|B
operator|&&
name|RexMultisetUtil
operator|.
name|containsMultiset
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|||
name|RexOver
operator|.
name|containsOver
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
literal|null
argument_list|)
operator|)
return|;
block|}
block|}
decl_stmt|;
comment|/** Predicate for whether a calc contains multisets or windowed    * aggregates. */
specifier|public
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Calc
argument_list|>
name|CALC_PREDICATE
init|=
operator|new
name|Predicate
argument_list|<
name|Calc
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|apply
parameter_list|(
name|Calc
name|calc
parameter_list|)
block|{
return|return
operator|!
operator|(
name|B
operator|&&
name|RexMultisetUtil
operator|.
name|containsMultiset
argument_list|(
name|calc
operator|.
name|getProgram
argument_list|()
argument_list|)
operator|||
name|calc
operator|.
name|getProgram
argument_list|()
operator|.
name|containsAggs
argument_list|()
operator|)
return|;
block|}
block|}
decl_stmt|;
specifier|static
specifier|final
name|boolean
name|B
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataType
argument_list|>
name|GET_TYPE
init|=
operator|new
name|Function
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataType
argument_list|>
argument_list|()
block|{
specifier|public
name|RelDataType
name|apply
parameter_list|(
name|RelDataTypeField
name|field
parameter_list|)
block|{
return|return
name|field
operator|.
name|getType
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Whether this node is a limit without sort specification.    */
specifier|public
specifier|static
name|boolean
name|isPureLimit
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|isLimit
argument_list|(
name|rel
argument_list|)
operator|&&
operator|!
name|isOrder
argument_list|(
name|rel
argument_list|)
return|;
block|}
comment|/**    * Whether this node is a sort without limit specification.    */
specifier|public
specifier|static
name|boolean
name|isPureOrder
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
operator|!
name|isLimit
argument_list|(
name|rel
argument_list|)
operator|&&
name|isOrder
argument_list|(
name|rel
argument_list|)
return|;
block|}
comment|/**    * Whether this node contains a limit specification.    */
specifier|public
specifier|static
name|boolean
name|isLimit
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
operator|(
name|rel
operator|instanceof
name|Sort
operator|)
operator|&&
operator|(
operator|(
name|Sort
operator|)
name|rel
operator|)
operator|.
name|fetch
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Whether this node contains a sort specification.    */
specifier|public
specifier|static
name|boolean
name|isOrder
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
operator|(
name|rel
operator|instanceof
name|Sort
operator|)
operator|&&
operator|!
operator|(
operator|(
name|Sort
operator|)
name|rel
operator|)
operator|.
name|getCollation
argument_list|()
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns a set of tables used by this expression or its children    */
specifier|public
specifier|static
name|Set
argument_list|<
name|RelOptTable
argument_list|>
name|findTables
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|findAllTables
argument_list|(
name|rel
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a list of all tables used by this expression or its children    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelOptTable
argument_list|>
name|findAllTables
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelOptTable
argument_list|>
name|usedTables
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
operator|new
name|RelVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|TableScan
condition|)
block|{
name|usedTables
operator|.
name|add
argument_list|(
name|node
operator|.
name|getTable
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// CHECKSTYLE: IGNORE 1
block|}
operator|.
name|go
argument_list|(
name|rel
argument_list|)
expr_stmt|;
return|return
name|usedTables
return|;
block|}
comment|/**    * Returns a list of variables set by a relational expression or its    * descendants.    */
specifier|public
specifier|static
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|getVariablesSet
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|VariableSetVisitor
name|visitor
init|=
operator|new
name|VariableSetVisitor
argument_list|()
decl_stmt|;
name|go
argument_list|(
name|visitor
argument_list|,
name|rel
argument_list|)
expr_stmt|;
return|return
name|visitor
operator|.
name|variables
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|List
argument_list|<
name|CorrelationId
argument_list|>
name|getVariablesSetAndUsed
parameter_list|(
name|RelNode
name|rel0
parameter_list|,
name|RelNode
name|rel1
parameter_list|)
block|{
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|set
init|=
name|getVariablesSet
argument_list|(
name|rel0
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|used
init|=
name|getVariablesUsed
argument_list|(
name|rel1
argument_list|)
decl_stmt|;
if|if
condition|(
name|used
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
specifier|final
name|List
argument_list|<
name|CorrelationId
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|CorrelationId
name|s
range|:
name|set
control|)
block|{
if|if
condition|(
name|used
operator|.
name|contains
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|result
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns a set of variables used by a relational expression or its    * descendants.    *    *<p>The set may contain "duplicates" (variables with different ids that,    * when resolved, will reference the same source relational expression).    *    *<p>The item type is the same as    * {@link org.apache.calcite.rex.RexCorrelVariable#id}.    */
specifier|public
specifier|static
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|getVariablesUsed
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|CorrelationCollector
name|visitor
init|=
operator|new
name|CorrelationCollector
argument_list|()
decl_stmt|;
name|rel
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
return|return
name|visitor
operator|.
name|vuv
operator|.
name|variables
return|;
block|}
comment|/** Finds which columns of a correlation variable are used within a    * relational expression. */
specifier|public
specifier|static
name|ImmutableBitSet
name|correlationColumns
parameter_list|(
name|CorrelationId
name|id
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|CorrelationCollector
name|collector
init|=
operator|new
name|CorrelationCollector
argument_list|()
decl_stmt|;
name|rel
operator|.
name|accept
argument_list|(
name|collector
argument_list|)
expr_stmt|;
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|builder
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|field
range|:
name|collector
operator|.
name|vuv
operator|.
name|variableFields
operator|.
name|get
argument_list|(
name|id
argument_list|)
control|)
block|{
if|if
condition|(
name|field
operator|>=
literal|0
condition|)
block|{
name|builder
operator|.
name|set
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns true, and calls {@link Litmus#succeed()} if a given relational    * expression does not contain a given correlation. */
specifier|public
specifier|static
name|boolean
name|notContainsCorrelation
parameter_list|(
name|RelNode
name|r
parameter_list|,
name|CorrelationId
name|correlationId
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|set
init|=
name|getVariablesUsed
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|set
operator|.
name|contains
argument_list|(
name|correlationId
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"contains {}"
argument_list|,
name|correlationId
argument_list|)
return|;
block|}
block|}
comment|/**    * Sets a {@link RelVisitor} going on a given relational expression, and    * returns the result.    */
specifier|public
specifier|static
name|void
name|go
parameter_list|(
name|RelVisitor
name|visitor
parameter_list|,
name|RelNode
name|p
parameter_list|)
block|{
try|try
block|{
name|visitor
operator|.
name|go
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
name|e
argument_list|,
literal|"while visiting tree"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns a list of the types of the fields in a given struct type. The    * list is immutable.    *    * @param type Struct type    * @return List of field types    * @see org.apache.calcite.rel.type.RelDataType#getFieldNames()    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataType
argument_list|>
name|getFieldTypeList
parameter_list|(
specifier|final
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
name|type
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|GET_TYPE
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|areRowTypesEqual
parameter_list|(
name|RelDataType
name|rowType1
parameter_list|,
name|RelDataType
name|rowType2
parameter_list|,
name|boolean
name|compareNames
parameter_list|)
block|{
if|if
condition|(
name|rowType1
operator|==
name|rowType2
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|compareNames
condition|)
block|{
comment|// if types are not identity-equal, then either the names or
comment|// the types must be different
return|return
literal|false
return|;
block|}
if|if
condition|(
name|rowType2
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|rowType1
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|f1
init|=
name|rowType1
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|f2
init|=
name|rowType2
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|f1
argument_list|,
name|f2
argument_list|)
control|)
block|{
specifier|final
name|RelDataType
name|type1
init|=
name|pair
operator|.
name|left
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type2
init|=
name|pair
operator|.
name|right
operator|.
name|getType
argument_list|()
decl_stmt|;
comment|// If one of the types is ANY comparison should succeed
if|if
condition|(
name|type1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
operator|||
name|type2
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|type1
operator|.
name|equals
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Verifies that a row type being added to an equivalence class matches the    * existing type, raising an assertion if this is not the case.    *    * @param originalRel      canonical rel for equivalence class    * @param newRel           rel being added to equivalence class    * @param equivalenceClass object representing equivalence class    */
specifier|public
specifier|static
name|void
name|verifyTypeEquivalence
parameter_list|(
name|RelNode
name|originalRel
parameter_list|,
name|RelNode
name|newRel
parameter_list|,
name|Object
name|equivalenceClass
parameter_list|)
block|{
name|RelDataType
name|expectedRowType
init|=
name|originalRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|RelDataType
name|actualRowType
init|=
name|newRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
comment|// Row types must be the same, except for field names.
if|if
condition|(
name|areRowTypesEqual
argument_list|(
name|expectedRowType
argument_list|,
name|actualRowType
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|String
name|s
init|=
literal|"Cannot add expression of different type to set:\n"
operator|+
literal|"set type is "
operator|+
name|expectedRowType
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\nexpression type is "
operator|+
name|actualRowType
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\nset is "
operator|+
name|equivalenceClass
operator|.
name|toString
argument_list|()
operator|+
literal|"\nexpression is "
operator|+
name|newRel
operator|.
name|toString
argument_list|()
decl_stmt|;
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
name|s
argument_list|)
throw|;
block|}
comment|/**    * Returns a permutation describing where output fields come from. In    * the returned map, value of {@code map.getTargetOpt(i)} is {@code n} if    * field {@code i} projects input field {@code n}, -1 if it is an    * expression.    */
specifier|public
specifier|static
name|Mappings
operator|.
name|TargetMapping
name|permutation
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|)
block|{
specifier|final
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|PARTIAL_FUNCTION
argument_list|,
name|nodes
operator|.
name|size
argument_list|()
argument_list|,
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RexNode
argument_list|>
name|node
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|nodes
argument_list|)
control|)
block|{
if|if
condition|(
name|node
operator|.
name|e
operator|instanceof
name|RexInputRef
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|node
operator|.
name|i
argument_list|,
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|.
name|e
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|node
operator|.
name|e
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
condition|)
block|{
name|RexNode
name|operand
init|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|.
name|e
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand
operator|instanceof
name|RexInputRef
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|node
operator|.
name|i
argument_list|,
operator|(
operator|(
name|RexInputRef
operator|)
name|operand
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|mapping
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createExistsPlan
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelNode
name|seekRel
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|conditions
parameter_list|,
name|RexLiteral
name|extraExpr
parameter_list|,
name|String
name|extraName
parameter_list|)
block|{
assert|assert
name|extraExpr
operator|==
literal|null
operator|||
name|extraName
operator|!=
literal|null
assert|;
name|RelNode
name|ret
init|=
name|seekRel
decl_stmt|;
if|if
condition|(
operator|(
name|conditions
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|conditions
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|RexNode
name|conditionExp
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|conditions
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|RelFactories
operator|.
name|FilterFactory
name|factory
init|=
name|RelFactories
operator|.
name|DEFAULT_FILTER_FACTORY
decl_stmt|;
name|ret
operator|=
name|factory
operator|.
name|createFilter
argument_list|(
name|ret
argument_list|,
name|conditionExp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extraExpr
operator|!=
literal|null
condition|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataTypeFactory
name|typeFactory
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
assert|assert
name|extraExpr
operator|==
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
assert|;
comment|// this should only be called for the exists case
comment|// first stick an Agg on top of the sub-query
comment|// agg does not like no agg functions so just pretend it is
comment|// doing a min(TRUE)
name|ret
operator|=
name|createProject
argument_list|(
name|ret
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|extraExpr
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
specifier|final
name|AggregateCall
name|aggCall
init|=
name|AggregateCall
operator|.
name|create
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MIN
argument_list|,
literal|false
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|null
argument_list|,
name|extraName
argument_list|)
decl_stmt|;
name|ret
operator|=
name|LogicalAggregate
operator|.
name|create
argument_list|(
name|ret
argument_list|,
literal|false
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|()
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|aggCall
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Creates a plan suitable for use in<code>EXISTS</code> or<code>IN</code>    * statements.    *    * @see org.apache.calcite.sql2rel.SqlToRelConverter#convertExists    *    * @param seekRel    A query rel, for example the resulting rel from 'select *    *                   from emp' or 'values (1,2,3)' or '('Foo', 34)'.    * @param subQueryType Sub-query type    * @param logic  Whether to use 2- or 3-valued boolean logic    * @param notIn Whether the operator is NOT IN    *    * @return A pair of a relational expression which outer joins a boolean    * condition column, and a numeric offset. The offset is 2 if column 0 is    * the number of rows and column 1 is the number of rows with not-null keys;    * 0 otherwise.    */
specifier|public
specifier|static
name|Exists
name|createExistsPlan
parameter_list|(
name|RelNode
name|seekRel
parameter_list|,
name|SubQueryType
name|subQueryType
parameter_list|,
name|Logic
name|logic
parameter_list|,
name|boolean
name|notIn
parameter_list|)
block|{
switch|switch
condition|(
name|subQueryType
condition|)
block|{
case|case
name|SCALAR
case|:
return|return
operator|new
name|Exists
argument_list|(
name|seekRel
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
switch|switch
condition|(
name|logic
condition|)
block|{
case|case
name|TRUE_FALSE_UNKNOWN
case|:
case|case
name|UNKNOWN_AS_TRUE
case|:
if|if
condition|(
operator|!
name|containsNullableFields
argument_list|(
name|seekRel
argument_list|)
condition|)
block|{
name|logic
operator|=
name|Logic
operator|.
name|TRUE_FALSE
expr_stmt|;
block|}
block|}
name|RelNode
name|ret
init|=
name|seekRel
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|seekRel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|int
name|keyCount
init|=
name|ret
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|outerJoin
init|=
name|notIn
operator|||
name|logic
operator|==
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
decl_stmt|;
if|if
condition|(
operator|!
name|outerJoin
condition|)
block|{
specifier|final
name|LogicalAggregate
name|aggregate
init|=
name|LogicalAggregate
operator|.
name|create
argument_list|(
name|ret
argument_list|,
literal|false
argument_list|,
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|keyCount
argument_list|)
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
expr|<
name|AggregateCall
operator|>
name|of
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|Exists
argument_list|(
name|aggregate
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// for IN/NOT IN, it needs to output the fields
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|subQueryType
operator|==
name|SubQueryType
operator|.
name|IN
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyCount
condition|;
name|i
operator|++
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|ret
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|projectedKeyCount
init|=
name|exprs
operator|.
name|size
argument_list|()
decl_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|createProject
argument_list|(
name|ret
argument_list|,
name|exprs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
specifier|final
name|AggregateCall
name|aggCall
init|=
name|AggregateCall
operator|.
name|create
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MIN
argument_list|,
literal|false
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|projectedKeyCount
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|projectedKeyCount
argument_list|,
name|ret
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|ret
operator|=
name|LogicalAggregate
operator|.
name|create
argument_list|(
name|ret
argument_list|,
literal|false
argument_list|,
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|projectedKeyCount
argument_list|)
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|aggCall
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|logic
condition|)
block|{
case|case
name|TRUE_FALSE_UNKNOWN
case|:
case|case
name|UNKNOWN_AS_TRUE
case|:
return|return
operator|new
name|Exists
argument_list|(
name|ret
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
default|default:
return|return
operator|new
name|Exists
argument_list|(
name|ret
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createRenameRel
parameter_list|(
name|RelDataType
name|outputType
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
name|RelDataType
name|inputType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputFields
init|=
name|inputType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|inputFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|outputFields
init|=
name|outputType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|outputFields
operator|.
name|size
argument_list|()
operator|==
name|n
operator|:
literal|"rename: field count mismatch: in="
operator|+
name|inputType
operator|+
literal|", out"
operator|+
name|outputType
assert|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|renames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|inputFields
argument_list|,
name|outputFields
argument_list|)
control|)
block|{
specifier|final
name|RelDataTypeField
name|inputField
init|=
name|pair
operator|.
name|left
decl_stmt|;
specifier|final
name|RelDataTypeField
name|outputField
init|=
name|pair
operator|.
name|right
decl_stmt|;
assert|assert
name|inputField
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|outputField
operator|.
name|getType
argument_list|()
argument_list|)
assert|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|renames
operator|.
name|add
argument_list|(
name|Pair
operator|.
expr|<
name|RexNode
argument_list|,
name|String
operator|>
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|inputField
operator|.
name|getType
argument_list|()
argument_list|,
name|inputField
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|,
name|outputField
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|createProject
argument_list|(
name|rel
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|renames
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|renames
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createFilter
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
specifier|final
name|RelFactories
operator|.
name|FilterFactory
name|factory
init|=
name|RelFactories
operator|.
name|DEFAULT_FILTER_FACTORY
decl_stmt|;
return|return
name|factory
operator|.
name|createFilter
argument_list|(
name|child
argument_list|,
name|condition
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createFilter
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|RelFactories
operator|.
name|FilterFactory
name|filterFactory
parameter_list|)
block|{
return|return
name|filterFactory
operator|.
name|createFilter
argument_list|(
name|child
argument_list|,
name|condition
argument_list|)
return|;
block|}
comment|/** Creates a filter, using the default filter factory,    * or returns the original relational expression if the    * condition is trivial. */
specifier|public
specifier|static
name|RelNode
name|createFilter
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|conditions
parameter_list|)
block|{
return|return
name|createFilter
argument_list|(
name|child
argument_list|,
name|conditions
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_FILTER_FACTORY
argument_list|)
return|;
block|}
comment|/** Creates a filter using the default factory,    * or returns the original relational expression if the    * condition is trivial. */
specifier|public
specifier|static
name|RelNode
name|createFilter
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|conditions
parameter_list|,
name|RelFactories
operator|.
name|FilterFactory
name|filterFactory
parameter_list|)
block|{
specifier|final
name|RelOptCluster
name|cluster
init|=
name|child
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|condition
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|conditions
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
return|return
name|child
return|;
block|}
else|else
block|{
return|return
name|filterFactory
operator|.
name|createFilter
argument_list|(
name|child
argument_list|,
name|condition
argument_list|)
return|;
block|}
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createNullFilter
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Integer
index|[]
name|fieldOrdinals
parameter_list|)
block|{
name|RexNode
name|condition
init|=
literal|null
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|fieldOrdinals
operator|!=
literal|null
condition|)
block|{
name|n
operator|=
name|fieldOrdinals
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|int
name|iField
decl_stmt|;
if|if
condition|(
name|fieldOrdinals
operator|!=
literal|null
condition|)
block|{
name|iField
operator|=
name|fieldOrdinals
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|iField
operator|=
name|i
expr_stmt|;
block|}
name|RelDataType
name|type
init|=
name|fields
operator|.
name|get
argument_list|(
name|iField
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|RexNode
name|newCondition
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|type
argument_list|,
name|iField
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
name|condition
operator|=
name|newCondition
expr_stmt|;
block|}
else|else
block|{
name|condition
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|condition
argument_list|,
name|newCondition
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
comment|// no filtering required
return|return
name|rel
return|;
block|}
specifier|final
name|RelFactories
operator|.
name|FilterFactory
name|factory
init|=
name|RelFactories
operator|.
name|DEFAULT_FILTER_FACTORY
decl_stmt|;
return|return
name|factory
operator|.
name|createFilter
argument_list|(
name|rel
argument_list|,
name|condition
argument_list|)
return|;
block|}
comment|/**    * Creates a projection which casts a rel's output to a desired row type.    *    * @param rel         producer of rows to be converted    * @param castRowType row type after cast    * @param rename      if true, use field names from castRowType; if false,    *                    preserve field names from rel    * @return conversion rel    */
specifier|public
specifier|static
name|RelNode
name|createCastRel
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
name|RelDataType
name|castRowType
parameter_list|,
name|boolean
name|rename
parameter_list|)
block|{
return|return
name|createCastRel
argument_list|(
name|rel
argument_list|,
name|castRowType
argument_list|,
name|rename
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|)
return|;
block|}
comment|/**    * Creates a projection which casts a rel's output to a desired row type.    *    * @param rel         producer of rows to be converted    * @param castRowType row type after cast    * @param rename      if true, use field names from castRowType; if false,    *                    preserve field names from rel    * @param projectFactory Project Factory    * @return conversion rel    */
specifier|public
specifier|static
name|RelNode
name|createCastRel
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
name|RelDataType
name|castRowType
parameter_list|,
name|boolean
name|rename
parameter_list|,
name|RelFactories
operator|.
name|ProjectFactory
name|projectFactory
parameter_list|)
block|{
assert|assert
name|projectFactory
operator|!=
literal|null
assert|;
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|areRowTypesEqual
argument_list|(
name|rowType
argument_list|,
name|castRowType
argument_list|,
name|rename
argument_list|)
condition|)
block|{
comment|// nothing to do
return|return
name|rel
return|;
block|}
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|castExps
init|=
name|RexUtil
operator|.
name|generateCastExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|castRowType
argument_list|,
name|rowType
argument_list|)
decl_stmt|;
if|if
condition|(
name|rename
condition|)
block|{
comment|// Use names and types from castRowType.
return|return
name|projectFactory
operator|.
name|createProject
argument_list|(
name|rel
argument_list|,
name|castExps
argument_list|,
name|castRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// Use names from rowType, types from castRowType.
return|return
name|projectFactory
operator|.
name|createProject
argument_list|(
name|rel
argument_list|,
name|castExps
argument_list|,
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Creates a LogicalAggregate that removes all duplicates from the result of    * an underlying relational expression.    *    * @param rel underlying rel    * @return rel implementing SingleValueAgg    */
specifier|public
specifier|static
name|RelNode
name|createSingleValueAggRel
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
comment|// assert (rel.getRowType().getFieldCount() == 1);
specifier|final
name|int
name|aggCallCnt
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggCallCnt
condition|;
name|i
operator|++
control|)
block|{
name|aggCalls
operator|.
name|add
argument_list|(
name|AggregateCall
operator|.
name|create
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SINGLE_VALUE
argument_list|,
literal|false
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|rel
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|LogicalAggregate
operator|.
name|create
argument_list|(
name|rel
argument_list|,
literal|false
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|()
argument_list|,
literal|null
argument_list|,
name|aggCalls
argument_list|)
return|;
block|}
comment|/**    * Creates a LogicalAggregate that removes all duplicates from the result of    * an underlying relational expression.    *    * @param rel underlying rel    * @return rel implementing DISTINCT    */
specifier|public
specifier|static
name|RelNode
name|createDistinctRel
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|LogicalAggregate
operator|.
name|create
argument_list|(
name|rel
argument_list|,
literal|false
argument_list|,
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
expr|<
name|AggregateCall
operator|>
name|of
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|boolean
name|analyzeSimpleEquiJoin
parameter_list|(
name|LogicalJoin
name|join
parameter_list|,
name|int
index|[]
name|joinFieldOrdinals
parameter_list|)
block|{
name|RexNode
name|joinExp
init|=
name|join
operator|.
name|getCondition
argument_list|()
decl_stmt|;
if|if
condition|(
name|joinExp
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RexCall
name|binaryExpression
init|=
operator|(
name|RexCall
operator|)
name|joinExp
decl_stmt|;
name|RexNode
name|leftComparand
init|=
name|binaryExpression
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|rightComparand
init|=
name|binaryExpression
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|leftComparand
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|rightComparand
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|leftFieldCount
init|=
name|join
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|RexInputRef
name|leftFieldAccess
init|=
operator|(
name|RexInputRef
operator|)
name|leftComparand
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|leftFieldAccess
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|)
condition|)
block|{
comment|// left field must access left side of join
return|return
literal|false
return|;
block|}
name|RexInputRef
name|rightFieldAccess
init|=
operator|(
name|RexInputRef
operator|)
name|rightComparand
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rightFieldAccess
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
operator|)
condition|)
block|{
comment|// right field must access right side of join
return|return
literal|false
return|;
block|}
name|joinFieldOrdinals
index|[
literal|0
index|]
operator|=
name|leftFieldAccess
operator|.
name|getIndex
argument_list|()
expr_stmt|;
name|joinFieldOrdinals
index|[
literal|1
index|]
operator|=
name|rightFieldAccess
operator|.
name|getIndex
argument_list|()
operator|-
name|leftFieldCount
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Splits out the equi-join components of a join condition, and returns    * what's left. For example, given the condition    *    *<blockquote><code>L.A = R.X AND L.B = L.C AND (L.D = 5 OR L.E =    * R.Y)</code></blockquote>    *    * returns    *    *<ul>    *<li>leftKeys = {A}    *<li>rightKeys = {X}    *<li>rest = L.B = L.C AND (L.D = 5 OR L.E = R.Y)</li>    *</ul>    *    * @param left      left input to join    * @param right     right input to join    * @param condition join condition    * @param leftKeys  The ordinals of the fields from the left input which are    *                  equi-join keys    * @param rightKeys The ordinals of the fields from the right input which    *                  are equi-join keys    * @param filterNulls List of boolean values for each join key position    *                    indicating whether the operator filters out nulls or not.    *                    Value is true if the operator is EQUALS and false if the    *                    operator is IS NOT DISTINCT FROM (or an expanded version).    *                    If<code>filterNulls</code> is null, only join conditions    *                    with EQUALS operators are considered equi-join components.    *                    Rest (including IS NOT DISTINCT FROM) are returned in    *                    remaining join condition.    *    * @return remaining join filters that are not equijoins; may return a    * {@link RexLiteral} true, but never null    */
specifier|public
specifier|static
name|RexNode
name|splitJoinCondition
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|RelNode
name|right
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
name|List
argument_list|<
name|Boolean
argument_list|>
name|filterNulls
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|splitJoinCondition
argument_list|(
name|left
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|condition
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|filterNulls
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|left
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|boolean
name|isEqui
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|RelNode
name|right
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Boolean
argument_list|>
name|filterNulls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|splitJoinCondition
argument_list|(
name|left
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|condition
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|filterNulls
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
return|return
name|nonEquiList
operator|.
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/**    * Splits out the equi-join (and optionally, a single non-equi) components    * of a join condition, and returns what's left. Projection might be    * required by the caller to provide join keys that are not direct field    * references.    *    * @param sysFieldList  list of system fields    * @param leftRel       left join input    * @param rightRel      right join input    * @param condition     join condition    * @param leftJoinKeys  The join keys from the left input which are equi-join    *                      keys    * @param rightJoinKeys The join keys from the right input which are    *                      equi-join keys    * @param filterNulls   The join key positions for which null values will not    *                      match. null values only match for the "is not distinct    *                      from" condition.    * @param rangeOp       if null, only locate equi-joins; otherwise, locate a    *                      single non-equi join predicate and return its operator    *                      in this list; join keys associated with the non-equi    *                      join predicate are at the end of the key lists    *                      returned    * @return What's left, never null    */
specifier|public
specifier|static
name|RexNode
name|splitJoinCondition
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sysFieldList
parameter_list|,
name|RelNode
name|leftRel
parameter_list|,
name|RelNode
name|rightRel
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|filterNulls
parameter_list|,
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|rangeOp
parameter_list|)
block|{
return|return
name|splitJoinCondition
argument_list|(
name|sysFieldList
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|leftRel
argument_list|,
name|rightRel
argument_list|)
argument_list|,
name|condition
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|leftJoinKeys
argument_list|,
name|rightJoinKeys
argument_list|)
argument_list|,
name|filterNulls
argument_list|,
name|rangeOp
argument_list|)
return|;
block|}
comment|/**    * Splits out the equi-join (and optionally, a single non-equi) components    * of a join condition, and returns what's left. Projection might be    * required by the caller to provide join keys that are not direct field    * references.    *    * @param sysFieldList  list of system fields    * @param inputs        join inputs    * @param condition     join condition    * @param joinKeys      The join keys from the inputs which are equi-join    *                      keys    * @param filterNulls   The join key positions for which null values will not    *                      match. null values only match for the "is not distinct    *                      from" condition.    * @param rangeOp       if null, only locate equi-joins; otherwise, locate a    *                      single non-equi join predicate and return its operator    *                      in this list; join keys associated with the non-equi    *                      join predicate are at the end of the key lists    *                      returned    * @return What's left, never null    */
specifier|public
specifier|static
name|RexNode
name|splitJoinCondition
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sysFieldList
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|filterNulls
parameter_list|,
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|rangeOp
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|splitJoinCondition
argument_list|(
name|sysFieldList
argument_list|,
name|inputs
argument_list|,
name|condition
argument_list|,
name|joinKeys
argument_list|,
name|filterNulls
argument_list|,
name|rangeOp
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
comment|// Convert the remainders into a list that are AND'ed together.
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RexNode
name|splitCorrelatedFilterCondition
parameter_list|(
name|LogicalFilter
name|filter
parameter_list|,
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|splitCorrelatedFilterCondition
argument_list|(
name|filter
argument_list|,
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
comment|// Convert the remainders into a list that are AND'ed together.
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|filter
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RexNode
name|splitCorrelatedFilterCondition
parameter_list|(
name|LogicalFilter
name|filter
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|boolean
name|extractCorrelatedFieldAccess
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|splitCorrelatedFilterCondition
argument_list|(
name|filter
argument_list|,
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|,
name|extractCorrelatedFieldAccess
argument_list|)
expr_stmt|;
comment|// Convert the remainders into a list that are AND'ed together.
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|filter
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|splitJoinCondition
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sysFieldList
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|filterNulls
parameter_list|,
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|rangeOp
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|)
block|{
specifier|final
name|int
name|sysFieldCount
init|=
name|sysFieldList
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableBitSet
index|[]
name|inputsRange
init|=
operator|new
name|ImmutableBitSet
index|[
name|inputs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|totalFieldCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|firstField
init|=
name|totalFieldCount
operator|+
name|sysFieldCount
decl_stmt|;
name|totalFieldCount
operator|=
name|firstField
operator|+
name|inputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
name|inputsRange
index|[
name|i
index|]
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|firstField
argument_list|,
name|totalFieldCount
argument_list|)
expr_stmt|;
block|}
comment|// adjustment array
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|totalFieldCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|adjustment
init|=
name|inputsRange
index|[
name|i
index|]
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|adjustment
init|;
name|j
operator|<
name|inputsRange
index|[
name|i
index|]
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|adjustments
index|[
name|j
index|]
operator|=
operator|-
name|adjustment
expr_stmt|;
block|}
block|}
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitJoinCondition
argument_list|(
name|sysFieldList
argument_list|,
name|inputs
argument_list|,
name|operand
argument_list|,
name|joinKeys
argument_list|,
name|filterNulls
argument_list|,
name|rangeOp
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|RexNode
name|leftKey
init|=
literal|null
decl_stmt|;
name|RexNode
name|rightKey
init|=
literal|null
decl_stmt|;
name|int
name|leftInput
init|=
literal|0
decl_stmt|;
name|int
name|rightInput
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftFields
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightFields
init|=
literal|null
decl_stmt|;
name|boolean
name|reverse
init|=
literal|false
decl_stmt|;
name|call
operator|=
name|collapseExpandedIsNotDistinctFromExpr
argument_list|(
name|call
argument_list|,
name|rexBuilder
argument_list|)
expr_stmt|;
name|SqlKind
name|kind
init|=
name|call
operator|.
name|getKind
argument_list|()
decl_stmt|;
comment|// Only consider range operators if we haven't already seen one
if|if
condition|(
operator|(
name|kind
operator|==
name|SqlKind
operator|.
name|EQUALS
operator|)
operator|||
operator|(
name|filterNulls
operator|!=
literal|null
operator|&&
name|kind
operator|==
name|SqlKind
operator|.
name|IS_NOT_DISTINCT_FROM
operator|)
operator|||
operator|(
name|rangeOp
operator|!=
literal|null
operator|&&
name|rangeOp
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|kind
operator|==
name|SqlKind
operator|.
name|GREATER_THAN
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|GREATER_THAN_OR_EQUAL
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|LESS_THAN
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|LESS_THAN_OR_EQUAL
operator|)
operator|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|op0
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|op1
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|projRefs0
init|=
name|InputFinder
operator|.
name|bits
argument_list|(
name|op0
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|projRefs1
init|=
name|InputFinder
operator|.
name|bits
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|boolean
name|foundBothInputs
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|foundBothInputs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|projRefs0
operator|.
name|intersects
argument_list|(
name|inputsRange
index|[
name|i
index|]
argument_list|)
operator|&&
name|projRefs0
operator|.
name|union
argument_list|(
name|inputsRange
index|[
name|i
index|]
argument_list|)
operator|.
name|equals
argument_list|(
name|inputsRange
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|leftKey
operator|==
literal|null
condition|)
block|{
name|leftKey
operator|=
name|op0
expr_stmt|;
name|leftInput
operator|=
name|i
expr_stmt|;
name|leftFields
operator|=
name|inputs
operator|.
name|get
argument_list|(
name|leftInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rightKey
operator|=
name|op0
expr_stmt|;
name|rightInput
operator|=
name|i
expr_stmt|;
name|rightFields
operator|=
name|inputs
operator|.
name|get
argument_list|(
name|rightInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
expr_stmt|;
name|reverse
operator|=
literal|true
expr_stmt|;
name|foundBothInputs
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|projRefs1
operator|.
name|intersects
argument_list|(
name|inputsRange
index|[
name|i
index|]
argument_list|)
operator|&&
name|projRefs1
operator|.
name|union
argument_list|(
name|inputsRange
index|[
name|i
index|]
argument_list|)
operator|.
name|equals
argument_list|(
name|inputsRange
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|leftKey
operator|==
literal|null
condition|)
block|{
name|leftKey
operator|=
name|op1
expr_stmt|;
name|leftInput
operator|=
name|i
expr_stmt|;
name|leftFields
operator|=
name|inputs
operator|.
name|get
argument_list|(
name|leftInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rightKey
operator|=
name|op1
expr_stmt|;
name|rightInput
operator|=
name|i
expr_stmt|;
name|rightFields
operator|=
name|inputs
operator|.
name|get
argument_list|(
name|rightInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
expr_stmt|;
name|foundBothInputs
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|leftKey
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|rightKey
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// replace right Key input ref
name|rightKey
operator|=
name|rightKey
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|rightFields
argument_list|,
name|rightFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
comment|// left key only needs to be adjusted if there are system
comment|// fields, but do it for uniformity
name|leftKey
operator|=
name|leftKey
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|leftFields
argument_list|,
name|leftFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
name|RelDataType
name|leftKeyType
init|=
name|leftKey
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|rightKeyType
init|=
name|rightKey
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftKeyType
operator|!=
name|rightKeyType
condition|)
block|{
comment|// perform casting
name|RelDataType
name|targetKeyType
init|=
name|typeFactory
operator|.
name|leastRestrictive
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|leftKeyType
argument_list|,
name|rightKeyType
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetKeyType
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Cannot find common type for join keys "
operator|+
name|leftKey
operator|+
literal|" (type "
operator|+
name|leftKeyType
operator|+
literal|") and "
operator|+
name|rightKey
operator|+
literal|" (type "
operator|+
name|rightKeyType
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|leftKeyType
operator|!=
name|targetKeyType
condition|)
block|{
name|leftKey
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|targetKeyType
argument_list|,
name|leftKey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rightKeyType
operator|!=
name|targetKeyType
condition|)
block|{
name|rightKey
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|targetKeyType
argument_list|,
name|rightKey
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|rangeOp
operator|==
literal|null
operator|)
operator|&&
operator|(
operator|(
name|leftKey
operator|==
literal|null
operator|)
operator|||
operator|(
name|rightKey
operator|==
literal|null
operator|)
operator|)
condition|)
block|{
comment|// no equality join keys found yet:
comment|// try transforming the condition to
comment|// equality "join" conditions, e.g.
comment|//     f(LHS)> 0 ===> ( f(LHS)> 0 ) = TRUE,
comment|// and make the RHS produce TRUE, but only if we're strictly
comment|// looking for equi-joins
specifier|final
name|ImmutableBitSet
name|projRefs
init|=
name|InputFinder
operator|.
name|bits
argument_list|(
name|condition
argument_list|)
decl_stmt|;
name|leftKey
operator|=
literal|null
expr_stmt|;
name|rightKey
operator|=
literal|null
expr_stmt|;
name|boolean
name|foundInput
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|foundInput
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inputsRange
index|[
name|i
index|]
operator|.
name|contains
argument_list|(
name|projRefs
argument_list|)
condition|)
block|{
name|leftInput
operator|=
name|i
expr_stmt|;
name|leftFields
operator|=
name|inputs
operator|.
name|get
argument_list|(
name|leftInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
expr_stmt|;
name|leftKey
operator|=
name|condition
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|leftFields
argument_list|,
name|leftFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
name|rightKey
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// effectively performing an equality comparison
name|kind
operator|=
name|SqlKind
operator|.
name|EQUALS
expr_stmt|;
name|foundInput
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|leftKey
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|rightKey
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// found suitable join keys
comment|// add them to key list, ensuring that if there is a
comment|// non-equi join predicate, it appears at the end of the
comment|// key list; also mark the null filtering property
name|addJoinKey
argument_list|(
name|joinKeys
operator|.
name|get
argument_list|(
name|leftInput
argument_list|)
argument_list|,
name|leftKey
argument_list|,
operator|(
name|rangeOp
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|rangeOp
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|addJoinKey
argument_list|(
name|joinKeys
operator|.
name|get
argument_list|(
name|rightInput
argument_list|)
argument_list|,
name|rightKey
argument_list|,
operator|(
name|rangeOp
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|rangeOp
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|filterNulls
operator|!=
literal|null
operator|&&
name|kind
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
comment|// nulls are considered not matching for equality comparison
comment|// add the position of the most recently inserted key
name|filterNulls
operator|.
name|add
argument_list|(
name|joinKeys
operator|.
name|get
argument_list|(
name|leftInput
argument_list|)
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rangeOp
operator|!=
literal|null
operator|&&
name|kind
operator|!=
name|SqlKind
operator|.
name|EQUALS
operator|&&
name|kind
operator|!=
name|SqlKind
operator|.
name|IS_DISTINCT_FROM
condition|)
block|{
if|if
condition|(
name|reverse
condition|)
block|{
name|kind
operator|=
name|kind
operator|.
name|reverse
argument_list|()
expr_stmt|;
block|}
name|rangeOp
operator|.
name|add
argument_list|(
name|op
argument_list|(
name|kind
argument_list|,
name|call
operator|.
name|getOperator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// else fall through and add this condition as nonEqui condition
block|}
comment|// The operator is not of RexCall type
comment|// So we fail. Fall through.
comment|// Add this condition to the list of non-equi-join conditions.
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
comment|/** Builds an equi-join condition from a set of left and right keys. */
specifier|public
specifier|static
name|RexNode
name|createEquiJoinCondition
parameter_list|(
specifier|final
name|RelNode
name|left
parameter_list|,
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
specifier|final
name|RelNode
name|right
parameter_list|,
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|leftTypes
init|=
name|RelOptUtil
operator|.
name|getFieldTypeList
argument_list|(
name|left
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|rightTypes
init|=
name|RelOptUtil
operator|.
name|getFieldTypeList
argument_list|(
name|right
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
operator|new
name|AbstractList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
specifier|final
name|int
name|leftKey
init|=
name|leftKeys
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|final
name|int
name|rightKey
init|=
name|rightKeys
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|leftTypes
operator|.
name|get
argument_list|(
name|leftKey
argument_list|)
argument_list|,
name|leftKey
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|rightTypes
operator|.
name|get
argument_list|(
name|rightKey
argument_list|)
argument_list|,
name|leftTypes
operator|.
name|size
argument_list|()
operator|+
name|rightKey
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|leftKeys
operator|.
name|size
argument_list|()
return|;
block|}
block|}
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|SqlOperator
name|op
parameter_list|(
name|SqlKind
name|kind
parameter_list|,
name|SqlOperator
name|operator
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|EQUALS
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|EQUALS
return|;
case|case
name|NOT_EQUALS
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
return|;
case|case
name|GREATER_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
return|;
case|case
name|LESS_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
return|;
case|case
name|IS_DISTINCT_FROM
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_DISTINCT_FROM
return|;
case|case
name|IS_NOT_DISTINCT_FROM
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
return|;
default|default:
return|return
name|operator
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|addJoinKey
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeyList
parameter_list|,
name|RexNode
name|key
parameter_list|,
name|boolean
name|preserveLastElementInList
parameter_list|)
block|{
if|if
condition|(
operator|!
name|joinKeyList
operator|.
name|isEmpty
argument_list|()
operator|&&
name|preserveLastElementInList
condition|)
block|{
name|joinKeyList
operator|.
name|add
argument_list|(
name|joinKeyList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|joinKeyList
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|splitCorrelatedFilterCondition
parameter_list|(
name|LogicalFilter
name|filter
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitCorrelatedFilterCondition
argument_list|(
name|filter
argument_list|,
name|operand
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|op0
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|op1
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op0
argument_list|)
operator|)
operator|&&
operator|(
name|op1
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|joinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexInputRef
operator|)
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
if|else if
condition|(
operator|(
name|op0
operator|instanceof
name|RexInputRef
operator|)
operator|&&
operator|!
operator|(
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op1
argument_list|)
operator|)
condition|)
block|{
name|joinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexInputRef
operator|)
name|op0
argument_list|)
expr_stmt|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// The operator is not of RexCall type
comment|// So we fail. Fall through.
comment|// Add this condition to the list of non-equi-join conditions.
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|splitCorrelatedFilterCondition
parameter_list|(
name|LogicalFilter
name|filter
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|,
name|boolean
name|extractCorrelatedFieldAccess
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitCorrelatedFilterCondition
argument_list|(
name|filter
argument_list|,
name|operand
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|,
name|extractCorrelatedFieldAccess
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|op0
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|op1
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|extractCorrelatedFieldAccess
condition|)
block|{
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|containsFieldAccess
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|op1
operator|instanceof
name|RexFieldAccess
operator|)
condition|)
block|{
name|joinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
if|else if
condition|(
operator|(
name|op0
operator|instanceof
name|RexFieldAccess
operator|)
operator|&&
operator|!
name|RexUtil
operator|.
name|containsFieldAccess
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|joinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op0
argument_list|)
operator|)
operator|&&
operator|(
name|op1
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|joinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
if|else if
condition|(
operator|(
name|op0
operator|instanceof
name|RexInputRef
operator|)
operator|&&
operator|!
operator|(
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op1
argument_list|)
operator|)
condition|)
block|{
name|joinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|// The operator is not of RexCall type
comment|// So we fail. Fall through.
comment|// Add this condition to the list of non-equi-join conditions.
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|splitJoinCondition
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|int
name|leftFieldCount
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
name|List
argument_list|<
name|Boolean
argument_list|>
name|filterNulls
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
name|SqlKind
name|kind
init|=
name|call
operator|.
name|getKind
argument_list|()
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|SqlKind
operator|.
name|AND
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitJoinCondition
argument_list|(
name|rexBuilder
argument_list|,
name|leftFieldCount
argument_list|,
name|operand
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|filterNulls
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|filterNulls
operator|!=
literal|null
condition|)
block|{
name|call
operator|=
name|collapseExpandedIsNotDistinctFromExpr
argument_list|(
name|call
argument_list|,
name|rexBuilder
argument_list|)
expr_stmt|;
name|kind
operator|=
name|call
operator|.
name|getKind
argument_list|()
expr_stmt|;
block|}
comment|// "=" and "IS NOT DISTINCT FROM" are the same except for how they
comment|// treat nulls.
if|if
condition|(
name|kind
operator|==
name|SqlKind
operator|.
name|EQUALS
operator|||
operator|(
name|filterNulls
operator|!=
literal|null
operator|&&
name|kind
operator|==
name|SqlKind
operator|.
name|IS_NOT_DISTINCT_FROM
operator|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
operator|&&
operator|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|RexInputRef
name|op0
init|=
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexInputRef
name|op1
init|=
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|RexInputRef
name|leftField
decl_stmt|;
name|RexInputRef
name|rightField
decl_stmt|;
if|if
condition|(
operator|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|)
operator|&&
operator|(
name|op1
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
operator|)
condition|)
block|{
comment|// Arguments were of form 'op0 = op1'
name|leftField
operator|=
name|op0
expr_stmt|;
name|rightField
operator|=
name|op1
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|op1
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|)
operator|&&
operator|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
operator|)
condition|)
block|{
comment|// Arguments were of form 'op1 = op0'
name|leftField
operator|=
name|op1
expr_stmt|;
name|rightField
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
return|return;
block|}
name|leftKeys
operator|.
name|add
argument_list|(
name|leftField
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|rightKeys
operator|.
name|add
argument_list|(
name|rightField
operator|.
name|getIndex
argument_list|()
operator|-
name|leftFieldCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|filterNulls
operator|!=
literal|null
condition|)
block|{
name|filterNulls
operator|.
name|add
argument_list|(
name|kind
operator|==
name|SqlKind
operator|.
name|EQUALS
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Arguments were not field references, one from each side, so
comment|// we fail. Fall through.
block|}
block|}
comment|// Add this condition to the list of non-equi-join conditions.
if|if
condition|(
operator|!
name|condition
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Helper method for    * {@link #splitJoinCondition(RexBuilder, int, RexNode, List, List, List, List)} and    * {@link #splitJoinCondition(List, List, RexNode, List, List, List, List)}.    *    *<p>If the given expr<code>call</code> is an expanded version of    * IS NOT DISTINCT FROM function call, collapse it and return a    * IS NOT DISTINCT FROM function call.    *    *<p>For example: {@code t1.key IS NOT DISTINCT FROM t2.key}    * can rewritten in expanded form as    * {@code t1.key = t2.key OR (t1.key IS NULL AND t2.key IS NULL)}.    *    * @param call       Function expression to try collapsing.    * @param rexBuilder {@link RexBuilder} instance to create new {@link RexCall} instances.    * @return If the given function is an expanded IS NOT DISTINCT FROM function call,    *         return a IS NOT DISTINCT FROM function call. Otherwise return the input    *         function call as it is.    */
specifier|private
specifier|static
name|RexCall
name|collapseExpandedIsNotDistinctFromExpr
parameter_list|(
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|OR
operator|||
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|2
condition|)
block|{
return|return
name|call
return|;
block|}
specifier|final
name|RexNode
name|op0
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op1
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|op0
operator|instanceof
name|RexCall
operator|)
operator|||
operator|!
operator|(
name|op1
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
return|return
name|call
return|;
block|}
name|RexCall
name|opEqCall
init|=
operator|(
name|RexCall
operator|)
name|op0
decl_stmt|;
name|RexCall
name|opNullEqCall
init|=
operator|(
name|RexCall
operator|)
name|op1
decl_stmt|;
if|if
condition|(
name|opEqCall
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
operator|&&
name|opNullEqCall
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
name|RexCall
name|temp
init|=
name|opEqCall
decl_stmt|;
name|opEqCall
operator|=
name|opNullEqCall
expr_stmt|;
name|opNullEqCall
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|opNullEqCall
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|AND
operator|||
name|opNullEqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|2
operator|||
name|opEqCall
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
return|return
name|call
return|;
block|}
specifier|final
name|RexNode
name|op10
init|=
name|opNullEqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op11
init|=
name|opNullEqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|op10
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|IS_NULL
operator|||
name|op11
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|IS_NULL
condition|)
block|{
return|return
name|call
return|;
block|}
specifier|final
name|RexNode
name|isNullInput0
init|=
operator|(
operator|(
name|RexCall
operator|)
name|op10
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|isNullInput1
init|=
operator|(
operator|(
name|RexCall
operator|)
name|op11
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|String
name|isNullInput0Digest
init|=
name|isNullInput0
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|String
name|isNullInput1Digest
init|=
name|isNullInput1
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|String
name|equalsInput0Digest
init|=
name|opEqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|String
name|equalsInput1Digest
init|=
name|opEqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|isNullInput0Digest
operator|.
name|equals
argument_list|(
name|equalsInput0Digest
argument_list|)
operator|&&
name|isNullInput1Digest
operator|.
name|equals
argument_list|(
name|equalsInput1Digest
argument_list|)
operator|)
operator|||
operator|(
name|isNullInput1Digest
operator|.
name|equals
argument_list|(
name|equalsInput0Digest
argument_list|)
operator|&&
name|isNullInput0Digest
operator|.
name|equals
argument_list|(
name|equalsInput1Digest
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|RexCall
operator|)
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|isNullInput0
argument_list|,
name|isNullInput1
argument_list|)
argument_list|)
return|;
block|}
return|return
name|call
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|void
name|projectJoinInputs
parameter_list|(
name|RelNode
index|[]
name|inputRels
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
parameter_list|,
name|int
name|systemColCount
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|outputProj
parameter_list|)
block|{
name|RelNode
name|leftRel
init|=
name|inputRels
index|[
literal|0
index|]
decl_stmt|;
name|RelNode
name|rightRel
init|=
name|inputRels
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|leftRel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeSystem
name|typeSystem
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|getTypeSystem
argument_list|()
decl_stmt|;
name|int
name|origLeftInputSize
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|origRightInputSize
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newLeftFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|newLeftFieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newRightFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|newRightFieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|leftKeyCount
init|=
name|leftJoinKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|rightKeyCount
init|=
name|rightJoinKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|systemColCount
condition|;
name|i
operator|++
control|)
block|{
name|outputProj
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origLeftInputSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newLeftFields
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|newLeftFieldNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|outputProj
operator|.
name|add
argument_list|(
name|systemColCount
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|newLeftKeyCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leftKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|leftKey
init|=
name|leftJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftKey
operator|instanceof
name|RexInputRef
condition|)
block|{
comment|// already added to the projected left fields
comment|// only need to remember the index in the join key list
name|leftKeys
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|leftKey
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newLeftFields
operator|.
name|add
argument_list|(
name|leftKey
argument_list|)
expr_stmt|;
name|newLeftFieldNames
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|leftKeys
operator|.
name|add
argument_list|(
name|origLeftInputSize
operator|+
name|newLeftKeyCount
argument_list|)
expr_stmt|;
name|newLeftKeyCount
operator|++
expr_stmt|;
block|}
block|}
name|int
name|leftFieldCount
init|=
name|origLeftInputSize
operator|+
name|newLeftKeyCount
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origRightInputSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newRightFields
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|newRightFieldNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|outputProj
operator|.
name|add
argument_list|(
name|systemColCount
operator|+
name|leftFieldCount
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|newRightKeyCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rightKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|rightKey
init|=
name|rightJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightKey
operator|instanceof
name|RexInputRef
condition|)
block|{
comment|// already added to the projected left fields
comment|// only need to remember the index in the join key list
name|rightKeys
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|rightKey
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newRightFields
operator|.
name|add
argument_list|(
name|rightKey
argument_list|)
expr_stmt|;
name|newRightFieldNames
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|rightKeys
operator|.
name|add
argument_list|(
name|origRightInputSize
operator|+
name|newRightKeyCount
argument_list|)
expr_stmt|;
name|newRightKeyCount
operator|++
expr_stmt|;
block|}
block|}
comment|// added project if need to produce new keys than the original input
comment|// fields
if|if
condition|(
name|newLeftKeyCount
operator|>
literal|0
condition|)
block|{
name|leftRel
operator|=
name|createProject
argument_list|(
name|leftRel
argument_list|,
name|newLeftFields
argument_list|,
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|newLeftFieldNames
argument_list|,
name|typeSystem
operator|.
name|isSchemaCaseSensitive
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newRightKeyCount
operator|>
literal|0
condition|)
block|{
name|rightRel
operator|=
name|createProject
argument_list|(
name|rightRel
argument_list|,
name|newRightFields
argument_list|,
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|newRightFieldNames
argument_list|,
name|typeSystem
operator|.
name|isSchemaCaseSensitive
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inputRels
index|[
literal|0
index|]
operator|=
name|leftRel
expr_stmt|;
name|inputRels
index|[
literal|1
index|]
operator|=
name|rightRel
expr_stmt|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createProjectJoinRel
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|outputProj
parameter_list|,
name|RelNode
name|joinRel
parameter_list|)
block|{
name|int
name|newProjectOutputSize
init|=
name|outputProj
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|joinOutputFields
init|=
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
comment|// If no projection was passed in, or the number of desired projection
comment|// columns is the same as the number of columns returned from the
comment|// join, then no need to create a projection
if|if
condition|(
operator|(
name|newProjectOutputSize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|newProjectOutputSize
operator|<
name|joinOutputFields
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|newProjects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|fieldIndex
range|:
name|outputProj
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|joinOutputFields
operator|.
name|get
argument_list|(
name|fieldIndex
argument_list|)
decl_stmt|;
name|newProjects
operator|.
name|add
argument_list|(
name|Pair
operator|.
expr|<
name|RexNode
argument_list|,
name|String
operator|>
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|fieldIndex
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Create a project rel on the output of the join.
return|return
name|createProject
argument_list|(
name|joinRel
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|newProjects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|newProjects
argument_list|)
argument_list|)
return|;
block|}
return|return
name|joinRel
return|;
block|}
specifier|public
specifier|static
name|void
name|registerAbstractRels
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|AggregateProjectPullUpConstantsRule
operator|.
name|INSTANCE2
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|UnionPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PruneEmptyRules
operator|.
name|UNION_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PruneEmptyRules
operator|.
name|INTERSECT_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PruneEmptyRules
operator|.
name|MINUS_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PruneEmptyRules
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PruneEmptyRules
operator|.
name|SORT_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PruneEmptyRules
operator|.
name|AGGREGATE_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_LEFT_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_RIGHT_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PruneEmptyRules
operator|.
name|SORT_FETCH_ZERO_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|UnionMergeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|UnionMergeRule
operator|.
name|INTERSECT_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|UnionMergeRule
operator|.
name|MINUS_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|FilterMergeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|DateRangeRules
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|IntersectToDistinctRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Dumps a plan as a string.    *    * @param header      Header to print before the plan. Ignored if the format    *                    is XML    * @param rel         Relational expression to explain    * @param format      Output format    * @param detailLevel Detail level    * @return Plan    */
specifier|public
specifier|static
name|String
name|dumpPlan
parameter_list|(
name|String
name|header
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|SqlExplainFormat
name|format
parameter_list|,
name|SqlExplainLevel
name|detailLevel
parameter_list|)
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|header
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
name|RelWriter
name|planWriter
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|XML
case|:
name|planWriter
operator|=
operator|new
name|RelXmlWriter
argument_list|(
name|pw
argument_list|,
name|detailLevel
argument_list|)
expr_stmt|;
break|break;
case|case
name|JSON
case|:
name|planWriter
operator|=
operator|new
name|RelJsonWriter
argument_list|()
expr_stmt|;
name|rel
operator|.
name|explain
argument_list|(
name|planWriter
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|RelJsonWriter
operator|)
name|planWriter
operator|)
operator|.
name|asString
argument_list|()
return|;
default|default:
name|planWriter
operator|=
operator|new
name|RelWriterImpl
argument_list|(
name|pw
argument_list|,
name|detailLevel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|rel
operator|.
name|explain
argument_list|(
name|planWriter
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|String
name|dumpPlan
parameter_list|(
name|String
name|header
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|boolean
name|asXml
parameter_list|,
name|SqlExplainLevel
name|detailLevel
parameter_list|)
block|{
return|return
name|dumpPlan
argument_list|(
name|header
argument_list|,
name|rel
argument_list|,
name|asXml
condition|?
name|SqlExplainFormat
operator|.
name|XML
else|:
name|SqlExplainFormat
operator|.
name|TEXT
argument_list|,
name|detailLevel
argument_list|)
return|;
block|}
comment|/**    * Creates the row type descriptor for the result of a DML operation, which    * is a single column named ROWCOUNT of type BIGINT for INSERT;    * a single column named PLAN for EXPLAIN.    *    * @param kind        Kind of node    * @param typeFactory factory to use for creating type descriptor    * @return created type    */
specifier|public
specifier|static
name|RelDataType
name|createDmlRowType
parameter_list|(
name|SqlKind
name|kind
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|INSERT
case|:
case|case
name|DELETE
case|:
case|case
name|UPDATE
case|:
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|AvaticaConnection
operator|.
name|ROWCOUNT_COLUMN_NAME
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|EXPLAIN
case|:
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|AvaticaConnection
operator|.
name|PLAN_COLUMN_NAME
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|kind
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns whether two types are equal using '='.    *    * @param desc1 Description of first type    * @param type1 First type    * @param desc2 Description of second type    * @param type2 Second type    * @param litmus What to do if an error is detected (types are not equal)    * @return Whether the types are equal    */
specifier|public
specifier|static
name|boolean
name|eq
parameter_list|(
specifier|final
name|String
name|desc1
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
specifier|final
name|String
name|desc2
parameter_list|,
name|RelDataType
name|type2
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
comment|// if any one of the types is ANY return true
if|if
condition|(
name|type1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
operator|||
name|type2
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
condition|)
block|{
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
if|if
condition|(
name|type1
operator|!=
name|type2
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"type mismatch:\n{}:\n{}\n{}:\n{}"
argument_list|,
name|desc1
argument_list|,
name|type1
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|desc2
argument_list|,
name|type2
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
return|;
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Returns whether two types are equal using    * {@link #areRowTypesEqual(RelDataType, RelDataType, boolean)}. Both types    * must not be null.    *    * @param desc1 Description of role of first type    * @param type1 First type    * @param desc2 Description of role of second type    * @param type2 Second type    * @param litmus Whether to assert if they are not equal    * @return Whether the types are equal    */
specifier|public
specifier|static
name|boolean
name|equal
parameter_list|(
specifier|final
name|String
name|desc1
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
specifier|final
name|String
name|desc2
parameter_list|,
name|RelDataType
name|type2
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
if|if
condition|(
operator|!
name|areRowTypesEqual
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"Type mismatch:\n{}:\n{}\n{}:\n{}"
argument_list|,
name|desc1
argument_list|,
name|type1
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|desc2
argument_list|,
name|type2
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
return|;
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/** Returns whether two relational expressions have the same row-type. */
specifier|public
specifier|static
name|boolean
name|equalType
parameter_list|(
name|String
name|desc0
parameter_list|,
name|RelNode
name|rel0
parameter_list|,
name|String
name|desc1
parameter_list|,
name|RelNode
name|rel1
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
comment|// TODO: change 'equal' to 'eq', which is stronger.
return|return
name|equal
argument_list|(
name|desc0
argument_list|,
name|rel0
operator|.
name|getRowType
argument_list|()
argument_list|,
name|desc1
argument_list|,
name|rel1
operator|.
name|getRowType
argument_list|()
argument_list|,
name|litmus
argument_list|)
return|;
block|}
comment|/**    * Returns a translation of the<code>IS DISTINCT FROM</code> (or<code>IS    * NOT DISTINCT FROM</code>) sql operator.    *    * @param neg if false, returns a translation of IS NOT DISTINCT FROM    */
specifier|public
specifier|static
name|RexNode
name|isDistinctFrom
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|x
parameter_list|,
name|RexNode
name|y
parameter_list|,
name|boolean
name|neg
parameter_list|)
block|{
name|RexNode
name|ret
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|x
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
assert|assert
name|y
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
assert|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|xFields
init|=
name|x
operator|.
name|getType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|yFields
init|=
name|y
operator|.
name|getType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|xFields
operator|.
name|size
argument_list|()
operator|==
name|yFields
operator|.
name|size
argument_list|()
assert|;
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|xFields
argument_list|,
name|yFields
argument_list|)
control|)
block|{
name|RelDataTypeField
name|xField
init|=
name|pair
operator|.
name|left
decl_stmt|;
name|RelDataTypeField
name|yField
init|=
name|pair
operator|.
name|right
decl_stmt|;
name|RexNode
name|newX
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|x
argument_list|,
name|xField
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|newY
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|y
argument_list|,
name|yField
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|newCall
init|=
name|isDistinctFromInternal
argument_list|(
name|rexBuilder
argument_list|,
name|newX
argument_list|,
name|newY
argument_list|,
name|neg
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
name|ret
operator|=
name|newCall
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|ret
argument_list|,
name|newCall
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ret
operator|=
name|isDistinctFromInternal
argument_list|(
name|rexBuilder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|neg
argument_list|)
expr_stmt|;
block|}
comment|// The result of IS DISTINCT FROM is NOT NULL because it can
comment|// only return TRUE or FALSE.
name|ret
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|isDistinctFromInternal
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|x
parameter_list|,
name|RexNode
name|y
parameter_list|,
name|boolean
name|neg
parameter_list|)
block|{
name|SqlOperator
name|nullOp
decl_stmt|;
name|SqlOperator
name|eqOp
decl_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|nullOp
operator|=
name|SqlStdOperatorTable
operator|.
name|IS_NULL
expr_stmt|;
name|eqOp
operator|=
name|SqlStdOperatorTable
operator|.
name|EQUALS
expr_stmt|;
block|}
else|else
block|{
name|nullOp
operator|=
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
expr_stmt|;
name|eqOp
operator|=
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
expr_stmt|;
block|}
name|RexNode
index|[]
name|whenThenElse
init|=
block|{
comment|// when x is null
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|x
argument_list|)
block|,
comment|// then return y is [not] null
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|nullOp
argument_list|,
name|y
argument_list|)
block|,
comment|// when y is null
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|y
argument_list|)
block|,
comment|// then return x is [not] null
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|nullOp
argument_list|,
name|x
argument_list|)
block|,
comment|// else return x compared to y
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|eqOp
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
block|}
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|whenThenElse
argument_list|)
return|;
block|}
comment|/**    * Converts a relational expression to a string, showing just basic    * attributes.    */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|toString
argument_list|(
name|rel
argument_list|,
name|SqlExplainLevel
operator|.
name|EXPPLAN_ATTRIBUTES
argument_list|)
return|;
block|}
comment|/**    * Converts a relational expression to a string.    */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
name|SqlExplainLevel
name|detailLevel
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|RelWriter
name|planWriter
init|=
operator|new
name|RelWriterImpl
argument_list|(
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
argument_list|,
name|detailLevel
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|rel
operator|.
name|explain
argument_list|(
name|planWriter
argument_list|)
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|renameIfNecessary
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelDataType
name|desiredRowType
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|rowType
operator|==
name|desiredRowType
condition|)
block|{
comment|// Nothing to do.
return|return
name|rel
return|;
block|}
assert|assert
operator|!
name|rowType
operator|.
name|equals
argument_list|(
name|desiredRowType
argument_list|)
assert|;
if|if
condition|(
operator|!
name|areRowTypesEqual
argument_list|(
name|rowType
argument_list|,
name|desiredRowType
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// The row types are different ignoring names. Nothing we can do.
return|return
name|rel
return|;
block|}
name|rel
operator|=
name|createRename
argument_list|(
name|rel
argument_list|,
name|desiredRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rel
return|;
block|}
specifier|public
specifier|static
name|String
name|dumpType
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
specifier|final
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
specifier|final
name|TypeDumper
name|typeDumper
init|=
operator|new
name|TypeDumper
argument_list|(
name|pw
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|typeDumper
operator|.
name|acceptFields
argument_list|(
name|type
operator|.
name|getFieldList
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|typeDumper
operator|.
name|accept
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Decomposes a predicate into a list of expressions that are AND'ed    * together.    *    * @param rexPredicate predicate to be analyzed    * @param rexList      list of decomposed RexNodes    */
specifier|public
specifier|static
name|void
name|decomposeConjunction
parameter_list|(
name|RexNode
name|rexPredicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexList
parameter_list|)
block|{
if|if
condition|(
name|rexPredicate
operator|==
literal|null
operator|||
name|rexPredicate
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|rexPredicate
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|AND
argument_list|)
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexPredicate
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|decomposeConjunction
argument_list|(
name|operand
argument_list|,
name|rexList
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rexList
operator|.
name|add
argument_list|(
name|rexPredicate
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Decomposes a predicate into a list of expressions that are AND'ed    * together, and a list of expressions that are preceded by NOT.    *    *<p>For example, {@code a AND NOT b AND NOT (c and d) AND TRUE AND NOT    * FALSE} returns {@code rexList = [a], notList = [b, c AND d]}.</p>    *    *<p>TRUE and NOT FALSE expressions are ignored. FALSE and NOT TRUE    * expressions are placed on {@code rexList} and {@code notList} as other    * expressions.</p>    *    *<p>For example, {@code a AND TRUE AND NOT TRUE} returns    * {@code rexList = [a], notList = [TRUE]}.</p>    *    * @param rexPredicate predicate to be analyzed    * @param rexList      list of decomposed RexNodes (except those with NOT)    * @param notList      list of decomposed RexNodes that were prefixed NOT    */
specifier|public
specifier|static
name|void
name|decomposeConjunction
parameter_list|(
name|RexNode
name|rexPredicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexList
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|notList
parameter_list|)
block|{
if|if
condition|(
name|rexPredicate
operator|==
literal|null
operator|||
name|rexPredicate
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return;
block|}
switch|switch
condition|(
name|rexPredicate
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexPredicate
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|decomposeConjunction
argument_list|(
name|operand
argument_list|,
name|rexList
argument_list|,
name|notList
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NOT
case|:
specifier|final
name|RexNode
name|e
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rexPredicate
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return;
block|}
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|OR
case|:
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|ors
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|decomposeDisjunction
argument_list|(
name|e
argument_list|,
name|ors
argument_list|)
expr_stmt|;
for|for
control|(
name|RexNode
name|or
range|:
name|ors
control|)
block|{
switch|switch
condition|(
name|or
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|NOT
case|:
name|rexList
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|or
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|notList
operator|.
name|add
argument_list|(
name|or
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|notList
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LITERAL
case|:
if|if
condition|(
operator|!
name|RexLiteral
operator|.
name|isNullLiteral
argument_list|(
name|rexPredicate
argument_list|)
operator|&&
name|RexLiteral
operator|.
name|booleanValue
argument_list|(
name|rexPredicate
argument_list|)
condition|)
block|{
return|return;
comment|// ignore TRUE
block|}
comment|// fall through
default|default:
name|rexList
operator|.
name|add
argument_list|(
name|rexPredicate
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/**    * Decomposes a predicate into a list of expressions that are OR'ed    * together.    *    * @param rexPredicate predicate to be analyzed    * @param rexList      list of decomposed RexNodes    */
specifier|public
specifier|static
name|void
name|decomposeDisjunction
parameter_list|(
name|RexNode
name|rexPredicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexList
parameter_list|)
block|{
if|if
condition|(
name|rexPredicate
operator|==
literal|null
operator|||
name|rexPredicate
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|rexPredicate
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|OR
argument_list|)
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexPredicate
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|decomposeDisjunction
argument_list|(
name|operand
argument_list|,
name|rexList
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rexList
operator|.
name|add
argument_list|(
name|rexPredicate
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns a condition decomposed by AND.    *    *<p>For example, {@code conjunctions(TRUE)} returns the empty list;    * {@code conjunctions(FALSE)} returns list {@code {FALSE}}.</p>    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|conjunctions
parameter_list|(
name|RexNode
name|rexPredicate
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|decomposeConjunction
argument_list|(
name|rexPredicate
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|/**    * Returns a condition decomposed by OR.    *    *<p>For example, {@code disjunctions(FALSE)} returns the empty list.</p>    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|disjunctions
parameter_list|(
name|RexNode
name|rexPredicate
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|decomposeDisjunction
argument_list|(
name|rexPredicate
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|/**    * Ands two sets of join filters together, either of which can be null.    *    * @param rexBuilder rexBuilder to create AND expression    * @param left       filter on the left that the right will be AND'd to    * @param right      filter on the right    * @return AND'd filter    *    * @see org.apache.calcite.rex.RexUtil#composeConjunction    */
specifier|public
specifier|static
name|RexNode
name|andJoinFilters
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|left
parameter_list|,
name|RexNode
name|right
parameter_list|)
block|{
comment|// don't bother AND'ing in expressions that always evaluate to
comment|// true
if|if
condition|(
operator|(
name|left
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|left
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|right
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|right
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|left
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|left
operator|=
name|right
expr_stmt|;
block|}
comment|// Joins must have some filter
if|if
condition|(
name|left
operator|==
literal|null
condition|)
block|{
name|left
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|left
return|;
block|}
comment|/** Decomposes the WHERE clause of a view into predicates that constraint    * a column to a particular value.    *    *<p>This method is key to the validation of a modifiable view. Columns that    * are constrained to a single value can be omitted from the    * SELECT clause of a modifiable view.    *    * @param projectMap Mapping from column ordinal to the expression that    * populate that column, to be populated by this method    * @param filters List of remaining filters, to be populated by this method    * @param constraint Constraint to be analyzed    */
specifier|public
specifier|static
name|void
name|inferViewPredicates
parameter_list|(
name|Map
argument_list|<
name|Integer
argument_list|,
name|RexNode
argument_list|>
name|projectMap
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
parameter_list|,
name|RexNode
name|constraint
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|node
range|:
name|conjunctions
argument_list|(
name|constraint
argument_list|)
control|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|o0
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|o1
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|o0
operator|instanceof
name|RexLiteral
condition|)
block|{
name|o0
operator|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|o1
operator|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o0
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
condition|)
block|{
name|o0
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|o0
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o0
operator|instanceof
name|RexInputRef
operator|&&
name|o1
operator|instanceof
name|RexLiteral
condition|)
block|{
specifier|final
name|int
name|index
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|o0
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|projectMap
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|==
literal|null
condition|)
block|{
name|projectMap
operator|.
name|put
argument_list|(
name|index
argument_list|,
name|o1
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|filters
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Adjusts key values in a list by some fixed amount.    *    * @param keys       list of key values    * @param adjustment the amount to adjust the key values by    * @return modified list    */
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|adjustKeys
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|keys
parameter_list|,
name|int
name|adjustment
parameter_list|)
block|{
if|if
condition|(
name|adjustment
operator|==
literal|0
condition|)
block|{
return|return
name|keys
return|;
block|}
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|newKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|key
range|:
name|keys
control|)
block|{
name|newKeys
operator|.
name|add
argument_list|(
name|key
operator|+
name|adjustment
argument_list|)
expr_stmt|;
block|}
return|return
name|newKeys
return|;
block|}
comment|/**    * Simplifies outer joins if filter above would reject nulls.    *    * @param joinRel Join    * @param aboveFilters Filters from above    * @param joinType Join type, can not be inner join    */
specifier|public
specifier|static
name|JoinRelType
name|simplifyJoin
parameter_list|(
name|RelNode
name|joinRel
parameter_list|,
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|aboveFilters
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|)
block|{
specifier|final
name|int
name|nTotalFields
init|=
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nSysFields
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|nFieldsLeft
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nFieldsRight
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
name|nTotalFields
operator|==
name|nSysFields
operator|+
name|nFieldsLeft
operator|+
name|nFieldsRight
assert|;
comment|// set the reference bitmaps for the left and right children
name|ImmutableBitSet
name|leftBitmap
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
argument_list|,
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|rightBitmap
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
name|nTotalFields
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|filter
range|:
name|aboveFilters
control|)
block|{
if|if
condition|(
name|joinType
operator|.
name|generatesNullsOnLeft
argument_list|()
operator|&&
name|Strong
operator|.
name|isNotTrue
argument_list|(
name|filter
argument_list|,
name|leftBitmap
argument_list|)
condition|)
block|{
name|joinType
operator|=
name|joinType
operator|.
name|cancelNullsOnLeft
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
operator|&&
name|Strong
operator|.
name|isNotTrue
argument_list|(
name|filter
argument_list|,
name|rightBitmap
argument_list|)
condition|)
block|{
name|joinType
operator|=
name|joinType
operator|.
name|cancelNullsOnRight
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|joinType
operator|==
name|JoinRelType
operator|.
name|INNER
condition|)
block|{
break|break;
block|}
block|}
return|return
name|joinType
return|;
block|}
comment|/**    * Classifies filters according to where they should be processed. They    * either stay where they are, are pushed to the join (if they originated    * from above the join), or are pushed to one of the children. Filters that    * are pushed are added to list passed in as input parameters.    *    * @param joinRel      join node    * @param filters      filters to be classified    * @param joinType     join type    * @param pushInto     whether filters can be pushed into the ON clause    * @param pushLeft     true if filters can be pushed to the left    * @param pushRight    true if filters can be pushed to the right    * @param joinFilters  list of filters to push to the join    * @param leftFilters  list of filters to push to the left child    * @param rightFilters list of filters to push to the right child    * @return whether at least one filter was pushed    */
specifier|public
specifier|static
name|boolean
name|classifyFilters
parameter_list|(
name|RelNode
name|joinRel
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|,
name|boolean
name|pushInto
parameter_list|,
name|boolean
name|pushLeft
parameter_list|,
name|boolean
name|pushRight
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilters
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftFilters
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightFilters
parameter_list|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|joinFields
init|=
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nTotalFields
init|=
name|joinFields
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nSysFields
init|=
literal|0
decl_stmt|;
comment|// joinRel.getSystemFieldList().size();
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftFields
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nFieldsLeft
init|=
name|leftFields
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightFields
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nFieldsRight
init|=
name|rightFields
operator|.
name|size
argument_list|()
decl_stmt|;
assert|assert
name|nTotalFields
operator|==
operator|(
name|joinRel
operator|instanceof
name|SemiJoin
condition|?
name|nSysFields
operator|+
name|nFieldsLeft
else|:
name|nSysFields
operator|+
name|nFieldsLeft
operator|+
name|nFieldsRight
operator|)
assert|;
comment|// set the reference bitmaps for the left and right children
name|ImmutableBitSet
name|leftBitmap
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
argument_list|,
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|rightBitmap
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
name|nTotalFields
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToRemove
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|filter
range|:
name|filters
control|)
block|{
specifier|final
name|InputFinder
name|inputFinder
init|=
name|InputFinder
operator|.
name|analyze
argument_list|(
name|filter
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|inputBits
init|=
name|inputFinder
operator|.
name|inputBitSet
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// REVIEW - are there any expressions that need special handling
comment|// and therefore cannot be pushed?
comment|// filters can be pushed to the left child if the left child
comment|// does not generate NULLs and the only columns referenced in
comment|// the filter originate from the left child
if|if
condition|(
name|pushLeft
operator|&&
name|leftBitmap
operator|.
name|contains
argument_list|(
name|inputBits
argument_list|)
condition|)
block|{
comment|// ignore filters that always evaluate to true
if|if
condition|(
operator|!
name|filter
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// adjust the field references in the filter to reflect
comment|// that fields in the left now shift over by the number
comment|// of system fields
specifier|final
name|RexNode
name|shiftedFilter
init|=
name|shiftFilter
argument_list|(
name|nSysFields
argument_list|,
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
operator|-
name|nSysFields
argument_list|,
name|rexBuilder
argument_list|,
name|joinFields
argument_list|,
name|nTotalFields
argument_list|,
name|leftFields
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|leftFilters
operator|.
name|add
argument_list|(
name|shiftedFilter
argument_list|)
expr_stmt|;
block|}
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
comment|// filters can be pushed to the right child if the right child
comment|// does not generate NULLs and the only columns referenced in
comment|// the filter originate from the right child
block|}
if|else if
condition|(
name|pushRight
operator|&&
name|rightBitmap
operator|.
name|contains
argument_list|(
name|inputBits
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|filter
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// adjust the field references in the filter to reflect
comment|// that fields in the right now shift over to the left;
comment|// since we never push filters to a NULL generating
comment|// child, the types of the source should match the dest
comment|// so we don't need to explicitly pass the destination
comment|// fields to RexInputConverter
specifier|final
name|RexNode
name|shiftedFilter
init|=
name|shiftFilter
argument_list|(
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
name|nTotalFields
argument_list|,
operator|-
operator|(
name|nSysFields
operator|+
name|nFieldsLeft
operator|)
argument_list|,
name|rexBuilder
argument_list|,
name|joinFields
argument_list|,
name|nTotalFields
argument_list|,
name|rightFields
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|rightFilters
operator|.
name|add
argument_list|(
name|shiftedFilter
argument_list|)
expr_stmt|;
block|}
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If the filter can't be pushed to either child and the join
comment|// is an inner join, push them to the join if they originated
comment|// from above the join
if|if
condition|(
name|joinType
operator|==
name|JoinRelType
operator|.
name|INNER
operator|&&
name|pushInto
condition|)
block|{
if|if
condition|(
operator|!
name|joinFilters
operator|.
name|contains
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|joinFilters
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Remove filters after the loop, to prevent concurrent modification.
if|if
condition|(
operator|!
name|filtersToRemove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|filters
operator|.
name|removeAll
argument_list|(
name|filtersToRemove
argument_list|)
expr_stmt|;
block|}
comment|// Did anything change?
return|return
operator|!
name|filtersToRemove
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|shiftFilter
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|offset
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|joinFields
parameter_list|,
name|int
name|nTotalFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightFields
parameter_list|,
name|RexNode
name|filter
parameter_list|)
block|{
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|nTotalFields
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
block|}
return|return
name|filter
operator|.
name|accept
argument_list|(
operator|new
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|joinFields
argument_list|,
name|rightFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Splits a filter into two lists, depending on whether or not the filter    * only references its child input    *    * @param childBitmap Fields in the child    * @param predicate   filters that will be split    * @param pushable    returns the list of filters that can be pushed to the    *                    child input    * @param notPushable returns the list of filters that cannot be pushed to    *                    the child input    */
specifier|public
specifier|static
name|void
name|splitFilters
parameter_list|(
name|ImmutableBitSet
name|childBitmap
parameter_list|,
name|RexNode
name|predicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|pushable
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|notPushable
parameter_list|)
block|{
comment|// for each filter, if the filter only references the child inputs,
comment|// then it can be pushed
for|for
control|(
name|RexNode
name|filter
range|:
name|conjunctions
argument_list|(
name|predicate
argument_list|)
control|)
block|{
name|ImmutableBitSet
name|filterRefs
init|=
name|InputFinder
operator|.
name|bits
argument_list|(
name|filter
argument_list|)
decl_stmt|;
if|if
condition|(
name|childBitmap
operator|.
name|contains
argument_list|(
name|filterRefs
argument_list|)
condition|)
block|{
name|pushable
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notPushable
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|boolean
name|checkProjAndChildInputs
parameter_list|(
name|Project
name|project
parameter_list|,
name|boolean
name|checkNames
parameter_list|)
block|{
name|int
name|n
init|=
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|RelDataType
name|inputType
init|=
name|project
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputType
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|n
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|projFields
init|=
name|project
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputFields
init|=
name|inputType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|boolean
name|namesDifferent
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|RexNode
name|exp
init|=
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|exp
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RexInputRef
name|fieldAccess
init|=
operator|(
name|RexInputRef
operator|)
name|exp
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|fieldAccess
operator|.
name|getIndex
argument_list|()
condition|)
block|{
comment|// can't support reorder yet
return|return
literal|false
return|;
block|}
if|if
condition|(
name|checkNames
condition|)
block|{
name|String
name|inputFieldName
init|=
name|inputFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|projFieldName
init|=
name|projFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|projFieldName
operator|.
name|equals
argument_list|(
name|inputFieldName
argument_list|)
condition|)
block|{
name|namesDifferent
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// inputs are the same; return value depends on the checkNames
comment|// parameter
return|return
operator|!
name|checkNames
operator|||
name|namesDifferent
return|;
block|}
comment|/**    * Creates projection expressions reflecting the swapping of a join's input.    *    * @param newJoin   the RelNode corresponding to the join with its inputs    *                  swapped    * @param origJoin  original LogicalJoin    * @param origOrder if true, create the projection expressions to reflect    *                  the original (pre-swapped) join projection; otherwise,    *                  create the projection to reflect the order of the swapped    *                  projection    * @return array of expression representing the swapped join inputs    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|createSwappedJoinExprs
parameter_list|(
name|RelNode
name|newJoin
parameter_list|,
name|Join
name|origJoin
parameter_list|,
name|boolean
name|origOrder
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|newJoinFields
init|=
name|newJoin
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|newJoin
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nFields
init|=
name|origOrder
condition|?
name|origJoin
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
else|:
name|origJoin
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newJoinFields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|source
init|=
operator|(
name|i
operator|+
name|nFields
operator|)
operator|%
name|newJoinFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|RelDataTypeField
name|field
init|=
name|origOrder
condition|?
name|newJoinFields
operator|.
name|get
argument_list|(
name|source
argument_list|)
else|:
name|newJoinFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|exps
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|exps
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RexNode
name|pushFilterPastProject
parameter_list|(
name|RexNode
name|filter
parameter_list|,
specifier|final
name|Project
name|projRel
parameter_list|)
block|{
return|return
name|pushPastProject
argument_list|(
name|filter
argument_list|,
name|projRel
argument_list|)
return|;
block|}
comment|/**    * Converts an expression that is based on the output fields of a    * {@link Project} to an equivalent expression on the Project's    * input fields.    *    * @param node The expression to be converted    * @param project Project underneath the expression    * @return converted expression    */
specifier|public
specifier|static
name|RexNode
name|pushPastProject
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|Project
name|project
parameter_list|)
block|{
return|return
name|node
operator|.
name|accept
argument_list|(
name|pushShuttle
argument_list|(
name|project
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Converts a list of expressions that are based on the output fields of a    * {@link Project} to equivalent expressions on the Project's    * input fields.    *    * @param nodes The expressions to be converted    * @param project Project underneath the expression    * @return converted expressions    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|pushPastProject
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|Project
name|project
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|pushShuttle
argument_list|(
name|project
argument_list|)
operator|.
name|visitList
argument_list|(
name|nodes
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
specifier|private
specifier|static
name|RexShuttle
name|pushShuttle
parameter_list|(
specifier|final
name|Project
name|project
parameter_list|)
block|{
return|return
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|ref
parameter_list|)
block|{
return|return
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Creates a new {@link org.apache.calcite.rel.rules.MultiJoin} to reflect    * projection references from a    * {@link org.apache.calcite.rel.logical.LogicalProject} that is on top of the    * {@link org.apache.calcite.rel.rules.MultiJoin}.    *    * @param multiJoin the original MultiJoin    * @param project   the LogicalProject on top of the MultiJoin    * @return the new MultiJoin    */
specifier|public
specifier|static
name|MultiJoin
name|projectMultiJoin
parameter_list|(
name|MultiJoin
name|multiJoin
parameter_list|,
name|LogicalProject
name|project
parameter_list|)
block|{
comment|// Locate all input references in the projection expressions as well
comment|// the post-join filter.  Since the filter effectively sits in
comment|// between the LogicalProject and the MultiJoin, the projection needs
comment|// to include those filter references.
name|ImmutableBitSet
name|inputRefs
init|=
name|InputFinder
operator|.
name|bits
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getPostJoinFilter
argument_list|()
argument_list|)
decl_stmt|;
comment|// create new copies of the bitmaps
name|List
argument_list|<
name|RelNode
argument_list|>
name|multiJoinInputs
init|=
name|multiJoin
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|BitSet
argument_list|>
name|newProjFields
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|multiJoinInput
range|:
name|multiJoinInputs
control|)
block|{
name|newProjFields
operator|.
name|add
argument_list|(
operator|new
name|BitSet
argument_list|(
name|multiJoinInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// set the bits found in the expressions
name|int
name|currInput
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|startField
init|=
literal|0
decl_stmt|;
name|int
name|nFields
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|bit
range|:
name|inputRefs
control|)
block|{
while|while
condition|(
name|bit
operator|>=
operator|(
name|startField
operator|+
name|nFields
operator|)
condition|)
block|{
name|startField
operator|+=
name|nFields
expr_stmt|;
name|currInput
operator|++
expr_stmt|;
assert|assert
name|currInput
operator|<
name|multiJoinInputs
operator|.
name|size
argument_list|()
assert|;
name|nFields
operator|=
name|multiJoinInputs
operator|.
name|get
argument_list|(
name|currInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
name|newProjFields
operator|.
name|get
argument_list|(
name|currInput
argument_list|)
operator|.
name|set
argument_list|(
name|bit
operator|-
name|startField
argument_list|)
expr_stmt|;
block|}
comment|// create a new MultiJoin containing the new field bitmaps
comment|// for each input
return|return
operator|new
name|MultiJoin
argument_list|(
name|multiJoin
operator|.
name|getCluster
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getInputs
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getJoinFilter
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getRowType
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|isFullOuterJoin
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getOuterJoinConditions
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getJoinTypes
argument_list|()
argument_list|,
name|Lists
operator|.
name|transform
argument_list|(
name|newProjFields
argument_list|,
name|ImmutableBitSet
operator|.
name|FROM_BIT_SET
argument_list|)
argument_list|,
name|multiJoin
operator|.
name|getJoinFieldRefCountsMap
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getPostJoinFilter
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|RelNode
parameter_list|>
name|T
name|addTrait
parameter_list|(
name|T
name|rel
parameter_list|,
name|RelTrait
name|trait
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|T
operator|)
name|rel
operator|.
name|copy
argument_list|(
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|trait
argument_list|)
argument_list|,
operator|(
name|List
operator|)
name|rel
operator|.
name|getInputs
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a shallow copy of a relational expression with a particular    * input replaced.    */
specifier|public
specifier|static
name|RelNode
name|replaceInput
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|newInput
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|parent
operator|.
name|getInputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputs
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
operator|==
name|newInput
condition|)
block|{
return|return
name|parent
return|;
block|}
name|inputs
operator|.
name|set
argument_list|(
name|ordinal
argument_list|,
name|newInput
argument_list|)
expr_stmt|;
return|return
name|parent
operator|.
name|copy
argument_list|(
name|parent
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|inputs
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link org.apache.calcite.rel.logical.LogicalProject} that    * projects particular fields of its input, according to a mapping.    */
specifier|public
specifier|static
name|RelNode
name|createProject
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|)
block|{
return|return
name|createProject
argument_list|(
name|child
argument_list|,
name|Mappings
operator|.
name|asList
argument_list|(
name|mapping
operator|.
name|inverse
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RelNode
name|createProject
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|RelFactories
operator|.
name|ProjectFactory
name|projectFactory
parameter_list|)
block|{
return|return
name|createProject
argument_list|(
name|projectFactory
argument_list|,
name|child
argument_list|,
name|Mappings
operator|.
name|asList
argument_list|(
name|mapping
operator|.
name|inverse
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns whether relational expression {@code target} occurs within a    * relational expression {@code ancestor}. */
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|RelNode
name|ancestor
parameter_list|,
specifier|final
name|RelNode
name|target
parameter_list|)
block|{
if|if
condition|(
name|ancestor
operator|==
name|target
condition|)
block|{
comment|// Short-cut common case.
return|return
literal|true
return|;
block|}
try|try
block|{
operator|new
name|RelVisitor
argument_list|()
block|{
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
name|target
condition|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// CHECKSTYLE: IGNORE 1
block|}
operator|.
name|go
argument_list|(
name|ancestor
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/** Within a relational expression {@code query}, replaces occurrences of    * {@code find} with {@code replace}. */
specifier|public
specifier|static
name|RelNode
name|replace
parameter_list|(
name|RelNode
name|query
parameter_list|,
name|RelNode
name|find
parameter_list|,
name|RelNode
name|replace
parameter_list|)
block|{
if|if
condition|(
name|find
operator|==
name|replace
condition|)
block|{
comment|// Short-cut common case.
return|return
name|query
return|;
block|}
assert|assert
name|equalType
argument_list|(
literal|"find"
argument_list|,
name|find
argument_list|,
literal|"replace"
argument_list|,
name|replace
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
if|if
condition|(
name|query
operator|==
name|find
condition|)
block|{
comment|// Short-cut another common case.
return|return
name|replace
return|;
block|}
return|return
name|replaceRecurse
argument_list|(
name|query
argument_list|,
name|find
argument_list|,
name|replace
argument_list|)
return|;
block|}
comment|/** Helper for {@link #replace}. */
specifier|private
specifier|static
name|RelNode
name|replaceRecurse
parameter_list|(
name|RelNode
name|query
parameter_list|,
name|RelNode
name|find
parameter_list|,
name|RelNode
name|replace
parameter_list|)
block|{
if|if
condition|(
name|query
operator|==
name|find
condition|)
block|{
return|return
name|replace
return|;
block|}
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|query
operator|.
name|getInputs
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|inputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|newInputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|inputs
control|)
block|{
name|newInputs
operator|.
name|add
argument_list|(
name|replaceRecurse
argument_list|(
name|input
argument_list|,
name|find
argument_list|,
name|replace
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newInputs
operator|.
name|equals
argument_list|(
name|inputs
argument_list|)
condition|)
block|{
return|return
name|query
operator|.
name|copy
argument_list|(
name|query
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newInputs
argument_list|)
return|;
block|}
block|}
return|return
name|query
return|;
block|}
comment|/** Returns a simple    * {@link org.apache.calcite.plan.RelOptTable.ToRelContext}. */
specifier|public
specifier|static
name|RelOptTable
operator|.
name|ToRelContext
name|getContext
parameter_list|(
specifier|final
name|RelOptCluster
name|cluster
parameter_list|)
block|{
return|return
operator|new
name|RelOptTable
operator|.
name|ToRelContext
argument_list|()
block|{
specifier|public
name|RelOptCluster
name|getCluster
parameter_list|()
block|{
return|return
name|cluster
return|;
block|}
specifier|public
name|RelRoot
name|expandView
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|String
name|queryString
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|schemaPath
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|viewPath
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
comment|/** Returns the number of {@link org.apache.calcite.rel.core.Join} nodes in a    * tree. */
specifier|public
specifier|static
name|int
name|countJoins
parameter_list|(
name|RelNode
name|rootRel
parameter_list|)
block|{
comment|/** Visitor that counts join nodes. */
class|class
name|JoinCounter
extends|extends
name|RelVisitor
block|{
name|int
name|joinCount
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|Join
condition|)
block|{
operator|++
name|joinCount
expr_stmt|;
block|}
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
name|int
name|run
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
name|go
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|joinCount
return|;
block|}
block|}
return|return
operator|new
name|JoinCounter
argument_list|()
operator|.
name|run
argument_list|(
name|rootRel
argument_list|)
return|;
block|}
comment|/** Permutes a record type according to a mapping. */
specifier|public
specifier|static
name|RelDataType
name|permute
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|Mapping
name|mapping
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|Mappings
operator|.
name|apply3
argument_list|(
name|mapping
argument_list|,
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a relational expression which projects a list of expressions.    *    * @param child         input relational expression    * @param exprList      list of expressions for the input columns    * @param fieldNameList aliases of the expressions, or null to generate    */
specifier|public
specifier|static
name|RelNode
name|createProject
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprList
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
parameter_list|)
block|{
return|return
name|createProject
argument_list|(
name|child
argument_list|,
name|exprList
argument_list|,
name|fieldNameList
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Creates a relational expression which projects a list of (expression, name)    * pairs.    *    * @param child       input relational expression    * @param projectList list of (expression, name) pairs    * @param optimize    Whether to optimize    */
specifier|public
specifier|static
name|RelNode
name|createProject
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|projectList
parameter_list|,
name|boolean
name|optimize
parameter_list|)
block|{
return|return
name|createProject
argument_list|(
name|child
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|projectList
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|projectList
argument_list|)
argument_list|,
name|optimize
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|child
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a relational expression that projects the given fields of the    * input.    *    *<p>Optimizes if the fields are the identity projection.</p>    *    * @param child   Input relational expression    * @param posList Source of each projected field    * @return Relational expression that projects given fields    */
specifier|public
specifier|static
name|RelNode
name|createProject
parameter_list|(
specifier|final
name|RelNode
name|child
parameter_list|,
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|posList
parameter_list|)
block|{
return|return
name|createProject
argument_list|(
name|RelFactories
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|,
name|child
argument_list|,
name|posList
argument_list|)
return|;
block|}
comment|/**    * Creates a relational expression which projects an array of expressions,    * and optionally optimizes.    *    *<p>The result may not be a    * {@link org.apache.calcite.rel.logical.LogicalProject}. If the    * projection is trivial,<code>child</code> is returned directly; and future    * versions may return other formulations of expressions, such as    * {@link org.apache.calcite.rel.logical.LogicalCalc}.    *    * @param child      input relational expression    * @param exprs      list of expressions for the input columns    * @param fieldNames aliases of the expressions, or null to generate    * @param optimize   Whether to return<code>child</code> unchanged if the    *                   projections are trivial.    */
specifier|public
specifier|static
name|RelNode
name|createProject
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|,
name|boolean
name|optimize
parameter_list|)
block|{
return|return
name|createProject
argument_list|(
name|child
argument_list|,
name|exprs
argument_list|,
name|fieldNames
argument_list|,
name|optimize
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|child
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a relational expression which projects an array of expressions,    * and optionally optimizes.    *    *<p>The result may not be a    * {@link org.apache.calcite.rel.logical.LogicalProject}. If the    * projection is trivial,<code>child</code> is returned directly; and future    * versions may return other formulations of expressions, such as    * {@link org.apache.calcite.rel.logical.LogicalCalc}.    *    * @param child          input relational expression    * @param exprs          list of expressions for the input columns    * @param fieldNames     aliases of the expressions, or null to generate    * @param optimize       Whether to return<code>child</code> unchanged if the    *                       projections are trivial.    * @param relBuilder     Factory to create project operators    */
specifier|public
specifier|static
name|RelNode
name|createProject
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|,
name|boolean
name|optimize
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|)
block|{
specifier|final
name|RelOptCluster
name|cluster
init|=
name|child
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|RexUtil
operator|.
name|createStructType
argument_list|(
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|exprs
argument_list|,
name|fieldNames
argument_list|,
name|SqlValidatorUtil
operator|.
name|F_SUGGESTER
argument_list|)
decl_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|RexUtil
operator|.
name|isIdentity
argument_list|(
name|exprs
argument_list|,
name|child
operator|.
name|getRowType
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|child
operator|instanceof
name|Project
operator|&&
name|fieldNames
operator|!=
literal|null
condition|)
block|{
comment|// Rename columns of child projection if desired field names are given.
name|Project
name|childProject
init|=
operator|(
name|Project
operator|)
name|child
decl_stmt|;
name|child
operator|=
name|childProject
operator|.
name|copy
argument_list|(
name|childProject
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|childProject
operator|.
name|getInput
argument_list|()
argument_list|,
name|childProject
operator|.
name|getProjects
argument_list|()
argument_list|,
name|rowType
argument_list|)
expr_stmt|;
block|}
return|return
name|child
return|;
block|}
name|relBuilder
operator|.
name|push
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|exprs
argument_list|,
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|,
operator|!
name|optimize
argument_list|)
expr_stmt|;
return|return
name|relBuilder
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|createRename
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|fieldNames
operator|.
name|size
argument_list|()
operator|==
name|fields
operator|.
name|size
argument_list|()
assert|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|refs
init|=
operator|new
name|AbstractList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fields
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|RexNode
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|RexInputRef
operator|.
name|of
argument_list|(
name|index
argument_list|,
name|fields
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|createProject
argument_list|(
name|rel
argument_list|,
name|refs
argument_list|,
name|fieldNames
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Creates a relational expression which permutes the output fields of a    * relational expression according to a permutation.    *    *<p>Optimizations:</p>    *    *<ul>    *<li>If the relational expression is a    * {@link org.apache.calcite.rel.logical.LogicalCalc} or    * {@link org.apache.calcite.rel.logical.LogicalProject} that is already    * acting as a permutation, combines the new permutation with the old;</li>    *    *<li>If the permutation is the identity, returns the original relational    * expression.</li>    *</ul>    *    *<p>If a permutation is combined with its inverse, these optimizations    * would combine to remove them both.    *    * @param rel         Relational expression    * @param permutation Permutation to apply to fields    * @param fieldNames  Field names; if null, or if a particular entry is null,    *                    the name of the permuted field is used    * @return relational expression which permutes its input fields    */
specifier|public
specifier|static
name|RelNode
name|permute
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Permutation
name|permutation
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
if|if
condition|(
name|permutation
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
return|return
name|rel
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|LogicalCalc
condition|)
block|{
name|LogicalCalc
name|calc
init|=
operator|(
name|LogicalCalc
operator|)
name|rel
decl_stmt|;
name|Permutation
name|permutation1
init|=
name|calc
operator|.
name|getProgram
argument_list|()
operator|.
name|getPermutation
argument_list|()
decl_stmt|;
if|if
condition|(
name|permutation1
operator|!=
literal|null
condition|)
block|{
name|Permutation
name|permutation2
init|=
name|permutation
operator|.
name|product
argument_list|(
name|permutation1
argument_list|)
decl_stmt|;
return|return
name|permute
argument_list|(
name|rel
argument_list|,
name|permutation2
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|rel
operator|instanceof
name|LogicalProject
condition|)
block|{
name|Permutation
name|permutation1
init|=
operator|(
operator|(
name|LogicalProject
operator|)
name|rel
operator|)
operator|.
name|getPermutation
argument_list|()
decl_stmt|;
if|if
condition|(
name|permutation1
operator|!=
literal|null
condition|)
block|{
name|Permutation
name|permutation2
init|=
name|permutation
operator|.
name|product
argument_list|(
name|permutation1
argument_list|)
decl_stmt|;
return|return
name|permute
argument_list|(
name|rel
argument_list|,
name|permutation2
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|outputTypeList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|outputNameList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|rel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|permutation
operator|.
name|getTargetCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|target
init|=
name|permutation
operator|.
name|getTarget
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeField
name|targetField
init|=
name|fields
operator|.
name|get
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|outputTypeList
operator|.
name|add
argument_list|(
name|targetField
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|outputNameList
operator|.
name|add
argument_list|(
operator|(
operator|(
name|fieldNames
operator|==
literal|null
operator|)
operator|||
operator|(
name|fieldNames
operator|.
name|size
argument_list|()
operator|<=
name|i
operator|)
operator|||
operator|(
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
operator|)
operator|)
condition|?
name|targetField
operator|.
name|getName
argument_list|()
else|:
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|exprList
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|int
name|source
init|=
name|permutation
operator|.
name|getSource
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|projectRefList
operator|.
name|add
argument_list|(
operator|new
name|RexLocalRef
argument_list|(
name|source
argument_list|,
name|fields
operator|.
name|get
argument_list|(
name|source
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RexProgram
name|program
init|=
operator|new
name|RexProgram
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|exprList
argument_list|,
name|projectRefList
argument_list|,
literal|null
argument_list|,
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|outputTypeList
argument_list|,
name|outputNameList
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|LogicalCalc
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|program
argument_list|)
return|;
block|}
comment|/**    * Creates a relational expression that projects the given fields of the    * input.    *    *<p>Optimizes if the fields are the identity projection.    *    * @param factory ProjectFactory    * @param child Input relational expression    * @param posList Source of each projected field    * @return Relational expression that projects given fields    */
specifier|public
specifier|static
name|RelNode
name|createProject
parameter_list|(
specifier|final
name|RelFactories
operator|.
name|ProjectFactory
name|factory
parameter_list|,
specifier|final
name|RelNode
name|child
parameter_list|,
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|posList
parameter_list|)
block|{
name|RelDataType
name|rowType
init|=
name|child
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|rowType
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|child
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
return|return
name|createProject
argument_list|(
name|child
argument_list|,
operator|new
name|AbstractList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|posList
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|RexNode
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
specifier|final
name|int
name|pos
init|=
name|posList
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|child
argument_list|,
name|pos
argument_list|)
return|;
block|}
block|}
argument_list|,
operator|new
name|AbstractList
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|posList
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|String
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
specifier|final
name|int
name|pos
init|=
name|posList
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|fieldNames
operator|.
name|get
argument_list|(
name|pos
argument_list|)
return|;
block|}
block|}
argument_list|,
literal|true
argument_list|,
name|RelBuilder
operator|.
name|proto
argument_list|(
name|factory
argument_list|)
operator|.
name|create
argument_list|(
name|child
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|projectMapping
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Mapping
name|mapping
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|,
name|RelFactories
operator|.
name|ProjectFactory
name|projectFactory
parameter_list|)
block|{
assert|assert
name|mapping
operator|.
name|getMappingType
argument_list|()
operator|.
name|isSingleSource
argument_list|()
assert|;
assert|assert
name|mapping
operator|.
name|getMappingType
argument_list|()
operator|.
name|isMandatorySource
argument_list|()
assert|;
if|if
condition|(
name|mapping
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
return|return
name|rel
return|;
block|}
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|outputNameList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mapping
operator|.
name|getTargetCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|source
init|=
name|mapping
operator|.
name|getSource
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeField
name|sourceField
init|=
name|fields
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|outputNameList
operator|.
name|add
argument_list|(
operator|(
operator|(
name|fieldNames
operator|==
literal|null
operator|)
operator|||
operator|(
name|fieldNames
operator|.
name|size
argument_list|()
operator|<=
name|i
operator|)
operator|||
operator|(
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
operator|)
operator|)
condition|?
name|sourceField
operator|.
name|getName
argument_list|()
else|:
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|exprList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|rel
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|projectFactory
operator|.
name|createProject
argument_list|(
name|rel
argument_list|,
name|exprList
argument_list|,
name|outputNameList
argument_list|)
return|;
block|}
comment|/** Policies for handling two- and three-valued boolean logic. */
specifier|public
enum|enum
name|Logic
block|{
comment|/** Three-valued boolean logic. */
name|TRUE_FALSE_UNKNOWN
block|,
comment|/** Nulls are not possible. */
name|TRUE_FALSE
block|,
comment|/** Two-valued logic where UNKNOWN is treated as FALSE.      *      *<p>"x IS TRUE" produces the same result, and "WHERE x", "JOIN ... ON x"      * and "HAVING x" have the same effect. */
name|UNKNOWN_AS_FALSE
block|,
comment|/** Two-valued logic where UNKNOWN is treated as TRUE.      *      *<p>"x IS FALSE" produces the same result, as does "WHERE NOT x", etc.      *      *<p>In particular, this is the mode used by "WHERE k NOT IN q". If      * "k IN q" produces TRUE or UNKNOWN, "NOT k IN q" produces FALSE or      * UNKNOWN and the row is eliminated; if "k IN q" it returns FALSE, the      * row is retained by the WHERE clause. */
name|UNKNOWN_AS_TRUE
block|,
comment|/** A semi-join will have been applied, so that only rows for which the      * value is TRUE will have been returned. */
name|TRUE
block|,
comment|/** An anti-semi-join will have been applied, so that only rows for which      * the value is FALSE will have been returned.      *      *<p>Currently only used within {@link LogicVisitor}, to ensure that      * 'NOT (NOT EXISTS (q))' behaves the same as 'EXISTS (q)') */
name|FALSE
block|;
specifier|public
name|Logic
name|negate
parameter_list|()
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|UNKNOWN_AS_FALSE
case|:
case|case
name|TRUE
case|:
return|return
name|UNKNOWN_AS_TRUE
return|;
case|case
name|UNKNOWN_AS_TRUE
case|:
return|return
name|UNKNOWN_AS_FALSE
return|;
default|default:
return|return
name|this
return|;
block|}
block|}
comment|/** Variant of {@link #negate()} to be used within {@link LogicVisitor},      * where FALSE values may exist. */
specifier|public
name|Logic
name|negate2
parameter_list|()
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|FALSE
case|:
return|return
name|TRUE
return|;
case|case
name|TRUE
case|:
return|return
name|FALSE
return|;
case|case
name|UNKNOWN_AS_FALSE
case|:
return|return
name|UNKNOWN_AS_TRUE
return|;
case|case
name|UNKNOWN_AS_TRUE
case|:
return|return
name|UNKNOWN_AS_FALSE
return|;
default|default:
return|return
name|this
return|;
block|}
block|}
block|}
comment|/**    * Pushes down expressions in "equal" join condition.    *    *<p>For example, given    * "emp JOIN dept ON emp.deptno + 1 = dept.deptno", adds a project above    * "emp" that computes the expression    * "emp.deptno + 1". The resulting join condition is a simple combination    * of AND, equals, and input fields, plus the remaining non-equal conditions.    *    * @param originalJoin Join whose condition is to be pushed down    * @param relBuilder Factory to create project operator    */
specifier|public
specifier|static
name|RelNode
name|pushDownJoinConditions
parameter_list|(
name|Join
name|originalJoin
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|)
block|{
name|RexNode
name|joinCond
init|=
name|originalJoin
operator|.
name|getCondition
argument_list|()
decl_stmt|;
specifier|final
name|JoinRelType
name|joinType
init|=
name|originalJoin
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraLeftExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraRightExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|leftCount
init|=
name|originalJoin
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|rightCount
init|=
name|originalJoin
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
comment|// You cannot push a 'get' because field names might change.
comment|//
comment|// Pushing sub-queries is OK in principle (if they don't reference both
comment|// sides of the join via correlating variables) but we'd rather not do it
comment|// yet.
if|if
condition|(
operator|!
name|containsGet
argument_list|(
name|joinCond
argument_list|)
operator|&&
name|RexUtil
operator|.
name|SubQueryFinder
operator|.
name|find
argument_list|(
name|joinCond
argument_list|)
operator|==
literal|null
condition|)
block|{
name|joinCond
operator|=
name|pushDownEqualJoinConditions
argument_list|(
name|joinCond
argument_list|,
name|leftCount
argument_list|,
name|rightCount
argument_list|,
name|extraLeftExprs
argument_list|,
name|extraRightExprs
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|push
argument_list|(
name|originalJoin
operator|.
name|getLeft
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extraLeftExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|AbstractList
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
name|leftCount
condition|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
expr|<
name|RexNode
operator|,
name|String
operator|>
name|of
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|index
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|extraLeftExprs
operator|.
name|get
argument_list|(
name|index
operator|-
name|leftCount
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
block|}
decl_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|pairs
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|pairs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|push
argument_list|(
name|originalJoin
operator|.
name|getRight
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extraRightExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|newLeftCount
init|=
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|AbstractList
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rightCount
operator|+
name|extraRightExprs
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
name|rightCount
condition|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
expr|<
name|RexNode
operator|,
name|String
operator|>
name|of
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|index
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|RexUtil
operator|.
name|shift
argument_list|(
name|extraRightExprs
operator|.
name|get
argument_list|(
name|index
operator|-
name|rightCount
argument_list|)
argument_list|,
operator|-
name|newLeftCount
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
block|}
decl_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|pairs
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|pairs
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|right
init|=
name|relBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|left
init|=
name|relBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|originalJoin
operator|.
name|copy
argument_list|(
name|originalJoin
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|joinCond
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|joinType
argument_list|,
name|originalJoin
operator|.
name|isSemiJoinDone
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extraLeftExprs
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|extraRightExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Mappings
operator|.
name|createShiftMapping
argument_list|(
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
operator|+
name|rightCount
operator|+
name|extraRightExprs
operator|.
name|size
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|leftCount
argument_list|,
name|leftCount
argument_list|,
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
argument_list|,
name|rightCount
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|fields
argument_list|(
name|mapping
operator|.
name|inverse
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|relBuilder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Pushes down expressions in "equal" join condition, using the default    * builder.    *    * @see #pushDownJoinConditions(Join, RelBuilder)    */
specifier|public
specifier|static
name|RelNode
name|pushDownJoinConditions
parameter_list|(
name|Join
name|originalJoin
parameter_list|)
block|{
return|return
name|pushDownJoinConditions
argument_list|(
name|originalJoin
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelNode
name|pushDownJoinConditions
parameter_list|(
name|Join
name|originalJoin
parameter_list|,
name|RelFactories
operator|.
name|ProjectFactory
name|projectFactory
parameter_list|)
block|{
return|return
name|pushDownJoinConditions
argument_list|(
name|originalJoin
argument_list|,
name|RelBuilder
operator|.
name|proto
argument_list|(
name|projectFactory
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RelNode
name|pushDownJoinConditions
parameter_list|(
name|Join
name|originalJoin
parameter_list|,
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
return|return
name|pushDownJoinConditions
argument_list|(
name|originalJoin
argument_list|,
name|relBuilderFactory
operator|.
name|create
argument_list|(
name|originalJoin
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|containsGet
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
try|try
block|{
name|node
operator|.
name|accept
argument_list|(
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|RexBuilder
operator|.
name|GET_OPERATOR
condition|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Pushes down parts of a join condition.    *    *<p>For example, given    * "emp JOIN dept ON emp.deptno + 1 = dept.deptno", adds a project above    * "emp" that computes the expression    * "emp.deptno + 1". The resulting join condition is a simple combination    * of AND, equals, and input fields.    */
specifier|private
specifier|static
name|RexNode
name|pushDownEqualJoinConditions
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|int
name|leftCount
parameter_list|,
name|int
name|rightCount
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraLeftExprs
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraRightExprs
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
case|case
name|EQUALS
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|operand
init|=
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|left2
init|=
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|right2
init|=
name|rightCount
operator|+
name|extraRightExprs
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|e
init|=
name|pushDownEqualJoinConditions
argument_list|(
name|operand
argument_list|,
name|leftCount
argument_list|,
name|rightCount
argument_list|,
name|extraLeftExprs
argument_list|,
name|extraRightExprs
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|remainingOperands
init|=
name|Util
operator|.
name|skip
argument_list|(
name|operands
argument_list|,
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|int
name|left3
init|=
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
name|fix
argument_list|(
name|remainingOperands
argument_list|,
name|left2
argument_list|,
name|left3
argument_list|)
expr_stmt|;
name|fix
argument_list|(
name|list
argument_list|,
name|left2
argument_list|,
name|left3
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|list
operator|.
name|equals
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|call
operator|.
name|clone
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|list
argument_list|)
return|;
block|}
return|return
name|call
return|;
case|case
name|OR
case|:
case|case
name|INPUT_REF
case|:
case|case
name|LITERAL
case|:
return|return
name|node
return|;
default|default:
specifier|final
name|ImmutableBitSet
name|bits
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|final
name|int
name|mid
init|=
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|Side
operator|.
name|of
argument_list|(
name|bits
argument_list|,
name|mid
argument_list|)
condition|)
block|{
case|case
name|LEFT
case|:
name|fix
argument_list|(
name|extraRightExprs
argument_list|,
name|mid
argument_list|,
name|mid
operator|+
literal|1
argument_list|)
expr_stmt|;
name|extraLeftExprs
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|mid
argument_list|,
name|node
operator|.
name|getType
argument_list|()
argument_list|)
return|;
case|case
name|RIGHT
case|:
specifier|final
name|int
name|index2
init|=
name|mid
operator|+
name|rightCount
operator|+
name|extraRightExprs
operator|.
name|size
argument_list|()
decl_stmt|;
name|extraRightExprs
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|index2
argument_list|,
name|node
operator|.
name|getType
argument_list|()
argument_list|)
return|;
case|case
name|BOTH
case|:
case|case
name|EMPTY
case|:
default|default:
return|return
name|node
return|;
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|fix
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|,
name|int
name|before
parameter_list|,
name|int
name|after
parameter_list|)
block|{
if|if
condition|(
name|before
operator|==
name|after
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|node
init|=
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|operands
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|RexUtil
operator|.
name|shift
argument_list|(
name|node
argument_list|,
name|before
argument_list|,
name|after
operator|-
name|before
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Determines whether any of the fields in a given relational expression may    * contain null values, taking into account constraints on the field types and    * also deduced predicates.    */
specifier|private
specifier|static
name|boolean
name|containsNullableFields
parameter_list|(
name|RelNode
name|r
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|r
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|r
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// All columns are declared NOT NULL.
return|return
literal|false
return|;
block|}
specifier|final
name|RelOptPredicateList
name|predicates
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
operator|.
name|getPulledUpPredicates
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// We have no predicates, so cannot deduce that any of the fields
comment|// declared NULL are really NOT NULL.
return|return
literal|true
return|;
block|}
name|RexExecutorImpl
name|rexImpl
init|=
operator|(
name|RexExecutorImpl
operator|)
name|r
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|.
name|getExecutor
argument_list|()
decl_stmt|;
specifier|final
name|RexImplicationChecker
name|checker
init|=
operator|new
name|RexImplicationChecker
argument_list|(
name|rexBuilder
argument_list|,
name|rexImpl
argument_list|,
name|rowType
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|first
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|predicates
operator|.
name|pulledUpPredicates
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|second
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|list
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Suppose we have EMP(empno INT NOT NULL, mgr INT),
comment|// and predicates [empno> 0, mgr> 0].
comment|// We make first: "empno> 0 AND mgr> 0"
comment|// and second: "mgr IS NOT NULL"
comment|// and ask whether first implies second.
comment|// It does, so we have no nullable columns.
return|return
operator|!
name|checker
operator|.
name|implies
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/** Visitor that finds all variables used but not stopped in an expression. */
specifier|private
specifier|static
class|class
name|VariableSetVisitor
extends|extends
name|RelVisitor
block|{
specifier|final
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|variables
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// implement RelVisitor
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|p
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
name|super
operator|.
name|visit
argument_list|(
name|p
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|p
operator|.
name|collectVariablesUsed
argument_list|(
name|variables
argument_list|)
expr_stmt|;
comment|// Important! Remove stopped variables AFTER we visit children
comment|// (which what super.visit() does)
name|variables
operator|.
name|removeAll
argument_list|(
name|p
operator|.
name|getVariablesSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Visitor that finds all variables used in an expression. */
specifier|public
specifier|static
class|class
name|VariableUsedVisitor
extends|extends
name|RexShuttle
block|{
specifier|public
specifier|final
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|variables
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
specifier|final
name|Multimap
argument_list|<
name|CorrelationId
argument_list|,
name|Integer
argument_list|>
name|variableFields
init|=
name|LinkedHashMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|RelShuttle
name|relShuttle
decl_stmt|;
specifier|public
name|VariableUsedVisitor
parameter_list|(
name|RelShuttle
name|relShuttle
parameter_list|)
block|{
name|this
operator|.
name|relShuttle
operator|=
name|relShuttle
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|p
parameter_list|)
block|{
name|variables
operator|.
name|add
argument_list|(
name|p
operator|.
name|id
argument_list|)
expr_stmt|;
name|variableFields
operator|.
name|put
argument_list|(
name|p
operator|.
name|id
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
if|if
condition|(
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
operator|instanceof
name|RexCorrelVariable
condition|)
block|{
specifier|final
name|RexCorrelVariable
name|v
init|=
operator|(
name|RexCorrelVariable
operator|)
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
decl_stmt|;
name|variableFields
operator|.
name|put
argument_list|(
name|v
operator|.
name|id
argument_list|,
name|fieldAccess
operator|.
name|getField
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|visitFieldAccess
argument_list|(
name|fieldAccess
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitSubQuery
parameter_list|(
name|RexSubQuery
name|subQuery
parameter_list|)
block|{
if|if
condition|(
name|relShuttle
operator|!=
literal|null
condition|)
block|{
name|subQuery
operator|.
name|rel
operator|.
name|accept
argument_list|(
name|relShuttle
argument_list|)
expr_stmt|;
comment|// look inside sub-queries
block|}
return|return
name|super
operator|.
name|visitSubQuery
argument_list|(
name|subQuery
argument_list|)
return|;
block|}
block|}
comment|/** Shuttle that finds the set of inputs that are used. */
specifier|public
specifier|static
class|class
name|InputReferencedVisitor
extends|extends
name|RexShuttle
block|{
specifier|public
specifier|final
name|SortedSet
argument_list|<
name|Integer
argument_list|>
name|inputPosReferenced
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|inputPosReferenced
operator|.
name|add
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|inputRef
return|;
block|}
block|}
comment|/** Converts types to descriptive strings. */
specifier|public
specifier|static
class|class
name|TypeDumper
block|{
specifier|private
specifier|final
name|String
name|extraIndent
init|=
literal|"  "
decl_stmt|;
specifier|private
name|String
name|indent
decl_stmt|;
specifier|private
specifier|final
name|PrintWriter
name|pw
decl_stmt|;
name|TypeDumper
parameter_list|(
name|PrintWriter
name|pw
parameter_list|)
block|{
name|this
operator|.
name|pw
operator|=
name|pw
expr_stmt|;
name|this
operator|.
name|indent
operator|=
literal|""
expr_stmt|;
block|}
name|void
name|accept
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|type
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
comment|// RECORD (
comment|//   I INTEGER NOT NULL,
comment|//   J VARCHAR(240))
name|pw
operator|.
name|println
argument_list|(
literal|"RECORD ("
argument_list|)
expr_stmt|;
name|String
name|prevIndent
init|=
name|indent
decl_stmt|;
name|this
operator|.
name|indent
operator|=
name|indent
operator|+
name|extraIndent
expr_stmt|;
name|acceptFields
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|this
operator|.
name|indent
operator|=
name|prevIndent
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|" NOT NULL"
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|type
operator|instanceof
name|MultisetSqlType
condition|)
block|{
comment|// E.g. "INTEGER NOT NULL MULTISET NOT NULL"
name|accept
argument_list|(
name|type
operator|.
name|getComponentType
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" MULTISET"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|" NOT NULL"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// E.g. "INTEGER" E.g. "VARCHAR(240) CHARACTER SET "ISO-8859-1"
comment|// COLLATE "ISO-8859-1$en_US$primary" NOT NULL"
name|pw
operator|.
name|print
argument_list|(
name|type
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|acceptFields
parameter_list|(
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|accept
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Visitor which builds a bitmap of the inputs used by an expression.    */
specifier|public
specifier|static
class|class
name|InputFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|public
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|inputBitSet
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
decl_stmt|;
specifier|public
name|InputFinder
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|InputFinder
parameter_list|(
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputBitSet
operator|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
expr_stmt|;
name|this
operator|.
name|extraFields
operator|=
name|extraFields
expr_stmt|;
block|}
comment|/** Returns an input finder that has analyzed a given expression. */
specifier|public
specifier|static
name|InputFinder
name|analyze
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
specifier|final
name|InputFinder
name|inputFinder
init|=
operator|new
name|InputFinder
argument_list|()
decl_stmt|;
name|node
operator|.
name|accept
argument_list|(
name|inputFinder
argument_list|)
expr_stmt|;
return|return
name|inputFinder
return|;
block|}
comment|/**      * Returns a bit set describing the inputs used by an expression.      */
specifier|public
specifier|static
name|ImmutableBitSet
name|bits
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|analyze
argument_list|(
name|node
argument_list|)
operator|.
name|inputBitSet
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**      * Returns a bit set describing the inputs used by a collection of      * project expressions and an optional condition.      */
specifier|public
specifier|static
name|ImmutableBitSet
name|bits
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|RexNode
name|expr
parameter_list|)
block|{
specifier|final
name|InputFinder
name|inputFinder
init|=
operator|new
name|InputFinder
argument_list|()
decl_stmt|;
name|RexUtil
operator|.
name|apply
argument_list|(
name|inputFinder
argument_list|,
name|exprs
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|inputFinder
operator|.
name|inputBitSet
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|inputBitSet
operator|.
name|set
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|RexBuilder
operator|.
name|GET_OPERATOR
condition|)
block|{
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|extraFields
operator|.
name|add
argument_list|(
operator|new
name|RelDataTypeFieldImpl
argument_list|(
operator|(
name|String
operator|)
name|literal
operator|.
name|getValue2
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
comment|/**    * Walks an expression tree, converting the index of RexInputRefs based on    * some adjustment factor.    */
specifier|public
specifier|static
class|class
name|RexInputConverter
extends|extends
name|RexShuttle
block|{
specifier|protected
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
decl_stmt|;
specifier|protected
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|destFields
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftDestFields
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightDestFields
decl_stmt|;
specifier|private
specifier|final
name|int
name|nLeftDestFields
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|adjustments
decl_stmt|;
comment|/**      * @param rexBuilder      builder for creating new RexInputRefs      * @param srcFields       fields where the RexInputRefs originated      *                        from; if null, a new RexInputRef is always      *                        created, referencing the input from destFields      *                        corresponding to its current index value      * @param destFields      fields that the new RexInputRefs will be      *                        referencing; if null, use the type information      *                        from the source field when creating the new      *                        RexInputRef      * @param leftDestFields  in the case where the destination is a join,      *                        these are the fields from the left join input      * @param rightDestFields in the case where the destination is a join,      *                        these are the fields from the right join input      * @param adjustments     the amount to adjust each field by      */
specifier|private
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|destFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftDestFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightDestFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
name|this
operator|.
name|srcFields
operator|=
name|srcFields
expr_stmt|;
name|this
operator|.
name|destFields
operator|=
name|destFields
expr_stmt|;
name|this
operator|.
name|adjustments
operator|=
name|adjustments
expr_stmt|;
name|this
operator|.
name|leftDestFields
operator|=
name|leftDestFields
expr_stmt|;
name|this
operator|.
name|rightDestFields
operator|=
name|rightDestFields
expr_stmt|;
if|if
condition|(
name|leftDestFields
operator|==
literal|null
condition|)
block|{
name|nLeftDestFields
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|destFields
operator|==
literal|null
assert|;
name|nLeftDestFields
operator|=
name|leftDestFields
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftDestFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightDestFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|srcFields
argument_list|,
literal|null
argument_list|,
name|leftDestFields
argument_list|,
name|rightDestFields
argument_list|,
name|adjustments
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|destFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|srcFields
argument_list|,
name|destFields
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|adjustments
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|srcFields
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|adjustments
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|var
parameter_list|)
block|{
name|int
name|srcIndex
init|=
name|var
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|int
name|destIndex
init|=
name|srcIndex
operator|+
name|adjustments
index|[
name|srcIndex
index|]
decl_stmt|;
name|RelDataType
name|type
decl_stmt|;
if|if
condition|(
name|destFields
operator|!=
literal|null
condition|)
block|{
name|type
operator|=
name|destFields
operator|.
name|get
argument_list|(
name|destIndex
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|leftDestFields
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|destIndex
operator|<
name|nLeftDestFields
condition|)
block|{
name|type
operator|=
name|leftDestFields
operator|.
name|get
argument_list|(
name|destIndex
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|rightDestFields
operator|.
name|get
argument_list|(
name|destIndex
operator|-
name|nLeftDestFields
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|type
operator|=
name|srcFields
operator|.
name|get
argument_list|(
name|srcIndex
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|adjustments
index|[
name|srcIndex
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|srcFields
operator|==
literal|null
operator|)
operator|||
operator|(
name|type
operator|!=
name|srcFields
operator|.
name|get
argument_list|(
name|srcIndex
argument_list|)
operator|.
name|getType
argument_list|()
operator|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|type
argument_list|,
name|destIndex
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|var
return|;
block|}
block|}
block|}
comment|/** What kind of sub-query. */
specifier|public
enum|enum
name|SubQueryType
block|{
name|EXISTS
block|,
name|IN
block|,
name|SCALAR
block|}
comment|/**    * Categorizes whether a bit set contains bits left and right of a    * line.    */
enum|enum
name|Side
block|{
name|LEFT
block|,
name|RIGHT
block|,
name|BOTH
block|,
name|EMPTY
block|;
specifier|static
name|Side
name|of
parameter_list|(
name|ImmutableBitSet
name|bitSet
parameter_list|,
name|int
name|middle
parameter_list|)
block|{
specifier|final
name|int
name|firstBit
init|=
name|bitSet
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstBit
operator|<
literal|0
condition|)
block|{
return|return
name|EMPTY
return|;
block|}
if|if
condition|(
name|firstBit
operator|>=
name|middle
condition|)
block|{
return|return
name|RIGHT
return|;
block|}
if|if
condition|(
name|bitSet
operator|.
name|nextSetBit
argument_list|(
name|middle
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|LEFT
return|;
block|}
return|return
name|BOTH
return|;
block|}
block|}
comment|/** Shuttle that finds correlation variables inside a given relational    * expression, including those that are inside    * {@link RexSubQuery sub-queries}. */
specifier|private
specifier|static
class|class
name|CorrelationCollector
extends|extends
name|RelHomogeneousShuttle
block|{
specifier|private
specifier|final
name|VariableUsedVisitor
name|vuv
init|=
operator|new
name|VariableUsedVisitor
argument_list|(
name|this
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|RelNode
name|visit
parameter_list|(
name|RelNode
name|other
parameter_list|)
block|{
name|other
operator|.
name|collectVariablesUsed
argument_list|(
name|vuv
operator|.
name|variables
argument_list|)
expr_stmt|;
name|other
operator|.
name|accept
argument_list|(
name|vuv
argument_list|)
expr_stmt|;
name|RelNode
name|result
init|=
name|super
operator|.
name|visit
argument_list|(
name|other
argument_list|)
decl_stmt|;
comment|// Important! Remove stopped variables AFTER we visit
comment|// children. (which what super.visit() does)
name|vuv
operator|.
name|variables
operator|.
name|removeAll
argument_list|(
name|other
operator|.
name|getVariablesSet
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/** Result of calling    * {@link org.apache.calcite.plan.RelOptUtil#createExistsPlan} */
specifier|public
specifier|static
class|class
name|Exists
block|{
specifier|public
specifier|final
name|RelNode
name|r
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|indicator
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|outerJoin
decl_stmt|;
specifier|private
name|Exists
parameter_list|(
name|RelNode
name|r
parameter_list|,
name|boolean
name|indicator
parameter_list|,
name|boolean
name|outerJoin
parameter_list|)
block|{
name|this
operator|.
name|r
operator|=
name|r
expr_stmt|;
name|this
operator|.
name|indicator
operator|=
name|indicator
expr_stmt|;
name|this
operator|.
name|outerJoin
operator|=
name|outerJoin
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End RelOptUtil.java
end_comment

end_unit

