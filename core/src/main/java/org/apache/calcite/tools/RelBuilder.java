begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Experimental
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Contexts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Intersect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Match
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Minus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|SemiJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Values
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFieldImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCorrelVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSimplify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Hook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|server
operator|.
name|CalciteServerStatement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SemiJoinType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Holder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableIntList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableNullableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NlsString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
operator|.
name|RESOURCE
import|;
end_import

begin_comment
comment|/**  * Builder for relational expressions.  *  *<p>{@code RelBuilder} does not make possible anything that you could not  * also accomplish by calling the factory methods of the particular relational  * expression. But it makes common tasks more straightforward and concise.  *  *<p>{@code RelBuilder} uses factories to create relational expressions.  * By default, it uses the default factories, which create logical relational  * expressions ({@link LogicalFilter},  * {@link LogicalProject} and so forth).  * But you could override those factories so that, say, {@code filter} creates  * instead a {@code HiveFilter}.  *  *<p>It is not thread-safe.  */
end_comment

begin_class
specifier|public
class|class
name|RelBuilder
block|{
specifier|protected
specifier|final
name|RelOptCluster
name|cluster
decl_stmt|;
specifier|protected
specifier|final
name|RelOptSchema
name|relOptSchema
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|FilterFactory
name|filterFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|ProjectFactory
name|projectFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|AggregateFactory
name|aggregateFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|SortFactory
name|sortFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|SetOpFactory
name|setOpFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|JoinFactory
name|joinFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|SemiJoinFactory
name|semiJoinFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|CorrelateFactory
name|correlateFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|ValuesFactory
name|valuesFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|TableScanFactory
name|scanFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|MatchFactory
name|matchFactory
decl_stmt|;
specifier|private
specifier|final
name|Deque
argument_list|<
name|Frame
argument_list|>
name|stack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|simplify
decl_stmt|;
specifier|private
specifier|final
name|RexSimplify
name|simplifier
decl_stmt|;
specifier|protected
name|RelBuilder
parameter_list|(
name|Context
name|context
parameter_list|,
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptSchema
name|relOptSchema
parameter_list|)
block|{
name|this
operator|.
name|cluster
operator|=
name|cluster
expr_stmt|;
name|this
operator|.
name|relOptSchema
operator|=
name|relOptSchema
expr_stmt|;
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
name|context
operator|=
name|Contexts
operator|.
name|EMPTY_CONTEXT
expr_stmt|;
block|}
name|this
operator|.
name|simplify
operator|=
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
operator|.
name|get
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|aggregateFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|AggregateFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_AGGREGATE_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|filterFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|FilterFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_FILTER_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|projectFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|ProjectFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|sortFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|SortFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_SORT_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|setOpFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|SetOpFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_SET_OP_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|joinFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|JoinFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_JOIN_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|semiJoinFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|SemiJoinFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_SEMI_JOIN_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|correlateFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|CorrelateFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_CORRELATE_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|valuesFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|ValuesFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_VALUES_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|scanFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|TableScanFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_TABLE_SCAN_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|matchFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|MatchFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_MATCH_FACTORY
argument_list|)
expr_stmt|;
specifier|final
name|RexExecutor
name|executor
init|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RexExecutor
operator|.
name|class
argument_list|)
argument_list|,
name|Util
operator|.
name|first
argument_list|(
name|cluster
operator|.
name|getPlanner
argument_list|()
operator|.
name|getExecutor
argument_list|()
argument_list|,
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelOptPredicateList
name|predicates
init|=
name|RelOptPredicateList
operator|.
name|EMPTY
decl_stmt|;
name|this
operator|.
name|simplifier
operator|=
operator|new
name|RexSimplify
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|predicates
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a RelBuilder. */
specifier|public
specifier|static
name|RelBuilder
name|create
parameter_list|(
name|FrameworkConfig
name|config
parameter_list|)
block|{
specifier|final
name|RelOptCluster
index|[]
name|clusters
init|=
block|{
literal|null
block|}
decl_stmt|;
specifier|final
name|RelOptSchema
index|[]
name|relOptSchemas
init|=
block|{
literal|null
block|}
decl_stmt|;
name|Frameworks
operator|.
name|withPrepare
argument_list|(
operator|new
name|Frameworks
operator|.
name|PrepareAction
argument_list|<
name|Void
argument_list|>
argument_list|(
name|config
argument_list|)
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptSchema
name|relOptSchema
parameter_list|,
name|SchemaPlus
name|rootSchema
parameter_list|,
name|CalciteServerStatement
name|statement
parameter_list|)
block|{
name|clusters
index|[
literal|0
index|]
operator|=
name|cluster
expr_stmt|;
name|relOptSchemas
index|[
literal|0
index|]
operator|=
name|relOptSchema
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
operator|new
name|RelBuilder
argument_list|(
name|config
operator|.
name|getContext
argument_list|()
argument_list|,
name|clusters
index|[
literal|0
index|]
argument_list|,
name|relOptSchemas
index|[
literal|0
index|]
argument_list|)
return|;
block|}
comment|/** Returns the type factory. */
specifier|public
name|RelDataTypeFactory
name|getTypeFactory
parameter_list|()
block|{
return|return
name|cluster
operator|.
name|getTypeFactory
argument_list|()
return|;
block|}
comment|/** Returns the builder for {@link RexNode} expressions. */
specifier|public
name|RexBuilder
name|getRexBuilder
parameter_list|()
block|{
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
return|;
block|}
comment|/** Creates a {@link RelBuilderFactory}, a partially-created RelBuilder.    * Just add a {@link RelOptCluster} and a {@link RelOptSchema} */
specifier|public
specifier|static
name|RelBuilderFactory
name|proto
parameter_list|(
specifier|final
name|Context
name|context
parameter_list|)
block|{
return|return
parameter_list|(
name|cluster
parameter_list|,
name|schema
parameter_list|)
lambda|->
operator|new
name|RelBuilder
argument_list|(
name|context
argument_list|,
name|cluster
argument_list|,
name|schema
argument_list|)
return|;
block|}
comment|/** Creates a {@link RelBuilderFactory} that uses a given set of factories. */
specifier|public
specifier|static
name|RelBuilderFactory
name|proto
parameter_list|(
name|Object
modifier|...
name|factories
parameter_list|)
block|{
return|return
name|proto
argument_list|(
name|Contexts
operator|.
name|of
argument_list|(
name|factories
argument_list|)
argument_list|)
return|;
block|}
comment|// Methods for manipulating the stack
comment|/** Adds a relational expression to be the input to the next relational    * expression constructed.    *    *<p>This method is usual when you want to weave in relational expressions    * that are not supported by the builder. If, while creating such expressions,    * you need to use previously built expressions as inputs, call    * {@link #build()} to pop those inputs. */
specifier|public
name|RelBuilder
name|push
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Adds a rel node to the top of the stack while preserving the field names    * and aliases. */
specifier|private
name|void
name|replaceTop
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|node
argument_list|,
name|frame
operator|.
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Pushes a collection of relational expressions. */
specifier|public
name|RelBuilder
name|pushAll
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|nodes
parameter_list|)
block|{
for|for
control|(
name|RelNode
name|node
range|:
name|nodes
control|)
block|{
name|push
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Returns the final relational expression.    *    *<p>Throws if the stack is empty.    */
specifier|public
name|RelNode
name|build
parameter_list|()
block|{
return|return
name|stack
operator|.
name|pop
argument_list|()
operator|.
name|rel
return|;
block|}
comment|/** Returns the relational expression at the top of the stack, but does not    * remove it. */
specifier|public
name|RelNode
name|peek
parameter_list|()
block|{
return|return
name|peek_
argument_list|()
operator|.
name|rel
return|;
block|}
specifier|private
name|Frame
name|peek_
parameter_list|()
block|{
return|return
name|stack
operator|.
name|peek
argument_list|()
return|;
block|}
comment|/** Returns the relational expression {@code n} positions from the top of the    * stack, but does not remove it. */
specifier|public
name|RelNode
name|peek
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|peek_
argument_list|(
name|n
argument_list|)
operator|.
name|rel
return|;
block|}
specifier|private
name|Frame
name|peek_
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|get
argument_list|(
name|stack
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Returns the relational expression {@code n} positions from the top of the    * stack, but does not remove it. */
specifier|public
name|RelNode
name|peek
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
return|return
name|peek_
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
operator|.
name|rel
return|;
block|}
specifier|private
name|Frame
name|peek_
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
return|return
name|peek_
argument_list|(
name|inputCount
operator|-
literal|1
operator|-
name|inputOrdinal
argument_list|)
return|;
block|}
comment|/** Returns the number of fields in all inputs before (to the left of)    * the given input.    *    * @param inputCount Number of inputs    * @param inputOrdinal Input ordinal    */
specifier|private
name|int
name|inputOffset
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputOrdinal
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|+=
name|peek
argument_list|(
name|inputCount
argument_list|,
name|i
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
comment|// Methods that return scalar expressions
comment|/** Creates a literal (constant expression). */
specifier|public
name|RexNode
name|literal
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|constantNull
argument_list|()
return|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|(
name|Boolean
operator|)
name|value
argument_list|)
return|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|BigDecimal
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|(
name|BigDecimal
operator|)
name|value
argument_list|)
return|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Float
operator|||
name|value
operator|instanceof
name|Double
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeApproxLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot convert "
operator|+
name|value
operator|+
literal|" ("
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|+
literal|") to a constant"
argument_list|)
throw|;
block|}
block|}
comment|/** Creates a correlation variable for the current input, and writes it into    * a Holder. */
specifier|public
name|RelBuilder
name|variable
parameter_list|(
name|Holder
argument_list|<
name|RexCorrelVariable
argument_list|>
name|v
parameter_list|)
block|{
name|v
operator|.
name|set
argument_list|(
operator|(
name|RexCorrelVariable
operator|)
name|getRexBuilder
argument_list|()
operator|.
name|makeCorrel
argument_list|(
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|cluster
operator|.
name|createCorrel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a reference to a field by name.    *    *<p>Equivalent to {@code field(1, 0, fieldName)}.    *    * @param fieldName Field name    */
specifier|public
name|RexInputRef
name|field
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|fieldName
argument_list|)
return|;
block|}
comment|/** Creates a reference to a field of given input relational expression    * by name.    *    * @param inputCount Number of inputs    * @param inputOrdinal Input ordinal    * @param fieldName Field name    */
specifier|public
name|RexInputRef
name|field
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|peek_
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|Pair
operator|.
name|left
argument_list|(
name|frame
operator|.
name|fields
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|fieldNames
operator|.
name|indexOf
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
return|return
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|,
name|i
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field ["
operator|+
name|fieldName
operator|+
literal|"] not found; input fields are: "
operator|+
name|fieldNames
argument_list|)
throw|;
block|}
block|}
comment|/** Creates a reference to an input field by ordinal.    *    *<p>Equivalent to {@code field(1, 0, ordinal)}.    *    * @param fieldOrdinal Field ordinal    */
specifier|public
name|RexInputRef
name|field
parameter_list|(
name|int
name|fieldOrdinal
parameter_list|)
block|{
return|return
operator|(
name|RexInputRef
operator|)
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|fieldOrdinal
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Creates a reference to a field of a given input relational expression    * by ordinal.    *    * @param inputCount Number of inputs    * @param inputOrdinal Input ordinal    * @param fieldOrdinal Field ordinal within input    */
specifier|public
name|RexInputRef
name|field
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|,
name|int
name|fieldOrdinal
parameter_list|)
block|{
return|return
operator|(
name|RexInputRef
operator|)
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|,
name|fieldOrdinal
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** As {@link #field(int, int, int)}, but if {@code alias} is true, the method    * may apply an alias to make sure that the field has the same name as in the    * input frame. If no alias is applied the expression is definitely a    * {@link RexInputRef}. */
specifier|private
name|RexNode
name|field
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|,
name|int
name|fieldOrdinal
parameter_list|,
name|boolean
name|alias
parameter_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|peek_
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|frame
operator|.
name|rel
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|input
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldOrdinal
operator|<
literal|0
operator|||
name|fieldOrdinal
operator|>
name|rowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field ordinal ["
operator|+
name|fieldOrdinal
operator|+
literal|"] out of range; input fields are: "
operator|+
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
throw|;
block|}
specifier|final
name|RelDataTypeField
name|field
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|fieldOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|inputOffset
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|ref
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|offset
operator|+
name|fieldOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeField
name|aliasField
init|=
name|frame
operator|.
name|fields
argument_list|()
operator|.
name|get
argument_list|(
name|fieldOrdinal
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alias
operator|||
name|field
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|aliasField
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|ref
return|;
block|}
else|else
block|{
return|return
name|alias
argument_list|(
name|ref
argument_list|,
name|aliasField
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Creates a reference to a field of the current record which originated    * in a relation with a given alias. */
specifier|public
name|RexNode
name|field
parameter_list|(
name|String
name|alias
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|field
argument_list|(
literal|1
argument_list|,
name|alias
argument_list|,
name|fieldName
argument_list|)
return|;
block|}
comment|/** Creates a reference to a field which originated in a relation with the    * given alias. Searches for the relation starting at the top of the    * stack. */
specifier|public
name|RexNode
name|field
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|String
name|alias
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|inputOrdinal
init|=
literal|0
init|;
name|inputOrdinal
operator|<
name|inputCount
condition|;
operator|++
name|inputOrdinal
control|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|peek_
argument_list|(
name|inputOrdinal
argument_list|)
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|Field
argument_list|>
name|p
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|frame
operator|.
name|fields
argument_list|)
control|)
block|{
comment|// If alias and field name match, reference that field.
if|if
condition|(
name|p
operator|.
name|e
operator|.
name|left
operator|.
name|contains
argument_list|(
name|alias
argument_list|)
operator|&&
name|p
operator|.
name|e
operator|.
name|right
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputCount
operator|-
literal|1
operator|-
name|inputOrdinal
argument_list|,
name|p
operator|.
name|i
argument_list|)
return|;
block|}
name|fields
operator|.
name|add
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"{aliases=%s,fieldName=%s}"
argument_list|,
name|p
operator|.
name|e
operator|.
name|left
argument_list|,
name|p
operator|.
name|e
operator|.
name|right
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"no aliased field found; fields are: "
operator|+
name|fields
argument_list|)
throw|;
block|}
comment|/** Returns a reference to a given field of a record-valued expression. */
specifier|public
name|RexNode
name|field
parameter_list|(
name|RexNode
name|e
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|e
argument_list|,
name|name
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Returns references to the fields of the top input. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|()
block|{
return|return
name|fields
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/** Returns references to the fields of a given input. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
specifier|final
name|RelNode
name|input
init|=
name|peek
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|input
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|fieldOrdinal
range|:
name|Util
operator|.
name|range
argument_list|(
name|rowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
control|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|,
name|fieldOrdinal
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|nodes
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns references to fields for a given collation. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|RelCollation
name|collation
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|fieldCollation
range|:
name|collation
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
name|RexNode
name|node
init|=
name|field
argument_list|(
name|fieldCollation
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fieldCollation
operator|.
name|direction
condition|)
block|{
case|case
name|DESCENDING
case|:
name|node
operator|=
name|desc
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|fieldCollation
operator|.
name|nullDirection
condition|)
block|{
case|case
name|FIRST
case|:
name|node
operator|=
name|nullsFirst
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|LAST
case|:
name|node
operator|=
name|nullsLast
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|nodes
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns references to fields for a given list of input ordinals. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Number
argument_list|>
name|ordinals
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Number
name|ordinal
range|:
name|ordinals
control|)
block|{
name|RexNode
name|node
init|=
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|ordinal
operator|.
name|intValue
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|nodes
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns references to fields identified by name. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|fieldName
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns references to fields identified by a mapping. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|)
block|{
return|return
name|fields
argument_list|(
name|Mappings
operator|.
name|asList
argument_list|(
name|mapping
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an access to a field by name. */
specifier|public
name|RexNode
name|dot
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|builder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
return|return
name|builder
operator|.
name|makeFieldAccess
argument_list|(
name|node
argument_list|,
name|fieldName
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Creates an access to a field by ordinal. */
specifier|public
name|RexNode
name|dot
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|int
name|fieldOrdinal
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|builder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
return|return
name|builder
operator|.
name|makeFieldAccess
argument_list|(
name|node
argument_list|,
name|fieldOrdinal
argument_list|)
return|;
block|}
comment|/** Creates a call to a scalar operator. */
specifier|public
name|RexNode
name|call
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|operator
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to a scalar operator. */
specifier|private
name|RexNode
name|call
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|operandList
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|builder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|builder
operator|.
name|deriveReturnType
argument_list|(
name|operator
argument_list|,
name|operandList
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot derive type: "
operator|+
name|operator
operator|+
literal|"; operands: "
operator|+
name|Lists
operator|.
name|transform
argument_list|(
name|operandList
argument_list|,
name|e
lambda|->
name|e
operator|+
literal|": "
operator|+
name|e
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|operator
argument_list|,
name|operandList
argument_list|)
return|;
block|}
comment|/** Creates a call to a scalar operator. */
specifier|public
name|RexNode
name|call
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|operator
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an AND. */
specifier|public
name|RexNode
name|and
parameter_list|(
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|and
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an AND.    *    *<p>Simplifies the expression a little:    * {@code e AND TRUE} becomes {@code e};    * {@code e AND e2 AND NOT e} becomes {@code e2}. */
specifier|public
name|RexNode
name|and
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|simplifier
operator|.
name|simplifyAnds
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/** Creates an OR. */
specifier|public
name|RexNode
name|or
parameter_list|(
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|or
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an OR. */
specifier|public
name|RexNode
name|or
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|RexUtil
operator|.
name|composeDisjunction
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|/** Creates a NOT. */
specifier|public
name|RexNode
name|not
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates an {@code =}. */
specifier|public
name|RexNode
name|equals
parameter_list|(
name|RexNode
name|operand0
parameter_list|,
name|RexNode
name|operand1
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
return|;
block|}
comment|/** Creates a {@code<>}. */
specifier|public
name|RexNode
name|notEquals
parameter_list|(
name|RexNode
name|operand0
parameter_list|,
name|RexNode
name|operand1
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
return|;
block|}
comment|/** Creates a IS NULL. */
specifier|public
name|RexNode
name|isNull
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates a IS NOT NULL. */
specifier|public
name|RexNode
name|isNotNull
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates an expression that casts an expression to a given type. */
specifier|public
name|RexNode
name|cast
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
comment|/** Creates an expression that casts an expression to a type with a given name    * and precision or length. */
specifier|public
name|RexNode
name|cast
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|,
name|precision
argument_list|)
decl_stmt|;
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
comment|/** Creates an expression that casts an expression to a type with a given    * name, precision and scale. */
specifier|public
name|RexNode
name|cast
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|int
name|precision
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|,
name|precision
argument_list|,
name|scale
argument_list|)
decl_stmt|;
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
comment|/**    * Returns an expression wrapped in an alias.    *    * @see #project    */
specifier|public
name|RexNode
name|alias
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AS
argument_list|,
name|expr
argument_list|,
name|literal
argument_list|(
name|alias
argument_list|)
argument_list|)
return|;
block|}
comment|/** Converts a sort expression to descending. */
specifier|public
name|RexNode
name|desc
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DESC
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/** Converts a sort expression to nulls last. */
specifier|public
name|RexNode
name|nullsLast
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NULLS_LAST
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/** Converts a sort expression to nulls first. */
specifier|public
name|RexNode
name|nullsFirst
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NULLS_FIRST
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|// Methods that create group keys and aggregate calls
comment|/** Creates an empty group key. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|()
block|{
return|return
name|groupKey
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a group key. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|groupKey
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a group key. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
operator|new
name|GroupKeyImpl
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Creates a group key with grouping sets. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
parameter_list|)
block|{
return|return
name|groupKey_
argument_list|(
name|nodes
argument_list|,
literal|false
argument_list|,
name|nodeLists
argument_list|)
return|;
block|}
comment|/** @deprecated Now that indicator is deprecated, use    * {@link #groupKey(Iterable, Iterable)}, which has the same behavior as    * calling this method with {@code indicator = false}. */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|boolean
name|indicator
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
parameter_list|)
block|{
return|return
name|groupKey_
argument_list|(
name|nodes
argument_list|,
name|indicator
argument_list|,
name|nodeLists
argument_list|)
return|;
block|}
specifier|private
name|GroupKey
name|groupKey_
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|boolean
name|indicator
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodeList
range|:
name|nodeLists
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodeList
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|GroupKeyImpl
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|,
name|indicator
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Creates a group key of fields identified by ordinal. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|int
modifier|...
name|fieldOrdinals
parameter_list|)
block|{
return|return
name|groupKey
argument_list|(
name|fields
argument_list|(
name|ImmutableIntList
operator|.
name|of
argument_list|(
name|fieldOrdinals
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a group key of fields identified by name. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|String
modifier|...
name|fieldNames
parameter_list|)
block|{
return|return
name|groupKey
argument_list|(
name|fields
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|fieldNames
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a group key, identified by field positions    * in the underlying relational expression.    *    *<p>This method of creating a group key does not allow you to group on new    * expressions, only column projections, but is efficient, especially when you    * are coming from an existing {@link Aggregate}. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
annotation|@
name|Nonnull
name|ImmutableBitSet
name|groupSet
parameter_list|)
block|{
return|return
name|groupKey
argument_list|(
name|groupSet
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupSet
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a group key with grouping sets, both identified by field positions    * in the underlying relational expression.    *    *<p>This method of creating a group key does not allow you to group on new    * expressions, only column projections, but is efficient, especially when you    * are coming from an existing {@link Aggregate}. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
annotation|@
name|Nonnull
name|Iterable
argument_list|<
name|?
extends|extends
name|ImmutableBitSet
argument_list|>
name|groupSets
parameter_list|)
block|{
return|return
name|groupKey_
argument_list|(
name|groupSet
argument_list|,
literal|false
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|groupSets
argument_list|)
argument_list|)
return|;
block|}
comment|/** As {@link #groupKey(ImmutableBitSet, Iterable)}. */
comment|// deprecated, to be removed before 2.0
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
parameter_list|)
block|{
return|return
name|groupKey_
argument_list|(
name|groupSet
argument_list|,
literal|false
argument_list|,
name|groupSets
operator|==
literal|null
condition|?
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupSet
argument_list|)
else|:
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|groupSets
argument_list|)
argument_list|)
return|;
block|}
comment|/** @deprecated Use {@link #groupKey(ImmutableBitSet, Iterable)}. */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|boolean
name|indicator
parameter_list|,
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
parameter_list|)
block|{
return|return
name|groupKey_
argument_list|(
name|groupSet
argument_list|,
name|indicator
argument_list|,
name|groupSets
operator|==
literal|null
condition|?
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupSet
argument_list|)
else|:
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|groupSets
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|GroupKey
name|groupKey_
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|boolean
name|indicator
parameter_list|,
annotation|@
name|Nonnull
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
parameter_list|)
block|{
if|if
condition|(
name|groupSet
operator|.
name|length
argument_list|()
operator|>
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"out of bounds: "
operator|+
name|groupSet
argument_list|)
throw|;
block|}
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|groupSets
argument_list|)
expr_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|fields
argument_list|(
name|ImmutableIntList
operator|.
name|of
argument_list|(
name|groupSet
operator|.
name|toArray
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
init|=
name|Util
operator|.
name|transform
argument_list|(
name|groupSets
argument_list|,
name|bitSet
lambda|->
name|fields
argument_list|(
name|ImmutableIntList
operator|.
name|of
argument_list|(
name|bitSet
operator|.
name|toArray
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|groupKey_
argument_list|(
name|nodes
argument_list|,
name|indicator
argument_list|,
name|nodeLists
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|RexNode
name|filter
parameter_list|,
name|String
name|alias
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
literal|false
argument_list|,
name|filter
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to an aggregate function. */
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|boolean
name|approximate
parameter_list|,
name|RexNode
name|filter
parameter_list|,
name|String
name|alias
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
name|filter
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|RexNode
name|filter
parameter_list|,
name|String
name|alias
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
literal|false
argument_list|,
name|filter
argument_list|,
name|alias
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|/** Creates a call to an aggregate function. */
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|boolean
name|approximate
parameter_list|,
name|RexNode
name|filter
parameter_list|,
name|String
name|alias
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|filter
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|BOOLEAN
condition|)
block|{
throw|throw
name|RESOURCE
operator|.
name|filterMustBeBoolean
argument_list|()
operator|.
name|ex
argument_list|()
throw|;
block|}
if|if
condition|(
name|filter
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|filter
operator|=
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|AggCallImpl
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
name|filter
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to the COUNT aggregate function. */
specifier|public
name|AggCall
name|count
parameter_list|(
name|boolean
name|distinct
parameter_list|,
name|String
name|alias
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
name|distinct
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|/** Creates a call to the COUNT(*) aggregate function. */
specifier|public
name|AggCall
name|countStar
parameter_list|(
name|String
name|alias
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|)
return|;
block|}
comment|/** Creates a call to the SUM aggregate function. */
specifier|public
name|AggCall
name|sum
parameter_list|(
name|boolean
name|distinct
parameter_list|,
name|String
name|alias
parameter_list|,
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUM
argument_list|,
name|distinct
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates a call to the AVG aggregate function. */
specifier|public
name|AggCall
name|avg
parameter_list|(
name|boolean
name|distinct
parameter_list|,
name|String
name|alias
parameter_list|,
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AVG
argument_list|,
name|distinct
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates a call to the MIN aggregate function. */
specifier|public
name|AggCall
name|min
parameter_list|(
name|String
name|alias
parameter_list|,
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MIN
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates a call to the MAX aggregate function. */
specifier|public
name|AggCall
name|max
parameter_list|(
name|String
name|alias
parameter_list|,
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MAX
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|// Methods for patterns
comment|/**    * Creates a reference to a given field of the pattern.    *    * @param alpha the pattern name    * @param type Type of field    * @param i Ordinal of field    * @return Reference to field of pattern    */
specifier|public
name|RexNode
name|patternField
parameter_list|(
name|String
name|alpha
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makePatternFieldRef
argument_list|(
name|alpha
argument_list|,
name|type
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/** Creates a call that concatenates patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternConcat
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
comment|// Convert into binary calls
return|return
name|patternConcat
argument_list|(
name|patternConcat
argument_list|(
name|Util
operator|.
name|skipLast
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|list
argument_list|)
argument_list|)
return|;
block|}
specifier|final
name|RelDataType
name|t
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
decl_stmt|;
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|t
argument_list|,
name|SqlStdOperatorTable
operator|.
name|PATTERN_CONCAT
argument_list|,
name|list
argument_list|)
return|;
block|}
comment|/** Creates a call that concatenates patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternConcat
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|patternConcat
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates alternate patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternAlter
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|RelDataType
name|t
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
decl_stmt|;
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|t
argument_list|,
name|SqlStdOperatorTable
operator|.
name|PATTERN_ALTER
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates alternate patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternAlter
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|patternAlter
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates quantify patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternQuantify
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|RelDataType
name|t
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
decl_stmt|;
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|t
argument_list|,
name|SqlStdOperatorTable
operator|.
name|PATTERN_QUANTIFIER
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates quantify patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternQuantify
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|patternQuantify
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates permute patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternPermute
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|RelDataType
name|t
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
decl_stmt|;
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|t
argument_list|,
name|SqlStdOperatorTable
operator|.
name|PATTERN_PERMUTE
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates permute patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternPermute
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|patternPermute
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates an exclude pattern;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternExclude
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
specifier|final
name|RelDataType
name|t
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
decl_stmt|;
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|t
argument_list|,
name|SqlStdOperatorTable
operator|.
name|PATTERN_EXCLUDE
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|node
argument_list|)
argument_list|)
return|;
block|}
comment|// Methods that create relational expressions
comment|/** Creates a {@link TableScan} of the table    * with a given name.    *    *<p>Throws if the table does not exist.    *    *<p>Returns this builder.    *    * @param tableNames Name of table (can optionally be qualified)    */
specifier|public
name|RelBuilder
name|scan
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|tableNames
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tableNames
argument_list|)
decl_stmt|;
specifier|final
name|RelOptTable
name|relOptTable
init|=
name|relOptSchema
operator|.
name|getTableForMember
argument_list|(
name|names
argument_list|)
decl_stmt|;
if|if
condition|(
name|relOptTable
operator|==
literal|null
condition|)
block|{
throw|throw
name|RESOURCE
operator|.
name|tableNotFound
argument_list|(
name|String
operator|.
name|join
argument_list|(
literal|"."
argument_list|,
name|names
argument_list|)
argument_list|)
operator|.
name|ex
argument_list|()
throw|;
block|}
specifier|final
name|RelNode
name|scan
init|=
name|scanFactory
operator|.
name|createScan
argument_list|(
name|cluster
argument_list|,
name|relOptTable
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|scan
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link TableScan} of the table    * with a given name.    *    *<p>Throws if the table does not exist.    *    *<p>Returns this builder.    *    * @param tableNames Name of table (can optionally be qualified)    */
specifier|public
name|RelBuilder
name|scan
parameter_list|(
name|String
modifier|...
name|tableNames
parameter_list|)
block|{
return|return
name|scan
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tableNames
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Filter} of an array of    * predicates.    *    *<p>The predicates are combined using AND,    * and optimized in a similar way to the {@link #and} method.    * If the result is TRUE no filter is created. */
specifier|public
name|RelBuilder
name|filter
parameter_list|(
name|RexNode
modifier|...
name|predicates
parameter_list|)
block|{
return|return
name|filter
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|predicates
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Filter} of a list of    * predicates.    *    *<p>The predicates are combined using AND,    * and optimized in a similar way to the {@link #and} method.    * If the result is TRUE no filter is created. */
specifier|public
name|RelBuilder
name|filter
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|predicates
parameter_list|)
block|{
specifier|final
name|RexNode
name|simplifiedPredicates
init|=
name|simplifier
operator|.
name|simplifyFilterPredicates
argument_list|(
name|predicates
argument_list|)
decl_stmt|;
if|if
condition|(
name|simplifiedPredicates
operator|==
literal|null
condition|)
block|{
return|return
name|empty
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|simplifiedPredicates
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|filter
init|=
name|filterFactory
operator|.
name|createFilter
argument_list|(
name|frame
operator|.
name|rel
argument_list|,
name|simplifiedPredicates
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|filter
argument_list|,
name|frame
operator|.
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Creates a {@link Project} of the given    * expressions. */
specifier|public
name|RelBuilder
name|project
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|project
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Project} of the given list    * of expressions.    *    *<p>Infers names as would {@link #project(Iterable, Iterable)} if all    * suggested names were null.    *    * @param nodes Expressions    */
specifier|public
name|RelBuilder
name|project
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|project
argument_list|(
name|nodes
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a {@link Project} of the given list    * of expressions and field names.    *    * @param nodes Expressions    * @param fieldNames field names for expressions    */
specifier|public
name|RelBuilder
name|project
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|Iterable
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
return|return
name|project
argument_list|(
name|nodes
argument_list|,
name|fieldNames
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Creates a {@link Project} of all original fields, plus the given    * expressions. */
specifier|public
name|RelBuilder
name|projectPlus
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|projectPlus
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Project} of all original fields, plus the given list of    * expressions. */
specifier|public
name|RelBuilder
name|projectPlus
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
return|return
name|project
argument_list|(
name|builder
operator|.
name|addAll
argument_list|(
name|fields
argument_list|()
argument_list|)
operator|.
name|addAll
argument_list|(
name|nodes
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a {@link Project} of the given list    * of expressions, using the given names.    *    *<p>Names are deduced as follows:    *<ul>    *<li>If the length of {@code fieldNames} is greater than the index of    *     the current entry in {@code nodes}, and the entry in    *     {@code fieldNames} is not null, uses it; otherwise    *<li>If an expression projects an input field,    *     or is a cast an input field,    *     uses the input field name; otherwise    *<li>If an expression is a call to    *     {@link SqlStdOperatorTable#AS}    *     (see {@link #alias}), removes the call but uses the intended alias.    *</ul>    *    *<p>After the field names have been inferred, makes the    * field names unique by appending numeric suffixes.    *    * @param nodes Expressions    * @param fieldNames Suggested field names    * @param force create project even if it is identity    */
specifier|public
name|RelBuilder
name|project
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|Iterable
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|peek
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|inputRowType
init|=
name|frame
operator|.
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodeList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
comment|// Perform a quick check for identity. We'll do a deeper check
comment|// later when we've derived column names.
if|if
condition|(
operator|!
name|force
operator|&&
name|Iterables
operator|.
name|isEmpty
argument_list|(
name|fieldNames
argument_list|)
operator|&&
name|RexUtil
operator|.
name|isIdentity
argument_list|(
name|nodeList
argument_list|,
name|inputRowType
argument_list|)
condition|)
block|{
return|return
name|this
return|;
block|}
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|fieldNames
argument_list|)
decl_stmt|;
while|while
condition|(
name|fieldNameList
operator|.
name|size
argument_list|()
operator|<
name|nodeList
operator|.
name|size
argument_list|()
condition|)
block|{
name|fieldNameList
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame
operator|.
name|rel
operator|instanceof
name|Project
operator|&&
name|shouldMergeProject
argument_list|()
condition|)
block|{
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|frame
operator|.
name|rel
decl_stmt|;
comment|// Populate field names. If the upper expression is an input ref and does
comment|// not have a recommended name, use the name of the underlying field.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldNameList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fieldNameList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
condition|)
block|{
specifier|final
name|RexNode
name|node
init|=
name|nodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|RexInputRef
condition|)
block|{
specifier|final
name|RexInputRef
name|ref
init|=
operator|(
name|RexInputRef
operator|)
name|node
decl_stmt|;
name|fieldNameList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|project
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newNodes
init|=
name|RelOptUtil
operator|.
name|pushPastProject
argument_list|(
name|nodeList
argument_list|,
name|project
argument_list|)
decl_stmt|;
comment|// Carefully build a list of fields, so that table aliases from the input
comment|// can be seen for fields that are based on a RexInputRef.
specifier|final
name|Frame
name|frame1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Field
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|f
range|:
name|project
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|fields
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|Field
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
name|frame1
operator|.
name|fields
argument_list|)
control|)
block|{
switch|switch
condition|(
name|pair
operator|.
name|left
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|INPUT_REF
case|:
specifier|final
name|int
name|i
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|pair
operator|.
name|left
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
specifier|final
name|Field
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableSet
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|pair
operator|.
name|right
operator|.
name|left
decl_stmt|;
name|fields
operator|.
name|set
argument_list|(
name|i
argument_list|,
operator|new
name|Field
argument_list|(
name|aliases
argument_list|,
name|field
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|project
operator|.
name|getInput
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|project
argument_list|(
name|newNodes
argument_list|,
name|fieldNameList
argument_list|,
name|force
argument_list|)
return|;
block|}
comment|// Simplify expressions.
if|if
condition|(
name|simplify
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|nodeList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|simplifier
operator|.
name|simplifyPreservingType
argument_list|(
name|nodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Replace null names with generated aliases.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldNameList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fieldNameList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
condition|)
block|{
name|fieldNameList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|inferAlias
argument_list|(
name|nodeList
argument_list|,
name|nodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Field
argument_list|>
name|fields
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|uniqueNameList
init|=
name|getTypeFactory
argument_list|()
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|isSchemaCaseSensitive
argument_list|()
condition|?
operator|new
name|HashSet
argument_list|<>
argument_list|()
else|:
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|String
operator|.
name|CASE_INSENSITIVE_ORDER
argument_list|)
decl_stmt|;
comment|// calculate final names and build field list
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldNameList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|RexNode
name|node
init|=
name|nodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|fieldNameList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Field
name|field
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|uniqueNameList
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
block|}
do|do
block|{
name|name
operator|=
name|SqlValidatorUtil
operator|.
name|F_SUGGESTER
operator|.
name|apply
argument_list|(
name|name
argument_list|,
name|j
argument_list|,
name|j
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|uniqueNameList
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
do|;
name|fieldNameList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|RelDataTypeField
name|fieldType
init|=
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|name
argument_list|,
name|i
argument_list|,
name|node
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|INPUT_REF
case|:
comment|// preserve rel aliases for INPUT_REF fields
specifier|final
name|int
name|index
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|field
operator|=
operator|new
name|Field
argument_list|(
name|frame
operator|.
name|fields
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|left
argument_list|,
name|fieldType
argument_list|)
expr_stmt|;
break|break;
default|default:
name|field
operator|=
operator|new
name|Field
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|fieldType
argument_list|)
expr_stmt|;
break|break;
block|}
name|uniqueNameList
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|force
operator|&&
name|RexUtil
operator|.
name|isIdentity
argument_list|(
name|nodeList
argument_list|,
name|inputRowType
argument_list|)
condition|)
block|{
if|if
condition|(
name|fieldNameList
operator|.
name|equals
argument_list|(
name|inputRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
condition|)
block|{
comment|// Do not create an identity project if it does not rename any fields
return|return
name|this
return|;
block|}
else|else
block|{
comment|// create "virtual" row type for project only rename fields
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|frame
operator|.
name|rel
argument_list|,
name|fields
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
specifier|final
name|RelNode
name|project
init|=
name|projectFactory
operator|.
name|createProject
argument_list|(
name|frame
operator|.
name|rel
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodeList
argument_list|)
argument_list|,
name|fieldNameList
argument_list|)
decl_stmt|;
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|project
argument_list|,
name|fields
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Whether to attempt to merge consecutive {@link Project} operators.    *    *<p>The default implementation returns {@code true};    * sub-classes may disable merge by overriding to return {@code false}. */
annotation|@
name|Experimental
specifier|protected
name|boolean
name|shouldMergeProject
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/** Creates a {@link Project} of the given    * expressions and field names, and optionally optimizing.    *    *<p>If {@code fieldNames} is null, or if a particular entry in    * {@code fieldNames} is null, derives field names from the input    * expressions.    *    *<p>If {@code force} is false,    * and the input is a {@code Project},    * and the expressions  make the trivial projection ($0, $1, ...),    * modifies the input.    *    * @param nodes       Expressions    * @param fieldNames  Suggested field names, or null to generate    * @param force       Whether to create a renaming Project if the    *                    projections are trivial    */
specifier|public
name|RelBuilder
name|projectNamed
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|Iterable
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodeList
init|=
name|nodes
operator|instanceof
name|List
condition|?
operator|(
name|List
operator|)
name|nodes
else|:
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
init|=
name|fieldNames
operator|==
literal|null
condition|?
literal|null
else|:
name|fieldNames
operator|instanceof
name|List
condition|?
operator|(
name|List
argument_list|<
name|String
argument_list|>
operator|)
name|fieldNames
else|:
name|ImmutableNullableList
operator|.
name|copyOf
argument_list|(
name|fieldNames
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|peek
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|RexUtil
operator|.
name|createStructType
argument_list|(
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|nodeList
argument_list|,
name|fieldNameList
argument_list|,
name|SqlValidatorUtil
operator|.
name|F_SUGGESTER
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|RexUtil
operator|.
name|isIdentity
argument_list|(
name|nodeList
argument_list|,
name|input
operator|.
name|getRowType
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|input
operator|instanceof
name|Project
operator|&&
name|fieldNames
operator|!=
literal|null
condition|)
block|{
comment|// Rename columns of child projection if desired field names are given.
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|Project
name|childProject
init|=
operator|(
name|Project
operator|)
name|frame
operator|.
name|rel
decl_stmt|;
specifier|final
name|Project
name|newInput
init|=
name|childProject
operator|.
name|copy
argument_list|(
name|childProject
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|childProject
operator|.
name|getInput
argument_list|()
argument_list|,
name|childProject
operator|.
name|getProjects
argument_list|()
argument_list|,
name|rowType
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|newInput
argument_list|,
name|frame
operator|.
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|project
argument_list|(
name|nodeList
argument_list|,
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Ensures that the field names match those given.    *    *<p>If all fields have the same name, adds nothing;    * if any fields do not have the same name, adds a {@link Project}.    *    *<p>Note that the names can be short-lived. Other {@code RelBuilder}    * operations make no guarantees about the field names of the rows they    * produce.    *    * @param fieldNames List of desired field names; may contain null values or    * have fewer fields than the current row type    */
specifier|public
name|RelBuilder
name|rename
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|oldFieldNames
init|=
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|fieldNames
operator|.
name|size
argument_list|()
operator|<=
name|oldFieldNames
operator|.
name|size
argument_list|()
argument_list|,
literal|"More names than fields"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|newFieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|oldFieldNames
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|s
init|=
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|newFieldNames
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldFieldNames
operator|.
name|equals
argument_list|(
name|newFieldNames
argument_list|)
condition|)
block|{
return|return
name|this
return|;
block|}
if|if
condition|(
name|peek
argument_list|()
operator|instanceof
name|Values
condition|)
block|{
comment|// Special treatment for VALUES. Re-build it rather than add a project.
specifier|final
name|Values
name|v
init|=
operator|(
name|Values
operator|)
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|b
init|=
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataTypeField
argument_list|>
name|p
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|newFieldNames
argument_list|,
name|v
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
control|)
block|{
name|b
operator|.
name|add
argument_list|(
name|p
operator|.
name|left
argument_list|,
name|p
operator|.
name|right
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|values
argument_list|(
name|v
operator|.
name|tuples
argument_list|,
name|b
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
return|return
name|project
argument_list|(
name|fields
argument_list|()
argument_list|,
name|newFieldNames
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Infers the alias of an expression.    *    *<p>If the expression was created by {@link #alias}, replaces the expression    * in the project list.    */
specifier|private
name|String
name|inferAlias
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
parameter_list|,
name|RexNode
name|expr
parameter_list|,
name|int
name|i
parameter_list|)
block|{
switch|switch
condition|(
name|expr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|INPUT_REF
case|:
specifier|final
name|RexInputRef
name|ref
init|=
operator|(
name|RexInputRef
operator|)
name|expr
decl_stmt|;
return|return
name|stack
operator|.
name|peek
argument_list|()
operator|.
name|fields
operator|.
name|get
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|.
name|getValue
argument_list|()
operator|.
name|getName
argument_list|()
return|;
case|case
name|CAST
case|:
return|return
name|inferAlias
argument_list|(
name|exprList
argument_list|,
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
return|;
case|case
name|AS
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|expr
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|exprList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|NlsString
operator|)
operator|(
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|getValue
argument_list|()
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
comment|/** Creates an {@link Aggregate} that makes the    * relational expression distinct on all fields. */
specifier|public
name|RelBuilder
name|distinct
parameter_list|()
block|{
return|return
name|aggregate
argument_list|(
name|groupKey
argument_list|(
name|fields
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an {@link Aggregate} with an array of    * calls. */
specifier|public
name|RelBuilder
name|aggregate
parameter_list|(
name|GroupKey
name|groupKey
parameter_list|,
name|AggCall
modifier|...
name|aggCalls
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|groupKey
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|aggCalls
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an {@link Aggregate} with a list of    * calls. */
specifier|public
name|RelBuilder
name|aggregate
parameter_list|(
name|GroupKey
name|groupKey
parameter_list|,
name|Iterable
argument_list|<
name|AggCall
argument_list|>
name|aggCalls
parameter_list|)
block|{
specifier|final
name|Registrar
name|registrar
init|=
operator|new
name|Registrar
argument_list|()
decl_stmt|;
name|registrar
operator|.
name|extraNodes
operator|.
name|addAll
argument_list|(
name|fields
argument_list|()
argument_list|)
expr_stmt|;
name|registrar
operator|.
name|names
operator|.
name|addAll
argument_list|(
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|GroupKeyImpl
name|groupKey_
init|=
operator|(
name|GroupKeyImpl
operator|)
name|groupKey
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|groupSet
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|registrar
operator|.
name|registerExpressions
argument_list|(
name|groupKey_
operator|.
name|nodes
argument_list|)
argument_list|)
decl_stmt|;
name|label
label|:
if|if
condition|(
name|Iterables
operator|.
name|isEmpty
argument_list|(
name|aggCalls
argument_list|)
operator|&&
operator|!
name|groupKey_
operator|.
name|indicator
condition|)
block|{
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|peek
argument_list|()
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|groupSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|Double
name|minRowCount
init|=
name|mq
operator|.
name|getMinRowCount
argument_list|(
name|peek
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|minRowCount
operator|==
literal|null
operator|||
name|minRowCount
operator|<
literal|1D
condition|)
block|{
comment|// We can't remove "GROUP BY ()" if there's a chance the rel could be
comment|// empty.
break|break
name|label
break|;
block|}
block|}
if|if
condition|(
name|registrar
operator|.
name|extraNodes
operator|.
name|size
argument_list|()
operator|==
name|fields
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|final
name|Boolean
name|unique
init|=
name|mq
operator|.
name|areColumnsUnique
argument_list|(
name|peek
argument_list|()
argument_list|,
name|groupSet
argument_list|)
decl_stmt|;
if|if
condition|(
name|unique
operator|!=
literal|null
operator|&&
name|unique
condition|)
block|{
comment|// Rel is already unique.
return|return
name|project
argument_list|(
name|fields
argument_list|(
name|groupSet
operator|.
name|asList
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|final
name|Double
name|maxRowCount
init|=
name|mq
operator|.
name|getMaxRowCount
argument_list|(
name|peek
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxRowCount
operator|!=
literal|null
operator|&&
name|maxRowCount
operator|<=
literal|1D
condition|)
block|{
comment|// If there is at most one row, rel is already unique.
return|return
name|this
return|;
block|}
block|}
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
decl_stmt|;
if|if
condition|(
name|groupKey_
operator|.
name|nodeLists
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|sizeBefore
init|=
name|registrar
operator|.
name|extraNodes
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|SortedSet
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSetSet
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|ImmutableBitSet
operator|.
name|ORDERING
argument_list|)
decl_stmt|;
for|for
control|(
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|nodeList
range|:
name|groupKey_
operator|.
name|nodeLists
control|)
block|{
specifier|final
name|ImmutableBitSet
name|groupSet2
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|registrar
operator|.
name|registerExpressions
argument_list|(
name|nodeList
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|groupSet
operator|.
name|contains
argument_list|(
name|groupSet2
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"group set element "
operator|+
name|nodeList
operator|+
literal|" must be a subset of group key"
argument_list|)
throw|;
block|}
name|groupSetSet
operator|.
name|add
argument_list|(
name|groupSet2
argument_list|)
expr_stmt|;
block|}
name|groupSets
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|groupSetSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|registrar
operator|.
name|extraNodes
operator|.
name|size
argument_list|()
operator|>
name|sizeBefore
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"group sets contained expressions not in group key: "
operator|+
name|registrar
operator|.
name|extraNodes
operator|.
name|subList
argument_list|(
name|sizeBefore
argument_list|,
name|registrar
operator|.
name|extraNodes
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|groupSets
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupSet
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|AggCall
name|aggCall
range|:
name|aggCalls
control|)
block|{
if|if
condition|(
name|aggCall
operator|instanceof
name|AggCallImpl
condition|)
block|{
specifier|final
name|AggCallImpl
name|aggCall1
init|=
operator|(
name|AggCallImpl
operator|)
name|aggCall
decl_stmt|;
name|registrar
operator|.
name|registerExpressions
argument_list|(
name|aggCall1
operator|.
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|aggCall1
operator|.
name|filter
operator|!=
literal|null
condition|)
block|{
name|registrar
operator|.
name|registerExpression
argument_list|(
name|aggCall1
operator|.
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|project
argument_list|(
name|registrar
operator|.
name|extraNodes
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|registrar
operator|.
name|names
argument_list|)
expr_stmt|;
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|r
init|=
name|frame
operator|.
name|rel
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggCall
name|aggCall
range|:
name|aggCalls
control|)
block|{
specifier|final
name|AggregateCall
name|aggregateCall
decl_stmt|;
if|if
condition|(
name|aggCall
operator|instanceof
name|AggCallImpl
condition|)
block|{
specifier|final
name|AggCallImpl
name|aggCall1
init|=
operator|(
name|AggCallImpl
operator|)
name|aggCall
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|args
init|=
name|registrar
operator|.
name|registerExpressions
argument_list|(
name|aggCall1
operator|.
name|operands
argument_list|)
decl_stmt|;
specifier|final
name|int
name|filterArg
init|=
name|aggCall1
operator|.
name|filter
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|registrar
operator|.
name|registerExpression
argument_list|(
name|aggCall1
operator|.
name|filter
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggCall1
operator|.
name|distinct
operator|&&
operator|!
name|aggCall1
operator|.
name|aggFunction
operator|.
name|isQuantifierAllowed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"DISTINCT not allowed"
argument_list|)
throw|;
block|}
if|if
condition|(
name|aggCall1
operator|.
name|filter
operator|!=
literal|null
operator|&&
operator|!
name|aggCall1
operator|.
name|aggFunction
operator|.
name|allowsFilter
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"FILTER not allowed"
argument_list|)
throw|;
block|}
name|aggregateCall
operator|=
name|AggregateCall
operator|.
name|create
argument_list|(
name|aggCall1
operator|.
name|aggFunction
argument_list|,
name|aggCall1
operator|.
name|distinct
argument_list|,
name|aggCall1
operator|.
name|approximate
argument_list|,
name|args
argument_list|,
name|filterArg
argument_list|,
name|groupSet
operator|.
name|cardinality
argument_list|()
argument_list|,
name|r
argument_list|,
literal|null
argument_list|,
name|aggCall1
operator|.
name|alias
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aggregateCall
operator|=
operator|(
operator|(
name|AggCallImpl2
operator|)
name|aggCall
operator|)
operator|.
name|aggregateCall
expr_stmt|;
block|}
name|aggregateCalls
operator|.
name|add
argument_list|(
name|aggregateCall
argument_list|)
expr_stmt|;
block|}
assert|assert
name|ImmutableBitSet
operator|.
name|ORDERING
operator|.
name|isStrictlyOrdered
argument_list|(
name|groupSets
argument_list|)
operator|:
name|groupSets
assert|;
for|for
control|(
name|ImmutableBitSet
name|set
range|:
name|groupSets
control|)
block|{
assert|assert
name|groupSet
operator|.
name|contains
argument_list|(
name|set
argument_list|)
assert|;
block|}
name|RelNode
name|aggregate
init|=
name|aggregateFactory
operator|.
name|createAggregate
argument_list|(
name|r
argument_list|,
name|groupKey_
operator|.
name|indicator
argument_list|,
name|groupSet
argument_list|,
name|groupSets
argument_list|,
name|aggregateCalls
argument_list|)
decl_stmt|;
comment|// build field list
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Field
argument_list|>
name|fields
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|aggregateFields
init|=
name|aggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// first, group fields
for|for
control|(
name|Integer
name|groupField
range|:
name|groupSet
operator|.
name|asList
argument_list|()
control|)
block|{
name|RexNode
name|node
init|=
name|registrar
operator|.
name|extraNodes
operator|.
name|get
argument_list|(
name|groupField
argument_list|)
decl_stmt|;
specifier|final
name|SqlKind
name|kind
init|=
name|node
operator|.
name|getKind
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|INPUT_REF
case|:
name|fields
operator|.
name|add
argument_list|(
name|frame
operator|.
name|fields
operator|.
name|get
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|String
name|name
init|=
name|aggregateFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|RelDataTypeField
name|fieldType
init|=
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|name
argument_list|,
name|i
argument_list|,
name|node
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|fieldType
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|// second, indicator fields (copy from aggregate rel type)
if|if
condition|(
name|groupKey_
operator|.
name|indicator
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|groupSet
operator|.
name|cardinality
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|aggregateFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeField
name|fieldType
init|=
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|i
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|fieldType
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|// third, aggregate fields. retain `i' as field index
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|aggregateCalls
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|final
name|AggregateCall
name|call
init|=
name|aggregateCalls
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeField
name|fieldType
init|=
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|aggregateFields
operator|.
name|get
argument_list|(
name|i
operator|+
name|j
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
name|i
operator|+
name|j
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|fieldType
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|aggregate
argument_list|,
name|fields
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|private
name|RelBuilder
name|setOp
parameter_list|(
name|boolean
name|all
parameter_list|,
name|SqlKind
name|kind
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|inputs
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
if|if
condition|(
name|n
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"bad INTERSECT/UNION/EXCEPT input count"
argument_list|)
throw|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"bad setOp "
operator|+
name|kind
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1
case|:
return|return
name|push
argument_list|(
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|push
argument_list|(
name|setOpFactory
operator|.
name|createSetOp
argument_list|(
name|kind
argument_list|,
name|inputs
argument_list|,
name|all
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Creates a {@link Union} of the two most recent    * relational expressions on the stack.    *    * @param all Whether to create UNION ALL    */
specifier|public
name|RelBuilder
name|union
parameter_list|(
name|boolean
name|all
parameter_list|)
block|{
return|return
name|union
argument_list|(
name|all
argument_list|,
literal|2
argument_list|)
return|;
block|}
comment|/** Creates a {@link Union} of the {@code n}    * most recent relational expressions on the stack.    *    * @param all Whether to create UNION ALL    * @param n Number of inputs to the UNION operator    */
specifier|public
name|RelBuilder
name|union
parameter_list|(
name|boolean
name|all
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|setOp
argument_list|(
name|all
argument_list|,
name|SqlKind
operator|.
name|UNION
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Creates an {@link Intersect} of the two most    * recent relational expressions on the stack.    *    * @param all Whether to create INTERSECT ALL    */
specifier|public
name|RelBuilder
name|intersect
parameter_list|(
name|boolean
name|all
parameter_list|)
block|{
return|return
name|intersect
argument_list|(
name|all
argument_list|,
literal|2
argument_list|)
return|;
block|}
comment|/** Creates an {@link Intersect} of the {@code n}    * most recent relational expressions on the stack.    *    * @param all Whether to create INTERSECT ALL    * @param n Number of inputs to the INTERSECT operator    */
specifier|public
name|RelBuilder
name|intersect
parameter_list|(
name|boolean
name|all
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|setOp
argument_list|(
name|all
argument_list|,
name|SqlKind
operator|.
name|INTERSECT
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Creates a {@link Minus} of the two most recent    * relational expressions on the stack.    *    * @param all Whether to create EXCEPT ALL    */
specifier|public
name|RelBuilder
name|minus
parameter_list|(
name|boolean
name|all
parameter_list|)
block|{
return|return
name|minus
argument_list|(
name|all
argument_list|,
literal|2
argument_list|)
return|;
block|}
comment|/** Creates a {@link Minus} of the {@code n}    * most recent relational expressions on the stack.    *    * @param all Whether to create EXCEPT ALL    */
specifier|public
name|RelBuilder
name|minus
parameter_list|(
name|boolean
name|all
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|setOp
argument_list|(
name|all
argument_list|,
name|SqlKind
operator|.
name|EXCEPT
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Creates a {@link Join}. */
specifier|public
name|RelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|RexNode
name|condition0
parameter_list|,
name|RexNode
modifier|...
name|conditions
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|joinType
argument_list|,
name|Lists
operator|.
name|asList
argument_list|(
name|condition0
argument_list|,
name|conditions
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Join} with multiple    * conditions. */
specifier|public
name|RelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|conditions
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|joinType
argument_list|,
name|and
argument_list|(
name|conditions
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|RelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|joinType
argument_list|,
name|condition
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a {@link Join} with correlating    * variables. */
specifier|public
name|RelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|variablesSet
parameter_list|)
block|{
name|Frame
name|right
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|Frame
name|left
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|join
decl_stmt|;
specifier|final
name|boolean
name|correlate
init|=
name|variablesSet
operator|.
name|size
argument_list|()
operator|==
literal|1
decl_stmt|;
name|RexNode
name|postCondition
init|=
name|literal
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|correlate
condition|)
block|{
specifier|final
name|CorrelationId
name|id
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|variablesSet
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|requiredColumns
init|=
name|RelOptUtil
operator|.
name|correlationColumns
argument_list|(
name|id
argument_list|,
name|right
operator|.
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|RelOptUtil
operator|.
name|notContainsCorrelation
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|id
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"variable "
operator|+
name|id
operator|+
literal|" must not be used by left input to correlation"
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|LEFT
case|:
comment|// Correlate does not have an ON clause.
comment|// For a LEFT correlate, predicate must be evaluated first.
comment|// For INNER, we can defer.
name|stack
operator|.
name|push
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|filter
argument_list|(
name|condition
operator|.
name|accept
argument_list|(
operator|new
name|Shifter
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|id
argument_list|,
name|right
operator|.
name|rel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|right
operator|=
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
break|break;
default|default:
name|postCondition
operator|=
name|condition
expr_stmt|;
block|}
name|join
operator|=
name|correlateFactory
operator|.
name|createCorrelate
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|right
operator|.
name|rel
argument_list|,
name|id
argument_list|,
name|requiredColumns
argument_list|,
name|SemiJoinType
operator|.
name|of
argument_list|(
name|joinType
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|join
operator|=
name|joinFactory
operator|.
name|createJoin
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|right
operator|.
name|rel
argument_list|,
name|condition
argument_list|,
name|variablesSet
argument_list|,
name|joinType
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Field
argument_list|>
name|fields
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|fields
operator|.
name|addAll
argument_list|(
name|left
operator|.
name|fields
argument_list|)
expr_stmt|;
name|fields
operator|.
name|addAll
argument_list|(
name|right
operator|.
name|fields
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|join
argument_list|,
name|fields
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|filter
argument_list|(
name|postCondition
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link Join} using USING syntax.    *    *<p>For each of the field names, both left and right inputs must have a    * field of that name. Constructs a join condition that the left and right    * fields are equal.    *    * @param joinType Join type    * @param fieldNames Field names    */
specifier|public
name|RelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|String
modifier|...
name|fieldNames
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|conditions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
name|conditions
operator|.
name|add
argument_list|(
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|fieldName
argument_list|)
argument_list|,
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|fieldName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|join
argument_list|(
name|joinType
argument_list|,
name|conditions
argument_list|)
return|;
block|}
comment|/** Creates a {@link SemiJoin}. */
specifier|public
name|RelBuilder
name|semiJoin
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|conditions
parameter_list|)
block|{
specifier|final
name|Frame
name|right
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|semiJoin
init|=
name|semiJoinFactory
operator|.
name|createSemiJoin
argument_list|(
name|peek
argument_list|()
argument_list|,
name|right
operator|.
name|rel
argument_list|,
name|and
argument_list|(
name|conditions
argument_list|)
argument_list|)
decl_stmt|;
name|replaceTop
argument_list|(
name|semiJoin
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link SemiJoin}. */
specifier|public
name|RelBuilder
name|semiJoin
parameter_list|(
name|RexNode
modifier|...
name|conditions
parameter_list|)
block|{
return|return
name|semiJoin
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|conditions
argument_list|)
argument_list|)
return|;
block|}
comment|/** Assigns a table alias to the top entry on the stack. */
specifier|public
name|RelBuilder
name|as
parameter_list|(
specifier|final
name|String
name|alias
parameter_list|)
block|{
specifier|final
name|Frame
name|pair
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Field
argument_list|>
name|newFields
init|=
name|Util
operator|.
name|transform
argument_list|(
name|pair
operator|.
name|fields
argument_list|,
name|field
lambda|->
name|field
operator|.
name|addAlias
argument_list|(
name|alias
argument_list|)
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|pair
operator|.
name|rel
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|newFields
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link Values}.    *    *<p>The {@code values} array must have the same number of entries as    * {@code fieldNames}, or an integer multiple if you wish to create multiple    * rows.    *    *<p>If there are zero rows, or if all values of a any column are    * null, this method cannot deduce the type of columns. For these cases,    * call {@link #values(Iterable, RelDataType)}.    *    * @param fieldNames Field names    * @param values Values    */
specifier|public
name|RelBuilder
name|values
parameter_list|(
name|String
index|[]
name|fieldNames
parameter_list|,
name|Object
modifier|...
name|values
parameter_list|)
block|{
if|if
condition|(
name|fieldNames
operator|==
literal|null
operator|||
name|fieldNames
operator|.
name|length
operator|==
literal|0
operator|||
name|values
operator|.
name|length
operator|%
name|fieldNames
operator|.
name|length
operator|!=
literal|0
operator|||
name|values
operator|.
name|length
operator|<
name|fieldNames
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Value count must be a positive multiple of field count"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|rowCount
init|=
name|values
operator|.
name|length
operator|/
name|fieldNames
operator|.
name|length
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|String
argument_list|>
name|fieldName
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|fieldNames
argument_list|)
control|)
block|{
if|if
condition|(
name|allNull
argument_list|(
name|values
argument_list|,
name|fieldName
operator|.
name|i
argument_list|,
name|fieldNames
operator|.
name|length
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"All values of field '"
operator|+
name|fieldName
operator|.
name|e
operator|+
literal|"' are null; cannot deduce type"
argument_list|)
throw|;
block|}
block|}
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
init|=
name|tupleList
argument_list|(
name|fieldNames
operator|.
name|length
argument_list|,
name|values
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|builder
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Ord
argument_list|<
name|String
argument_list|>
name|fieldName
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|fieldNames
argument_list|)
control|)
block|{
specifier|final
name|String
name|name
init|=
name|fieldName
operator|.
name|e
operator|!=
literal|null
condition|?
name|fieldName
operator|.
name|e
else|:
literal|"expr$"
operator|+
name|fieldName
operator|.
name|i
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|leastRestrictive
argument_list|(
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|tupleList
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|get
argument_list|(
name|fieldName
operator|.
name|i
argument_list|)
operator|.
name|getType
argument_list|()
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rowCount
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataType
name|rowType
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|values
argument_list|(
name|tupleList
argument_list|,
name|rowType
argument_list|)
return|;
block|}
specifier|private
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
parameter_list|(
name|int
name|columnCount
parameter_list|,
name|Object
index|[]
name|values
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|listBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|valueList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|value
init|=
name|values
index|[
name|i
index|]
decl_stmt|;
name|valueList
operator|.
name|add
argument_list|(
operator|(
name|RexLiteral
operator|)
name|literal
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|columnCount
operator|==
literal|0
condition|)
block|{
name|listBuilder
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|valueList
argument_list|)
argument_list|)
expr_stmt|;
name|valueList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|listBuilder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns whether all values for a given column are null. */
specifier|private
name|boolean
name|allNull
parameter_list|(
name|Object
index|[]
name|values
parameter_list|,
name|int
name|column
parameter_list|,
name|int
name|columnCount
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|column
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|+=
name|columnCount
control|)
block|{
if|if
condition|(
name|values
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** Creates a relational expression that reads from an input and throws    * all of the rows away.    *    *<p>Note that this method always pops one relational expression from the    * stack. {@code values}, in contrast, does not pop any relational    * expressions, and always produces a leaf.    *    *<p>The default implementation creates a {@link Values} with the same    * specified row type as the input, and ignores the input entirely.    * But schema-on-query systems such as Drill might override this method to    * create a relation expression that retains the input, just to read its    * schema.    */
specifier|public
name|RelBuilder
name|empty
parameter_list|()
block|{
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
return|return
name|values
argument_list|(
name|frame
operator|.
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a {@link Values} with a specified row type.    *    *<p>This method can handle cases that {@link #values(String[], Object...)}    * cannot, such as all values of a column being null, or there being zero    * rows.    *    * @param rowType Row type    * @param columnValues Values    */
specifier|public
name|RelBuilder
name|values
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|Object
modifier|...
name|columnValues
parameter_list|)
block|{
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
init|=
name|tupleList
argument_list|(
name|rowType
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|columnValues
argument_list|)
decl_stmt|;
name|RelNode
name|values
init|=
name|valuesFactory
operator|.
name|createValues
argument_list|(
name|cluster
argument_list|,
name|rowType
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tupleList
argument_list|)
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|values
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link Values} with a specified row type.    *    *<p>This method can handle cases that {@link #values(String[], Object...)}    * cannot, such as all values of a column being null, or there being zero    * rows.    *    * @param tupleList Tuple list    * @param rowType Row type    */
specifier|public
name|RelBuilder
name|values
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
block|{
name|RelNode
name|values
init|=
name|valuesFactory
operator|.
name|createValues
argument_list|(
name|cluster
argument_list|,
name|rowType
argument_list|,
name|copy
argument_list|(
name|tupleList
argument_list|)
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|values
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link Values} with a specified row type and    * zero rows.    *    * @param rowType Row type    */
specifier|public
name|RelBuilder
name|values
parameter_list|(
name|RelDataType
name|rowType
parameter_list|)
block|{
return|return
name|values
argument_list|(
name|ImmutableList
operator|.
expr|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
operator|>
name|of
argument_list|()
argument_list|,
name|rowType
argument_list|)
return|;
block|}
comment|/** Converts an iterable of lists into an immutable list of immutable lists    * with the same contents. Returns the same object if possible. */
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|E
argument_list|>
argument_list|>
name|copy
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|tupleList
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|E
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|int
name|changeCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|E
argument_list|>
name|literals
range|:
name|tupleList
control|)
block|{
specifier|final
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|literals2
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|literals
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|literals2
argument_list|)
expr_stmt|;
if|if
condition|(
name|literals
operator|!=
name|literals2
condition|)
block|{
operator|++
name|changeCount
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changeCount
operator|==
literal|0
condition|)
block|{
comment|// don't make a copy if we don't have to
comment|//noinspection unchecked
return|return
operator|(
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|E
argument_list|>
argument_list|>
operator|)
name|tupleList
return|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Creates a limit without a sort. */
specifier|public
name|RelBuilder
name|limit
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|fetch
parameter_list|)
block|{
return|return
name|sortLimit
argument_list|(
name|offset
argument_list|,
name|fetch
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a {@link Sort} by field ordinals.    *    *<p>Negative fields mean descending: -1 means field(0) descending,    * -2 means field(1) descending, etc.    */
specifier|public
name|RelBuilder
name|sort
parameter_list|(
name|int
modifier|...
name|fields
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|field
range|:
name|fields
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|field
operator|<
literal|0
condition|?
name|desc
argument_list|(
name|field
argument_list|(
operator|-
name|field
operator|-
literal|1
argument_list|)
argument_list|)
else|:
name|field
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a {@link Sort} by expressions. */
specifier|public
name|RelBuilder
name|sort
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Sort} by expressions. */
specifier|public
name|RelBuilder
name|sort
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|nodes
argument_list|)
return|;
block|}
comment|/** Creates a {@link Sort} by expressions, with limit and offset. */
specifier|public
name|RelBuilder
name|sortLimit
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|fetch
parameter_list|,
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|sortLimit
argument_list|(
name|offset
argument_list|,
name|fetch
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Sort} by a list of expressions, with limit and offset.    *    * @param offset Number of rows to skip; non-positive means don't skip any    * @param fetch Maximum number of rows to fetch; negative means no limit    * @param nodes Sort expressions    */
specifier|public
name|RelBuilder
name|sortLimit
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|fetch
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|originalExtraNodes
init|=
name|fields
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|originalExtraNodes
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
specifier|final
name|RelFieldCollation
name|collation
init|=
name|collation
argument_list|(
name|node
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|ASCENDING
argument_list|,
literal|null
argument_list|,
name|extraNodes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|RelCollations
operator|.
name|ordinals
argument_list|(
name|fieldCollations
argument_list|)
operator|.
name|contains
argument_list|(
name|collation
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
condition|)
block|{
name|fieldCollations
operator|.
name|add
argument_list|(
name|collation
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|RexNode
name|offsetNode
init|=
name|offset
operator|<=
literal|0
condition|?
literal|null
else|:
name|literal
argument_list|(
name|offset
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|fetchNode
init|=
name|fetch
operator|<
literal|0
condition|?
literal|null
else|:
name|literal
argument_list|(
name|fetch
argument_list|)
decl_stmt|;
if|if
condition|(
name|offsetNode
operator|==
literal|null
operator|&&
name|fetch
operator|==
literal|0
condition|)
block|{
return|return
name|empty
argument_list|()
return|;
block|}
if|if
condition|(
name|offsetNode
operator|==
literal|null
operator|&&
name|fetchNode
operator|==
literal|null
operator|&&
name|fieldCollations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|this
return|;
comment|// sort is trivial
block|}
specifier|final
name|boolean
name|addedFields
init|=
name|extraNodes
operator|.
name|size
argument_list|()
operator|>
name|originalExtraNodes
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldCollations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
assert|assert
operator|!
name|addedFields
assert|;
name|RelNode
name|top
init|=
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|top
operator|instanceof
name|Sort
condition|)
block|{
specifier|final
name|Sort
name|sort2
init|=
operator|(
name|Sort
operator|)
name|top
decl_stmt|;
if|if
condition|(
name|sort2
operator|.
name|offset
operator|==
literal|null
operator|&&
name|sort2
operator|.
name|fetch
operator|==
literal|null
condition|)
block|{
name|replaceTop
argument_list|(
name|sort2
operator|.
name|getInput
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|sort
init|=
name|sortFactory
operator|.
name|createSort
argument_list|(
name|peek
argument_list|()
argument_list|,
name|sort2
operator|.
name|collation
argument_list|,
name|offsetNode
argument_list|,
name|fetchNode
argument_list|)
decl_stmt|;
name|replaceTop
argument_list|(
name|sort
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
if|if
condition|(
name|top
operator|instanceof
name|Project
condition|)
block|{
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|top
decl_stmt|;
if|if
condition|(
name|project
operator|.
name|getInput
argument_list|()
operator|instanceof
name|Sort
condition|)
block|{
specifier|final
name|Sort
name|sort2
init|=
operator|(
name|Sort
operator|)
name|project
operator|.
name|getInput
argument_list|()
decl_stmt|;
if|if
condition|(
name|sort2
operator|.
name|offset
operator|==
literal|null
operator|&&
name|sort2
operator|.
name|fetch
operator|==
literal|null
condition|)
block|{
specifier|final
name|RelNode
name|sort
init|=
name|sortFactory
operator|.
name|createSort
argument_list|(
name|sort2
operator|.
name|getInput
argument_list|()
argument_list|,
name|sort2
operator|.
name|collation
argument_list|,
name|offsetNode
argument_list|,
name|fetchNode
argument_list|)
decl_stmt|;
name|replaceTop
argument_list|(
name|projectFactory
operator|.
name|createProject
argument_list|(
name|sort
argument_list|,
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|project
operator|.
name|getNamedProjects
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|addedFields
condition|)
block|{
name|project
argument_list|(
name|extraNodes
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|sort
init|=
name|sortFactory
operator|.
name|createSort
argument_list|(
name|peek
argument_list|()
argument_list|,
name|RelCollations
operator|.
name|of
argument_list|(
name|fieldCollations
argument_list|)
argument_list|,
name|offsetNode
argument_list|,
name|fetchNode
argument_list|)
decl_stmt|;
name|replaceTop
argument_list|(
name|sort
argument_list|)
expr_stmt|;
if|if
condition|(
name|addedFields
condition|)
block|{
name|project
argument_list|(
name|originalExtraNodes
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
specifier|private
specifier|static
name|RelFieldCollation
name|collation
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|RelFieldCollation
operator|.
name|Direction
name|direction
parameter_list|,
name|RelFieldCollation
operator|.
name|NullDirection
name|nullDirection
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraNodes
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|INPUT_REF
case|:
return|return
operator|new
name|RelFieldCollation
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|,
name|direction
argument_list|,
name|Util
operator|.
name|first
argument_list|(
name|nullDirection
argument_list|,
name|direction
operator|.
name|defaultNullDirection
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|DESCENDING
case|:
return|return
name|collation
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
argument_list|,
name|nullDirection
argument_list|,
name|extraNodes
argument_list|)
return|;
case|case
name|NULLS_FIRST
case|:
return|return
name|collation
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|direction
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
argument_list|,
name|extraNodes
argument_list|)
return|;
case|case
name|NULLS_LAST
case|:
return|return
name|collation
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|direction
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
argument_list|,
name|extraNodes
argument_list|)
return|;
default|default:
specifier|final
name|int
name|fieldIndex
init|=
name|extraNodes
operator|.
name|size
argument_list|()
decl_stmt|;
name|extraNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|new
name|RelFieldCollation
argument_list|(
name|fieldIndex
argument_list|,
name|direction
argument_list|,
name|Util
operator|.
name|first
argument_list|(
name|nullDirection
argument_list|,
name|direction
operator|.
name|defaultNullDirection
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * Creates a projection that converts the current relational expression's    * output to a desired row type.    *    * @param castRowType row type after cast    * @param rename      if true, use field names from castRowType; if false,    *                    preserve field names from rel    */
specifier|public
name|RelBuilder
name|convert
parameter_list|(
name|RelDataType
name|castRowType
parameter_list|,
name|boolean
name|rename
parameter_list|)
block|{
specifier|final
name|RelNode
name|r
init|=
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|r2
init|=
name|RelOptUtil
operator|.
name|createCastRel
argument_list|(
name|r
argument_list|,
name|castRowType
argument_list|,
name|rename
argument_list|,
name|projectFactory
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|r2
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|RelBuilder
name|permute
parameter_list|(
name|Mapping
name|mapping
parameter_list|)
block|{
assert|assert
name|mapping
operator|.
name|getMappingType
argument_list|()
operator|.
name|isSingleSource
argument_list|()
assert|;
assert|assert
name|mapping
operator|.
name|getMappingType
argument_list|()
operator|.
name|isMandatorySource
argument_list|()
assert|;
if|if
condition|(
name|mapping
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
return|return
name|this
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mapping
operator|.
name|getTargetCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprList
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|mapping
operator|.
name|getSource
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|project
argument_list|(
name|exprList
argument_list|)
return|;
block|}
specifier|public
name|RelBuilder
name|aggregate
parameter_list|(
name|GroupKey
name|groupKey
parameter_list|,
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|groupKey
argument_list|,
name|Lists
operator|.
name|transform
argument_list|(
name|aggregateCalls
argument_list|,
name|AggCallImpl2
operator|::
operator|new
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Match}. */
specifier|public
name|RelBuilder
name|match
parameter_list|(
name|RexNode
name|pattern
parameter_list|,
name|boolean
name|strictStart
parameter_list|,
name|boolean
name|strictEnd
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|patternDefinitions
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|measureList
parameter_list|,
name|RexNode
name|after
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
extends|extends
name|SortedSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|subsets
parameter_list|,
name|boolean
name|allRows
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|partitionKeys
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|orderKeys
parameter_list|,
name|RexNode
name|interval
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|orderKey
range|:
name|orderKeys
control|)
block|{
specifier|final
name|RelFieldCollation
operator|.
name|Direction
name|direction
decl_stmt|;
switch|switch
condition|(
name|orderKey
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
name|direction
operator|=
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
expr_stmt|;
name|orderKey
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|orderKey
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NULLS_FIRST
case|:
case|case
name|NULLS_LAST
case|:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
default|default:
name|direction
operator|=
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|ASCENDING
expr_stmt|;
break|break;
block|}
specifier|final
name|RelFieldCollation
operator|.
name|NullDirection
name|nullDirection
init|=
name|direction
operator|.
name|defaultNullDirection
argument_list|()
decl_stmt|;
specifier|final
name|RexInputRef
name|ref
init|=
operator|(
name|RexInputRef
operator|)
name|orderKey
decl_stmt|;
name|fieldCollations
operator|.
name|add
argument_list|(
operator|new
name|RelFieldCollation
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|,
name|direction
argument_list|,
name|nullDirection
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|typeBuilder
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|partitionKey
range|:
name|partitionKeys
control|)
block|{
name|typeBuilder
operator|.
name|add
argument_list|(
name|partitionKey
operator|.
name|toString
argument_list|()
argument_list|,
name|partitionKey
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allRows
condition|)
block|{
for|for
control|(
name|RexNode
name|orderKey
range|:
name|orderKeys
control|)
block|{
if|if
condition|(
operator|!
name|typeBuilder
operator|.
name|nameExists
argument_list|(
name|orderKey
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|typeBuilder
operator|.
name|add
argument_list|(
name|orderKey
operator|.
name|toString
argument_list|()
argument_list|,
name|orderKey
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|RelDataType
name|inputRowType
init|=
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|fs
range|:
name|inputRowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|typeBuilder
operator|.
name|nameExists
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|typeBuilder
operator|.
name|add
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|measures
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|measure
range|:
name|measureList
control|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|measure
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|typeBuilder
operator|.
name|add
argument_list|(
name|alias
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|measures
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|match
init|=
name|matchFactory
operator|.
name|createMatch
argument_list|(
name|peek
argument_list|()
argument_list|,
name|pattern
argument_list|,
name|typeBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|strictStart
argument_list|,
name|strictEnd
argument_list|,
name|patternDefinitions
argument_list|,
name|measures
operator|.
name|build
argument_list|()
argument_list|,
name|after
argument_list|,
name|subsets
argument_list|,
name|allRows
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|partitionKeys
argument_list|)
argument_list|,
name|RelCollations
operator|.
name|of
argument_list|(
name|fieldCollations
argument_list|)
argument_list|,
name|interval
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|match
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Clears the stack.    *    *<p>The builder's state is now the same as when it was created. */
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|stack
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/** Information necessary to create a call to an aggregate function.    *    * @see RelBuilder#aggregateCall */
specifier|public
interface|interface
name|AggCall
block|{   }
comment|/** Information necessary to create the GROUP BY clause of an Aggregate.    *    * @see RelBuilder#groupKey */
specifier|public
interface|interface
name|GroupKey
block|{
comment|/** Assigns an alias to this group key.      *      *<p>Used to assign field names in the {@code group} operation. */
name|GroupKey
name|alias
parameter_list|(
name|String
name|alias
parameter_list|)
function_decl|;
block|}
comment|/** Implementation of {@link GroupKey}. */
specifier|protected
specifier|static
class|class
name|GroupKeyImpl
implements|implements
name|GroupKey
block|{
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|nodes
decl_stmt|;
specifier|final
name|boolean
name|indicator
decl_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
decl_stmt|;
specifier|final
name|String
name|alias
decl_stmt|;
name|GroupKeyImpl
parameter_list|(
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|boolean
name|indicator
parameter_list|,
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
name|this
operator|.
name|nodes
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|indicator
assert|;
name|this
operator|.
name|indicator
operator|=
name|indicator
expr_stmt|;
name|this
operator|.
name|nodeLists
operator|=
name|nodeLists
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|alias
operator|==
literal|null
condition|?
name|nodes
operator|.
name|toString
argument_list|()
else|:
name|nodes
operator|+
literal|" as "
operator|+
name|alias
return|;
block|}
specifier|public
name|GroupKey
name|alias
parameter_list|(
name|String
name|alias
parameter_list|)
block|{
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|alias
argument_list|,
name|alias
argument_list|)
condition|?
name|this
else|:
operator|new
name|GroupKeyImpl
argument_list|(
name|nodes
argument_list|,
name|indicator
argument_list|,
name|nodeLists
argument_list|,
name|alias
argument_list|)
return|;
block|}
block|}
comment|/** Implementation of {@link AggCall}. */
specifier|private
specifier|static
class|class
name|AggCallImpl
implements|implements
name|AggCall
block|{
specifier|private
specifier|final
name|SqlAggFunction
name|aggFunction
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|distinct
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|approximate
decl_stmt|;
specifier|private
specifier|final
name|RexNode
name|filter
decl_stmt|;
specifier|private
specifier|final
name|String
name|alias
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|operands
decl_stmt|;
name|AggCallImpl
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|boolean
name|approximate
parameter_list|,
name|RexNode
name|filter
parameter_list|,
name|String
name|alias
parameter_list|,
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
name|this
operator|.
name|aggFunction
operator|=
name|aggFunction
expr_stmt|;
name|this
operator|.
name|distinct
operator|=
name|distinct
expr_stmt|;
name|this
operator|.
name|approximate
operator|=
name|approximate
expr_stmt|;
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
name|this
operator|.
name|operands
operator|=
name|operands
expr_stmt|;
block|}
block|}
comment|/** Implementation of {@link AggCall} that wraps an    * {@link AggregateCall}. */
specifier|private
specifier|static
class|class
name|AggCallImpl2
implements|implements
name|AggCall
block|{
specifier|private
specifier|final
name|AggregateCall
name|aggregateCall
decl_stmt|;
name|AggCallImpl2
parameter_list|(
name|AggregateCall
name|aggregateCall
parameter_list|)
block|{
name|this
operator|.
name|aggregateCall
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|aggregateCall
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Collects the extra expressions needed for {@link #aggregate}.    *    *<p>The extra expressions come from the group key and as arguments to    * aggregate calls, and later there will be a {@link #project} or a    * {@link #rename(List)} if necessary. */
specifier|private
specifier|static
class|class
name|Registrar
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|registerExpression
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|operands
decl_stmt|;
name|int
name|i
init|=
name|registerExpression
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|names
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|RexLiteral
operator|.
name|stringValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
name|int
name|i
init|=
name|extraNodes
operator|.
name|indexOf
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|extraNodes
operator|.
name|size
argument_list|()
expr_stmt|;
name|extraNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|names
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|registerExpressions
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|builder
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|registerExpression
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
block|}
comment|/** Builder stack frame.    *    *<p>Describes a previously created relational expression and    * information about how table aliases map into its row type. */
specifier|private
specifier|static
class|class
name|Frame
block|{
specifier|final
name|RelNode
name|rel
decl_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|Field
argument_list|>
name|fields
decl_stmt|;
specifier|private
name|Frame
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|ImmutableList
argument_list|<
name|Field
argument_list|>
name|fields
parameter_list|)
block|{
name|this
operator|.
name|rel
operator|=
name|rel
expr_stmt|;
name|this
operator|.
name|fields
operator|=
name|fields
expr_stmt|;
block|}
specifier|private
name|Frame
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|String
name|tableAlias
init|=
name|deriveAlias
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Field
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|ImmutableSet
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|tableAlias
operator|==
literal|null
condition|?
name|ImmutableSet
operator|.
name|of
argument_list|()
else|:
name|ImmutableSet
operator|.
name|of
argument_list|(
name|tableAlias
argument_list|)
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|aliases
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|rel
operator|=
name|rel
expr_stmt|;
name|this
operator|.
name|fields
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|static
name|String
name|deriveAlias
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|TableScan
condition|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|rel
operator|.
name|getTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|names
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Util
operator|.
name|last
argument_list|(
name|names
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
parameter_list|()
block|{
return|return
name|Pair
operator|.
name|right
argument_list|(
name|fields
argument_list|)
return|;
block|}
block|}
comment|/** A field that belongs to a stack {@link Frame}. */
specifier|private
specifier|static
class|class
name|Field
extends|extends
name|Pair
argument_list|<
name|ImmutableSet
argument_list|<
name|String
argument_list|>
argument_list|,
name|RelDataTypeField
argument_list|>
block|{
name|Field
parameter_list|(
name|ImmutableSet
argument_list|<
name|String
argument_list|>
name|left
parameter_list|,
name|RelDataTypeField
name|right
parameter_list|)
block|{
name|super
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
name|Field
name|addAlias
parameter_list|(
name|String
name|alias
parameter_list|)
block|{
if|if
condition|(
name|left
operator|.
name|contains
argument_list|(
name|alias
argument_list|)
condition|)
block|{
return|return
name|this
return|;
block|}
specifier|final
name|ImmutableSet
argument_list|<
name|String
argument_list|>
name|aliasList
init|=
name|ImmutableSet
operator|.
expr|<
name|String
operator|>
name|builder
argument_list|()
operator|.
name|addAll
argument_list|(
name|left
argument_list|)
operator|.
name|add
argument_list|(
name|alias
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
operator|new
name|Field
argument_list|(
name|aliasList
argument_list|,
name|right
argument_list|)
return|;
block|}
block|}
comment|/** Shuttle that shifts a predicate's inputs to the left, replacing early    * ones with references to a    * {@link RexCorrelVariable}. */
specifier|private
class|class
name|Shifter
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|RelNode
name|left
decl_stmt|;
specifier|private
specifier|final
name|CorrelationId
name|id
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|right
decl_stmt|;
name|Shifter
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|CorrelationId
name|id
parameter_list|,
name|RelNode
name|right
parameter_list|)
block|{
name|this
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|right
operator|=
name|right
expr_stmt|;
block|}
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
specifier|final
name|RelDataType
name|leftRowType
init|=
name|left
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|int
name|leftCount
init|=
name|leftRowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|<
name|leftCount
condition|)
block|{
specifier|final
name|RexNode
name|v
init|=
name|rexBuilder
operator|.
name|makeCorrel
argument_list|(
name|leftRowType
argument_list|,
name|id
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|v
argument_list|,
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|right
argument_list|,
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|-
name|leftCount
argument_list|)
return|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|// End RelBuilder.java
end_comment

end_unit

