begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Experimental
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Contexts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Convention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|ViewExpanders
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|prepare
operator|.
name|RelOptTableImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelDistribution
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelHomogeneousShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Correlate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Intersect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Match
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Minus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RepeatUnion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Snapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Spool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableFunctionScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableSpool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Uncollect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Values
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|hint
operator|.
name|Hintable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|hint
operator|.
name|RelHint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelColumnMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFieldImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCorrelVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSimplify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Hook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|TransientTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|ListTransientTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlCountAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLikeOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlReturnTypeInference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|TableFunctionReturnTypeInference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|SqlToRelConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Holder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableIntList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableNullableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NlsString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Optionality
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSortedMultiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|MonotonicNonNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|UnaryOperator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|StreamSupport
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Nullness
operator|.
name|castNonNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
operator|.
name|UNION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
operator|.
name|RESOURCE
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * Builder for relational expressions.  *  *<p>{@code RelBuilder} does not make possible anything that you could not  * also accomplish by calling the factory methods of the particular relational  * expression. But it makes common tasks more straightforward and concise.  *  *<p>{@code RelBuilder} uses factories to create relational expressions.  * By default, it uses the default factories, which create logical relational  * expressions ({@link LogicalFilter},  * {@link LogicalProject} and so forth).  * But you could override those factories so that, say, {@code filter} creates  * instead a {@code HiveFilter}.  *  *<p>It is not thread-safe.  */
end_comment

begin_class
specifier|public
class|class
name|RelBuilder
block|{
specifier|protected
specifier|final
name|RelOptCluster
name|cluster
decl_stmt|;
specifier|protected
specifier|final
annotation|@
name|Nullable
name|RelOptSchema
name|relOptSchema
decl_stmt|;
specifier|private
specifier|final
name|Deque
argument_list|<
name|Frame
argument_list|>
name|stack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|RexSimplify
name|simplifier
decl_stmt|;
specifier|private
specifier|final
name|Config
name|config
decl_stmt|;
specifier|private
specifier|final
name|RelOptTable
operator|.
name|ViewExpander
name|viewExpander
decl_stmt|;
specifier|private
name|RelFactories
operator|.
name|Struct
name|struct
decl_stmt|;
specifier|protected
name|RelBuilder
parameter_list|(
annotation|@
name|Nullable
name|Context
name|context
parameter_list|,
name|RelOptCluster
name|cluster
parameter_list|,
annotation|@
name|Nullable
name|RelOptSchema
name|relOptSchema
parameter_list|)
block|{
name|this
operator|.
name|cluster
operator|=
name|cluster
expr_stmt|;
name|this
operator|.
name|relOptSchema
operator|=
name|relOptSchema
expr_stmt|;
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
name|context
operator|=
name|Contexts
operator|.
name|EMPTY_CONTEXT
expr_stmt|;
block|}
name|this
operator|.
name|config
operator|=
name|getConfig
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|viewExpander
operator|=
name|getViewExpander
argument_list|(
name|cluster
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|struct
operator|=
name|requireNonNull
argument_list|(
name|RelFactories
operator|.
name|Struct
operator|.
name|fromContext
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexExecutor
name|executor
init|=
name|context
operator|.
name|maybeUnwrap
argument_list|(
name|RexExecutor
operator|.
name|class
argument_list|)
operator|.
name|orElse
argument_list|(
name|Util
operator|.
name|first
argument_list|(
name|cluster
operator|.
name|getPlanner
argument_list|()
operator|.
name|getExecutor
argument_list|()
argument_list|,
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelOptPredicateList
name|predicates
init|=
name|RelOptPredicateList
operator|.
name|EMPTY
decl_stmt|;
name|this
operator|.
name|simplifier
operator|=
operator|new
name|RexSimplify
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|predicates
argument_list|,
name|executor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Derives the view expander    * {@link org.apache.calcite.plan.RelOptTable.ViewExpander}    * to be used for this RelBuilder.    *    *<p>The ViewExpander instance is used for expanding views in the default    * table scan factory {@code RelFactories.TableScanFactoryImpl}.    * You can also define a new table scan factory in the {@code struct}    * to override the whole table scan creation.    *    *<p>The default view expander does not support expanding views.    */
specifier|private
specifier|static
name|RelOptTable
operator|.
name|ViewExpander
name|getViewExpander
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|Context
name|context
parameter_list|)
block|{
return|return
name|context
operator|.
name|maybeUnwrap
argument_list|(
name|RelOptTable
operator|.
name|ViewExpander
operator|.
name|class
argument_list|)
operator|.
name|orElseGet
argument_list|(
parameter_list|()
lambda|->
name|ViewExpanders
operator|.
name|simpleContext
argument_list|(
name|cluster
argument_list|)
argument_list|)
return|;
block|}
comment|/** Derives the Config to be used for this RelBuilder.    *    *<p>Overrides {@link RelBuilder.Config#simplify} if    * {@link Hook#REL_BUILDER_SIMPLIFY} is set.    */
specifier|private
specifier|static
name|Config
name|getConfig
parameter_list|(
name|Context
name|context
parameter_list|)
block|{
specifier|final
name|Config
name|config
init|=
name|context
operator|.
name|maybeUnwrap
argument_list|(
name|Config
operator|.
name|class
argument_list|)
operator|.
name|orElse
argument_list|(
name|Config
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
name|boolean
name|simplify
init|=
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
operator|.
name|get
argument_list|(
name|config
operator|.
name|simplify
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|config
operator|.
name|withSimplify
argument_list|(
name|simplify
argument_list|)
return|;
block|}
comment|/** Creates a RelBuilder. */
specifier|public
specifier|static
name|RelBuilder
name|create
parameter_list|(
name|FrameworkConfig
name|config
parameter_list|)
block|{
return|return
name|Frameworks
operator|.
name|withPrepare
argument_list|(
name|config
argument_list|,
parameter_list|(
name|cluster
parameter_list|,
name|relOptSchema
parameter_list|,
name|rootSchema
parameter_list|,
name|statement
parameter_list|)
lambda|->
operator|new
name|RelBuilder
argument_list|(
name|config
operator|.
name|getContext
argument_list|()
argument_list|,
name|cluster
argument_list|,
name|relOptSchema
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a copy of this RelBuilder, with the same state as this, applying    * a transform to the config. */
specifier|public
name|RelBuilder
name|transform
parameter_list|(
name|UnaryOperator
argument_list|<
name|Config
argument_list|>
name|transform
parameter_list|)
block|{
specifier|final
name|Context
name|context
init|=
name|Contexts
operator|.
name|of
argument_list|(
name|struct
argument_list|,
name|transform
operator|.
name|apply
argument_list|(
name|config
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|RelBuilder
argument_list|(
name|context
argument_list|,
name|cluster
argument_list|,
name|relOptSchema
argument_list|)
return|;
block|}
comment|/** Performs an action on this RelBuilder if a condition is true.    *    *<p>For example, consider the following code:    *    *<blockquote><pre>    *   RelNode filterAndRename(RelBuilder relBuilder, RelNode rel,    *       RexNode condition, List&lt;String&gt; fieldNames) {    *     relBuilder.push(rel)    *         .filter(condition);    *     if (fieldNames != null) {    *       relBuilder.rename(fieldNames);    *     }    *     return relBuilder    *         .build();</pre>    *</blockquote>    *    *<p>The pipeline is disrupted by the 'if'. The {@code let} method    * allows you to perform the flow as a single pipeline:    *    *<blockquote><pre>    *   RelNode filterAndRename(RelBuilder relBuilder, RelNode rel,    *       RexNode condition, List&lt;String&gt; fieldNames) {    *     return relBuilder.push(rel)    *         .filter(condition)    *         .let(r -&gt; fieldNames == null ? r : r.rename(fieldNames))    *         .build();</pre>    *</blockquote>    *    *<p>In pipelined cases such as this one, the lambda must return this    * RelBuilder. But {@code let} return values of other types.    */
specifier|public
parameter_list|<
name|R
parameter_list|>
name|R
name|let
parameter_list|(
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|R
argument_list|>
name|consumer
parameter_list|)
block|{
return|return
name|consumer
operator|.
name|apply
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/** Converts this RelBuilder to a string.    * The string is the string representation of all of the RelNodes on the stack. */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|stack
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|frame
lambda|->
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|frame
operator|.
name|rel
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|""
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns the type factory. */
specifier|public
name|RelDataTypeFactory
name|getTypeFactory
parameter_list|()
block|{
return|return
name|cluster
operator|.
name|getTypeFactory
argument_list|()
return|;
block|}
comment|/** Returns new RelBuilder that adopts the convention provided.    * RelNode will be created with such convention if corresponding factory is provided. */
specifier|public
name|RelBuilder
name|adoptConvention
parameter_list|(
name|Convention
name|convention
parameter_list|)
block|{
name|this
operator|.
name|struct
operator|=
name|convention
operator|.
name|getRelFactories
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns the builder for {@link RexNode} expressions. */
specifier|public
name|RexBuilder
name|getRexBuilder
parameter_list|()
block|{
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
return|;
block|}
comment|/** Creates a {@link RelBuilderFactory}, a partially-created RelBuilder.    * Just add a {@link RelOptCluster} and a {@link RelOptSchema} */
specifier|public
specifier|static
name|RelBuilderFactory
name|proto
parameter_list|(
specifier|final
name|Context
name|context
parameter_list|)
block|{
return|return
parameter_list|(
name|cluster
parameter_list|,
name|schema
parameter_list|)
lambda|->
operator|new
name|RelBuilder
argument_list|(
name|context
argument_list|,
name|cluster
argument_list|,
name|schema
argument_list|)
return|;
block|}
comment|/** Creates a {@link RelBuilderFactory} that uses a given set of factories. */
specifier|public
specifier|static
name|RelBuilderFactory
name|proto
parameter_list|(
name|Object
modifier|...
name|factories
parameter_list|)
block|{
return|return
name|proto
argument_list|(
name|Contexts
operator|.
name|of
argument_list|(
name|factories
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|RelOptCluster
name|getCluster
parameter_list|()
block|{
return|return
name|cluster
return|;
block|}
specifier|public
annotation|@
name|Nullable
name|RelOptSchema
name|getRelOptSchema
parameter_list|()
block|{
return|return
name|relOptSchema
return|;
block|}
specifier|public
name|RelFactories
operator|.
name|TableScanFactory
name|getScanFactory
parameter_list|()
block|{
return|return
name|struct
operator|.
name|scanFactory
return|;
block|}
comment|// Methods for manipulating the stack
comment|/** Adds a relational expression to be the input to the next relational    * expression constructed.    *    *<p>This method is usual when you want to weave in relational expressions    * that are not supported by the builder. If, while creating such expressions,    * you need to use previously built expressions as inputs, call    * {@link #build()} to pop those inputs. */
specifier|public
name|RelBuilder
name|push
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Adds a rel node to the top of the stack while preserving the field names    * and aliases. */
specifier|private
name|void
name|replaceTop
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|node
argument_list|,
name|frame
operator|.
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Pushes a collection of relational expressions. */
specifier|public
name|RelBuilder
name|pushAll
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|nodes
parameter_list|)
block|{
for|for
control|(
name|RelNode
name|node
range|:
name|nodes
control|)
block|{
name|push
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Returns the final relational expression.    *    *<p>Throws if the stack is empty.    */
specifier|public
name|RelNode
name|build
parameter_list|()
block|{
return|return
name|stack
operator|.
name|pop
argument_list|()
operator|.
name|rel
return|;
block|}
comment|/** Returns the relational expression at the top of the stack, but does not    * remove it. */
specifier|public
name|RelNode
name|peek
parameter_list|()
block|{
return|return
name|castNonNull
argument_list|(
name|peek_
argument_list|()
argument_list|)
operator|.
name|rel
return|;
block|}
specifier|private
annotation|@
name|Nullable
name|Frame
name|peek_
parameter_list|()
block|{
return|return
name|stack
operator|.
name|peek
argument_list|()
return|;
block|}
comment|/** Returns the relational expression {@code n} positions from the top of the    * stack, but does not remove it. */
specifier|public
name|RelNode
name|peek
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|peek_
argument_list|(
name|n
argument_list|)
operator|.
name|rel
return|;
block|}
specifier|private
name|Frame
name|peek_
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|get
argument_list|(
name|stack
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Returns the relational expression {@code n} positions from the top of the    * stack, but does not remove it. */
specifier|public
name|RelNode
name|peek
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
return|return
name|peek_
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
operator|.
name|rel
return|;
block|}
specifier|private
name|Frame
name|peek_
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
return|return
name|peek_
argument_list|(
name|inputCount
operator|-
literal|1
operator|-
name|inputOrdinal
argument_list|)
return|;
block|}
comment|/** Returns the number of fields in all inputs before (to the left of)    * the given input.    *    * @param inputCount Number of inputs    * @param inputOrdinal Input ordinal    */
specifier|private
name|int
name|inputOffset
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputOrdinal
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|+=
name|peek
argument_list|(
name|inputCount
argument_list|,
name|i
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
comment|// Methods that return scalar expressions
comment|/** Creates a literal (constant expression). */
specifier|public
name|RexLiteral
name|literal
parameter_list|(
annotation|@
name|Nullable
name|Object
name|value
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|type
argument_list|)
return|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|(
name|Boolean
operator|)
name|value
argument_list|)
return|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|BigDecimal
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|(
name|BigDecimal
operator|)
name|value
argument_list|)
return|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Float
operator|||
name|value
operator|instanceof
name|Double
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeApproxLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
return|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Enum
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|value
argument_list|,
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|SYMBOL
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot convert "
operator|+
name|value
operator|+
literal|" ("
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|+
literal|") to a constant"
argument_list|)
throw|;
block|}
block|}
comment|/** Creates a correlation variable for the current input, and writes it into    * a Holder. */
specifier|public
name|RelBuilder
name|variable
parameter_list|(
name|Holder
argument_list|<
name|RexCorrelVariable
argument_list|>
name|v
parameter_list|)
block|{
name|v
operator|.
name|set
argument_list|(
operator|(
name|RexCorrelVariable
operator|)
name|getRexBuilder
argument_list|()
operator|.
name|makeCorrel
argument_list|(
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|cluster
operator|.
name|createCorrel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a reference to a field by name.    *    *<p>Equivalent to {@code field(1, 0, fieldName)}.    *    * @param fieldName Field name    */
specifier|public
name|RexInputRef
name|field
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|fieldName
argument_list|)
return|;
block|}
comment|/** Creates a reference to a field of given input relational expression    * by name.    *    * @param inputCount Number of inputs    * @param inputOrdinal Input ordinal    * @param fieldName Field name    */
specifier|public
name|RexInputRef
name|field
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|peek_
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|Pair
operator|.
name|left
argument_list|(
name|frame
operator|.
name|fields
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|fieldNames
operator|.
name|indexOf
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
return|return
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|,
name|i
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field ["
operator|+
name|fieldName
operator|+
literal|"] not found; input fields are: "
operator|+
name|fieldNames
argument_list|)
throw|;
block|}
block|}
comment|/** Creates a reference to an input field by ordinal.    *    *<p>Equivalent to {@code field(1, 0, ordinal)}.    *    * @param fieldOrdinal Field ordinal    */
specifier|public
name|RexInputRef
name|field
parameter_list|(
name|int
name|fieldOrdinal
parameter_list|)
block|{
return|return
operator|(
name|RexInputRef
operator|)
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|fieldOrdinal
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Creates a reference to a field of a given input relational expression    * by ordinal.    *    * @param inputCount Number of inputs    * @param inputOrdinal Input ordinal    * @param fieldOrdinal Field ordinal within input    */
specifier|public
name|RexInputRef
name|field
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|,
name|int
name|fieldOrdinal
parameter_list|)
block|{
return|return
operator|(
name|RexInputRef
operator|)
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|,
name|fieldOrdinal
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** As {@link #field(int, int, int)}, but if {@code alias} is true, the method    * may apply an alias to make sure that the field has the same name as in the    * input frame. If no alias is applied the expression is definitely a    * {@link RexInputRef}. */
specifier|private
name|RexNode
name|field
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|,
name|int
name|fieldOrdinal
parameter_list|,
name|boolean
name|alias
parameter_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|peek_
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|frame
operator|.
name|rel
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|input
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldOrdinal
operator|<
literal|0
operator|||
name|fieldOrdinal
operator|>
name|rowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field ordinal ["
operator|+
name|fieldOrdinal
operator|+
literal|"] out of range; input fields are: "
operator|+
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
throw|;
block|}
specifier|final
name|RelDataTypeField
name|field
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|fieldOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|inputOffset
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|ref
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|offset
operator|+
name|fieldOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeField
name|aliasField
init|=
name|frame
operator|.
name|fields
argument_list|()
operator|.
name|get
argument_list|(
name|fieldOrdinal
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alias
operator|||
name|field
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|aliasField
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|ref
return|;
block|}
else|else
block|{
return|return
name|alias
argument_list|(
name|ref
argument_list|,
name|aliasField
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Creates a reference to a field of the current record which originated    * in a relation with a given alias. */
specifier|public
name|RexNode
name|field
parameter_list|(
name|String
name|alias
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|field
argument_list|(
literal|1
argument_list|,
name|alias
argument_list|,
name|fieldName
argument_list|)
return|;
block|}
comment|/** Creates a reference to a field which originated in a relation with the    * given alias. Searches for the relation starting at the top of the    * stack. */
specifier|public
name|RexNode
name|field
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|String
name|alias
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
name|requireNonNull
argument_list|(
name|alias
argument_list|,
literal|"alias"
argument_list|)
expr_stmt|;
name|requireNonNull
argument_list|(
name|fieldName
argument_list|,
literal|"fieldName"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|inputOrdinal
init|=
literal|0
init|;
name|inputOrdinal
operator|<
name|inputCount
condition|;
operator|++
name|inputOrdinal
control|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|peek_
argument_list|(
name|inputOrdinal
argument_list|)
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|Field
argument_list|>
name|p
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|frame
operator|.
name|fields
argument_list|)
control|)
block|{
comment|// If alias and field name match, reference that field.
if|if
condition|(
name|p
operator|.
name|e
operator|.
name|left
operator|.
name|contains
argument_list|(
name|alias
argument_list|)
operator|&&
name|p
operator|.
name|e
operator|.
name|right
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputCount
operator|-
literal|1
operator|-
name|inputOrdinal
argument_list|,
name|p
operator|.
name|i
argument_list|)
return|;
block|}
name|fields
operator|.
name|add
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"{aliases=%s,fieldName=%s}"
argument_list|,
name|p
operator|.
name|e
operator|.
name|left
argument_list|,
name|p
operator|.
name|e
operator|.
name|right
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"{alias="
operator|+
name|alias
operator|+
literal|",fieldName="
operator|+
name|fieldName
operator|+
literal|"} "
operator|+
literal|"field not found; fields are: "
operator|+
name|fields
argument_list|)
throw|;
block|}
comment|/** Returns a reference to a given field of a record-valued expression. */
specifier|public
name|RexNode
name|field
parameter_list|(
name|RexNode
name|e
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|e
argument_list|,
name|name
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Returns references to the fields of the top input. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|()
block|{
return|return
name|fields
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/** Returns references to the fields of a given input. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
specifier|final
name|RelNode
name|input
init|=
name|peek
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|input
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|fieldOrdinal
range|:
name|Util
operator|.
name|range
argument_list|(
name|rowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
control|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|,
name|fieldOrdinal
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|nodes
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns references to fields for a given collation. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|RelCollation
name|collation
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|fieldCollation
range|:
name|collation
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
name|RexNode
name|node
init|=
name|field
argument_list|(
name|fieldCollation
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fieldCollation
operator|.
name|direction
condition|)
block|{
case|case
name|DESCENDING
case|:
name|node
operator|=
name|desc
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|fieldCollation
operator|.
name|nullDirection
condition|)
block|{
case|case
name|FIRST
case|:
name|node
operator|=
name|nullsFirst
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|LAST
case|:
name|node
operator|=
name|nullsLast
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|nodes
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns references to fields for a given list of input ordinals. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Number
argument_list|>
name|ordinals
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Number
name|ordinal
range|:
name|ordinals
control|)
block|{
name|RexNode
name|node
init|=
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|ordinal
operator|.
name|intValue
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|nodes
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns references to fields for a given bit set of input ordinals. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|ImmutableBitSet
name|ordinals
parameter_list|)
block|{
return|return
name|fields
argument_list|(
name|ordinals
operator|.
name|asList
argument_list|()
argument_list|)
return|;
block|}
comment|/** Returns references to fields identified by name. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|fieldName
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns references to fields identified by a mapping. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|)
block|{
return|return
name|fields
argument_list|(
name|Mappings
operator|.
name|asListNonNull
argument_list|(
name|mapping
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an access to a field by name. */
specifier|public
name|RexNode
name|dot
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|builder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
return|return
name|builder
operator|.
name|makeFieldAccess
argument_list|(
name|node
argument_list|,
name|fieldName
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Creates an access to a field by ordinal. */
specifier|public
name|RexNode
name|dot
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|int
name|fieldOrdinal
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|builder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
return|return
name|builder
operator|.
name|makeFieldAccess
argument_list|(
name|node
argument_list|,
name|fieldOrdinal
argument_list|)
return|;
block|}
comment|/** Creates a call to a scalar operator. */
specifier|public
name|RexNode
name|call
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|operator
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to a scalar operator. */
specifier|private
name|RexCall
name|call
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|operandList
parameter_list|)
block|{
switch|switch
condition|(
name|operator
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LIKE
case|:
case|case
name|SIMILAR
case|:
specifier|final
name|SqlLikeOperator
name|likeOperator
init|=
operator|(
name|SqlLikeOperator
operator|)
name|operator
decl_stmt|;
if|if
condition|(
name|likeOperator
operator|.
name|isNegated
argument_list|()
condition|)
block|{
specifier|final
name|SqlOperator
name|notLikeOperator
init|=
name|likeOperator
operator|.
name|not
argument_list|()
decl_stmt|;
return|return
operator|(
name|RexCall
operator|)
name|not
argument_list|(
name|call
argument_list|(
name|notLikeOperator
argument_list|,
name|operandList
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|BETWEEN
case|:
assert|assert
name|operandList
operator|.
name|size
argument_list|()
operator|==
literal|3
assert|;
return|return
operator|(
name|RexCall
operator|)
name|between
argument_list|(
name|operandList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|operandList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|operandList
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
specifier|final
name|RexBuilder
name|builder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|builder
operator|.
name|deriveReturnType
argument_list|(
name|operator
argument_list|,
name|operandList
argument_list|)
decl_stmt|;
return|return
operator|(
name|RexCall
operator|)
name|builder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|operator
argument_list|,
name|operandList
argument_list|)
return|;
block|}
comment|/** Creates a call to a scalar operator. */
specifier|public
name|RexNode
name|call
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|operator
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an IN. */
specifier|public
name|RexNode
name|in
parameter_list|(
name|RexNode
name|arg
parameter_list|,
name|RexNode
modifier|...
name|ranges
parameter_list|)
block|{
return|return
name|in
argument_list|(
name|arg
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|ranges
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an IN. */
specifier|public
name|RexNode
name|in
parameter_list|(
name|RexNode
name|arg
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|ranges
parameter_list|)
block|{
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeIn
argument_list|(
name|arg
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|ranges
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an AND. */
specifier|public
name|RexNode
name|and
parameter_list|(
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|and
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an AND.    *    *<p>Simplifies the expression a little:    * {@code e AND TRUE} becomes {@code e};    * {@code e AND e2 AND NOT e} becomes {@code e2}. */
specifier|public
name|RexNode
name|and
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|getRexBuilder
argument_list|()
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|/** Creates an OR. */
specifier|public
name|RexNode
name|or
parameter_list|(
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|or
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an OR. */
specifier|public
name|RexNode
name|or
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|RexUtil
operator|.
name|composeDisjunction
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|/** Creates a NOT. */
specifier|public
name|RexNode
name|not
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates an {@code =}. */
specifier|public
name|RexNode
name|equals
parameter_list|(
name|RexNode
name|operand0
parameter_list|,
name|RexNode
name|operand1
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
return|;
block|}
comment|/** Creates a {@code<>}. */
specifier|public
name|RexNode
name|notEquals
parameter_list|(
name|RexNode
name|operand0
parameter_list|,
name|RexNode
name|operand1
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
return|;
block|}
comment|/** Creates a {@code BETWEEN}. */
specifier|public
name|RexNode
name|between
parameter_list|(
name|RexNode
name|arg
parameter_list|,
name|RexNode
name|lower
parameter_list|,
name|RexNode
name|upper
parameter_list|)
block|{
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeBetween
argument_list|(
name|arg
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|)
return|;
block|}
comment|/** Creates a IS NULL. */
specifier|public
name|RexNode
name|isNull
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates a IS NOT NULL. */
specifier|public
name|RexNode
name|isNotNull
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates an expression that casts an expression to a given type. */
specifier|public
name|RexNode
name|cast
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
comment|/** Creates an expression that casts an expression to a type with a given name    * and precision or length. */
specifier|public
name|RexNode
name|cast
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|,
name|precision
argument_list|)
decl_stmt|;
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
comment|/** Creates an expression that casts an expression to a type with a given    * name, precision and scale. */
specifier|public
name|RexNode
name|cast
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|int
name|precision
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|,
name|precision
argument_list|,
name|scale
argument_list|)
decl_stmt|;
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
comment|/**    * Returns an expression wrapped in an alias.    *    *<p>This method is idempotent: If the expression is already wrapped in the    * correct alias, does nothing; if wrapped in an incorrect alias, removes    * the incorrect alias and applies the correct alias.    *    * @see #project    */
specifier|public
name|RexNode
name|alias
parameter_list|(
name|RexNode
name|expr
parameter_list|,
annotation|@
name|Nullable
name|String
name|alias
parameter_list|)
block|{
specifier|final
name|RexNode
name|aliasLiteral
init|=
name|literal
argument_list|(
name|alias
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|expr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|expr
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|equals
argument_list|(
name|aliasLiteral
argument_list|)
condition|)
block|{
comment|// current alias is correct
return|return
name|expr
return|;
block|}
name|expr
operator|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// strip current (incorrect) alias, and fall through
default|default:
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AS
argument_list|,
name|expr
argument_list|,
name|aliasLiteral
argument_list|)
return|;
block|}
block|}
comment|/** Converts a sort expression to descending. */
specifier|public
name|RexNode
name|desc
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DESC
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/** Converts a sort expression to nulls last. */
specifier|public
name|RexNode
name|nullsLast
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NULLS_LAST
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/** Converts a sort expression to nulls first. */
specifier|public
name|RexNode
name|nullsFirst
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NULLS_FIRST
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|// Methods that create group keys and aggregate calls
comment|/** Creates an empty group key. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|()
block|{
return|return
name|groupKey
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a group key. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|groupKey
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a group key. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
operator|new
name|GroupKeyImpl
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Creates a group key with grouping sets. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
parameter_list|)
block|{
return|return
name|groupKey_
argument_list|(
name|nodes
argument_list|,
name|nodeLists
argument_list|)
return|;
block|}
comment|// CHECKSTYLE: IGNORE 1
comment|/** @deprecated Now that indicator is deprecated, use    * {@link #groupKey(Iterable, Iterable)}, which has the same behavior as    * calling this method with {@code indicator = false}. */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|boolean
name|indicator
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
parameter_list|)
block|{
name|Aggregate
operator|.
name|checkIndicator
argument_list|(
name|indicator
argument_list|)
expr_stmt|;
return|return
name|groupKey_
argument_list|(
name|nodes
argument_list|,
name|nodeLists
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|GroupKey
name|groupKey_
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodeList
range|:
name|nodeLists
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodeList
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|GroupKeyImpl
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Creates a group key of fields identified by ordinal. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|int
modifier|...
name|fieldOrdinals
parameter_list|)
block|{
return|return
name|groupKey
argument_list|(
name|fields
argument_list|(
name|ImmutableIntList
operator|.
name|of
argument_list|(
name|fieldOrdinals
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a group key of fields identified by name. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|String
modifier|...
name|fieldNames
parameter_list|)
block|{
return|return
name|groupKey
argument_list|(
name|fields
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|fieldNames
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a group key, identified by field positions    * in the underlying relational expression.    *    *<p>This method of creating a group key does not allow you to group on new    * expressions, only column projections, but is efficient, especially when you    * are coming from an existing {@link Aggregate}. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|)
block|{
return|return
name|groupKey_
argument_list|(
name|groupSet
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupSet
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a group key with grouping sets, both identified by field positions    * in the underlying relational expression.    *    *<p>This method of creating a group key does not allow you to group on new    * expressions, only column projections, but is efficient, especially when you    * are coming from an existing {@link Aggregate}. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|ImmutableBitSet
argument_list|>
name|groupSets
parameter_list|)
block|{
return|return
name|groupKey_
argument_list|(
name|groupSet
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|groupSets
argument_list|)
argument_list|)
return|;
block|}
comment|// CHECKSTYLE: IGNORE 1
comment|/** @deprecated Use {@link #groupKey(ImmutableBitSet)}    * or {@link #groupKey(ImmutableBitSet, Iterable)}. */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
annotation|@
name|Nullable
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
parameter_list|)
block|{
return|return
name|groupKey_
argument_list|(
name|groupSet
argument_list|,
name|groupSets
operator|==
literal|null
condition|?
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupSet
argument_list|)
else|:
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|groupSets
argument_list|)
argument_list|)
return|;
block|}
comment|// CHECKSTYLE: IGNORE 1
comment|/** @deprecated Use {@link #groupKey(ImmutableBitSet, Iterable)}. */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|boolean
name|indicator
parameter_list|,
annotation|@
name|Nullable
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
parameter_list|)
block|{
name|Aggregate
operator|.
name|checkIndicator
argument_list|(
name|indicator
argument_list|)
expr_stmt|;
return|return
name|groupKey_
argument_list|(
name|groupSet
argument_list|,
name|groupSets
operator|==
literal|null
condition|?
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupSet
argument_list|)
else|:
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|groupSets
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|GroupKey
name|groupKey_
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
parameter_list|)
block|{
if|if
condition|(
name|groupSet
operator|.
name|length
argument_list|()
operator|>
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"out of bounds: "
operator|+
name|groupSet
argument_list|)
throw|;
block|}
name|requireNonNull
argument_list|(
name|groupSets
argument_list|,
literal|"groupSets"
argument_list|)
expr_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|fields
argument_list|(
name|groupSet
argument_list|)
decl_stmt|;
return|return
name|groupKey_
argument_list|(
name|nodes
argument_list|,
name|Util
operator|.
name|transform
argument_list|(
name|groupSets
argument_list|,
name|this
operator|::
name|fields
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|RexNode
name|filter
parameter_list|,
annotation|@
name|Nullable
name|String
name|alias
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|filter
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|boolean
name|approximate
parameter_list|,
name|RexNode
name|filter
parameter_list|,
annotation|@
name|Nullable
name|String
name|alias
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
literal|false
argument_list|,
name|filter
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|RexNode
name|filter
parameter_list|,
annotation|@
name|Nullable
name|String
name|alias
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|filter
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|boolean
name|approximate
parameter_list|,
name|RexNode
name|filter
parameter_list|,
annotation|@
name|Nullable
name|String
name|alias
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
literal|false
argument_list|,
name|filter
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to an aggregate function.    *    *<p>To add other operands, apply    * {@link AggCall#distinct()},    * {@link AggCall#approximate(boolean)},    * {@link AggCall#filter(RexNode...)},    * {@link AggCall#sort},    * {@link AggCall#as} to the result. */
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|aggFunction
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to an aggregate function.    *    *<p>To add other operands, apply    * {@link AggCall#distinct()},    * {@link AggCall#approximate(boolean)},    * {@link AggCall#filter(RexNode...)},    * {@link AggCall#sort},    * {@link AggCall#as} to the result. */
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|aggFunction
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to an aggregate function as a copy of an    * {@link AggregateCall}. */
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|AggregateCall
name|a
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|a
operator|.
name|getAggregation
argument_list|()
argument_list|,
name|a
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|a
operator|.
name|isApproximate
argument_list|()
argument_list|,
name|a
operator|.
name|ignoreNulls
argument_list|()
argument_list|,
name|a
operator|.
name|filterArg
operator|<
literal|0
condition|?
literal|null
else|:
name|field
argument_list|(
name|a
operator|.
name|filterArg
argument_list|)
argument_list|,
name|fields
argument_list|(
name|a
operator|.
name|collation
argument_list|)
argument_list|,
name|a
operator|.
name|name
argument_list|,
name|fields
argument_list|(
name|a
operator|.
name|getArgList
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to an aggregate function as a copy of an    * {@link AggregateCall}, applying a mapping. */
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|AggregateCall
name|a
parameter_list|,
name|Mapping
name|mapping
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|a
operator|.
name|getAggregation
argument_list|()
argument_list|,
name|a
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|a
operator|.
name|isApproximate
argument_list|()
argument_list|,
name|a
operator|.
name|ignoreNulls
argument_list|()
argument_list|,
name|a
operator|.
name|filterArg
operator|<
literal|0
condition|?
literal|null
else|:
name|field
argument_list|(
name|Mappings
operator|.
name|apply
argument_list|(
name|mapping
argument_list|,
name|a
operator|.
name|filterArg
argument_list|)
argument_list|)
argument_list|,
name|fields
argument_list|(
name|RexUtil
operator|.
name|apply
argument_list|(
name|mapping
argument_list|,
name|a
operator|.
name|collation
argument_list|)
argument_list|)
argument_list|,
name|a
operator|.
name|name
argument_list|,
name|fields
argument_list|(
name|Mappings
operator|.
name|apply2
argument_list|(
name|mapping
argument_list|,
name|a
operator|.
name|getArgList
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to an aggregate function with all applicable operands. */
specifier|protected
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|boolean
name|approximate
parameter_list|,
name|boolean
name|ignoreNulls
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|filter
parameter_list|,
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|orderKeys
parameter_list|,
annotation|@
name|Nullable
name|String
name|alias
parameter_list|,
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
operator|new
name|AggCallImpl
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
name|ignoreNulls
argument_list|,
name|filter
argument_list|,
name|alias
argument_list|,
name|operands
argument_list|,
name|orderKeys
argument_list|)
return|;
block|}
comment|/** Creates a call to the {@code COUNT} aggregate function. */
specifier|public
name|AggCall
name|count
parameter_list|(
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|count
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|/** Creates a call to the {@code COUNT} aggregate function. */
specifier|public
name|AggCall
name|count
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|count
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|/** Creates a call to the {@code COUNT} aggregate function,    * optionally distinct and with an alias. */
specifier|public
name|AggCall
name|count
parameter_list|(
name|boolean
name|distinct
parameter_list|,
annotation|@
name|Nullable
name|String
name|alias
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
name|distinct
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to the {@code COUNT} aggregate function,    * optionally distinct and with an alias. */
specifier|public
name|AggCall
name|count
parameter_list|(
name|boolean
name|distinct
parameter_list|,
annotation|@
name|Nullable
name|String
name|alias
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
name|distinct
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to the {@code COUNT(*)} aggregate function. */
specifier|public
name|AggCall
name|countStar
parameter_list|(
annotation|@
name|Nullable
name|String
name|alias
parameter_list|)
block|{
return|return
name|count
argument_list|(
literal|false
argument_list|,
name|alias
argument_list|)
return|;
block|}
comment|/** Creates a call to the {@code SUM} aggregate function. */
specifier|public
name|AggCall
name|sum
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|sum
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates a call to the {@code SUM} aggregate function,    * optionally distinct and with an alias. */
specifier|public
name|AggCall
name|sum
parameter_list|(
name|boolean
name|distinct
parameter_list|,
annotation|@
name|Nullable
name|String
name|alias
parameter_list|,
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUM
argument_list|,
name|distinct
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|operand
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to the {@code AVG} aggregate function. */
specifier|public
name|AggCall
name|avg
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|avg
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates a call to the {@code AVG} aggregate function,    * optionally distinct and with an alias. */
specifier|public
name|AggCall
name|avg
parameter_list|(
name|boolean
name|distinct
parameter_list|,
annotation|@
name|Nullable
name|String
name|alias
parameter_list|,
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AVG
argument_list|,
name|distinct
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|operand
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to the {@code MIN} aggregate function. */
specifier|public
name|AggCall
name|min
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|min
argument_list|(
literal|null
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates a call to the {@code MIN} aggregate function,    * optionally with an alias. */
specifier|public
name|AggCall
name|min
parameter_list|(
annotation|@
name|Nullable
name|String
name|alias
parameter_list|,
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MIN
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|operand
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to the {@code MAX} aggregate function,    * optionally with an alias. */
specifier|public
name|AggCall
name|max
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|max
argument_list|(
literal|null
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates a call to the {@code MAX} aggregate function. */
specifier|public
name|AggCall
name|max
parameter_list|(
annotation|@
name|Nullable
name|String
name|alias
parameter_list|,
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MAX
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|operand
argument_list|)
argument_list|)
return|;
block|}
comment|// Methods for patterns
comment|/**    * Creates a reference to a given field of the pattern.    *    * @param alpha the pattern name    * @param type Type of field    * @param i Ordinal of field    * @return Reference to field of pattern    */
specifier|public
name|RexNode
name|patternField
parameter_list|(
name|String
name|alpha
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makePatternFieldRef
argument_list|(
name|alpha
argument_list|,
name|type
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/** Creates a call that concatenates patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternConcat
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
comment|// Convert into binary calls
return|return
name|patternConcat
argument_list|(
name|patternConcat
argument_list|(
name|Util
operator|.
name|skipLast
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|list
argument_list|)
argument_list|)
return|;
block|}
specifier|final
name|RelDataType
name|t
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
decl_stmt|;
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|t
argument_list|,
name|SqlStdOperatorTable
operator|.
name|PATTERN_CONCAT
argument_list|,
name|list
argument_list|)
return|;
block|}
comment|/** Creates a call that concatenates patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternConcat
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|patternConcat
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates alternate patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternAlter
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|RelDataType
name|t
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
decl_stmt|;
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|t
argument_list|,
name|SqlStdOperatorTable
operator|.
name|PATTERN_ALTER
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates alternate patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternAlter
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|patternAlter
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates quantify patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternQuantify
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|RelDataType
name|t
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
decl_stmt|;
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|t
argument_list|,
name|SqlStdOperatorTable
operator|.
name|PATTERN_QUANTIFIER
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates quantify patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternQuantify
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|patternQuantify
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates permute patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternPermute
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|RelDataType
name|t
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
decl_stmt|;
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|t
argument_list|,
name|SqlStdOperatorTable
operator|.
name|PATTERN_PERMUTE
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates permute patterns;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternPermute
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|patternPermute
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call that creates an exclude pattern;    * for use in {@link #match}. */
specifier|public
name|RexNode
name|patternExclude
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
specifier|final
name|RelDataType
name|t
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
decl_stmt|;
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|t
argument_list|,
name|SqlStdOperatorTable
operator|.
name|PATTERN_EXCLUDE
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|node
argument_list|)
argument_list|)
return|;
block|}
comment|// Methods that create relational expressions
comment|/** Creates a {@link TableScan} of the table    * with a given name.    *    *<p>Throws if the table does not exist.    *    *<p>Returns this builder.    *    * @param tableNames Name of table (can optionally be qualified)    */
specifier|public
name|RelBuilder
name|scan
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|tableNames
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tableNames
argument_list|)
decl_stmt|;
name|requireNonNull
argument_list|(
name|relOptSchema
argument_list|,
literal|"relOptSchema"
argument_list|)
expr_stmt|;
specifier|final
name|RelOptTable
name|relOptTable
init|=
name|relOptSchema
operator|.
name|getTableForMember
argument_list|(
name|names
argument_list|)
decl_stmt|;
if|if
condition|(
name|relOptTable
operator|==
literal|null
condition|)
block|{
throw|throw
name|RESOURCE
operator|.
name|tableNotFound
argument_list|(
name|String
operator|.
name|join
argument_list|(
literal|"."
argument_list|,
name|names
argument_list|)
argument_list|)
operator|.
name|ex
argument_list|()
throw|;
block|}
specifier|final
name|RelNode
name|scan
init|=
name|struct
operator|.
name|scanFactory
operator|.
name|createScan
argument_list|(
name|ViewExpanders
operator|.
name|toRelContext
argument_list|(
name|viewExpander
argument_list|,
name|cluster
argument_list|)
argument_list|,
name|relOptTable
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|relOptTable
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// When the node is not a TableScan but from expansion,
comment|// we need to explicitly add the alias.
if|if
condition|(
operator|!
operator|(
name|scan
operator|instanceof
name|TableScan
operator|)
condition|)
block|{
name|as
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tableNames
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Creates a {@link TableScan} of the table    * with a given name.    *    *<p>Throws if the table does not exist.    *    *<p>Returns this builder.    *    * @param tableNames Name of table (can optionally be qualified)    */
specifier|public
name|RelBuilder
name|scan
parameter_list|(
name|String
modifier|...
name|tableNames
parameter_list|)
block|{
return|return
name|scan
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tableNames
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Snapshot} of a given snapshot period.    *    *<p>Returns this builder.    *    * @param period Name of table (can optionally be qualified)    */
specifier|public
name|RelBuilder
name|snapshot
parameter_list|(
name|RexNode
name|period
parameter_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|snapshot
init|=
name|struct
operator|.
name|snapshotFactory
operator|.
name|createSnapshot
argument_list|(
name|frame
operator|.
name|rel
argument_list|,
name|period
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|snapshot
argument_list|,
name|frame
operator|.
name|fields
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Gets column mappings of the operator.    *    * @param op operator instance    * @return column mappings associated with this function    */
specifier|private
specifier|static
annotation|@
name|Nullable
name|Set
argument_list|<
name|RelColumnMapping
argument_list|>
name|getColumnMappings
parameter_list|(
name|SqlOperator
name|op
parameter_list|)
block|{
name|SqlReturnTypeInference
name|inference
init|=
name|op
operator|.
name|getReturnTypeInference
argument_list|()
decl_stmt|;
if|if
condition|(
name|inference
operator|instanceof
name|TableFunctionReturnTypeInference
condition|)
block|{
return|return
operator|(
operator|(
name|TableFunctionReturnTypeInference
operator|)
name|inference
operator|)
operator|.
name|getColumnMappings
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Creates a RexCall to the {@code CURSOR} function by ordinal.    *    * @param inputCount Number of inputs    * @param ordinal The reference to the relational input    * @return RexCall to CURSOR function    */
specifier|public
name|RexNode
name|cursor
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
if|if
condition|(
name|inputCount
operator|<=
name|ordinal
operator|||
name|ordinal
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"bad input count or ordinal"
argument_list|)
throw|;
block|}
comment|// Refer to the "ordinal"th input as if it were a field
comment|// (because that's how things are laid out inside a TableFunctionScan)
specifier|final
name|RelNode
name|input
init|=
name|peek
argument_list|(
name|inputCount
argument_list|,
name|ordinal
argument_list|)
decl_stmt|;
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CURSOR
argument_list|,
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|input
operator|.
name|getRowType
argument_list|()
argument_list|,
name|ordinal
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link TableFunctionScan}. */
specifier|public
name|RelBuilder
name|functionScan
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|int
name|inputCount
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|functionScan
argument_list|(
name|operator
argument_list|,
name|inputCount
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link TableFunctionScan}. */
specifier|public
name|RelBuilder
name|functionScan
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|int
name|inputCount
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
if|if
condition|(
name|inputCount
operator|<
literal|0
operator|||
name|inputCount
operator|>
name|stack
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"bad input count"
argument_list|)
throw|;
block|}
comment|// Gets inputs.
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputCount
condition|;
name|i
operator|++
control|)
block|{
name|inputs
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RexCall
name|call
init|=
name|call
argument_list|(
name|operator
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|functionScan
init|=
name|struct
operator|.
name|tableFunctionScanFactory
operator|.
name|createTableFunctionScan
argument_list|(
name|cluster
argument_list|,
name|inputs
argument_list|,
name|call
argument_list|,
literal|null
argument_list|,
name|getColumnMappings
argument_list|(
name|operator
argument_list|)
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|functionScan
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link Filter} of an array of    * predicates.    *    *<p>The predicates are combined using AND,    * and optimized in a similar way to the {@link #and} method.    * If the result is TRUE no filter is created. */
specifier|public
name|RelBuilder
name|filter
parameter_list|(
name|RexNode
modifier|...
name|predicates
parameter_list|)
block|{
return|return
name|filter
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|predicates
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Filter} of a list of    * predicates.    *    *<p>The predicates are combined using AND,    * and optimized in a similar way to the {@link #and} method.    * If the result is TRUE no filter is created. */
specifier|public
name|RelBuilder
name|filter
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|predicates
parameter_list|)
block|{
return|return
name|filter
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|predicates
argument_list|)
return|;
block|}
comment|/** Creates a {@link Filter} of a list of correlation variables    * and an array of predicates.    *    *<p>The predicates are combined using AND,    * and optimized in a similar way to the {@link #and} method.    * If the result is TRUE no filter is created. */
specifier|public
name|RelBuilder
name|filter
parameter_list|(
name|Iterable
argument_list|<
name|CorrelationId
argument_list|>
name|variablesSet
parameter_list|,
name|RexNode
modifier|...
name|predicates
parameter_list|)
block|{
return|return
name|filter
argument_list|(
name|variablesSet
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|predicates
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link Filter} of a list of correlation variables    * and a list of predicates.    *    *<p>The predicates are combined using AND,    * and optimized in a similar way to the {@link #and} method.    * If the result is TRUE no filter is created. */
specifier|public
name|RelBuilder
name|filter
parameter_list|(
name|Iterable
argument_list|<
name|CorrelationId
argument_list|>
name|variablesSet
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|predicates
parameter_list|)
block|{
specifier|final
name|RexNode
name|simplifiedPredicates
init|=
name|simplifier
operator|.
name|simplifyFilterPredicates
argument_list|(
name|predicates
argument_list|)
decl_stmt|;
if|if
condition|(
name|simplifiedPredicates
operator|==
literal|null
condition|)
block|{
return|return
name|empty
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|simplifiedPredicates
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|filter
init|=
name|struct
operator|.
name|filterFactory
operator|.
name|createFilter
argument_list|(
name|frame
operator|.
name|rel
argument_list|,
name|simplifiedPredicates
argument_list|,
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|variablesSet
argument_list|)
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|filter
argument_list|,
name|frame
operator|.
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Creates a {@link Project} of the given    * expressions. */
specifier|public
name|RelBuilder
name|project
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|project
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Project} of the given list    * of expressions.    *    *<p>Infers names as would {@link #project(Iterable, Iterable)} if all    * suggested names were null.    *    * @param nodes Expressions    */
specifier|public
name|RelBuilder
name|project
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|project
argument_list|(
name|nodes
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a {@link Project} of the given list    * of expressions and field names.    *    * @param nodes Expressions    * @param fieldNames field names for expressions    */
specifier|public
name|RelBuilder
name|project
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
argument_list|,
name|Iterable
operator|<
condition|?
then|extends @
name|Nullable
name|String
operator|>
name|fieldNames
argument_list|)
block|{
return|return
name|project
argument_list|(
name|nodes
argument_list|,
name|fieldNames
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Creates a {@link Project} of the given list    * of expressions, using the given names.    *    *<p>Names are deduced as follows:    *<ul>    *<li>If the length of {@code fieldNames} is greater than the index of    *     the current entry in {@code nodes}, and the entry in    *     {@code fieldNames} is not null, uses it; otherwise    *<li>If an expression projects an input field,    *     or is a cast an input field,    *     uses the input field name; otherwise    *<li>If an expression is a call to    *     {@link SqlStdOperatorTable#AS}    *     (see {@link #alias}), removes the call but uses the intended alias.    *</ul>    *    *<p>After the field names have been inferred, makes the    * field names unique by appending numeric suffixes.    *    * @param nodes Expressions    * @param fieldNames Suggested field names    * @param force create project even if it is identity    */
specifier|public
name|RelBuilder
name|project
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
argument_list|,
name|Iterable
operator|<
condition|?
then|extends @
name|Nullable
name|String
operator|>
name|fieldNames
argument_list|,
name|boolean
name|force
argument_list|)
block|{
return|return
name|project_
argument_list|(
name|nodes
argument_list|,
name|fieldNames
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|force
argument_list|)
return|;
block|}
comment|/** Creates a {@link Project} of all original fields, plus the given    * expressions. */
specifier|public
name|RelBuilder
name|projectPlus
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|projectPlus
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Project} of all original fields, plus the given list of    * expressions. */
specifier|public
name|RelBuilder
name|projectPlus
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|project
argument_list|(
name|Iterables
operator|.
name|concat
argument_list|(
name|fields
argument_list|()
argument_list|,
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Project} of all original fields, except the given    * expressions.    *    * @throws IllegalArgumentException if the given expressions contain duplicates    *    or there is an expression that does not match an existing field    */
specifier|public
name|RelBuilder
name|projectExcept
parameter_list|(
name|RexNode
modifier|...
name|expressions
parameter_list|)
block|{
return|return
name|projectExcept
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|expressions
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Project} of all original fields, except the given list of    * expressions.    *    * @throws IllegalArgumentException if the given expressions contain duplicates    *    or there is an expression that does not match an existing field    */
specifier|public
name|RelBuilder
name|projectExcept
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|expressions
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|allExpressions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fields
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|RexNode
argument_list|>
name|excludeExpressions
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|excludeExp
range|:
name|expressions
control|)
block|{
if|if
condition|(
operator|!
name|excludeExpressions
operator|.
name|add
argument_list|(
name|excludeExp
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Input list contains duplicates. Expression "
operator|+
name|excludeExp
operator|+
literal|" exists multiple times."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|allExpressions
operator|.
name|remove
argument_list|(
name|excludeExp
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expression "
operator|+
name|excludeExp
operator|.
name|toString
argument_list|()
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
block|}
return|return
name|this
operator|.
name|project
argument_list|(
name|allExpressions
argument_list|)
return|;
block|}
comment|/** Creates a {@link Project} of the given list    * of expressions, using the given names.    *    *<p>Names are deduced as follows:    *<ul>    *<li>If the length of {@code fieldNames} is greater than the index of    *     the current entry in {@code nodes}, and the entry in    *     {@code fieldNames} is not null, uses it; otherwise    *<li>If an expression projects an input field,    *     or is a cast an input field,    *     uses the input field name; otherwise    *<li>If an expression is a call to    *     {@link SqlStdOperatorTable#AS}    *     (see {@link #alias}), removes the call but uses the intended alias.    *</ul>    *    *<p>After the field names have been inferred, makes the    * field names unique by appending numeric suffixes.    *    * @param nodes Expressions    * @param fieldNames Suggested field names    * @param hints Hints    * @param force create project even if it is identity    */
specifier|private
name|RelBuilder
name|project_
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
argument_list|,
name|Iterable
operator|<
condition|?
then|extends @
name|Nullable
name|String
operator|>
name|fieldNames
argument_list|,
name|Iterable
argument_list|<
name|RelHint
argument_list|>
name|hints
argument_list|,
name|boolean
name|force
argument_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|requireNonNull
argument_list|(
name|peek_
argument_list|()
argument_list|,
literal|"frame stack is empty"
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|inputRowType
init|=
name|frame
operator|.
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodeList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
comment|// Perform a quick check for identity. We'll do a deeper check
comment|// later when we've derived column names.
if|if
condition|(
operator|!
name|force
operator|&&
name|Iterables
operator|.
name|isEmpty
argument_list|(
name|fieldNames
argument_list|)
operator|&&
name|RexUtil
operator|.
name|isIdentity
argument_list|(
name|nodeList
argument_list|,
name|inputRowType
argument_list|)
condition|)
block|{
return|return
name|this
return|;
block|}
specifier|final
name|List
argument_list|<
annotation|@
name|Nullable
name|String
argument_list|>
name|fieldNameList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|fieldNames
argument_list|)
decl_stmt|;
while|while
condition|(
name|fieldNameList
operator|.
name|size
argument_list|()
operator|<
name|nodeList
operator|.
name|size
argument_list|()
condition|)
block|{
name|fieldNameList
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|bloat
label|:
if|if
condition|(
name|frame
operator|.
name|rel
operator|instanceof
name|Project
operator|&&
name|config
operator|.
name|bloat
argument_list|()
operator|>=
literal|0
condition|)
block|{
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|frame
operator|.
name|rel
decl_stmt|;
comment|// Populate field names. If the upper expression is an input ref and does
comment|// not have a recommended name, use the name of the underlying field.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldNameList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fieldNameList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
condition|)
block|{
specifier|final
name|RexNode
name|node
init|=
name|nodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|RexInputRef
condition|)
block|{
specifier|final
name|RexInputRef
name|ref
init|=
operator|(
name|RexInputRef
operator|)
name|node
decl_stmt|;
name|fieldNameList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|project
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newNodes
init|=
name|RelOptUtil
operator|.
name|pushPastProjectUnlessBloat
argument_list|(
name|nodeList
argument_list|,
name|project
argument_list|,
name|config
operator|.
name|bloat
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newNodes
operator|==
literal|null
condition|)
block|{
comment|// The merged expression is more complex than the input expressions.
comment|// Do not merge.
break|break
name|bloat
break|;
block|}
comment|// Carefully build a list of fields, so that table aliases from the input
comment|// can be seen for fields that are based on a RexInputRef.
specifier|final
name|Frame
name|frame1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Field
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|f
range|:
name|project
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|fields
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|Field
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
name|frame1
operator|.
name|fields
argument_list|)
control|)
block|{
switch|switch
condition|(
name|pair
operator|.
name|left
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|INPUT_REF
case|:
specifier|final
name|int
name|i
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|pair
operator|.
name|left
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
specifier|final
name|Field
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableSet
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|pair
operator|.
name|right
operator|.
name|left
decl_stmt|;
name|fields
operator|.
name|set
argument_list|(
name|i
argument_list|,
operator|new
name|Field
argument_list|(
name|aliases
argument_list|,
name|field
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|project
operator|.
name|getInput
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|RelHint
argument_list|>
name|mergedHints
init|=
name|ImmutableSet
operator|.
name|builder
argument_list|()
decl_stmt|;
name|mergedHints
operator|.
name|addAll
argument_list|(
name|project
operator|.
name|getHints
argument_list|()
argument_list|)
expr_stmt|;
name|mergedHints
operator|.
name|addAll
argument_list|(
name|hints
argument_list|)
expr_stmt|;
return|return
name|project_
argument_list|(
name|newNodes
argument_list|,
name|fieldNameList
argument_list|,
name|mergedHints
operator|.
name|build
argument_list|()
argument_list|,
name|force
argument_list|)
return|;
block|}
comment|// Simplify expressions.
if|if
condition|(
name|config
operator|.
name|simplify
argument_list|()
condition|)
block|{
specifier|final
name|RexShuttle
name|shuttle
init|=
name|RexUtil
operator|.
name|searchShuttle
argument_list|(
name|getRexBuilder
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexNode
name|node0
init|=
name|nodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|node1
init|=
name|simplifier
operator|.
name|simplifyPreservingType
argument_list|(
name|node0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|node2
init|=
name|node1
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
name|nodeList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|node2
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Replace null names with generated aliases.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldNameList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fieldNameList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
condition|)
block|{
name|fieldNameList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|inferAlias
argument_list|(
name|nodeList
argument_list|,
name|nodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Field
argument_list|>
name|fields
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|uniqueNameList
init|=
name|getTypeFactory
argument_list|()
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|isSchemaCaseSensitive
argument_list|()
condition|?
operator|new
name|HashSet
argument_list|<>
argument_list|()
else|:
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|String
operator|.
name|CASE_INSENSITIVE_ORDER
argument_list|)
decl_stmt|;
comment|// calculate final names and build field list
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldNameList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|RexNode
name|node
init|=
name|nodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|fieldNameList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|originalName
init|=
name|name
decl_stmt|;
name|Field
name|field
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|uniqueNameList
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
block|}
do|do
block|{
name|name
operator|=
name|SqlValidatorUtil
operator|.
name|F_SUGGESTER
operator|.
name|apply
argument_list|(
name|originalName
argument_list|,
name|j
argument_list|,
name|j
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|uniqueNameList
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
do|;
name|fieldNameList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|RelDataTypeField
name|fieldType
init|=
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|name
argument_list|,
name|i
argument_list|,
name|node
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|INPUT_REF
case|:
comment|// preserve rel aliases for INPUT_REF fields
specifier|final
name|int
name|index
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|field
operator|=
operator|new
name|Field
argument_list|(
name|frame
operator|.
name|fields
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|left
argument_list|,
name|fieldType
argument_list|)
expr_stmt|;
break|break;
default|default:
name|field
operator|=
operator|new
name|Field
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|fieldType
argument_list|)
expr_stmt|;
break|break;
block|}
name|uniqueNameList
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|force
operator|&&
name|RexUtil
operator|.
name|isIdentity
argument_list|(
name|nodeList
argument_list|,
name|inputRowType
argument_list|)
condition|)
block|{
if|if
condition|(
name|fieldNameList
operator|.
name|equals
argument_list|(
name|inputRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
condition|)
block|{
comment|// Do not create an identity project if it does not rename any fields
return|return
name|this
return|;
block|}
else|else
block|{
comment|// create "virtual" row type for project only rename fields
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
comment|// Ignore the hints.
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|frame
operator|.
name|rel
argument_list|,
name|fields
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|// If the expressions are all literals, and the input is a Values with N
comment|// rows, replace with a Values with same tuple N times.
if|if
condition|(
name|config
operator|.
name|simplifyValues
argument_list|()
operator|&&
name|frame
operator|.
name|rel
operator|instanceof
name|Values
operator|&&
name|nodeList
operator|.
name|stream
argument_list|()
operator|.
name|allMatch
argument_list|(
name|e
lambda|->
name|e
operator|instanceof
name|RexLiteral
argument_list|)
condition|)
block|{
name|final
name|Values
name|values
operator|=
operator|(
name|Values
operator|)
name|build
argument_list|()
block|;
name|final
name|RelDataTypeFactory
operator|.
name|Builder
name|typeBuilder
operator|=
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
empty_stmt|;
name|Pair
operator|.
name|forEach
argument_list|(
name|fieldNameList
argument_list|,
name|nodeList
argument_list|,
parameter_list|(
name|name
parameter_list|,
name|expr
parameter_list|)
lambda|->
name|typeBuilder
operator|.
name|add
argument_list|(
name|requireNonNull
argument_list|(
name|name
argument_list|,
literal|"name"
argument_list|)
argument_list|,
name|expr
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
specifier|final
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|tuple
init|=
operator|(
name|List
argument_list|<
name|RexLiteral
argument_list|>
operator|)
operator|(
name|List
operator|)
name|nodeList
decl_stmt|;
return|return
name|values
argument_list|(
name|Collections
operator|.
name|nCopies
argument_list|(
name|values
operator|.
name|tuples
operator|.
name|size
argument_list|()
argument_list|,
name|tuple
argument_list|)
argument_list|,
name|typeBuilder
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
specifier|final
name|RelNode
name|project
init|=
name|struct
operator|.
name|projectFactory
operator|.
name|createProject
argument_list|(
name|frame
operator|.
name|rel
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|hints
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodeList
argument_list|)
argument_list|,
name|fieldNameList
argument_list|)
decl_stmt|;
name|stack
operator|.
name|pop
parameter_list|()
constructor_decl|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|project
argument_list|,
name|fields
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_class

begin_comment
comment|/** Creates a {@link Project} of the given    * expressions and field names, and optionally optimizing.    *    *<p>If {@code fieldNames} is null, or if a particular entry in    * {@code fieldNames} is null, derives field names from the input    * expressions.    *    *<p>If {@code force} is false,    * and the input is a {@code Project},    * and the expressions  make the trivial projection ($0, $1, ...),    * modifies the input.    *    * @param nodes       Expressions    * @param fieldNames  Suggested field names, or null to generate    * @param force       Whether to create a renaming Project if the    *                    projections are trivial    */
end_comment

begin_decl_stmt
specifier|public
name|RelBuilder
name|projectNamed
argument_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
argument_list|,
annotation|@
name|Nullable
name|Iterable
operator|<
condition|?
then|extends @
name|Nullable
name|String
operator|>
name|fieldNames
argument_list|,
name|boolean
name|force
argument_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodeList
init|=
name|nodes
operator|instanceof
name|List
condition|?
operator|(
name|List
operator|)
name|nodes
else|:
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
annotation|@
name|Nullable
name|String
argument_list|>
name|fieldNameList
init|=
name|fieldNames
operator|==
literal|null
condition|?
literal|null
else|:
name|fieldNames
operator|instanceof
name|List
condition|?
operator|(
name|List
argument_list|<
annotation|@
name|Nullable
name|String
argument_list|>
operator|)
name|fieldNames
else|:
name|ImmutableNullableList
operator|.
name|copyOf
argument_list|(
name|fieldNames
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|peek
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|RexUtil
operator|.
name|createStructType
argument_list|(
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|nodeList
argument_list|,
name|fieldNameList
argument_list|,
name|SqlValidatorUtil
operator|.
name|F_SUGGESTER
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|RexUtil
operator|.
name|isIdentity
argument_list|(
name|nodeList
argument_list|,
name|input
operator|.
name|getRowType
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|input
operator|instanceof
name|Project
operator|&&
name|fieldNames
operator|!=
literal|null
condition|)
block|{
comment|// Rename columns of child projection if desired field names are given.
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|Project
name|childProject
init|=
operator|(
name|Project
operator|)
name|frame
operator|.
name|rel
decl_stmt|;
specifier|final
name|Project
name|newInput
init|=
name|childProject
operator|.
name|copy
argument_list|(
name|childProject
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|childProject
operator|.
name|getInput
argument_list|()
argument_list|,
name|childProject
operator|.
name|getProjects
argument_list|()
argument_list|,
name|rowType
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|newInput
operator|.
name|attachHints
argument_list|(
name|childProject
operator|.
name|getHints
argument_list|()
argument_list|)
argument_list|,
name|frame
operator|.
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input
operator|instanceof
name|Values
operator|&&
name|fieldNameList
operator|!=
literal|null
condition|)
block|{
comment|// Rename columns of child values if desired field names are given.
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|Values
name|values
init|=
operator|(
name|Values
operator|)
name|frame
operator|.
name|rel
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|typeBuilder
init|=
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
decl_stmt|;
name|Pair
operator|.
name|forEach
argument_list|(
name|fieldNameList
argument_list|,
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|,
parameter_list|(
name|name
parameter_list|,
name|field
parameter_list|)
lambda|->
name|typeBuilder
operator|.
name|add
argument_list|(
name|requireNonNull
argument_list|(
name|name
argument_list|,
literal|"name"
argument_list|)
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|newRowType
init|=
name|typeBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|newValues
init|=
name|struct
operator|.
name|valuesFactory
operator|.
name|createValues
argument_list|(
name|cluster
argument_list|,
name|newRowType
argument_list|,
name|values
operator|.
name|tuples
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|newValues
argument_list|,
name|frame
operator|.
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|project
argument_list|(
name|nodeList
argument_list|,
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
end_decl_stmt

begin_comment
comment|/**    * Creates an {@link Uncollect} with given item aliases.    *    * @param itemAliases   Operand item aliases, never null    * @param withOrdinality If {@code withOrdinality}, the output contains an extra    * {@code ORDINALITY} column    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|uncollect
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|itemAliases
parameter_list|,
name|boolean
name|withOrdinality
parameter_list|)
block|{
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
operator|new
name|Uncollect
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|Convention
operator|.
name|NONE
argument_list|)
argument_list|,
name|frame
operator|.
name|rel
argument_list|,
name|withOrdinality
argument_list|,
name|requireNonNull
argument_list|(
name|itemAliases
argument_list|,
literal|"itemAliases"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Ensures that the field names match those given.    *    *<p>If all fields have the same name, adds nothing;    * if any fields do not have the same name, adds a {@link Project}.    *    *<p>Note that the names can be short-lived. Other {@code RelBuilder}    * operations make no guarantees about the field names of the rows they    * produce.    *    * @param fieldNames List of desired field names; may contain null values or    * have fewer fields than the current row type    */
end_comment

begin_decl_stmt
specifier|public
name|RelBuilder
name|rename
argument_list|(
name|List
operator|<
condition|?
then|extends @
name|Nullable
name|String
operator|>
name|fieldNames
argument_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|oldFieldNames
init|=
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|fieldNames
operator|.
name|size
argument_list|()
operator|<=
name|oldFieldNames
operator|.
name|size
argument_list|()
argument_list|,
literal|"More names than fields"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|newFieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|oldFieldNames
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|s
init|=
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|newFieldNames
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldFieldNames
operator|.
name|equals
argument_list|(
name|newFieldNames
argument_list|)
condition|)
block|{
return|return
name|this
return|;
block|}
if|if
condition|(
name|peek
argument_list|()
operator|instanceof
name|Values
condition|)
block|{
comment|// Special treatment for VALUES. Re-build it rather than add a project.
specifier|final
name|Values
name|v
init|=
operator|(
name|Values
operator|)
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|b
init|=
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataTypeField
argument_list|>
name|p
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|newFieldNames
argument_list|,
name|v
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
control|)
block|{
name|b
operator|.
name|add
argument_list|(
name|p
operator|.
name|left
argument_list|,
name|p
operator|.
name|right
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|values
argument_list|(
name|v
operator|.
name|tuples
argument_list|,
name|b
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
return|return
name|project
argument_list|(
name|fields
argument_list|()
argument_list|,
name|newFieldNames
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/** Infers the alias of an expression.    *    *<p>If the expression was created by {@link #alias}, replaces the expression    * in the project list.    */
end_comment

begin_function
specifier|private
annotation|@
name|Nullable
name|String
name|inferAlias
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
parameter_list|,
name|RexNode
name|expr
parameter_list|,
name|int
name|i
parameter_list|)
block|{
switch|switch
condition|(
name|expr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|INPUT_REF
case|:
specifier|final
name|RexInputRef
name|ref
init|=
operator|(
name|RexInputRef
operator|)
name|expr
decl_stmt|;
return|return
name|requireNonNull
argument_list|(
name|stack
operator|.
name|peek
argument_list|()
argument_list|,
literal|"empty frame stack"
argument_list|)
operator|.
name|fields
operator|.
name|get
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|.
name|getValue
argument_list|()
operator|.
name|getName
argument_list|()
return|;
case|case
name|CAST
case|:
return|return
name|inferAlias
argument_list|(
name|exprList
argument_list|,
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
return|;
case|case
name|AS
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|expr
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|exprList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|NlsString
name|value
init|=
operator|(
name|NlsString
operator|)
operator|(
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
return|return
name|castNonNull
argument_list|(
name|value
argument_list|)
operator|.
name|getValue
argument_list|()
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
end_function

begin_comment
comment|/** Creates an {@link Aggregate} that makes the    * relational expression distinct on all fields. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|distinct
parameter_list|()
block|{
return|return
name|aggregate
argument_list|(
name|groupKey
argument_list|(
name|fields
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates an {@link Aggregate} with an array of    * calls. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|aggregate
parameter_list|(
name|GroupKey
name|groupKey
parameter_list|,
name|AggCall
modifier|...
name|aggCalls
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|groupKey
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|aggCalls
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates an {@link Aggregate} with an array of    * {@link AggregateCall}s. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|aggregate
parameter_list|(
name|GroupKey
name|groupKey
parameter_list|,
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|groupKey
argument_list|,
name|aggregateCalls
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|AggCallImpl2
operator|::
operator|new
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates an {@link Aggregate} with multiple calls. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|aggregate
parameter_list|(
name|GroupKey
name|groupKey
parameter_list|,
name|Iterable
argument_list|<
name|AggCall
argument_list|>
name|aggCalls
parameter_list|)
block|{
specifier|final
name|Registrar
name|registrar
init|=
operator|new
name|Registrar
argument_list|(
name|fields
argument_list|()
argument_list|,
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|GroupKeyImpl
name|groupKey_
init|=
operator|(
name|GroupKeyImpl
operator|)
name|groupKey
decl_stmt|;
name|ImmutableBitSet
name|groupSet
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|registrar
operator|.
name|registerExpressions
argument_list|(
name|groupKey_
operator|.
name|nodes
argument_list|)
argument_list|)
decl_stmt|;
name|label
label|:
if|if
condition|(
name|Iterables
operator|.
name|isEmpty
argument_list|(
name|aggCalls
argument_list|)
condition|)
block|{
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|peek
argument_list|()
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|groupSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|Double
name|minRowCount
init|=
name|mq
operator|.
name|getMinRowCount
argument_list|(
name|peek
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|minRowCount
operator|==
literal|null
operator|||
name|minRowCount
operator|<
literal|1D
condition|)
block|{
comment|// We can't remove "GROUP BY ()" if there's a chance the rel could be
comment|// empty.
break|break
name|label
break|;
block|}
block|}
if|if
condition|(
name|registrar
operator|.
name|extraNodes
operator|.
name|size
argument_list|()
operator|==
name|fields
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|final
name|Boolean
name|unique
init|=
name|mq
operator|.
name|areColumnsUnique
argument_list|(
name|peek
argument_list|()
argument_list|,
name|groupSet
argument_list|)
decl_stmt|;
if|if
condition|(
name|unique
operator|!=
literal|null
operator|&&
name|unique
operator|&&
operator|!
name|config
operator|.
name|aggregateUnique
argument_list|()
operator|&&
name|groupKey_
operator|.
name|isSimple
argument_list|()
condition|)
block|{
comment|// Rel is already unique.
return|return
name|project
argument_list|(
name|fields
argument_list|(
name|groupSet
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|final
name|Double
name|maxRowCount
init|=
name|mq
operator|.
name|getMaxRowCount
argument_list|(
name|peek
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxRowCount
operator|!=
literal|null
operator|&&
name|maxRowCount
operator|<=
literal|1D
operator|&&
operator|!
name|config
operator|.
name|aggregateUnique
argument_list|()
operator|&&
name|groupKey_
operator|.
name|isSimple
argument_list|()
condition|)
block|{
comment|// If there is at most one row, rel is already unique.
return|return
name|project
argument_list|(
name|fields
argument_list|(
name|groupSet
argument_list|)
argument_list|)
return|;
block|}
block|}
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
decl_stmt|;
if|if
condition|(
name|groupKey_
operator|.
name|nodeLists
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|sizeBefore
init|=
name|registrar
operator|.
name|extraNodes
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSetList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|nodeList
range|:
name|groupKey_
operator|.
name|nodeLists
control|)
block|{
specifier|final
name|ImmutableBitSet
name|groupSet2
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|registrar
operator|.
name|registerExpressions
argument_list|(
name|nodeList
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|groupSet
operator|.
name|contains
argument_list|(
name|groupSet2
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"group set element "
operator|+
name|nodeList
operator|+
literal|" must be a subset of group key"
argument_list|)
throw|;
block|}
name|groupSetList
operator|.
name|add
argument_list|(
name|groupSet2
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableSortedMultiset
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSetMultiset
init|=
name|ImmutableSortedMultiset
operator|.
name|copyOf
argument_list|(
name|ImmutableBitSet
operator|.
name|COMPARATOR
argument_list|,
name|groupSetList
argument_list|)
decl_stmt|;
if|if
condition|(
name|Iterables
operator|.
name|any
argument_list|(
name|aggCalls
argument_list|,
name|RelBuilder
operator|::
name|isGroupId
argument_list|)
condition|)
block|{
return|return
name|rewriteAggregateWithGroupId
argument_list|(
name|groupSet
argument_list|,
name|groupSetMultiset
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|aggCalls
argument_list|)
argument_list|)
return|;
block|}
name|groupSets
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|groupSetMultiset
operator|.
name|elementSet
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|registrar
operator|.
name|extraNodes
operator|.
name|size
argument_list|()
operator|>
name|sizeBefore
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"group sets contained expressions not in group key: "
operator|+
name|registrar
operator|.
name|extraNodes
operator|.
name|subList
argument_list|(
name|sizeBefore
argument_list|,
name|registrar
operator|.
name|extraNodes
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|groupSets
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupSet
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|AggCall
name|aggCall
range|:
name|aggCalls
control|)
block|{
operator|(
operator|(
name|AggCallPlus
operator|)
name|aggCall
operator|)
operator|.
name|register
argument_list|(
name|registrar
argument_list|)
expr_stmt|;
block|}
name|project
argument_list|(
name|registrar
operator|.
name|extraNodes
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|registrar
operator|.
name|names
argument_list|)
expr_stmt|;
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|RelNode
name|r
init|=
name|frame
operator|.
name|rel
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggCall
name|aggCall
range|:
name|aggCalls
control|)
block|{
name|aggregateCalls
operator|.
name|add
argument_list|(
operator|(
operator|(
name|AggCallPlus
operator|)
name|aggCall
operator|)
operator|.
name|aggregateCall
argument_list|(
name|registrar
argument_list|,
name|groupSet
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
assert|assert
name|ImmutableBitSet
operator|.
name|ORDERING
operator|.
name|isStrictlyOrdered
argument_list|(
name|groupSets
argument_list|)
operator|:
name|groupSets
assert|;
for|for
control|(
name|ImmutableBitSet
name|set
range|:
name|groupSets
control|)
block|{
assert|assert
name|groupSet
operator|.
name|contains
argument_list|(
name|set
argument_list|)
assert|;
block|}
name|List
argument_list|<
name|Field
argument_list|>
name|inFields
init|=
name|frame
operator|.
name|fields
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|pruneInputOfAggregate
argument_list|()
operator|&&
name|r
operator|instanceof
name|Project
condition|)
block|{
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|fieldsUsed
init|=
name|RelOptUtil
operator|.
name|getAllFields2
argument_list|(
name|groupSet
argument_list|,
name|aggregateCalls
argument_list|)
decl_stmt|;
comment|// Some parts of the system can't handle rows with zero fields, so
comment|// pretend that one field is used.
if|if
condition|(
name|fieldsUsed
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|r
operator|=
operator|(
operator|(
name|Project
operator|)
name|r
operator|)
operator|.
name|getInput
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|fieldsUsed
operator|.
name|size
argument_list|()
operator|<
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
comment|// Some fields are computed but not used. Prune them.
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|source
range|:
name|fieldsUsed
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|source
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|groupSet
operator|=
name|groupSet
operator|.
name|permute
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|groupSets
operator|=
name|ImmutableBitSet
operator|.
name|ORDERING
operator|.
name|immutableSortedCopy
argument_list|(
name|ImmutableBitSet
operator|.
name|permute
argument_list|(
name|groupSets
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Mappings
operator|.
name|TargetMapping
name|targetMapping
init|=
name|Mappings
operator|.
name|target
argument_list|(
name|map
argument_list|,
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|fieldsUsed
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|oldAggregateCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|aggregateCalls
argument_list|)
decl_stmt|;
name|aggregateCalls
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|AggregateCall
name|aggregateCall
range|:
name|oldAggregateCalls
control|)
block|{
name|aggregateCalls
operator|.
name|add
argument_list|(
name|aggregateCall
operator|.
name|transform
argument_list|(
name|targetMapping
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inFields
operator|=
name|Mappings
operator|.
name|permute
argument_list|(
name|inFields
argument_list|,
name|targetMapping
operator|.
name|inverse
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|r
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newProjects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|builder
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|fieldsUsed
control|)
block|{
name|newProjects
operator|.
name|add
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|project
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|project
operator|.
name|copy
argument_list|(
name|cluster
operator|.
name|traitSet
argument_list|()
argument_list|,
name|project
operator|.
name|getInput
argument_list|()
argument_list|,
name|newProjects
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|config
operator|.
name|dedupAggregateCalls
argument_list|()
operator|||
name|Util
operator|.
name|isDistinct
argument_list|(
name|aggregateCalls
argument_list|)
condition|)
block|{
return|return
name|aggregate_
argument_list|(
name|groupSet
argument_list|,
name|groupSets
argument_list|,
name|r
argument_list|,
name|aggregateCalls
argument_list|,
name|registrar
operator|.
name|extraNodes
argument_list|,
name|inFields
argument_list|)
return|;
block|}
comment|// There are duplicate aggregate calls. Rebuild the list to eliminate
comment|// duplicates, then add a Project.
specifier|final
name|Set
argument_list|<
name|AggregateCall
argument_list|>
name|callSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
annotation|@
name|Nullable
name|String
argument_list|>
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Util
operator|.
name|range
argument_list|(
name|groupSet
operator|.
name|cardinality
argument_list|()
argument_list|)
operator|.
name|forEach
argument_list|(
name|i
lambda|->
name|projects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|distinctAggregateCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|aggregateCall
range|:
name|aggregateCalls
control|)
block|{
specifier|final
name|int
name|i
decl_stmt|;
if|if
condition|(
name|callSet
operator|.
name|add
argument_list|(
name|aggregateCall
argument_list|)
condition|)
block|{
name|i
operator|=
name|distinctAggregateCalls
operator|.
name|size
argument_list|()
expr_stmt|;
name|distinctAggregateCalls
operator|.
name|add
argument_list|(
name|aggregateCall
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|distinctAggregateCalls
operator|.
name|indexOf
argument_list|(
name|aggregateCall
argument_list|)
expr_stmt|;
assert|assert
name|i
operator|>=
literal|0
assert|;
block|}
name|projects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|groupSet
operator|.
name|cardinality
argument_list|()
operator|+
name|i
argument_list|,
name|aggregateCall
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|aggregate_
argument_list|(
name|groupSet
argument_list|,
name|groupSets
argument_list|,
name|r
argument_list|,
name|distinctAggregateCalls
argument_list|,
name|registrar
operator|.
name|extraNodes
argument_list|,
name|inFields
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|fields
init|=
name|projects
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|p
lambda|->
name|p
operator|.
name|right
operator|==
literal|null
condition|?
name|field
argument_list|(
name|p
operator|.
name|left
argument_list|)
else|:
name|alias
argument_list|(
name|field
argument_list|(
name|p
operator|.
name|left
argument_list|)
argument_list|,
name|p
operator|.
name|right
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|project
argument_list|(
name|fields
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Finishes the implementation of {@link #aggregate} by creating an    * {@link Aggregate} and pushing it onto the stack. */
end_comment

begin_function
specifier|private
name|RelBuilder
name|aggregate_
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraNodes
parameter_list|,
name|List
argument_list|<
name|Field
argument_list|>
name|inFields
parameter_list|)
block|{
specifier|final
name|RelNode
name|aggregate
init|=
name|struct
operator|.
name|aggregateFactory
operator|.
name|createAggregate
argument_list|(
name|input
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|groupSet
argument_list|,
name|groupSets
argument_list|,
name|aggregateCalls
argument_list|)
decl_stmt|;
comment|// build field list
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Field
argument_list|>
name|fields
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|aggregateFields
init|=
name|aggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// first, group fields
for|for
control|(
name|Integer
name|groupField
range|:
name|groupSet
operator|.
name|asList
argument_list|()
control|)
block|{
name|RexNode
name|node
init|=
name|extraNodes
operator|.
name|get
argument_list|(
name|groupField
argument_list|)
decl_stmt|;
specifier|final
name|SqlKind
name|kind
init|=
name|node
operator|.
name|getKind
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|INPUT_REF
case|:
name|fields
operator|.
name|add
argument_list|(
name|inFields
operator|.
name|get
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|String
name|name
init|=
name|aggregateFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|RelDataTypeField
name|fieldType
init|=
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|name
argument_list|,
name|i
argument_list|,
name|node
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|fieldType
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|// second, aggregate fields. retain `i' as field index
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|aggregateCalls
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|final
name|AggregateCall
name|call
init|=
name|aggregateCalls
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeField
name|fieldType
init|=
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|aggregateFields
operator|.
name|get
argument_list|(
name|i
operator|+
name|j
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
name|i
operator|+
name|j
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|fieldType
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|aggregate
argument_list|,
name|fields
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/**    * The {@code GROUP_ID()} function is used to distinguish duplicate groups.    * However, as Aggregate normalizes group sets to canonical form (i.e.,    * flatten, sorting, redundancy removal), this information is lost in RelNode.    * Therefore, it is impossible to implement the function in runtime.    *    *<p>To fill this gap, an aggregation query that contains {@code GROUP_ID()}    * function will generally be rewritten into UNION when converting to RelNode.    *    *<p>Also see the discussion in    *<a href="https://issues.apache.org/jira/browse/CALCITE-1824">[CALCITE-1824]    * GROUP_ID returns wrong result</a>.    */
end_comment

begin_function
specifier|private
name|RelBuilder
name|rewriteAggregateWithGroupId
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|ImmutableSortedMultiset
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
parameter_list|,
name|List
argument_list|<
name|AggCall
argument_list|>
name|aggregateCalls
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNamesIfNoRewrite
init|=
name|Aggregate
operator|.
name|deriveRowType
argument_list|(
name|getTypeFactory
argument_list|()
argument_list|,
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|false
argument_list|,
name|groupSet
argument_list|,
name|groupSets
operator|.
name|asList
argument_list|()
argument_list|,
name|aggregateCalls
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|c
lambda|->
operator|(
operator|(
name|AggCallPlus
operator|)
name|c
operator|)
operator|.
name|aggregateCall
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Util
operator|.
name|toImmutableList
argument_list|()
argument_list|)
argument_list|)
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
comment|// If n duplicates exist for a particular grouping, the {@code GROUP_ID()}
comment|// function produces values in the range 0 to n-1. For each value,
comment|// we need to figure out the corresponding group sets.
comment|//
comment|// For example, "... GROUPING SETS (a, a, b, c, c, c, c)"
comment|// (i) The max value of the GROUP_ID() function returns is 3
comment|// (ii) GROUPING SETS (a, b, c) produces value 0,
comment|//      GROUPING SETS (a, c) produces value 1,
comment|//      GROUPING SETS (c) produces value 2
comment|//      GROUPING SETS (c) produces value 3
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
argument_list|>
name|groupIdToGroupSets
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|maxGroupId
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Multiset
operator|.
name|Entry
argument_list|<
name|ImmutableBitSet
argument_list|>
name|entry
range|:
name|groupSets
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|int
name|groupId
init|=
name|entry
operator|.
name|getCount
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|groupId
operator|>
name|maxGroupId
condition|)
block|{
name|maxGroupId
operator|=
name|groupId
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|groupId
condition|;
name|i
operator|++
control|)
block|{
name|groupIdToGroupSets
operator|.
name|computeIfAbsent
argument_list|(
name|i
argument_list|,
name|k
lambda|->
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|ImmutableBitSet
operator|.
name|COMPARATOR
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getElement
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// AggregateCall list without GROUP_ID function
specifier|final
name|List
argument_list|<
name|AggCall
argument_list|>
name|aggregateCallsWithoutGroupId
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|aggregateCalls
argument_list|)
decl_stmt|;
name|aggregateCallsWithoutGroupId
operator|.
name|removeIf
argument_list|(
name|RelBuilder
operator|::
name|isGroupId
argument_list|)
expr_stmt|;
comment|// For each group id value, we first construct an Aggregate without
comment|// GROUP_ID() function call, and then create a Project node on top of it.
comment|// The Project adds literal value for group id in right position.
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|groupId
init|=
literal|0
init|;
name|groupId
operator|<=
name|maxGroupId
condition|;
name|groupId
operator|++
control|)
block|{
comment|// Create the Aggregate node without GROUP_ID() call
name|stack
operator|.
name|push
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|aggregate
argument_list|(
name|groupKey
argument_list|(
name|groupSet
argument_list|,
name|castNonNull
argument_list|(
name|groupIdToGroupSets
operator|.
name|get
argument_list|(
name|groupId
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|aggregateCallsWithoutGroupId
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|selectList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|groupExprLength
init|=
name|groupSet
operator|.
name|cardinality
argument_list|()
decl_stmt|;
comment|// Project fields in group by expressions
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|groupExprLength
condition|;
name|i
operator|++
control|)
block|{
name|selectList
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Project fields in aggregate calls
name|int
name|groupIdCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggregateCalls
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isGroupId
argument_list|(
name|aggregateCalls
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|selectList
operator|.
name|add
argument_list|(
name|getRexBuilder
argument_list|()
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|groupId
argument_list|)
argument_list|,
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|groupIdCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|selectList
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|groupExprLength
operator|+
name|i
operator|-
name|groupIdCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|project
argument_list|(
name|selectList
argument_list|,
name|fieldNamesIfNoRewrite
argument_list|)
expr_stmt|;
block|}
return|return
name|union
argument_list|(
literal|true
argument_list|,
name|maxGroupId
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|boolean
name|isGroupId
parameter_list|(
name|AggCall
name|c
parameter_list|)
block|{
return|return
operator|(
operator|(
name|AggCallPlus
operator|)
name|c
operator|)
operator|.
name|op
argument_list|()
operator|.
name|kind
operator|==
name|SqlKind
operator|.
name|GROUP_ID
return|;
block|}
end_function

begin_function
specifier|private
name|RelBuilder
name|setOp
parameter_list|(
name|boolean
name|all
parameter_list|,
name|SqlKind
name|kind
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|inputs
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
if|if
condition|(
name|n
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"bad INTERSECT/UNION/EXCEPT input count"
argument_list|)
throw|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"bad setOp "
operator|+
name|kind
argument_list|)
throw|;
block|}
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
return|return
name|push
argument_list|(
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|config
operator|.
name|simplifyValues
argument_list|()
operator|&&
name|kind
operator|==
name|UNION
operator|&&
name|inputs
operator|.
name|stream
argument_list|()
operator|.
name|allMatch
argument_list|(
name|r
lambda|->
name|r
operator|instanceof
name|Values
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|RelDataType
argument_list|>
name|inputTypes
operator|=
name|Util
operator|.
name|transform
argument_list|(
name|inputs
argument_list|,
name|RelNode
operator|::
name|getRowType
argument_list|)
block|;
name|RelDataType
name|rowType
operator|=
name|getTypeFactory
argument_list|()
operator|.
name|leastRestrictive
argument_list|(
name|inputTypes
argument_list|)
empty_stmt|;
name|requireNonNull
argument_list|(
name|rowType
argument_list|,
parameter_list|()
lambda|->
literal|"leastRestrictive("
operator|+
name|inputTypes
operator|+
literal|")"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tuples
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|inputs
control|)
block|{
name|tuples
operator|.
name|addAll
argument_list|(
operator|(
operator|(
name|Values
operator|)
name|input
operator|)
operator|.
name|tuples
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tuples2
init|=
name|all
condition|?
name|tuples
else|:
name|Util
operator|.
name|distinctList
argument_list|(
name|tuples
argument_list|)
decl_stmt|;
return|return
name|values
argument_list|(
name|tuples2
argument_list|,
name|rowType
argument_list|)
return|;
block|}
end_function

begin_return
return|return
name|push
argument_list|(
name|struct
operator|.
name|setOpFactory
operator|.
name|createSetOp
argument_list|(
name|kind
argument_list|,
name|inputs
argument_list|,
name|all
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/** Creates a {@link Union} of the two most recent    * relational expressions on the stack.    *    * @param all Whether to create UNION ALL    */
end_comment

begin_function
unit|public
name|RelBuilder
name|union
parameter_list|(
name|boolean
name|all
parameter_list|)
block|{
return|return
name|union
argument_list|(
name|all
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Union} of the {@code n}    * most recent relational expressions on the stack.    *    * @param all Whether to create UNION ALL    * @param n Number of inputs to the UNION operator    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|union
parameter_list|(
name|boolean
name|all
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|setOp
argument_list|(
name|all
argument_list|,
name|UNION
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates an {@link Intersect} of the two most    * recent relational expressions on the stack.    *    * @param all Whether to create INTERSECT ALL    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|intersect
parameter_list|(
name|boolean
name|all
parameter_list|)
block|{
return|return
name|intersect
argument_list|(
name|all
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates an {@link Intersect} of the {@code n}    * most recent relational expressions on the stack.    *    * @param all Whether to create INTERSECT ALL    * @param n Number of inputs to the INTERSECT operator    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|intersect
parameter_list|(
name|boolean
name|all
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|setOp
argument_list|(
name|all
argument_list|,
name|SqlKind
operator|.
name|INTERSECT
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Minus} of the two most recent    * relational expressions on the stack.    *    * @param all Whether to create EXCEPT ALL    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|minus
parameter_list|(
name|boolean
name|all
parameter_list|)
block|{
return|return
name|minus
argument_list|(
name|all
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Minus} of the {@code n}    * most recent relational expressions on the stack.    *    * @param all Whether to create EXCEPT ALL    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|minus
parameter_list|(
name|boolean
name|all
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|setOp
argument_list|(
name|all
argument_list|,
name|SqlKind
operator|.
name|EXCEPT
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@link TableScan} on a {@link TransientTable} with the given name, using as type    * the top of the stack's type.    *    * @param tableName table name    */
end_comment

begin_function
annotation|@
name|Experimental
specifier|public
name|RelBuilder
name|transientScan
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
return|return
name|this
operator|.
name|transientScan
argument_list|(
name|tableName
argument_list|,
name|this
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@link TableScan} on a {@link TransientTable} with the given name and type.    *    * @param tableName table name    * @param rowType row type of the table    */
end_comment

begin_function
annotation|@
name|Experimental
specifier|public
name|RelBuilder
name|transientScan
parameter_list|(
name|String
name|tableName
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
block|{
name|TransientTable
name|transientTable
init|=
operator|new
name|ListTransientTable
argument_list|(
name|tableName
argument_list|,
name|rowType
argument_list|)
decl_stmt|;
name|requireNonNull
argument_list|(
name|relOptSchema
argument_list|,
literal|"relOptSchema"
argument_list|)
expr_stmt|;
name|RelOptTable
name|relOptTable
init|=
name|RelOptTableImpl
operator|.
name|create
argument_list|(
name|relOptSchema
argument_list|,
name|rowType
argument_list|,
name|transientTable
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|tableName
argument_list|)
argument_list|)
decl_stmt|;
name|RelNode
name|scan
init|=
name|struct
operator|.
name|scanFactory
operator|.
name|createScan
argument_list|(
name|ViewExpanders
operator|.
name|toRelContext
argument_list|(
name|viewExpander
argument_list|,
name|cluster
argument_list|)
argument_list|,
name|relOptTable
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@link TableSpool} for the most recent relational expression.    *    * @param readType Spool's read type (as described in {@link Spool.Type})    * @param writeType Spool's write type (as described in {@link Spool.Type})    * @param table Table to write into    */
end_comment

begin_function
specifier|private
name|RelBuilder
name|tableSpool
parameter_list|(
name|Spool
operator|.
name|Type
name|readType
parameter_list|,
name|Spool
operator|.
name|Type
name|writeType
parameter_list|,
name|RelOptTable
name|table
parameter_list|)
block|{
name|RelNode
name|spool
init|=
name|struct
operator|.
name|spoolFactory
operator|.
name|createTableSpool
argument_list|(
name|peek
argument_list|()
argument_list|,
name|readType
argument_list|,
name|writeType
argument_list|,
name|table
argument_list|)
decl_stmt|;
name|replaceTop
argument_list|(
name|spool
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@link RepeatUnion} associated to a {@link TransientTable} without a maximum number    * of iterations, i.e. repeatUnion(tableName, all, -1).    *    * @param tableName name of the {@link TransientTable} associated to the {@link RepeatUnion}    * @param all whether duplicates will be considered or not    */
end_comment

begin_function
annotation|@
name|Experimental
specifier|public
name|RelBuilder
name|repeatUnion
parameter_list|(
name|String
name|tableName
parameter_list|,
name|boolean
name|all
parameter_list|)
block|{
return|return
name|repeatUnion
argument_list|(
name|tableName
argument_list|,
name|all
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@link RepeatUnion} associated to a {@link TransientTable} of the    * two most recent relational expressions on the stack.    *    *<p>Warning: if these relational expressions are not    * correctly defined, this operation might lead to an infinite loop.    *    *<p>The generated {@link RepeatUnion} operates as follows:    *    *<ul>    *<li>Evaluate its left term once, propagating the results into the    *     {@link TransientTable};    *<li>Evaluate its right term (which may contain a {@link TableScan} on the    *     {@link TransientTable}) over and over until it produces no more results    *     (or until an optional maximum number of iterations is reached). On each    *     iteration, the results are propagated into the {@link TransientTable},    *     overwriting the results from the previous one.    *</ul>    *    * @param tableName Name of the {@link TransientTable} associated to the    *     {@link RepeatUnion}    * @param all Whether duplicates are considered    * @param iterationLimit Maximum number of iterations; negative value means no limit    */
end_comment

begin_function
annotation|@
name|Experimental
specifier|public
name|RelBuilder
name|repeatUnion
parameter_list|(
name|String
name|tableName
parameter_list|,
name|boolean
name|all
parameter_list|,
name|int
name|iterationLimit
parameter_list|)
block|{
name|RelOptTableFinder
name|finder
init|=
operator|new
name|RelOptTableFinder
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stack
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// search scan(tableName) in the stack
name|peek
argument_list|(
name|i
argument_list|)
operator|.
name|accept
argument_list|(
name|finder
argument_list|)
expr_stmt|;
if|if
condition|(
name|finder
operator|.
name|relOptTable
operator|!=
literal|null
condition|)
block|{
comment|// found
break|break;
block|}
block|}
if|if
condition|(
name|finder
operator|.
name|relOptTable
operator|==
literal|null
condition|)
block|{
throw|throw
name|RESOURCE
operator|.
name|tableNotFound
argument_list|(
name|tableName
argument_list|)
operator|.
name|ex
argument_list|()
throw|;
block|}
name|RelNode
name|iterative
init|=
name|tableSpool
argument_list|(
name|Spool
operator|.
name|Type
operator|.
name|LAZY
argument_list|,
name|Spool
operator|.
name|Type
operator|.
name|LAZY
argument_list|,
name|finder
operator|.
name|relOptTable
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|seed
init|=
name|tableSpool
argument_list|(
name|Spool
operator|.
name|Type
operator|.
name|LAZY
argument_list|,
name|Spool
operator|.
name|Type
operator|.
name|LAZY
argument_list|,
name|finder
operator|.
name|relOptTable
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|repeatUnion
init|=
name|struct
operator|.
name|repeatUnionFactory
operator|.
name|createRepeatUnion
argument_list|(
name|seed
argument_list|,
name|iterative
argument_list|,
name|all
argument_list|,
name|iterationLimit
argument_list|)
decl_stmt|;
return|return
name|push
argument_list|(
name|repeatUnion
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Auxiliary class to find a certain RelOptTable based on its name.    */
end_comment

begin_class
specifier|private
specifier|static
specifier|final
class|class
name|RelOptTableFinder
extends|extends
name|RelHomogeneousShuttle
block|{
specifier|private
annotation|@
name|MonotonicNonNull
name|RelOptTable
name|relOptTable
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|String
name|tableName
decl_stmt|;
specifier|private
name|RelOptTableFinder
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|visit
parameter_list|(
name|TableScan
name|scan
parameter_list|)
block|{
specifier|final
name|RelOptTable
name|scanTable
init|=
name|scan
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|qualifiedName
init|=
name|scanTable
operator|.
name|getQualifiedName
argument_list|()
decl_stmt|;
if|if
condition|(
name|qualifiedName
operator|.
name|get
argument_list|(
name|qualifiedName
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|relOptTable
operator|=
name|scanTable
expr_stmt|;
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|scan
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/** Creates a {@link Join} with an array of conditions. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|RexNode
name|condition0
parameter_list|,
name|RexNode
modifier|...
name|conditions
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|joinType
argument_list|,
name|Lists
operator|.
name|asList
argument_list|(
name|condition0
argument_list|,
name|conditions
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Join} with multiple    * conditions. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|conditions
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|joinType
argument_list|,
name|and
argument_list|(
name|conditions
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Join} with one condition. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|joinType
argument_list|,
name|condition
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Join} with correlating variables. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|variablesSet
parameter_list|)
block|{
name|Frame
name|right
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|Frame
name|left
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|join
decl_stmt|;
specifier|final
name|boolean
name|correlate
init|=
name|variablesSet
operator|.
name|size
argument_list|()
operator|==
literal|1
decl_stmt|;
name|RexNode
name|postCondition
init|=
name|literal
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|simplify
argument_list|()
condition|)
block|{
comment|// Normalize expanded versions IS NOT DISTINCT FROM so that simplifier does not
comment|// transform the expression to something unrecognizable
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|condition
operator|=
name|RelOptUtil
operator|.
name|collapseExpandedIsNotDistinctFromExpr
argument_list|(
operator|(
name|RexCall
operator|)
name|condition
argument_list|,
name|getRexBuilder
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|condition
operator|=
name|simplifier
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|correlate
condition|)
block|{
specifier|final
name|CorrelationId
name|id
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|variablesSet
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|requiredColumns
init|=
name|RelOptUtil
operator|.
name|correlationColumns
argument_list|(
name|id
argument_list|,
name|right
operator|.
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|RelOptUtil
operator|.
name|notContainsCorrelation
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|id
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"variable "
operator|+
name|id
operator|+
literal|" must not be used by left input to correlation"
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|LEFT
case|:
comment|// Correlate does not have an ON clause.
comment|// For a LEFT correlate, predicate must be evaluated first.
comment|// For INNER, we can defer.
name|stack
operator|.
name|push
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|filter
argument_list|(
name|condition
operator|.
name|accept
argument_list|(
operator|new
name|Shifter
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|id
argument_list|,
name|right
operator|.
name|rel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|right
operator|=
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
break|break;
default|default:
name|postCondition
operator|=
name|condition
expr_stmt|;
block|}
name|join
operator|=
name|struct
operator|.
name|correlateFactory
operator|.
name|createCorrelate
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|right
operator|.
name|rel
argument_list|,
name|id
argument_list|,
name|requiredColumns
argument_list|,
name|joinType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RelNode
name|join0
init|=
name|struct
operator|.
name|joinFactory
operator|.
name|createJoin
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|right
operator|.
name|rel
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|condition
argument_list|,
name|variablesSet
argument_list|,
name|joinType
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|join0
operator|instanceof
name|Join
operator|&&
name|config
operator|.
name|pushJoinCondition
argument_list|()
condition|)
block|{
name|join
operator|=
name|RelOptUtil
operator|.
name|pushDownJoinConditions
argument_list|(
operator|(
name|Join
operator|)
name|join0
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|join
operator|=
name|join0
expr_stmt|;
block|}
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Field
argument_list|>
name|fields
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|fields
operator|.
name|addAll
argument_list|(
name|left
operator|.
name|fields
argument_list|)
expr_stmt|;
name|fields
operator|.
name|addAll
argument_list|(
name|right
operator|.
name|fields
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|join
argument_list|,
name|fields
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|filter
argument_list|(
name|postCondition
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Correlate}    * with a {@link CorrelationId} and an array of fields that are used by correlation. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|correlate
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|CorrelationId
name|correlationId
parameter_list|,
name|RexNode
modifier|...
name|requiredFields
parameter_list|)
block|{
return|return
name|correlate
argument_list|(
name|joinType
argument_list|,
name|correlationId
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|requiredFields
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Correlate}    * with a {@link CorrelationId} and a list of fields that are used by correlation. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|correlate
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|CorrelationId
name|correlationId
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|requiredFields
parameter_list|)
block|{
name|Frame
name|right
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|Registrar
name|registrar
init|=
operator|new
name|Registrar
argument_list|(
name|fields
argument_list|()
argument_list|,
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|requiredOrdinals
init|=
name|registrar
operator|.
name|registerExpressions
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|requiredFields
argument_list|)
argument_list|)
decl_stmt|;
name|project
argument_list|(
name|registrar
operator|.
name|extraNodes
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|registrar
operator|.
name|names
argument_list|)
expr_stmt|;
name|Frame
name|left
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|correlate
init|=
name|struct
operator|.
name|correlateFactory
operator|.
name|createCorrelate
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|right
operator|.
name|rel
argument_list|,
name|correlationId
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|requiredOrdinals
argument_list|)
argument_list|,
name|joinType
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Field
argument_list|>
name|fields
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|fields
operator|.
name|addAll
argument_list|(
name|left
operator|.
name|fields
argument_list|)
expr_stmt|;
name|fields
operator|.
name|addAll
argument_list|(
name|right
operator|.
name|fields
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|correlate
argument_list|,
name|fields
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Join} using USING syntax.    *    *<p>For each of the field names, both left and right inputs must have a    * field of that name. Constructs a join condition that the left and right    * fields are equal.    *    * @param joinType Join type    * @param fieldNames Field names    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|String
modifier|...
name|fieldNames
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|conditions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
name|conditions
operator|.
name|add
argument_list|(
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|fieldName
argument_list|)
argument_list|,
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|fieldName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|join
argument_list|(
name|joinType
argument_list|,
name|conditions
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Join} with {@link JoinRelType#SEMI}.    *    *<p>A semi-join is a form of join that combines two relational expressions    * according to some condition, and outputs only rows from the left input for    * which at least one row from the right input matches. It only outputs    * columns from the left input, and ignores duplicates on the right.    *    *<p>For example, {@code EMP semi-join DEPT} finds all {@code EMP} records    * that do not have a corresponding {@code DEPT} record, similar to the    * following SQL:    *    *<blockquote><pre>    * SELECT * FROM EMP    * WHERE EXISTS (SELECT 1 FROM DEPT    *     WHERE DEPT.DEPTNO = EMP.DEPTNO)</pre>    *</blockquote>    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|semiJoin
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|conditions
parameter_list|)
block|{
specifier|final
name|Frame
name|right
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|semiJoin
init|=
name|struct
operator|.
name|joinFactory
operator|.
name|createJoin
argument_list|(
name|peek
argument_list|()
argument_list|,
name|right
operator|.
name|rel
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|and
argument_list|(
name|conditions
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|JoinRelType
operator|.
name|SEMI
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|replaceTop
argument_list|(
name|semiJoin
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Join} with {@link JoinRelType#SEMI}.    *    * @see #semiJoin(Iterable) */
end_comment

begin_function
specifier|public
name|RelBuilder
name|semiJoin
parameter_list|(
name|RexNode
modifier|...
name|conditions
parameter_list|)
block|{
return|return
name|semiJoin
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|conditions
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates an anti-join.    *    *<p>An anti-join is a form of join that combines two relational expressions    * according to some condition, but outputs only rows from the left input    * for which no rows from the right input match.    *    *<p>For example, {@code EMP anti-join DEPT} finds all {@code EMP} records    * that do not have a corresponding {@code DEPT} record, similar to the    * following SQL:    *    *<blockquote><pre>    * SELECT * FROM EMP    * WHERE NOT EXISTS (SELECT 1 FROM DEPT    *     WHERE DEPT.DEPTNO = EMP.DEPTNO)</pre>    *</blockquote>    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|antiJoin
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|conditions
parameter_list|)
block|{
specifier|final
name|Frame
name|right
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|antiJoin
init|=
name|struct
operator|.
name|joinFactory
operator|.
name|createJoin
argument_list|(
name|peek
argument_list|()
argument_list|,
name|right
operator|.
name|rel
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|and
argument_list|(
name|conditions
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|JoinRelType
operator|.
name|ANTI
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|replaceTop
argument_list|(
name|antiJoin
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Creates an anti-join.    *    * @see #antiJoin(Iterable) */
end_comment

begin_function
specifier|public
name|RelBuilder
name|antiJoin
parameter_list|(
name|RexNode
modifier|...
name|conditions
parameter_list|)
block|{
return|return
name|antiJoin
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|conditions
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Assigns a table alias to the top entry on the stack. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|as
parameter_list|(
specifier|final
name|String
name|alias
parameter_list|)
block|{
specifier|final
name|Frame
name|pair
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Field
argument_list|>
name|newFields
init|=
name|Util
operator|.
name|transform
argument_list|(
name|pair
operator|.
name|fields
argument_list|,
name|field
lambda|->
name|field
operator|.
name|addAlias
argument_list|(
name|alias
argument_list|)
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|pair
operator|.
name|rel
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|newFields
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Values}.    *    *<p>The {@code values} array must have the same number of entries as    * {@code fieldNames}, or an integer multiple if you wish to create multiple    * rows.    *    *<p>If there are zero rows, or if all values of a any column are    * null, this method cannot deduce the type of columns. For these cases,    * call {@link #values(Iterable, RelDataType)}.    *    * @param fieldNames Field names    * @param values Values    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|values
parameter_list|(
annotation|@
name|Nullable
name|String
index|[]
name|fieldNames
parameter_list|,
annotation|@
name|Nullable
name|Object
modifier|...
name|values
parameter_list|)
block|{
if|if
condition|(
name|fieldNames
operator|==
literal|null
operator|||
name|fieldNames
operator|.
name|length
operator|==
literal|0
operator|||
name|values
operator|.
name|length
operator|%
name|fieldNames
operator|.
name|length
operator|!=
literal|0
operator|||
name|values
operator|.
name|length
operator|<
name|fieldNames
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Value count must be a positive multiple of field count"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|rowCount
init|=
name|values
operator|.
name|length
operator|/
name|fieldNames
operator|.
name|length
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
annotation|@
name|Nullable
name|String
argument_list|>
name|fieldName
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|fieldNames
argument_list|)
control|)
block|{
if|if
condition|(
name|allNull
argument_list|(
name|values
argument_list|,
name|fieldName
operator|.
name|i
argument_list|,
name|fieldNames
operator|.
name|length
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"All values of field '"
operator|+
name|fieldName
operator|.
name|e
operator|+
literal|"' (field index "
operator|+
name|fieldName
operator|.
name|i
operator|+
literal|")"
operator|+
literal|" are null; cannot deduce type"
argument_list|)
throw|;
block|}
block|}
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
init|=
name|tupleList
argument_list|(
name|fieldNames
operator|.
name|length
argument_list|,
name|values
argument_list|)
decl_stmt|;
assert|assert
name|tupleList
operator|.
name|size
argument_list|()
operator|==
name|rowCount
assert|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
init|=
name|Util
operator|.
name|transformIndexed
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|fieldNames
argument_list|)
argument_list|,
operator|(
name|name
expr|,
name|i
operator|)
operator|->
name|name
operator|!=
literal|null
condition|?
name|name
else|:
literal|"expr$"
operator|+
name|i
argument_list|)
decl_stmt|;
return|return
name|values
argument_list|(
name|tupleList
argument_list|,
name|fieldNameList
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
name|RelBuilder
name|values
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|builder
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
decl_stmt|;
name|Ord
operator|.
name|forEach
argument_list|(
name|fieldNames
argument_list|,
parameter_list|(
name|fieldName
parameter_list|,
name|i
parameter_list|)
lambda|->
block|{
specifier|final
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|leastRestrictive
argument_list|(
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|tupleList
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|tupleList
operator|.
name|size
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
assert|assert
name|type
operator|!=
literal|null
operator|:
literal|"can't infer type for field "
operator|+
name|i
operator|+
literal|", "
operator|+
name|fieldName
assert|;
name|builder
operator|.
name|add
argument_list|(
name|fieldName
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|values
argument_list|(
name|tupleList
argument_list|,
name|rowType
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
parameter_list|(
name|int
name|columnCount
parameter_list|,
annotation|@
name|Nullable
name|Object
index|[]
name|values
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|listBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|valueList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|value
init|=
name|values
index|[
name|i
index|]
decl_stmt|;
name|valueList
operator|.
name|add
argument_list|(
name|literal
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|columnCount
operator|==
literal|0
condition|)
block|{
name|listBuilder
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|valueList
argument_list|)
argument_list|)
expr_stmt|;
name|valueList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|listBuilder
operator|.
name|build
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/** Returns whether all values for a given column are null. */
end_comment

begin_function
specifier|private
specifier|static
name|boolean
name|allNull
parameter_list|(
annotation|@
name|Nullable
name|Object
index|[]
name|values
parameter_list|,
name|int
name|column
parameter_list|,
name|int
name|columnCount
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|column
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|+=
name|columnCount
control|)
block|{
if|if
condition|(
name|values
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function

begin_comment
comment|/** Creates a relational expression that reads from an input and throws    * all of the rows away.    *    *<p>Note that this method always pops one relational expression from the    * stack. {@code values}, in contrast, does not pop any relational    * expressions, and always produces a leaf.    *    *<p>The default implementation creates a {@link Values} with the same    * specified row type and aliases as the input, and ignores the input entirely.    * But schema-on-query systems such as Drill might override this method to    * create a relation expression that retains the input, just to read its    * schema.    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|empty
parameter_list|()
block|{
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|values
init|=
name|struct
operator|.
name|valuesFactory
operator|.
name|createValues
argument_list|(
name|cluster
argument_list|,
name|frame
operator|.
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|values
argument_list|,
name|frame
operator|.
name|fields
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Values} with a specified row type.    *    *<p>This method can handle cases that {@link #values(String[], Object...)}    * cannot, such as all values of a column being null, or there being zero    * rows.    *    * @param rowType Row type    * @param columnValues Values    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|values
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|Object
modifier|...
name|columnValues
parameter_list|)
block|{
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
init|=
name|tupleList
argument_list|(
name|rowType
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|columnValues
argument_list|)
decl_stmt|;
name|RelNode
name|values
init|=
name|struct
operator|.
name|valuesFactory
operator|.
name|createValues
argument_list|(
name|cluster
argument_list|,
name|rowType
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tupleList
argument_list|)
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|values
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Values} with a specified row type.    *    *<p>This method can handle cases that {@link #values(String[], Object...)}    * cannot, such as all values of a column being null, or there being zero    * rows.    *    * @param tupleList Tuple list    * @param rowType Row type    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|values
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
block|{
name|RelNode
name|values
init|=
name|struct
operator|.
name|valuesFactory
operator|.
name|createValues
argument_list|(
name|cluster
argument_list|,
name|rowType
argument_list|,
name|copy
argument_list|(
name|tupleList
argument_list|)
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|values
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Values} with a specified row type and    * zero rows.    *    * @param rowType Row type    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|values
parameter_list|(
name|RelDataType
name|rowType
parameter_list|)
block|{
return|return
name|values
argument_list|(
name|ImmutableList
operator|.
expr|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
operator|>
name|of
argument_list|()
argument_list|,
name|rowType
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Converts an iterable of lists into an immutable list of immutable lists    * with the same contents. Returns the same object if possible. */
end_comment

begin_function
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|E
argument_list|>
argument_list|>
name|copy
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|tupleList
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|E
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|int
name|changeCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|E
argument_list|>
name|literals
range|:
name|tupleList
control|)
block|{
specifier|final
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|literals2
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|literals
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|literals2
argument_list|)
expr_stmt|;
if|if
condition|(
name|literals
operator|!=
name|literals2
condition|)
block|{
operator|++
name|changeCount
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changeCount
operator|==
literal|0
operator|&&
name|tupleList
operator|instanceof
name|ImmutableList
condition|)
block|{
comment|// don't make a copy if we don't have to
comment|//noinspection unchecked
return|return
operator|(
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|E
argument_list|>
argument_list|>
operator|)
name|tupleList
return|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/** Creates a limit without a sort. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|limit
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|fetch
parameter_list|)
block|{
return|return
name|sortLimit
argument_list|(
name|offset
argument_list|,
name|fetch
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates an Exchange by distribution. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|exchange
parameter_list|(
name|RelDistribution
name|distribution
parameter_list|)
block|{
name|RelNode
name|exchange
init|=
name|struct
operator|.
name|exchangeFactory
operator|.
name|createExchange
argument_list|(
name|peek
argument_list|()
argument_list|,
name|distribution
argument_list|)
decl_stmt|;
name|replaceTop
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Creates a SortExchange by distribution and collation. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|sortExchange
parameter_list|(
name|RelDistribution
name|distribution
parameter_list|,
name|RelCollation
name|collation
parameter_list|)
block|{
name|RelNode
name|exchange
init|=
name|struct
operator|.
name|sortExchangeFactory
operator|.
name|createSortExchange
argument_list|(
name|peek
argument_list|()
argument_list|,
name|distribution
argument_list|,
name|collation
argument_list|)
decl_stmt|;
name|replaceTop
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Sort} by field ordinals.    *    *<p>Negative fields mean descending: -1 means field(0) descending,    * -2 means field(1) descending, etc.    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|sort
parameter_list|(
name|int
modifier|...
name|fields
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|field
range|:
name|fields
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|field
operator|<
literal|0
condition|?
name|desc
argument_list|(
name|field
argument_list|(
operator|-
name|field
operator|-
literal|1
argument_list|)
argument_list|)
else|:
name|field
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Sort} by expressions. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|sort
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Sort} by expressions. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|sort
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|nodes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Sort} by expressions, with limit and offset. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|sortLimit
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|fetch
parameter_list|,
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|sortLimit
argument_list|(
name|offset
argument_list|,
name|fetch
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Sort} by specifying collations.    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|sort
parameter_list|(
name|RelCollation
name|collation
parameter_list|)
block|{
specifier|final
name|RelNode
name|sort
init|=
name|struct
operator|.
name|sortFactory
operator|.
name|createSort
argument_list|(
name|peek
argument_list|()
argument_list|,
name|collation
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|replaceTop
argument_list|(
name|sort
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Sort} by a list of expressions, with limit and offset.    *    * @param offset Number of rows to skip; non-positive means don't skip any    * @param fetch Maximum number of rows to fetch; negative means no limit    * @param nodes Sort expressions    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|sortLimit
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|fetch
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|Registrar
name|registrar
init|=
operator|new
name|Registrar
argument_list|(
name|fields
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
name|registrar
operator|.
name|registerFieldCollations
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|offsetNode
init|=
name|offset
operator|<=
literal|0
condition|?
literal|null
else|:
name|literal
argument_list|(
name|offset
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|fetchNode
init|=
name|fetch
operator|<
literal|0
condition|?
literal|null
else|:
name|literal
argument_list|(
name|fetch
argument_list|)
decl_stmt|;
if|if
condition|(
name|offsetNode
operator|==
literal|null
operator|&&
name|fetch
operator|==
literal|0
operator|&&
name|config
operator|.
name|simplifyLimit
argument_list|()
condition|)
block|{
return|return
name|empty
argument_list|()
return|;
block|}
if|if
condition|(
name|offsetNode
operator|==
literal|null
operator|&&
name|fetchNode
operator|==
literal|null
operator|&&
name|fieldCollations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|this
return|;
comment|// sort is trivial
block|}
if|if
condition|(
name|fieldCollations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
assert|assert
name|registrar
operator|.
name|addedFieldCount
argument_list|()
operator|==
literal|0
assert|;
name|RelNode
name|top
init|=
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|top
operator|instanceof
name|Sort
condition|)
block|{
specifier|final
name|Sort
name|sort2
init|=
operator|(
name|Sort
operator|)
name|top
decl_stmt|;
if|if
condition|(
name|sort2
operator|.
name|offset
operator|==
literal|null
operator|&&
name|sort2
operator|.
name|fetch
operator|==
literal|null
condition|)
block|{
name|replaceTop
argument_list|(
name|sort2
operator|.
name|getInput
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|sort
init|=
name|struct
operator|.
name|sortFactory
operator|.
name|createSort
argument_list|(
name|peek
argument_list|()
argument_list|,
name|sort2
operator|.
name|collation
argument_list|,
name|offsetNode
argument_list|,
name|fetchNode
argument_list|)
decl_stmt|;
name|replaceTop
argument_list|(
name|sort
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
if|if
condition|(
name|top
operator|instanceof
name|Project
condition|)
block|{
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|top
decl_stmt|;
if|if
condition|(
name|project
operator|.
name|getInput
argument_list|()
operator|instanceof
name|Sort
condition|)
block|{
specifier|final
name|Sort
name|sort2
init|=
operator|(
name|Sort
operator|)
name|project
operator|.
name|getInput
argument_list|()
decl_stmt|;
if|if
condition|(
name|sort2
operator|.
name|offset
operator|==
literal|null
operator|&&
name|sort2
operator|.
name|fetch
operator|==
literal|null
condition|)
block|{
specifier|final
name|RelNode
name|sort
init|=
name|struct
operator|.
name|sortFactory
operator|.
name|createSort
argument_list|(
name|sort2
operator|.
name|getInput
argument_list|()
argument_list|,
name|sort2
operator|.
name|collation
argument_list|,
name|offsetNode
argument_list|,
name|fetchNode
argument_list|)
decl_stmt|;
name|replaceTop
argument_list|(
name|struct
operator|.
name|projectFactory
operator|.
name|createProject
argument_list|(
name|sort
argument_list|,
name|project
operator|.
name|getHints
argument_list|()
argument_list|,
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|project
operator|.
name|getNamedProjects
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|registrar
operator|.
name|addedFieldCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|project
argument_list|(
name|registrar
operator|.
name|extraNodes
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|sort
init|=
name|struct
operator|.
name|sortFactory
operator|.
name|createSort
argument_list|(
name|peek
argument_list|()
argument_list|,
name|RelCollations
operator|.
name|of
argument_list|(
name|fieldCollations
argument_list|)
argument_list|,
name|offsetNode
argument_list|,
name|fetchNode
argument_list|)
decl_stmt|;
name|replaceTop
argument_list|(
name|sort
argument_list|)
expr_stmt|;
if|if
condition|(
name|registrar
operator|.
name|addedFieldCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|project
argument_list|(
name|registrar
operator|.
name|originalExtraNodes
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
end_function

begin_decl_stmt
specifier|private
specifier|static
name|RelFieldCollation
name|collation
argument_list|(
name|RexNode
name|node
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
name|direction
argument_list|,
name|RelFieldCollation
operator|.
expr|@
name|Nullable
name|NullDirection
name|nullDirection
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraNodes
argument_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|INPUT_REF
case|:
return|return
operator|new
name|RelFieldCollation
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|,
name|direction
argument_list|,
name|Util
operator|.
name|first
argument_list|(
name|nullDirection
argument_list|,
name|direction
operator|.
name|defaultNullDirection
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|DESCENDING
case|:
return|return
name|collation
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
argument_list|,
name|nullDirection
argument_list|,
name|extraNodes
argument_list|)
return|;
case|case
name|NULLS_FIRST
case|:
return|return
name|collation
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|direction
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
argument_list|,
name|extraNodes
argument_list|)
return|;
case|case
name|NULLS_LAST
case|:
return|return
name|collation
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|direction
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
argument_list|,
name|extraNodes
argument_list|)
return|;
default|default:
specifier|final
name|int
name|fieldIndex
init|=
name|extraNodes
operator|.
name|size
argument_list|()
decl_stmt|;
name|extraNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|new
name|RelFieldCollation
argument_list|(
name|fieldIndex
argument_list|,
name|direction
argument_list|,
name|Util
operator|.
name|first
argument_list|(
name|nullDirection
argument_list|,
name|direction
operator|.
name|defaultNullDirection
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/**    * Creates a projection that converts the current relational expression's    * output to a desired row type.    *    *<p>The desired row type and the row type to be converted must have the    * same number of fields.    *    * @param castRowType row type after cast    * @param rename      if true, use field names from castRowType; if false,    *                    preserve field names from rel    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|convert
parameter_list|(
name|RelDataType
name|castRowType
parameter_list|,
name|boolean
name|rename
parameter_list|)
block|{
specifier|final
name|RelNode
name|r
init|=
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|r2
init|=
name|RelOptUtil
operator|.
name|createCastRel
argument_list|(
name|r
argument_list|,
name|castRowType
argument_list|,
name|rename
argument_list|,
name|struct
operator|.
name|projectFactory
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|r2
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_function
specifier|public
name|RelBuilder
name|permute
parameter_list|(
name|Mapping
name|mapping
parameter_list|)
block|{
assert|assert
name|mapping
operator|.
name|getMappingType
argument_list|()
operator|.
name|isSingleSource
argument_list|()
assert|;
assert|assert
name|mapping
operator|.
name|getMappingType
argument_list|()
operator|.
name|isMandatorySource
argument_list|()
assert|;
if|if
condition|(
name|mapping
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
return|return
name|this
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mapping
operator|.
name|getTargetCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprList
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|mapping
operator|.
name|getSource
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|project
argument_list|(
name|exprList
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Creates a {@link Match}. */
end_comment

begin_function
specifier|public
name|RelBuilder
name|match
parameter_list|(
name|RexNode
name|pattern
parameter_list|,
name|boolean
name|strictStart
parameter_list|,
name|boolean
name|strictEnd
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|patternDefinitions
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|measureList
parameter_list|,
name|RexNode
name|after
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
extends|extends
name|SortedSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|subsets
parameter_list|,
name|boolean
name|allRows
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|partitionKeys
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|orderKeys
parameter_list|,
name|RexNode
name|interval
parameter_list|)
block|{
specifier|final
name|Registrar
name|registrar
init|=
operator|new
name|Registrar
argument_list|(
name|fields
argument_list|()
argument_list|,
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
name|registrar
operator|.
name|registerFieldCollations
argument_list|(
name|orderKeys
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|partitionBitSet
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|registrar
operator|.
name|registerExpressions
argument_list|(
name|partitionKeys
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|typeBuilder
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|partitionKey
range|:
name|partitionKeys
control|)
block|{
name|typeBuilder
operator|.
name|add
argument_list|(
name|partitionKey
operator|.
name|toString
argument_list|()
argument_list|,
name|partitionKey
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allRows
condition|)
block|{
for|for
control|(
name|RexNode
name|orderKey
range|:
name|orderKeys
control|)
block|{
if|if
condition|(
operator|!
name|typeBuilder
operator|.
name|nameExists
argument_list|(
name|orderKey
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|typeBuilder
operator|.
name|add
argument_list|(
name|orderKey
operator|.
name|toString
argument_list|()
argument_list|,
name|orderKey
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|RelDataType
name|inputRowType
init|=
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|fs
range|:
name|inputRowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|typeBuilder
operator|.
name|nameExists
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|typeBuilder
operator|.
name|add
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|measures
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|measure
range|:
name|measureList
control|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|measure
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|typeBuilder
operator|.
name|add
argument_list|(
name|alias
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|measures
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|match
init|=
name|struct
operator|.
name|matchFactory
operator|.
name|createMatch
argument_list|(
name|peek
argument_list|()
argument_list|,
name|pattern
argument_list|,
name|typeBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|strictStart
argument_list|,
name|strictEnd
argument_list|,
name|patternDefinitions
argument_list|,
name|measures
operator|.
name|build
argument_list|()
argument_list|,
name|after
argument_list|,
name|subsets
argument_list|,
name|allRows
argument_list|,
name|partitionBitSet
argument_list|,
name|RelCollations
operator|.
name|of
argument_list|(
name|fieldCollations
argument_list|)
argument_list|,
name|interval
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|match
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Creates a Pivot.    *    *<p>To achieve the same effect as the SQL    *    *<blockquote><pre>{@code    * SELECT *    * FROM (SELECT mgr, deptno, job, sal FROM emp)    * PIVOT (SUM(sal) AS ss, COUNT(*) AS c    *     FOR (job, deptno)    *     IN (('CLERK', 10) AS c10, ('MANAGER', 20) AS m20))    * }</pre></blockquote>    *    *<p>use the builder as follows:    *    *<blockquote><pre>{@code    * RelBuilder b;    * b.scan("EMP");    * final RelBuilder.GroupKey groupKey = b.groupKey("MGR");    * final List<RelBuilder.AggCall> aggCalls =    *     Arrays.asList(b.sum(b.field("SAL")).as("SS"),    *         b.count().as("C"));    * final List<RexNode> axes =    *     Arrays.asList(b.field("JOB"),    *         b.field("DEPTNO"));    * final ImmutableMap.Builder<String, List<RexNode>> valueMap =    *     ImmutableMap.builder();    * valueMap.put("C10",    *     Arrays.asList(b.literal("CLERK"), b.literal(10)));    * valueMap.put("M20",    *     Arrays.asList(b.literal("MANAGER"), b.literal(20)));    * b.pivot(groupKey, aggCalls, axes, valueMap.build().entrySet());    * }</pre></blockquote>    *    *<p>Note that the SQL uses a sub-query to project away columns (e.g.    * {@code HIREDATE}) that it does not reference, so that they do not appear in    * the {@code GROUP BY}. You do not need to do that in this API, because the    * {@code groupKey} parameter specifies the keys.    *    *<p>Pivot is implemented by desugaring. The above example becomes the    * following:    *    *<blockquote><pre>{@code    * SELECT mgr,    *     SUM(sal) FILTER (WHERE job = 'CLERK' AND deptno = 10) AS c10_ss,    *     COUNT(*) FILTER (WHERE job = 'CLERK' AND deptno = 10) AS c10_c,    *     SUM(sal) FILTER (WHERE job = 'MANAGER' AND deptno = 20) AS m20_ss,    *      COUNT(*) FILTER (WHERE job = 'MANAGER' AND deptno = 20) AS m20_c    * FROM emp    * GROUP BY mgr    * }</pre></blockquote>    *    * @param groupKey Key columns    * @param aggCalls Aggregate expressions to compute for each value    * @param axes Columns to pivot    * @param values Values to pivot, and the alias for each column group    *    * @return this RelBuilder    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|pivot
parameter_list|(
name|GroupKey
name|groupKey
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|AggCall
argument_list|>
name|aggCalls
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|axes
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
argument_list|>
argument_list|>
name|values
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|axisList
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|axes
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AggCall
argument_list|>
name|multipliedAggCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Pair
operator|.
name|forEach
argument_list|(
name|values
argument_list|,
parameter_list|(
name|alias
parameter_list|,
name|expressions
parameter_list|)
lambda|->
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|expressionList
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|expressions
argument_list|)
decl_stmt|;
if|if
condition|(
name|expressionList
operator|.
name|size
argument_list|()
operator|!=
name|axisList
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"value count must match axis count ["
operator|+
name|expressionList
operator|+
literal|"], ["
operator|+
name|axisList
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|aggCalls
operator|.
name|forEach
argument_list|(
name|aggCall
lambda|->
block|{
specifier|final
name|String
name|alias2
init|=
name|alias
operator|+
literal|"_"
operator|+
operator|(
operator|(
name|AggCallPlus
operator|)
name|aggCall
operator|)
operator|.
name|alias
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Pair
operator|.
name|forEach
argument_list|(
name|axisList
argument_list|,
name|expressionList
argument_list|,
parameter_list|(
name|axis
parameter_list|,
name|expression
parameter_list|)
lambda|->
name|filters
operator|.
name|add
argument_list|(
name|equals
argument_list|(
name|axis
argument_list|,
name|expression
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|multipliedAggCalls
operator|.
name|add
argument_list|(
name|aggCall
operator|.
name|filter
argument_list|(
name|and
argument_list|(
name|filters
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
name|alias2
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
return|return
name|aggregate
argument_list|(
name|groupKey
argument_list|,
name|multipliedAggCalls
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates an Unpivot.    *    *<p>To achieve the same effect as the SQL    *    *<blockquote><pre>{@code    * SELECT *    * FROM (SELECT deptno, job, sal, comm FROM emp)    *   UNPIVOT INCLUDE NULLS (remuneration    *     FOR remuneration_type IN (comm AS 'commission',    *                               sal AS 'salary'))    * }</pre></blockquote>    *    *<p>use the builder as follows:    *    *<blockquote><pre>{@code    * RelBuilder b;    * b.scan("EMP");    * final List<String> measureNames = Arrays.asList("REMUNERATION");    * final List<String> axisNames = Arrays.asList("REMUNERATION_TYPE");    * final Map<List<RexLiteral>, List<RexNode>> axisMap =    *     ImmutableMap.<List<RexLiteral>, List<RexNode>>builder()    *         .put(Arrays.asList(b.literal("commission")),    *             Arrays.asList(b.field("COMM")))    *         .put(Arrays.asList(b.literal("salary")),    *             Arrays.asList(b.field("SAL")))    *         .build();    * b.unpivot(false, measureNames, axisNames, axisMap);    * }</pre></blockquote>    *    *<p>The query generates two columns: {@code remuneration_type} (an axis    * column) and {@code remuneration} (a measure column). Axis columns contain    * values to indicate the source of the row (in this case, {@code 'salary'}    * if the row came from the {@code sal} column, and {@code 'commission'}    * if the row came from the {@code comm} column).    *    * @param includeNulls Whether to include NULL values in the output    * @param measureNames Names of columns to be generated to hold pivoted    *                    measures    * @param axisNames Names of columns to be generated to hold qualifying values    * @param axisMap Mapping from the columns that hold measures to the values    *           that the axis columns will hold in the generated rows    * @return This RelBuilder    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|unpivot
parameter_list|(
name|boolean
name|includeNulls
parameter_list|,
name|Iterable
argument_list|<
name|String
argument_list|>
name|measureNames
parameter_list|,
name|Iterable
argument_list|<
name|String
argument_list|>
name|axisNames
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Map
operator|.
name|Entry
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|?
extends|extends
name|RexLiteral
argument_list|>
argument_list|,
name|?
extends|extends
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
argument_list|>
argument_list|>
name|axisMap
parameter_list|)
block|{
comment|// Make immutable copies of all arguments.
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|measureNameList
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|measureNames
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|axisNameList
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|axisNames
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|List
argument_list|<
name|RexLiteral
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
argument_list|>
name|map
init|=
name|StreamSupport
operator|.
name|stream
argument_list|(
name|axisMap
operator|.
name|spliterator
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|.
name|map
argument_list|(
name|pair
lambda|->
name|Pair
operator|.
block_content|<List<RexLiteral>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
operator|>
name|of
argument_list|(
name|ImmutableList
operator|.
expr|<
name|RexLiteral
operator|>
name|copyOf
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RexNode
operator|>
name|copyOf
argument_list|(
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Util
operator|.
name|toImmutableList
argument_list|()
argument_list|)
decl_stmt|;
comment|// Check that counts match.
name|Pair
operator|.
name|forEach
argument_list|(
name|map
argument_list|,
parameter_list|(
name|valueList
parameter_list|,
name|inputMeasureList
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|inputMeasureList
operator|.
name|size
argument_list|()
operator|!=
name|measureNameList
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Number of measures ("
operator|+
name|inputMeasureList
operator|.
name|size
argument_list|()
operator|+
literal|") must match number of measure names ("
operator|+
name|measureNameList
operator|.
name|size
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|valueList
operator|.
name|size
argument_list|()
operator|!=
name|axisNameList
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Number of axis values ("
operator|+
name|valueList
operator|.
name|size
argument_list|()
operator|+
literal|") match match number of axis names ("
operator|+
name|axisNameList
operator|.
name|size
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|leftRowType
init|=
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|BitSet
name|usedFields
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|Pair
operator|.
name|forEach
argument_list|(
name|map
argument_list|,
parameter_list|(
name|aliases
parameter_list|,
name|nodes
parameter_list|)
lambda|->
name|nodes
operator|.
name|forEach
argument_list|(
name|node
lambda|->
block|{
block_content|if (node instanceof RexInputRef
argument_list|)
block|{
name|usedFields
operator|.
name|set
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
block|;           }
block|}
end_function

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Create "VALUES (('commission'), ('salary')) AS t (remuneration_type)"
end_comment

begin_expr_stmt
name|values
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|map
argument_list|)
argument_list|)
argument_list|,
name|axisNameList
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|final
name|ImmutableBitSet
name|unusedFields
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|leftRowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
operator|.
name|except
argument_list|(
name|ImmutableBitSet
operator|.
name|fromBitSet
argument_list|(
name|usedFields
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fields
argument_list|(
name|unusedFields
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Ord
operator|.
name|forEach
argument_list|(
name|axisNameList
argument_list|,
parameter_list|(
name|dimensionName
parameter_list|,
name|d
parameter_list|)
lambda|->
name|projects
operator|.
name|add
argument_list|(
name|alias
argument_list|(
name|field
argument_list|(
name|leftRowType
operator|.
name|getFieldCount
argument_list|()
operator|+
name|d
argument_list|)
argument_list|,
name|dimensionName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|conditions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Ord
operator|.
name|forEach
argument_list|(
name|measureNameList
argument_list|,
parameter_list|(
name|measureName
parameter_list|,
name|m
parameter_list|)
lambda|->
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|caseOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Pair
operator|.
name|forEach
argument_list|(
name|map
argument_list|,
parameter_list|(
name|literals
parameter_list|,
name|nodes
parameter_list|)
lambda|->
block|{
name|Ord
operator|.
name|forEach
argument_list|(
name|literals
argument_list|,
parameter_list|(
name|literal
parameter_list|,
name|d
parameter_list|)
lambda|->
name|conditions
operator|.
name|add
argument_list|(
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|field
argument_list|(
name|leftRowType
operator|.
name|getFieldCount
argument_list|()
operator|+
name|d
argument_list|)
argument_list|,
name|literal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|caseOperands
operator|.
name|add
argument_list|(
name|and
argument_list|(
name|conditions
argument_list|)
argument_list|)
expr_stmt|;
name|conditions
operator|.
name|clear
argument_list|()
expr_stmt|;
name|caseOperands
operator|.
name|add
argument_list|(
name|nodes
operator|.
name|get
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|caseOperands
operator|.
name|add
argument_list|(
name|literal
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|projects
operator|.
name|add
argument_list|(
name|alias
argument_list|(
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|caseOperands
argument_list|)
argument_list|,
name|measureName
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|project
argument_list|(
name|projects
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if_stmt
if|if
condition|(
operator|!
name|includeNulls
condition|)
block|{
comment|// Add 'WHERE m1 IS NOT NULL OR m2 IS NOT NULL'
specifier|final
name|BitSet
name|notNullFields
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|Ord
operator|.
name|forEach
argument_list|(
name|measureNameList
argument_list|,
parameter_list|(
name|measureName
parameter_list|,
name|m
parameter_list|)
lambda|->
block|{
specifier|final
name|int
name|f
init|=
name|unusedFields
operator|.
name|cardinality
argument_list|()
operator|+
name|axisNameList
operator|.
name|size
argument_list|()
operator|+
name|m
decl_stmt|;
name|conditions
operator|.
name|add
argument_list|(
name|isNotNull
argument_list|(
name|field
argument_list|(
name|f
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|notNullFields
operator|.
name|set
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|filter
argument_list|(
name|or
argument_list|(
name|conditions
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|measureNameList
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// If there is one field, EXCLUDE NULLS will have converted it to NOT
comment|// NULL.
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|builder
init|=
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
decl_stmt|;
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|forEach
argument_list|(
name|field
lambda|->
block|{
specifier|final
name|RelDataType
name|type
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|notNullFields
operator|.
name|get
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
condition|?
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|false
argument_list|)
else|:
name|type
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|convert
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|conditions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_if_stmt

begin_return
return|return
name|this
return|;
end_return

begin_comment
unit|}
comment|/**    * Attaches an array of hints to the stack top relational expression.    *    *<p>The redundant hints would be eliminated.    *    * @param hints Hints    *    * @throws AssertionError if the top relational expression does not implement    * {@link org.apache.calcite.rel.hint.Hintable}    */
end_comment

begin_function
unit|public
name|RelBuilder
name|hints
parameter_list|(
name|RelHint
modifier|...
name|hints
parameter_list|)
block|{
return|return
name|hints
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|hints
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Attaches multiple hints to the stack top relational expression.    *    *<p>The redundant hints would be eliminated.    *    * @param hints Hints    *    * @throws AssertionError if the top relational expression does not implement    * {@link org.apache.calcite.rel.hint.Hintable}    */
end_comment

begin_function
specifier|public
name|RelBuilder
name|hints
parameter_list|(
name|Iterable
argument_list|<
name|RelHint
argument_list|>
name|hints
parameter_list|)
block|{
name|requireNonNull
argument_list|(
name|hints
argument_list|,
literal|"hints"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|relHintList
init|=
name|hints
operator|instanceof
name|List
condition|?
operator|(
name|List
argument_list|<
name|RelHint
argument_list|>
operator|)
name|hints
else|:
name|Lists
operator|.
name|newArrayList
argument_list|(
name|hints
argument_list|)
decl_stmt|;
if|if
condition|(
name|relHintList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|this
return|;
block|}
specifier|final
name|Frame
name|frame
init|=
name|peek_
argument_list|()
decl_stmt|;
assert|assert
name|frame
operator|!=
literal|null
operator|:
literal|"There is no relational expression to attach the hints"
assert|;
assert|assert
name|frame
operator|.
name|rel
operator|instanceof
name|Hintable
operator|:
literal|"The top relational expression is not a Hintable"
assert|;
name|Hintable
name|hintable
init|=
operator|(
name|Hintable
operator|)
name|frame
operator|.
name|rel
decl_stmt|;
name|replaceTop
argument_list|(
name|hintable
operator|.
name|attachHints
argument_list|(
name|relHintList
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Clears the stack.    *    *<p>The builder's state is now the same as when it was created. */
end_comment

begin_function
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|stack
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Information necessary to create a call to an aggregate function.    *    * @see RelBuilder#aggregateCall */
end_comment

begin_interface
specifier|public
interface|interface
name|AggCall
block|{
comment|/** Returns a copy of this AggCall that applies a filter before aggregating      * values. */
name|AggCall
name|filter
parameter_list|(
annotation|@
name|Nullable
name|RexNode
name|condition
parameter_list|)
function_decl|;
comment|/** Returns a copy of this AggCall that sorts its input values by      * {@code orderKeys} before aggregating, as in SQL's {@code WITHIN GROUP}      * clause. */
name|AggCall
name|sort
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|orderKeys
parameter_list|)
function_decl|;
comment|/** Returns a copy of this AggCall that sorts its input values by      * {@code orderKeys} before aggregating, as in SQL's {@code WITHIN GROUP}      * clause. */
name|AggCall
name|sort
parameter_list|(
name|RexNode
modifier|...
name|orderKeys
parameter_list|)
function_decl|;
comment|/** Returns a copy of this AggCall that may return approximate results      * if {@code approximate} is true. */
name|AggCall
name|approximate
parameter_list|(
name|boolean
name|approximate
parameter_list|)
function_decl|;
comment|/** Returns a copy of this AggCall that ignores nulls. */
name|AggCall
name|ignoreNulls
parameter_list|(
name|boolean
name|ignoreNulls
parameter_list|)
function_decl|;
comment|/** Returns a copy of this AggCall with a given alias. */
name|AggCall
name|as
parameter_list|(
annotation|@
name|Nullable
name|String
name|alias
parameter_list|)
function_decl|;
comment|/** Returns a copy of this AggCall that is optionally distinct. */
name|AggCall
name|distinct
parameter_list|(
name|boolean
name|distinct
parameter_list|)
function_decl|;
comment|/** Returns a copy of this AggCall that is distinct. */
specifier|default
name|AggCall
name|distinct
parameter_list|()
block|{
return|return
name|distinct
argument_list|(
literal|true
argument_list|)
return|;
block|}
block|}
end_interface

begin_comment
comment|/** Internal methods shared by all implementations of {@link AggCall}. */
end_comment

begin_interface
specifier|private
interface|interface
name|AggCallPlus
extends|extends
name|AggCall
block|{
comment|/** Returns the aggregate function. */
name|SqlAggFunction
name|op
parameter_list|()
function_decl|;
comment|/** Returns the alias. */
annotation|@
name|Nullable
name|String
name|alias
parameter_list|()
function_decl|;
comment|/** Returns an {@link AggregateCall} that is approximately equivalent      * to this {@code AggCall} and is good for certain things, such as deriving      * field names. */
name|AggregateCall
name|aggregateCall
parameter_list|()
function_decl|;
comment|/** Converts this {@code AggCall} to a good {@link AggregateCall}. */
name|AggregateCall
name|aggregateCall
parameter_list|(
name|Registrar
name|registrar
parameter_list|,
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|RelNode
name|r
parameter_list|)
function_decl|;
comment|/** Registers expressions in operands and filters. */
name|void
name|register
parameter_list|(
name|Registrar
name|registrar
parameter_list|)
function_decl|;
block|}
end_interface

begin_comment
comment|/** Information necessary to create the GROUP BY clause of an Aggregate.    *    * @see RelBuilder#groupKey */
end_comment

begin_interface
specifier|public
interface|interface
name|GroupKey
block|{
comment|/** Assigns an alias to this group key.      *      *<p>Used to assign field names in the {@code group} operation. */
name|GroupKey
name|alias
parameter_list|(
annotation|@
name|Nullable
name|String
name|alias
parameter_list|)
function_decl|;
comment|/** Returns the number of columns in the group key. */
name|int
name|groupKeyCount
parameter_list|()
function_decl|;
block|}
end_interface

begin_comment
comment|/** Implementation of {@link RelBuilder.GroupKey}. */
end_comment

begin_class
specifier|static
class|class
name|GroupKeyImpl
implements|implements
name|GroupKey
block|{
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|nodes
decl_stmt|;
specifier|final
annotation|@
name|Nullable
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
decl_stmt|;
specifier|final
annotation|@
name|Nullable
name|String
name|alias
decl_stmt|;
name|GroupKeyImpl
parameter_list|(
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
annotation|@
name|Nullable
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
parameter_list|,
annotation|@
name|Nullable
name|String
name|alias
parameter_list|)
block|{
name|this
operator|.
name|nodes
operator|=
name|requireNonNull
argument_list|(
name|nodes
argument_list|,
literal|"nodes"
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeLists
operator|=
name|nodeLists
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|alias
operator|==
literal|null
condition|?
name|nodes
operator|.
name|toString
argument_list|()
else|:
name|nodes
operator|+
literal|" as "
operator|+
name|alias
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|groupKeyCount
parameter_list|()
block|{
return|return
name|nodes
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|GroupKey
name|alias
parameter_list|(
annotation|@
name|Nullable
name|String
name|alias
parameter_list|)
block|{
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|alias
argument_list|,
name|alias
argument_list|)
condition|?
name|this
else|:
operator|new
name|GroupKeyImpl
argument_list|(
name|nodes
argument_list|,
name|nodeLists
argument_list|,
name|alias
argument_list|)
return|;
block|}
name|boolean
name|isSimple
parameter_list|()
block|{
return|return
name|nodeLists
operator|==
literal|null
operator|||
name|nodeLists
operator|.
name|size
argument_list|()
operator|==
literal|1
return|;
block|}
block|}
end_class

begin_comment
comment|/** Implementation of {@link AggCall}. */
end_comment

begin_class
specifier|private
class|class
name|AggCallImpl
implements|implements
name|AggCallPlus
block|{
specifier|private
specifier|final
name|SqlAggFunction
name|aggFunction
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|distinct
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|approximate
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|ignoreNulls
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|RexNode
name|filter
decl_stmt|;
comment|// may be null
specifier|private
specifier|final
annotation|@
name|Nullable
name|String
name|alias
decl_stmt|;
comment|// may be null
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|operands
decl_stmt|;
comment|// may be empty, never null
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|orderKeys
decl_stmt|;
comment|// may be empty, never null
name|AggCallImpl
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|boolean
name|approximate
parameter_list|,
name|boolean
name|ignoreNulls
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|filter
parameter_list|,
annotation|@
name|Nullable
name|String
name|alias
parameter_list|,
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|,
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|orderKeys
parameter_list|)
block|{
name|this
operator|.
name|aggFunction
operator|=
name|requireNonNull
argument_list|(
name|aggFunction
argument_list|,
literal|"aggFunction"
argument_list|)
expr_stmt|;
comment|// If the aggregate function ignores DISTINCT,
comment|// make the DISTINCT flag FALSE.
name|this
operator|.
name|distinct
operator|=
name|distinct
operator|&&
name|aggFunction
operator|.
name|getDistinctOptionality
argument_list|()
operator|!=
name|Optionality
operator|.
name|IGNORED
expr_stmt|;
name|this
operator|.
name|approximate
operator|=
name|approximate
expr_stmt|;
name|this
operator|.
name|ignoreNulls
operator|=
name|ignoreNulls
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
name|this
operator|.
name|operands
operator|=
name|requireNonNull
argument_list|(
name|operands
argument_list|,
literal|"operands"
argument_list|)
expr_stmt|;
name|this
operator|.
name|orderKeys
operator|=
name|requireNonNull
argument_list|(
name|orderKeys
argument_list|,
literal|"orderKeys"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|filter
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|BOOLEAN
condition|)
block|{
throw|throw
name|RESOURCE
operator|.
name|filterMustBeBoolean
argument_list|()
operator|.
name|ex
argument_list|()
throw|;
block|}
if|if
condition|(
name|filter
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|filter
operator|=
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
name|aggFunction
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|distinct
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"DISTINCT "
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|iMax
init|=
name|operands
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|iMax
condition|)
block|{
break|break;
block|}
name|b
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" FILTER (WHERE "
argument_list|)
operator|.
name|append
argument_list|(
name|filter
argument_list|)
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlAggFunction
name|op
parameter_list|()
block|{
return|return
name|aggFunction
return|;
block|}
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|String
name|alias
parameter_list|()
block|{
return|return
name|alias
return|;
block|}
annotation|@
name|Override
specifier|public
name|AggregateCall
name|aggregateCall
parameter_list|()
block|{
comment|// Use dummy values for collation and type. This method only promises to
comment|// return a call that is "approximately equivalent ... and is good for
comment|// deriving field names", so dummy values are good enough.
specifier|final
name|RelCollation
name|collation
init|=
name|RelCollations
operator|.
name|EMPTY
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
return|return
name|AggregateCall
operator|.
name|create
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
name|ignoreNulls
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|collation
argument_list|,
name|type
argument_list|,
name|alias
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|AggregateCall
name|aggregateCall
parameter_list|(
name|Registrar
name|registrar
parameter_list|,
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|RelNode
name|r
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|args
init|=
name|registrar
operator|.
name|registerExpressions
argument_list|(
name|this
operator|.
name|operands
argument_list|)
decl_stmt|;
specifier|final
name|int
name|filterArg
init|=
name|this
operator|.
name|filter
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|registrar
operator|.
name|registerExpression
argument_list|(
name|this
operator|.
name|filter
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|distinct
operator|&&
operator|!
name|this
operator|.
name|aggFunction
operator|.
name|isQuantifierAllowed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"DISTINCT not allowed"
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|filter
operator|!=
literal|null
operator|&&
operator|!
name|this
operator|.
name|aggFunction
operator|.
name|allowsFilter
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"FILTER not allowed"
argument_list|)
throw|;
block|}
name|RelCollation
name|collation
init|=
name|RelCollations
operator|.
name|of
argument_list|(
name|this
operator|.
name|orderKeys
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|orderKey
lambda|->
name|collation
argument_list|(
name|orderKey
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|ASCENDING
argument_list|,
literal|null
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggFunction
operator|instanceof
name|SqlCountAggFunction
operator|&&
operator|!
name|distinct
condition|)
block|{
name|args
operator|=
name|args
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|r
operator|::
name|fieldIsNullable
argument_list|)
operator|.
name|collect
argument_list|(
name|Util
operator|.
name|toImmutableList
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|AggregateCall
operator|.
name|create
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
name|ignoreNulls
argument_list|,
name|args
argument_list|,
name|filterArg
argument_list|,
name|collation
argument_list|,
name|groupSet
operator|.
name|cardinality
argument_list|()
argument_list|,
name|r
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|register
parameter_list|(
name|Registrar
name|registrar
parameter_list|)
block|{
name|registrar
operator|.
name|registerExpressions
argument_list|(
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
name|registrar
operator|.
name|registerExpression
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|sort
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|orderKeys
parameter_list|)
block|{
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|orderKeyList
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|orderKeys
argument_list|)
decl_stmt|;
return|return
name|orderKeyList
operator|.
name|equals
argument_list|(
name|this
operator|.
name|orderKeys
argument_list|)
condition|?
name|this
else|:
operator|new
name|AggCallImpl
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
name|ignoreNulls
argument_list|,
name|filter
argument_list|,
name|alias
argument_list|,
name|operands
argument_list|,
name|orderKeyList
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|sort
parameter_list|(
name|RexNode
modifier|...
name|orderKeys
parameter_list|)
block|{
return|return
name|sort
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|orderKeys
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|approximate
parameter_list|(
name|boolean
name|approximate
parameter_list|)
block|{
return|return
name|approximate
operator|==
name|this
operator|.
name|approximate
condition|?
name|this
else|:
operator|new
name|AggCallImpl
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
name|ignoreNulls
argument_list|,
name|filter
argument_list|,
name|alias
argument_list|,
name|operands
argument_list|,
name|orderKeys
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|filter
parameter_list|(
annotation|@
name|Nullable
name|RexNode
name|condition
parameter_list|)
block|{
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|condition
argument_list|,
name|this
operator|.
name|filter
argument_list|)
condition|?
name|this
else|:
operator|new
name|AggCallImpl
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
name|ignoreNulls
argument_list|,
name|condition
argument_list|,
name|alias
argument_list|,
name|operands
argument_list|,
name|orderKeys
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|as
parameter_list|(
annotation|@
name|Nullable
name|String
name|alias
parameter_list|)
block|{
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|alias
argument_list|,
name|this
operator|.
name|alias
argument_list|)
condition|?
name|this
else|:
operator|new
name|AggCallImpl
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
name|ignoreNulls
argument_list|,
name|filter
argument_list|,
name|alias
argument_list|,
name|operands
argument_list|,
name|orderKeys
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|distinct
parameter_list|(
name|boolean
name|distinct
parameter_list|)
block|{
return|return
name|distinct
operator|==
name|this
operator|.
name|distinct
condition|?
name|this
else|:
operator|new
name|AggCallImpl
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
name|ignoreNulls
argument_list|,
name|filter
argument_list|,
name|alias
argument_list|,
name|operands
argument_list|,
name|orderKeys
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|ignoreNulls
parameter_list|(
name|boolean
name|ignoreNulls
parameter_list|)
block|{
return|return
name|ignoreNulls
operator|==
name|this
operator|.
name|ignoreNulls
condition|?
name|this
else|:
operator|new
name|AggCallImpl
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
name|ignoreNulls
argument_list|,
name|filter
argument_list|,
name|alias
argument_list|,
name|operands
argument_list|,
name|orderKeys
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/** Implementation of {@link AggCall} that wraps an    * {@link AggregateCall}. */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|AggCallImpl2
implements|implements
name|AggCallPlus
block|{
specifier|private
specifier|final
name|AggregateCall
name|aggregateCall
decl_stmt|;
name|AggCallImpl2
parameter_list|(
name|AggregateCall
name|aggregateCall
parameter_list|)
block|{
name|this
operator|.
name|aggregateCall
operator|=
name|requireNonNull
argument_list|(
name|aggregateCall
argument_list|,
literal|"aggregateCall"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|aggregateCall
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlAggFunction
name|op
parameter_list|()
block|{
return|return
name|aggregateCall
operator|.
name|getAggregation
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|String
name|alias
parameter_list|()
block|{
return|return
name|aggregateCall
operator|.
name|name
return|;
block|}
annotation|@
name|Override
specifier|public
name|AggregateCall
name|aggregateCall
parameter_list|()
block|{
return|return
name|aggregateCall
return|;
block|}
annotation|@
name|Override
specifier|public
name|AggregateCall
name|aggregateCall
parameter_list|(
name|Registrar
name|registrar
parameter_list|,
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|RelNode
name|r
parameter_list|)
block|{
return|return
name|aggregateCall
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|register
parameter_list|(
name|Registrar
name|registrar
parameter_list|)
block|{
comment|// nothing to do
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|sort
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|orderKeys
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|sort
parameter_list|(
name|RexNode
modifier|...
name|orderKeys
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|approximate
parameter_list|(
name|boolean
name|approximate
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|filter
parameter_list|(
annotation|@
name|Nullable
name|RexNode
name|condition
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|as
parameter_list|(
annotation|@
name|Nullable
name|String
name|alias
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|distinct
parameter_list|(
name|boolean
name|distinct
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|AggCall
name|ignoreNulls
parameter_list|(
name|boolean
name|ignoreNulls
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
end_class

begin_comment
comment|/** Collects the extra expressions needed for {@link #aggregate}.    *    *<p>The extra expressions come from the group key and as arguments to    * aggregate calls, and later there will be a {@link #project} or a    * {@link #rename(List)} if necessary. */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|Registrar
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|originalExtraNodes
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraNodes
decl_stmt|;
specifier|final
name|List
argument_list|<
annotation|@
name|Nullable
name|String
argument_list|>
name|names
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Registrar
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|)
block|{
name|this
argument_list|(
name|fields
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Registrar
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
name|originalExtraNodes
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|extraNodes
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|originalExtraNodes
argument_list|)
expr_stmt|;
name|names
operator|.
name|addAll
argument_list|(
name|fieldNames
argument_list|)
expr_stmt|;
block|}
name|int
name|registerExpression
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|operands
decl_stmt|;
name|int
name|i
init|=
name|registerExpression
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|names
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|RexLiteral
operator|.
name|stringValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
return|;
default|default:
break|break;
block|}
name|int
name|i
init|=
name|extraNodes
operator|.
name|indexOf
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|extraNodes
operator|.
name|size
argument_list|()
expr_stmt|;
name|extraNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|names
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|registerExpressions
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|builder
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|registerExpression
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|registerFieldCollations
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|orderKeys
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|orderKey
range|:
name|orderKeys
control|)
block|{
specifier|final
name|RelFieldCollation
name|collation
init|=
name|collation
argument_list|(
name|orderKey
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|ASCENDING
argument_list|,
literal|null
argument_list|,
name|extraNodes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|RelCollations
operator|.
name|ordinals
argument_list|(
name|fieldCollations
argument_list|)
operator|.
name|contains
argument_list|(
name|collation
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
condition|)
block|{
name|fieldCollations
operator|.
name|add
argument_list|(
name|collation
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|fieldCollations
argument_list|)
return|;
block|}
comment|/** Returns the number of fields added. */
name|int
name|addedFieldCount
parameter_list|()
block|{
return|return
name|extraNodes
operator|.
name|size
argument_list|()
operator|-
name|originalExtraNodes
operator|.
name|size
argument_list|()
return|;
block|}
block|}
end_class

begin_comment
comment|/** Builder stack frame.    *    *<p>Describes a previously created relational expression and    * information about how table aliases map into its row type. */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|Frame
block|{
specifier|final
name|RelNode
name|rel
decl_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|Field
argument_list|>
name|fields
decl_stmt|;
specifier|private
name|Frame
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|ImmutableList
argument_list|<
name|Field
argument_list|>
name|fields
parameter_list|)
block|{
name|this
operator|.
name|rel
operator|=
name|rel
expr_stmt|;
name|this
operator|.
name|fields
operator|=
name|fields
expr_stmt|;
block|}
specifier|private
name|Frame
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|String
name|tableAlias
init|=
name|deriveAlias
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Field
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|ImmutableSet
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|tableAlias
operator|==
literal|null
condition|?
name|ImmutableSet
operator|.
name|of
argument_list|()
else|:
name|ImmutableSet
operator|.
name|of
argument_list|(
name|tableAlias
argument_list|)
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|aliases
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|rel
operator|=
name|rel
expr_stmt|;
name|this
operator|.
name|fields
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|rel
operator|+
literal|": "
operator|+
name|fields
return|;
block|}
specifier|private
specifier|static
annotation|@
name|Nullable
name|String
name|deriveAlias
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|TableScan
condition|)
block|{
name|TableScan
name|scan
init|=
operator|(
name|TableScan
operator|)
name|rel
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|scan
operator|.
name|getTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|names
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Util
operator|.
name|last
argument_list|(
name|names
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
parameter_list|()
block|{
return|return
name|Pair
operator|.
name|right
argument_list|(
name|fields
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/** A field that belongs to a stack {@link Frame}. */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|Field
extends|extends
name|Pair
argument_list|<
name|ImmutableSet
argument_list|<
name|String
argument_list|>
argument_list|,
name|RelDataTypeField
argument_list|>
block|{
name|Field
parameter_list|(
name|ImmutableSet
argument_list|<
name|String
argument_list|>
name|left
parameter_list|,
name|RelDataTypeField
name|right
parameter_list|)
block|{
name|super
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
name|Field
name|addAlias
parameter_list|(
name|String
name|alias
parameter_list|)
block|{
if|if
condition|(
name|left
operator|.
name|contains
argument_list|(
name|alias
argument_list|)
condition|)
block|{
return|return
name|this
return|;
block|}
specifier|final
name|ImmutableSet
argument_list|<
name|String
argument_list|>
name|aliasList
init|=
name|ImmutableSet
operator|.
expr|<
name|String
operator|>
name|builder
argument_list|()
operator|.
name|addAll
argument_list|(
name|left
argument_list|)
operator|.
name|add
argument_list|(
name|alias
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
operator|new
name|Field
argument_list|(
name|aliasList
argument_list|,
name|right
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/** Shuttle that shifts a predicate's inputs to the left, replacing early    * ones with references to a    * {@link RexCorrelVariable}. */
end_comment

begin_class
specifier|private
class|class
name|Shifter
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|RelNode
name|left
decl_stmt|;
specifier|private
specifier|final
name|CorrelationId
name|id
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|right
decl_stmt|;
name|Shifter
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|CorrelationId
name|id
parameter_list|,
name|RelNode
name|right
parameter_list|)
block|{
name|this
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|right
operator|=
name|right
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
specifier|final
name|RelDataType
name|leftRowType
init|=
name|left
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|int
name|leftCount
init|=
name|leftRowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|<
name|leftCount
condition|)
block|{
specifier|final
name|RexNode
name|v
init|=
name|rexBuilder
operator|.
name|makeCorrel
argument_list|(
name|leftRowType
argument_list|,
name|id
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|v
argument_list|,
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|right
argument_list|,
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|-
name|leftCount
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|/** Configuration of RelBuilder.    *    *<p>It is immutable, and all fields are public.    *    *<p>Start with the {@link #DEFAULT} instance,    * and call {@code withXxx} methods to set its properties. */
end_comment

begin_interface
specifier|public
interface|interface
name|Config
block|{
comment|/** Default configuration. */
name|Config
name|DEFAULT
init|=
name|ImmutableBeans
operator|.
name|create
argument_list|(
name|Config
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|static
name|ConfigBuilder
name|builder
parameter_list|()
block|{
return|return
name|DEFAULT
operator|.
name|toBuilder
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|default
name|ConfigBuilder
name|toBuilder
parameter_list|()
block|{
return|return
operator|new
name|ConfigBuilder
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/** Controls whether to merge two {@link Project} operators when inlining      * expressions causes complexity to increase.      *      *<p>Usually merging projects is beneficial, but occasionally the      * result is more complex than the original projects. Consider:      *      *<pre>      * P: Project(a+b+c AS x, d+e+f AS y, g+h+i AS z)  # complexity 15      * Q: Project(x*y*z AS p, x-y-z AS q)              # complexity 10      * R: Project((a+b+c)*(d+e+f)*(g+h+i) AS s,      *            (a+b+c)-(d+e+f)-(g+h+i) AS t)        # complexity 34      *</pre>      *      * The complexity of an expression is the number of nodes (leaves and      * operators). For example, {@code a+b+c} has complexity 5 (3 field      * references and 2 calls):      *      *<pre>      *       +      *      /  \      *     +    c      *    / \      *   a   b      *</pre>      *      *<p>A negative value never allows merges.      *      *<p>A zero or positive value, {@code bloat}, allows a merge if complexity      * of the result is less than or equal to the sum of the complexity of the      * originals plus {@code bloat}.      *      *<p>The default value, 100, allows a moderate increase in complexity but      * prevents cases where complexity would run away into the millions and run      * out of memory. Moderate complexity is OK; the implementation, say via      * {@link org.apache.calcite.adapter.enumerable.EnumerableCalc}, will often      * gather common sub-expressions and compute them only once.      */
annotation|@
name|ImmutableBeans
operator|.
name|Property
annotation|@
name|ImmutableBeans
operator|.
name|IntDefault
argument_list|(
literal|100
argument_list|)
name|int
name|bloat
parameter_list|()
function_decl|;
comment|/** Sets {@link #bloat}. */
name|Config
name|withBloat
parameter_list|(
name|int
name|bloat
parameter_list|)
function_decl|;
comment|/** Whether {@link RelBuilder#aggregate} should eliminate duplicate      * aggregate calls; default true. */
annotation|@
name|ImmutableBeans
operator|.
name|Property
annotation|@
name|ImmutableBeans
operator|.
name|BooleanDefault
argument_list|(
literal|true
argument_list|)
name|boolean
name|dedupAggregateCalls
parameter_list|()
function_decl|;
comment|/** Sets {@link #dedupAggregateCalls}. */
name|Config
name|withDedupAggregateCalls
parameter_list|(
name|boolean
name|dedupAggregateCalls
parameter_list|)
function_decl|;
comment|/** Whether {@link RelBuilder#aggregate} should prune unused      * input columns; default true. */
annotation|@
name|ImmutableBeans
operator|.
name|Property
annotation|@
name|ImmutableBeans
operator|.
name|BooleanDefault
argument_list|(
literal|true
argument_list|)
name|boolean
name|pruneInputOfAggregate
parameter_list|()
function_decl|;
comment|/** Sets {@link #pruneInputOfAggregate}. */
name|Config
name|withPruneInputOfAggregate
parameter_list|(
name|boolean
name|pruneInputOfAggregate
parameter_list|)
function_decl|;
comment|/** Whether to push down join conditions; default false (but      * {@link SqlToRelConverter#config()} by default sets this to true). */
annotation|@
name|ImmutableBeans
operator|.
name|Property
annotation|@
name|ImmutableBeans
operator|.
name|BooleanDefault
argument_list|(
literal|false
argument_list|)
name|boolean
name|pushJoinCondition
parameter_list|()
function_decl|;
comment|/** Sets {@link #pushJoinCondition()}. */
name|Config
name|withPushJoinCondition
parameter_list|(
name|boolean
name|pushJoinCondition
parameter_list|)
function_decl|;
comment|/** Whether to simplify expressions; default true. */
annotation|@
name|ImmutableBeans
operator|.
name|Property
annotation|@
name|ImmutableBeans
operator|.
name|BooleanDefault
argument_list|(
literal|true
argument_list|)
name|boolean
name|simplify
parameter_list|()
function_decl|;
comment|/** Sets {@link #simplify}. */
name|Config
name|withSimplify
parameter_list|(
name|boolean
name|simplify
parameter_list|)
function_decl|;
comment|/** Whether to simplify LIMIT 0 to an empty relation; default true. */
annotation|@
name|ImmutableBeans
operator|.
name|Property
annotation|@
name|ImmutableBeans
operator|.
name|BooleanDefault
argument_list|(
literal|true
argument_list|)
name|boolean
name|simplifyLimit
parameter_list|()
function_decl|;
comment|/** Sets {@link #simplifyLimit()}. */
name|Config
name|withSimplifyLimit
parameter_list|(
name|boolean
name|simplifyLimit
parameter_list|)
function_decl|;
comment|/** Whether to simplify {@code Union(Values, Values)} or      * {@code Union(Project(Values))} to {@code Values}; default true. */
annotation|@
name|ImmutableBeans
operator|.
name|Property
annotation|@
name|ImmutableBeans
operator|.
name|BooleanDefault
argument_list|(
literal|true
argument_list|)
name|boolean
name|simplifyValues
parameter_list|()
function_decl|;
comment|/** Sets {@link #simplifyValues()}. */
name|Config
name|withSimplifyValues
parameter_list|(
name|boolean
name|simplifyValues
parameter_list|)
function_decl|;
comment|/** Whether to create an Aggregate even if we know that the input is      * already unique; default false. */
annotation|@
name|ImmutableBeans
operator|.
name|Property
annotation|@
name|ImmutableBeans
operator|.
name|BooleanDefault
argument_list|(
literal|false
argument_list|)
name|boolean
name|aggregateUnique
parameter_list|()
function_decl|;
comment|/** Sets {@link #aggregateUnique()}. */
name|Config
name|withAggregateUnique
parameter_list|(
name|boolean
name|aggregateUnique
parameter_list|)
function_decl|;
block|}
end_interface

begin_comment
comment|/** Creates a {@link RelBuilder.Config}.    *    * @deprecated Use the {@code withXxx} methods in    * {@link RelBuilder.Config}. */
end_comment

begin_class
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
class|class
name|ConfigBuilder
block|{
specifier|private
name|Config
name|config
decl_stmt|;
specifier|private
name|ConfigBuilder
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
block|}
comment|/** Creates a {@link RelBuilder.Config}. */
specifier|public
name|Config
name|build
parameter_list|()
block|{
return|return
name|config
return|;
block|}
comment|/** Sets the value that will become      * {@link org.apache.calcite.tools.RelBuilder.Config#dedupAggregateCalls}. */
specifier|public
name|ConfigBuilder
name|withDedupAggregateCalls
parameter_list|(
name|boolean
name|dedupAggregateCalls
parameter_list|)
block|{
name|config
operator|=
name|config
operator|.
name|withDedupAggregateCalls
argument_list|(
name|dedupAggregateCalls
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Sets the value that will become      * {@link org.apache.calcite.tools.RelBuilder.Config#simplify}. */
specifier|public
name|ConfigBuilder
name|withSimplify
parameter_list|(
name|boolean
name|simplify
parameter_list|)
block|{
name|config
operator|=
name|config
operator|.
name|withSimplify
argument_list|(
name|simplify
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
end_class

unit|}
end_unit

