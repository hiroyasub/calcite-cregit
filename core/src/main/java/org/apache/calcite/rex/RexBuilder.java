begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|DateTimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|Spaces
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|SqlFunctions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIntervalQualifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSpecialOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlCountAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|ArraySqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|IntervalSqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|MapSqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NlsString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Factory for row expressions.  *  *<p>Some common literal values (NULL, TRUE, FALSE, 0, 1, '') are cached.</p>  */
end_comment

begin_class
specifier|public
class|class
name|RexBuilder
block|{
comment|/**    * Special operator that accesses an unadvertised field of an input record.    * This operator cannot be used in SQL queries; it is introduced temporarily    * during sql-to-rel translation, then replaced during the process that    * trims unwanted fields.    */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|GET_OPERATOR
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"_get"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Function
argument_list|<
name|RelDataTypeField
argument_list|,
name|RexInputRef
argument_list|>
name|TO_INPUT_REF
init|=
operator|new
name|Function
argument_list|<
name|RelDataTypeField
argument_list|,
name|RexInputRef
argument_list|>
argument_list|()
block|{
specifier|public
name|RexInputRef
name|apply
parameter_list|(
name|RelDataTypeField
name|input
parameter_list|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|input
operator|.
name|getIndex
argument_list|()
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|protected
specifier|final
name|RelDataTypeFactory
name|typeFactory
decl_stmt|;
specifier|private
specifier|final
name|RexLiteral
name|booleanTrue
decl_stmt|;
specifier|private
specifier|final
name|RexLiteral
name|booleanFalse
decl_stmt|;
specifier|private
specifier|final
name|RexLiteral
name|charEmpty
decl_stmt|;
specifier|private
specifier|final
name|RexLiteral
name|constantNull
decl_stmt|;
specifier|private
specifier|final
name|SqlStdOperatorTable
name|opTab
init|=
name|SqlStdOperatorTable
operator|.
name|instance
argument_list|()
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a RexBuilder.    *    * @param typeFactory Type factory    */
specifier|public
name|RexBuilder
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
name|this
operator|.
name|typeFactory
operator|=
name|typeFactory
expr_stmt|;
name|this
operator|.
name|booleanTrue
operator|=
name|makeLiteral
argument_list|(
name|Boolean
operator|.
name|TRUE
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
expr_stmt|;
name|this
operator|.
name|booleanFalse
operator|=
name|makeLiteral
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
expr_stmt|;
name|this
operator|.
name|charEmpty
operator|=
name|makeLiteral
argument_list|(
operator|new
name|NlsString
argument_list|(
literal|""
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|CHAR
argument_list|)
expr_stmt|;
name|this
operator|.
name|constantNull
operator|=
name|makeLiteral
argument_list|(
literal|null
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a list of {@link org.apache.calcite.rex.RexInputRef} expressions,    * projecting the fields of a given record type. */
specifier|public
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|identityProjects
parameter_list|(
specifier|final
name|RelDataType
name|rowType
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|TO_INPUT_REF
argument_list|)
return|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Returns this RexBuilder's type factory    *    * @return type factory    */
specifier|public
name|RelDataTypeFactory
name|getTypeFactory
parameter_list|()
block|{
return|return
name|typeFactory
return|;
block|}
comment|/**    * Returns this RexBuilder's operator table    *    * @return operator table    */
specifier|public
name|SqlStdOperatorTable
name|getOpTab
parameter_list|()
block|{
return|return
name|opTab
return|;
block|}
comment|/**    * Creates an expression accessing a given named field from a record.    *    *<p>NOTE: Be careful choosing the value of {@code caseSensitive}.    * If the field name was supplied by an end-user (e.g. as a column alias in    * SQL), use your session's case-sensitivity setting.    * Only hard-code {@code true} if you are sure that the field name is    * internally generated.    * Hard-coding {@code false} is almost certainly wrong.</p>    *    * @param expr      Expression yielding a record    * @param fieldName Name of field in record    * @param caseSensitive Whether match is case-sensitive    * @return Expression accessing a given named field    */
specifier|public
name|RexNode
name|makeFieldAccess
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|expr
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeField
name|field
init|=
name|type
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|,
name|caseSensitive
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Type '"
operator|+
name|type
operator|+
literal|"' has no field '"
operator|+
name|fieldName
operator|+
literal|"'"
argument_list|)
throw|;
block|}
return|return
name|makeFieldAccessInternal
argument_list|(
name|expr
argument_list|,
name|field
argument_list|)
return|;
block|}
comment|/**    * Creates an expression accessing a field with a given ordinal from a    * record.    *    * @param expr Expression yielding a record    * @param i    Ordinal of field    * @return Expression accessing given field    */
specifier|public
name|RexNode
name|makeFieldAccess
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|int
name|i
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|expr
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|type
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|>=
name|fields
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Field ordinal "
operator|+
name|i
operator|+
literal|" is invalid for "
operator|+
literal|" type '"
operator|+
name|type
operator|+
literal|"'"
argument_list|)
throw|;
block|}
return|return
name|makeFieldAccessInternal
argument_list|(
name|expr
argument_list|,
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates an expression accessing a given field from a record.    *    * @param expr  Expression yielding a record    * @param field Field    * @return Expression accessing given field    */
specifier|private
name|RexNode
name|makeFieldAccessInternal
parameter_list|(
name|RexNode
name|expr
parameter_list|,
specifier|final
name|RelDataTypeField
name|field
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|RexRangeRef
condition|)
block|{
name|RexRangeRef
name|range
init|=
operator|(
name|RexRangeRef
operator|)
name|expr
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getIndex
argument_list|()
operator|<
literal|0
condition|)
block|{
return|return
name|makeCall
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|GET_OPERATOR
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|expr
argument_list|,
name|makeLiteral
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|new
name|RexInputRef
argument_list|(
name|range
operator|.
name|getOffset
argument_list|()
operator|+
name|field
operator|.
name|getIndex
argument_list|()
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
return|return
operator|new
name|RexFieldAccess
argument_list|(
name|expr
argument_list|,
name|field
argument_list|)
return|;
block|}
comment|/**    * Creates a call with a list of arguments and a predetermined type.    */
specifier|public
name|RexNode
name|makeCall
parameter_list|(
name|RelDataType
name|returnType
parameter_list|,
name|SqlOperator
name|op
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|)
block|{
return|return
operator|new
name|RexCall
argument_list|(
name|returnType
argument_list|,
name|op
argument_list|,
name|exprs
argument_list|)
return|;
block|}
comment|/**    * Creates a call with an array of arguments.    *    *<p>If you already know the return type of the call, then    * {@link #makeCall(org.apache.calcite.rel.type.RelDataType, org.apache.calcite.sql.SqlOperator, java.util.List)}    * is preferred.</p>    */
specifier|public
name|RexNode
name|makeCall
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|deriveReturnType
argument_list|(
name|op
argument_list|,
name|exprs
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexCall
argument_list|(
name|type
argument_list|,
name|op
argument_list|,
name|exprs
argument_list|)
return|;
block|}
comment|/**    * Creates a call with a list of arguments.    *    *<p>Equivalent to    *<code>makeCall(op, exprList.toArray(new RexNode[exprList.size()]))</code>.    */
specifier|public
specifier|final
name|RexNode
name|makeCall
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|RexNode
modifier|...
name|exprs
parameter_list|)
block|{
return|return
name|makeCall
argument_list|(
name|op
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|exprs
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Derives the return type of a call to an operator.    *    * @param op          the operator being called    * @param exprs       actual operands    * @return derived type    */
specifier|public
name|RelDataType
name|deriveReturnType
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|)
block|{
return|return
name|op
operator|.
name|inferReturnType
argument_list|(
operator|new
name|RexCallBinding
argument_list|(
name|typeFactory
argument_list|,
name|op
argument_list|,
name|exprs
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RelCollation
operator|>
name|of
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a reference to an aggregate call, checking for repeated calls.    *    *<p>Argument types help to optimize for repeated aggregates.    * For instance count(42) is equivalent to count(*).</p>    *    * @param aggCall aggregate call to be added    * @param groupCount number of groups in the aggregate relation    * @param indicator Whether the Aggregate has indicator (GROUPING) columns    * @param aggCalls destination list of aggregate calls    * @param aggCallMapping the dictionary of already added calls    * @param aggArgTypes Argument types, not null    *    * @return Rex expression for the given aggregate call    */
specifier|public
name|RexNode
name|addAggCall
parameter_list|(
name|AggregateCall
name|aggCall
parameter_list|,
name|int
name|groupCount
parameter_list|,
name|boolean
name|indicator
parameter_list|,
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
parameter_list|,
name|Map
argument_list|<
name|AggregateCall
argument_list|,
name|RexNode
argument_list|>
name|aggCallMapping
parameter_list|,
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|aggArgTypes
parameter_list|)
block|{
if|if
condition|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
operator|instanceof
name|SqlCountAggFunction
operator|&&
operator|!
name|aggCall
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|args
init|=
name|aggCall
operator|.
name|getArgList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|nullableArgs
init|=
name|nullableArgs
argument_list|(
name|args
argument_list|,
name|aggArgTypes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nullableArgs
operator|.
name|equals
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|aggCall
operator|=
name|aggCall
operator|.
name|copy
argument_list|(
name|nullableArgs
argument_list|,
name|aggCall
operator|.
name|filterArg
argument_list|)
expr_stmt|;
block|}
block|}
name|RexNode
name|rex
init|=
name|aggCallMapping
operator|.
name|get
argument_list|(
name|aggCall
argument_list|)
decl_stmt|;
if|if
condition|(
name|rex
operator|==
literal|null
condition|)
block|{
name|int
name|index
init|=
name|aggCalls
operator|.
name|size
argument_list|()
operator|+
name|groupCount
operator|*
operator|(
name|indicator
condition|?
literal|2
else|:
literal|1
operator|)
decl_stmt|;
name|aggCalls
operator|.
name|add
argument_list|(
name|aggCall
argument_list|)
expr_stmt|;
name|rex
operator|=
name|makeInputRef
argument_list|(
name|aggCall
operator|.
name|getType
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|aggCallMapping
operator|.
name|put
argument_list|(
name|aggCall
argument_list|,
name|rex
argument_list|)
expr_stmt|;
block|}
return|return
name|rex
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|nullableArgs
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|list0
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|Integer
argument_list|,
name|RelDataType
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|list0
argument_list|,
name|types
argument_list|)
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|right
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|pair
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**    * Creates a call to a windowed agg.    */
specifier|public
name|RexNode
name|makeOver
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|SqlAggFunction
name|operator
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|partitionKeys
parameter_list|,
name|ImmutableList
argument_list|<
name|RexFieldCollation
argument_list|>
name|orderKeys
parameter_list|,
name|RexWindowBound
name|lowerBound
parameter_list|,
name|RexWindowBound
name|upperBound
parameter_list|,
name|boolean
name|physical
parameter_list|,
name|boolean
name|allowPartial
parameter_list|,
name|boolean
name|nullWhenCountZero
parameter_list|)
block|{
assert|assert
name|operator
operator|!=
literal|null
assert|;
assert|assert
name|exprs
operator|!=
literal|null
assert|;
assert|assert
name|partitionKeys
operator|!=
literal|null
assert|;
assert|assert
name|orderKeys
operator|!=
literal|null
assert|;
specifier|final
name|RexWindow
name|window
init|=
name|makeWindow
argument_list|(
name|partitionKeys
argument_list|,
name|orderKeys
argument_list|,
name|lowerBound
argument_list|,
name|upperBound
argument_list|,
name|physical
argument_list|)
decl_stmt|;
specifier|final
name|RexOver
name|over
init|=
operator|new
name|RexOver
argument_list|(
name|type
argument_list|,
name|operator
argument_list|,
name|exprs
argument_list|,
name|window
argument_list|)
decl_stmt|;
name|RexNode
name|result
init|=
name|over
decl_stmt|;
comment|// This should be correct but need time to go over test results.
comment|// Also want to look at combing with section below.
if|if
condition|(
name|nullWhenCountZero
condition|)
block|{
specifier|final
name|RelDataType
name|bigintType
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
name|result
operator|=
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
operator|new
name|RexOver
argument_list|(
name|bigintType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
name|exprs
argument_list|,
name|window
argument_list|)
argument_list|,
name|makeLiteral
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|,
name|bigintType
argument_list|,
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|)
argument_list|)
argument_list|,
name|ensureType
argument_list|(
name|type
argument_list|,
comment|// SUM0 is non-nullable, thus need a cast
operator|new
name|RexOver
argument_list|(
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|false
argument_list|)
argument_list|,
name|operator
argument_list|,
name|exprs
argument_list|,
name|window
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|,
name|makeCast
argument_list|(
name|type
argument_list|,
name|constantNull
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|allowPartial
condition|)
block|{
name|Util
operator|.
name|permAssert
argument_list|(
name|physical
argument_list|,
literal|"DISALLOW PARTIAL over RANGE"
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|bigintType
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
comment|// todo: read bound
name|result
operator|=
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|,
operator|new
name|RexOver
argument_list|(
name|bigintType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RexNode
operator|>
name|of
argument_list|()
argument_list|,
name|window
argument_list|)
argument_list|,
name|makeLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
argument_list|,
name|bigintType
argument_list|,
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|,
name|constantNull
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Creates a window specification.    *    * @param partitionKeys Partition keys    * @param orderKeys     Order keys    * @param lowerBound    Lower bound    * @param upperBound    Upper bound    * @param isRows        Whether physical. True if row-based, false if    *                      range-based    * @return window specification    */
specifier|public
name|RexWindow
name|makeWindow
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|partitionKeys
parameter_list|,
name|ImmutableList
argument_list|<
name|RexFieldCollation
argument_list|>
name|orderKeys
parameter_list|,
name|RexWindowBound
name|lowerBound
parameter_list|,
name|RexWindowBound
name|upperBound
parameter_list|,
name|boolean
name|isRows
parameter_list|)
block|{
return|return
operator|new
name|RexWindow
argument_list|(
name|partitionKeys
argument_list|,
name|orderKeys
argument_list|,
name|lowerBound
argument_list|,
name|upperBound
argument_list|,
name|isRows
argument_list|)
return|;
block|}
comment|/**    * Creates a constant for the SQL<code>NULL</code> value.    */
specifier|public
name|RexLiteral
name|constantNull
parameter_list|()
block|{
return|return
name|constantNull
return|;
block|}
comment|/**    * Creates an expression referencing a correlation variable.    *    * @param type Type of variable    * @param name Name of variable    * @return Correlation variable    */
specifier|public
name|RexNode
name|makeCorrel
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
operator|new
name|RexCorrelVariable
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**    * Creates an invocation of the NEW operator.    *    * @param type  Type to be instantiated    * @param exprs Arguments to NEW operator    * @return Expression invoking NEW operator    */
specifier|public
name|RexNode
name|makeNewInvocation
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|)
block|{
return|return
operator|new
name|RexCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|NEW
argument_list|,
name|exprs
argument_list|)
return|;
block|}
comment|/**    * Creates a call to the CAST operator, expanding if possible.    *    * @param type Type to cast to    * @param exp  Expression being cast    * @return Call to CAST operator    */
specifier|public
name|RexNode
name|makeCast
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
specifier|final
name|SqlTypeName
name|sqlType
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|exp
operator|instanceof
name|RexLiteral
condition|)
block|{
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|exp
decl_stmt|;
name|Comparable
name|value
init|=
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|RexLiteral
operator|.
name|valueMatchesType
argument_list|(
name|value
argument_list|,
name|sqlType
argument_list|,
literal|false
argument_list|)
operator|&&
operator|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|literal
operator|.
name|getTypeName
argument_list|()
operator|||
operator|!
name|SqlTypeFamily
operator|.
name|DATETIME
operator|.
name|getTypeNames
argument_list|()
operator|.
name|contains
argument_list|(
name|literal
operator|.
name|getTypeName
argument_list|()
argument_list|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|value
operator|instanceof
name|NlsString
operator|)
operator|||
operator|(
name|type
operator|.
name|getPrecision
argument_list|()
operator|>=
operator|(
operator|(
name|NlsString
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
operator|.
name|length
argument_list|()
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|value
operator|instanceof
name|ByteString
operator|)
operator|||
operator|(
name|type
operator|.
name|getPrecision
argument_list|()
operator|>=
operator|(
operator|(
name|ByteString
operator|)
name|value
operator|)
operator|.
name|length
argument_list|()
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
condition|)
block|{
case|case
name|CHAR
case|:
if|if
condition|(
name|value
operator|instanceof
name|NlsString
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|NlsString
operator|)
name|value
operator|)
operator|.
name|rtrim
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TIMESTAMP
case|:
case|case
name|TIME
case|:
specifier|final
name|Calendar
name|calendar
init|=
operator|(
name|Calendar
operator|)
name|value
decl_stmt|;
name|int
name|scale
init|=
name|type
operator|.
name|getScale
argument_list|()
decl_stmt|;
if|if
condition|(
name|scale
operator|==
name|RelDataType
operator|.
name|SCALE_NOT_SPECIFIED
condition|)
block|{
name|scale
operator|=
literal|0
expr_stmt|;
block|}
name|calendar
operator|.
name|setTimeInMillis
argument_list|(
name|SqlFunctions
operator|.
name|round
argument_list|(
name|calendar
operator|.
name|getTimeInMillis
argument_list|()
argument_list|,
name|DateTimeUtils
operator|.
name|powerX
argument_list|(
literal|10
argument_list|,
literal|3
operator|-
name|scale
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTERVAL_DAY_TIME
case|:
name|BigDecimal
name|value2
init|=
operator|(
name|BigDecimal
operator|)
name|value
decl_stmt|;
specifier|final
name|long
name|multiplier
init|=
name|literal
operator|.
name|getType
argument_list|()
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getStartUnit
argument_list|()
operator|.
name|multiplier
decl_stmt|;
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
comment|// Not all types are allowed for literals
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|INTEGER
case|:
name|typeName
operator|=
name|SqlTypeName
operator|.
name|BIGINT
expr_stmt|;
block|}
return|return
name|makeLiteral
argument_list|(
name|value2
operator|.
name|divide
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|multiplier
argument_list|)
argument_list|,
literal|0
argument_list|,
name|BigDecimal
operator|.
name|ROUND_HALF_DOWN
argument_list|)
argument_list|,
name|type
argument_list|,
name|typeName
argument_list|)
return|;
block|}
return|return
name|makeLiteral
argument_list|(
name|value
argument_list|,
name|type
argument_list|,
name|literal
operator|.
name|getTypeName
argument_list|()
argument_list|)
return|;
block|}
block|}
if|else if
condition|(
name|SqlTypeUtil
operator|.
name|isInterval
argument_list|(
name|type
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|exp
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|makeCastExactToInterval
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|else if
condition|(
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isInterval
argument_list|(
name|exp
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|makeCastIntervalToExact
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|else if
condition|(
name|sqlType
operator|==
name|SqlTypeName
operator|.
name|BOOLEAN
operator|&&
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|exp
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|makeCastExactToBoolean
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|else if
condition|(
name|exp
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|BOOLEAN
operator|&&
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|makeCastBooleanToExact
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
return|return
name|makeAbstractCast
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|makeCastExactToBoolean
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
return|return
name|makeCall
argument_list|(
name|toType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|exp
argument_list|,
name|makeZeroLiteral
argument_list|(
name|exp
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|makeCastBooleanToExact
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
specifier|final
name|RexNode
name|casted
init|=
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|exp
argument_list|,
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|,
name|toType
argument_list|)
argument_list|,
name|makeZeroLiteral
argument_list|(
name|toType
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|exp
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
name|casted
return|;
block|}
return|return
name|makeCall
argument_list|(
name|toType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RexNode
operator|>
name|of
argument_list|(
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|exp
argument_list|)
argument_list|,
name|casted
argument_list|,
name|makeNullLiteral
argument_list|(
name|toType
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|makeCastIntervalToExact
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
name|IntervalSqlType
name|intervalType
init|=
operator|(
name|IntervalSqlType
operator|)
name|exp
operator|.
name|getType
argument_list|()
decl_stmt|;
name|TimeUnit
name|endUnit
init|=
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getEndUnit
argument_list|()
decl_stmt|;
if|if
condition|(
name|endUnit
operator|==
literal|null
condition|)
block|{
name|endUnit
operator|=
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getStartUnit
argument_list|()
expr_stmt|;
block|}
name|int
name|scale
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|endUnit
operator|==
name|TimeUnit
operator|.
name|SECOND
condition|)
block|{
name|scale
operator|=
name|Math
operator|.
name|min
argument_list|(
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getFractionalSecondPrecision
argument_list|(
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|BigDecimal
name|multiplier
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|endUnit
operator|.
name|multiplier
argument_list|)
operator|.
name|divide
argument_list|(
name|BigDecimal
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|scale
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|value
init|=
name|decodeIntervalOrDecimal
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|multiplier
operator|.
name|longValue
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|value
operator|=
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DIVIDE_INTEGER
argument_list|,
name|value
argument_list|,
name|makeBigintLiteral
argument_list|(
name|multiplier
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scale
operator|>
literal|0
condition|)
block|{
name|RelDataType
name|decimalType
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
name|scale
operator|+
name|intervalType
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|value
operator|=
name|encodeIntervalOrDecimal
argument_list|(
name|value
argument_list|,
name|decimalType
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|ensureType
argument_list|(
name|toType
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|makeCastExactToInterval
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
name|IntervalSqlType
name|intervalType
init|=
operator|(
name|IntervalSqlType
operator|)
name|toType
decl_stmt|;
name|TimeUnit
name|endUnit
init|=
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getEndUnit
argument_list|()
decl_stmt|;
if|if
condition|(
name|endUnit
operator|==
literal|null
condition|)
block|{
name|endUnit
operator|=
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getStartUnit
argument_list|()
expr_stmt|;
block|}
name|int
name|scale
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|endUnit
operator|==
name|TimeUnit
operator|.
name|SECOND
condition|)
block|{
name|scale
operator|=
name|Math
operator|.
name|min
argument_list|(
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getFractionalSecondPrecision
argument_list|(
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|BigDecimal
name|multiplier
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|endUnit
operator|.
name|multiplier
argument_list|)
operator|.
name|divide
argument_list|(
name|BigDecimal
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|scale
argument_list|)
argument_list|)
decl_stmt|;
name|RelDataType
name|decimalType
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
name|scale
operator|+
name|intervalType
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|RexNode
name|value
init|=
name|decodeIntervalOrDecimal
argument_list|(
name|ensureType
argument_list|(
name|decimalType
argument_list|,
name|exp
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|multiplier
operator|.
name|longValue
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|value
operator|=
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
argument_list|,
name|value
argument_list|,
name|makeExactLiteral
argument_list|(
name|multiplier
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|encodeIntervalOrDecimal
argument_list|(
name|value
argument_list|,
name|toType
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Casts a decimal's integer representation to a decimal node. If the    * expression is not the expected integer type, then it is casted first.    *    *<p>An overflow check may be requested to ensure the internal value    * does not exceed the maximum value of the decimal type.    *    * @param value         integer representation of decimal    * @param type          type integer will be reinterpreted as    * @param checkOverflow indicates whether an overflow check is required    *                      when reinterpreting this particular value as the    *                      decimal type. A check usually not required for    *                      arithmetic, but is often required for rounding and    *                      explicit casts.    * @return the integer reinterpreted as an opaque decimal type    */
specifier|public
name|RexNode
name|encodeIntervalOrDecimal
parameter_list|(
name|RexNode
name|value
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|boolean
name|checkOverflow
parameter_list|)
block|{
name|RelDataType
name|bigintType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
name|RexNode
name|cast
init|=
name|ensureType
argument_list|(
name|bigintType
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|makeReinterpretCast
argument_list|(
name|type
argument_list|,
name|cast
argument_list|,
name|makeLiteral
argument_list|(
name|checkOverflow
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Retrieves an interval or decimal node's integer representation    *    * @param node the interval or decimal value as an opaque type    * @return an integer representation of the decimal value    */
specifier|public
name|RexNode
name|decodeIntervalOrDecimal
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
assert|assert
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
operator|||
name|SqlTypeUtil
operator|.
name|isInterval
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
assert|;
name|RelDataType
name|bigintType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
return|return
name|makeReinterpretCast
argument_list|(
name|matchNullability
argument_list|(
name|bigintType
argument_list|,
name|node
argument_list|)
argument_list|,
name|node
argument_list|,
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a call to the CAST operator.    *    * @param type Type to cast to    * @param exp  Expression being cast    * @return Call to CAST operator    */
specifier|public
name|RexNode
name|makeAbstractCast
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
return|return
operator|new
name|RexCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Makes a reinterpret cast.    *    * @param type          type returned by the cast    * @param exp           expression to be casted    * @param checkOverflow whether an overflow check is required    * @return a RexCall with two operands and a special return type    */
specifier|public
name|RexNode
name|makeReinterpretCast
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
name|exp
parameter_list|,
name|RexNode
name|checkOverflow
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|args
decl_stmt|;
if|if
condition|(
operator|(
name|checkOverflow
operator|!=
literal|null
operator|)
operator|&&
name|checkOverflow
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|args
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|exp
argument_list|,
name|checkOverflow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|args
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RexCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|REINTERPRET
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/**    * Makes an expression which converts a value of type T to a value of type T    * NOT NULL, or throws if the value is NULL. If the expression is already    * NOT NULL, does nothing.    */
specifier|public
name|RexNode
name|makeNotNullCast
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|expr
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
name|expr
return|;
block|}
name|RelDataType
name|typeNotNull
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexCall
argument_list|(
name|typeNotNull
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a reference to all the fields in the row. That is, the whole row    * as a single record object.    *    * @param input Input relational expression    */
specifier|public
name|RexNode
name|makeRangeReference
parameter_list|(
name|RelNode
name|input
parameter_list|)
block|{
return|return
operator|new
name|RexRangeRef
argument_list|(
name|input
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Creates a reference to all the fields in the row.    *    *<p>For example, if the input row has type<code>T{f0,f1,f2,f3,f4}</code>    * then<code>makeRangeReference(T{f0,f1,f2,f3,f4}, S{f3,f4}, 3)</code> is    * an expression which yields the last 2 fields.    *    * @param type     Type of the resulting range record.    * @param offset   Index of first field.    * @param nullable Whether the record is nullable.    */
specifier|public
name|RexRangeRef
name|makeRangeReference
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|int
name|offset
parameter_list|,
name|boolean
name|nullable
parameter_list|)
block|{
if|if
condition|(
name|nullable
operator|&&
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|nullable
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RexRangeRef
argument_list|(
name|type
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/**    * Creates a reference to a given field of the input record.    *    * @param type Type of field    * @param i    Ordinal of field    * @return Reference to field    */
specifier|public
name|RexInputRef
name|makeInputRef
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|type
operator|=
name|SqlTypeUtil
operator|.
name|addCharsetAndCollation
argument_list|(
name|type
argument_list|,
name|typeFactory
argument_list|)
expr_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|i
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**    * Creates a reference to a given field of the input relational expression.    *    * @param input Input relational expression    * @param i    Ordinal of field    * @return Reference to field    */
specifier|public
name|RexInputRef
name|makeInputRef
parameter_list|(
name|RelNode
name|input
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|makeInputRef
argument_list|(
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/**    * Creates a literal representing a flag.    *    * @param flag Flag value    */
specifier|public
name|RexLiteral
name|makeFlag
parameter_list|(
name|Enum
name|flag
parameter_list|)
block|{
assert|assert
name|flag
operator|!=
literal|null
assert|;
return|return
name|makeLiteral
argument_list|(
name|flag
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|SYMBOL
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|SYMBOL
argument_list|)
return|;
block|}
comment|/**    * Internal method to create a call to a literal. Code outside this package    * should call one of the type-specific methods such as    * {@link #makeDateLiteral(Calendar)}, {@link #makeLiteral(boolean)},    * {@link #makeLiteral(String)}.    *    * @param o        Value of literal, must be appropriate for the type    * @param type     Type of literal    * @param typeName SQL type of literal    * @return Literal    */
specifier|protected
name|RexLiteral
name|makeLiteral
parameter_list|(
name|Comparable
name|o
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|)
block|{
comment|// All literals except NULL have NOT NULL types.
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|o
operator|==
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|typeName
operator|==
name|SqlTypeName
operator|.
name|CHAR
condition|)
block|{
comment|// Character literals must have a charset and collation. Populate
comment|// from the type if necessary.
assert|assert
name|o
operator|instanceof
name|NlsString
assert|;
name|NlsString
name|nlsString
init|=
operator|(
name|NlsString
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|(
name|nlsString
operator|.
name|getCollation
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|(
name|nlsString
operator|.
name|getCharset
argument_list|()
operator|==
literal|null
operator|)
condition|)
block|{
assert|assert
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|CHAR
assert|;
assert|assert
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|name
argument_list|()
operator|!=
literal|null
assert|;
assert|assert
name|type
operator|.
name|getCollation
argument_list|()
operator|!=
literal|null
assert|;
name|o
operator|=
operator|new
name|NlsString
argument_list|(
name|nlsString
operator|.
name|getValue
argument_list|()
argument_list|,
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|type
operator|.
name|getCollation
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|RexLiteral
argument_list|(
name|o
argument_list|,
name|type
argument_list|,
name|typeName
argument_list|)
return|;
block|}
comment|/**    * Creates a boolean literal.    */
specifier|public
name|RexLiteral
name|makeLiteral
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
return|return
name|b
condition|?
name|booleanTrue
else|:
name|booleanFalse
return|;
block|}
comment|/**    * Creates a numeric literal.    */
specifier|public
name|RexLiteral
name|makeExactLiteral
parameter_list|(
name|BigDecimal
name|bd
parameter_list|)
block|{
name|RelDataType
name|relType
decl_stmt|;
name|int
name|scale
init|=
name|bd
operator|.
name|scale
argument_list|()
decl_stmt|;
name|long
name|l
init|=
name|bd
operator|.
name|unscaledValue
argument_list|()
operator|.
name|longValue
argument_list|()
decl_stmt|;
assert|assert
name|scale
operator|>=
literal|0
assert|;
assert|assert
name|scale
operator|<=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|getMaxNumericScale
argument_list|()
operator|:
name|scale
assert|;
assert|assert
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|l
argument_list|,
name|scale
argument_list|)
operator|.
name|equals
argument_list|(
name|bd
argument_list|)
assert|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|l
operator|>=
name|Integer
operator|.
name|MIN_VALUE
operator|)
operator|&&
operator|(
name|l
operator|<=
name|Integer
operator|.
name|MAX_VALUE
operator|)
condition|)
block|{
name|relType
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|relType
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|precision
init|=
name|bd
operator|.
name|unscaledValue
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|length
argument_list|()
decl_stmt|;
name|relType
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
name|scale
argument_list|,
name|precision
argument_list|)
expr_stmt|;
block|}
return|return
name|makeExactLiteral
argument_list|(
name|bd
argument_list|,
name|relType
argument_list|)
return|;
block|}
comment|/**    * Creates a BIGINT literal.    */
specifier|public
name|RexLiteral
name|makeBigintLiteral
parameter_list|(
name|BigDecimal
name|bd
parameter_list|)
block|{
name|RelDataType
name|bigintType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
return|return
name|makeLiteral
argument_list|(
name|bd
argument_list|,
name|bigintType
argument_list|,
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|)
return|;
block|}
comment|/**    * Creates a numeric literal.    */
specifier|public
name|RexLiteral
name|makeExactLiteral
parameter_list|(
name|BigDecimal
name|bd
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|makeLiteral
argument_list|(
name|bd
argument_list|,
name|type
argument_list|,
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|)
return|;
block|}
comment|/**    * Creates a byte array literal.    */
specifier|public
name|RexLiteral
name|makeBinaryLiteral
parameter_list|(
name|ByteString
name|byteString
parameter_list|)
block|{
return|return
name|makeLiteral
argument_list|(
name|byteString
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BINARY
argument_list|,
name|byteString
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|BINARY
argument_list|)
return|;
block|}
comment|/**    * Creates a double-precision literal.    */
specifier|public
name|RexLiteral
name|makeApproxLiteral
parameter_list|(
name|BigDecimal
name|bd
parameter_list|)
block|{
comment|// Validator should catch if underflow is allowed
comment|// If underflow is allowed, let underflow become zero
if|if
condition|(
name|bd
operator|.
name|doubleValue
argument_list|()
operator|==
literal|0
condition|)
block|{
name|bd
operator|=
name|BigDecimal
operator|.
name|ZERO
expr_stmt|;
block|}
return|return
name|makeApproxLiteral
argument_list|(
name|bd
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates an approximate numeric literal (double or float).    *    * @param bd   literal value    * @param type approximate numeric type    * @return new literal    */
specifier|public
name|RexLiteral
name|makeApproxLiteral
parameter_list|(
name|BigDecimal
name|bd
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
assert|assert
name|SqlTypeFamily
operator|.
name|APPROXIMATE_NUMERIC
operator|.
name|getTypeNames
argument_list|()
operator|.
name|contains
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
assert|;
return|return
name|makeLiteral
argument_list|(
name|bd
argument_list|,
name|type
argument_list|,
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
return|;
block|}
comment|/**    * Creates a character string literal.    */
specifier|public
name|RexLiteral
name|makeLiteral
parameter_list|(
name|String
name|s
parameter_list|)
block|{
assert|assert
name|s
operator|!=
literal|null
assert|;
return|return
name|makePreciseStringLiteral
argument_list|(
name|s
argument_list|)
return|;
block|}
comment|/**    * Creates a character string literal with type CHAR and default charset and    * collation.    *    * @param s String value    * @return Character string literal    */
specifier|protected
name|RexLiteral
name|makePreciseStringLiteral
parameter_list|(
name|String
name|s
parameter_list|)
block|{
assert|assert
name|s
operator|!=
literal|null
assert|;
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
return|return
name|charEmpty
return|;
block|}
else|else
block|{
return|return
name|makeLiteral
argument_list|(
operator|new
name|NlsString
argument_list|(
name|s
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|CHAR
argument_list|)
return|;
block|}
block|}
comment|/**    * Ensures expression is interpreted as a specified type. The returned    * expression may be wrapped with a cast.    *    * @param type             desired type    * @param node             expression    * @param matchNullability whether to correct nullability of specified    *                         type to match the expression; this usually should    *                         be true, except for explicit casts which can    *                         override default nullability    * @return a casted expression or the original expression    */
specifier|public
name|RexNode
name|ensureType
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
name|node
parameter_list|,
name|boolean
name|matchNullability
parameter_list|)
block|{
name|RelDataType
name|targetType
init|=
name|type
decl_stmt|;
if|if
condition|(
name|matchNullability
condition|)
block|{
name|targetType
operator|=
name|matchNullability
argument_list|(
name|type
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|node
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|targetType
argument_list|)
condition|)
block|{
return|return
name|makeCast
argument_list|(
name|targetType
argument_list|,
name|node
argument_list|)
return|;
block|}
return|return
name|node
return|;
block|}
comment|/**    * Ensures that a type's nullability matches a value's nullability.    */
specifier|public
name|RelDataType
name|matchNullability
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
name|value
parameter_list|)
block|{
name|boolean
name|typeNullability
init|=
name|type
operator|.
name|isNullable
argument_list|()
decl_stmt|;
name|boolean
name|valueNullability
init|=
name|value
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeNullability
operator|!=
name|valueNullability
condition|)
block|{
return|return
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|valueNullability
argument_list|)
return|;
block|}
return|return
name|type
return|;
block|}
comment|/**    * Creates a character string literal from an {@link NlsString}.    *    *<p>If the string's charset and collation are not set, uses the system    * defaults.    */
specifier|public
name|RexLiteral
name|makeCharLiteral
parameter_list|(
name|NlsString
name|str
parameter_list|)
block|{
assert|assert
name|str
operator|!=
literal|null
assert|;
name|RelDataType
name|type
init|=
name|SqlUtil
operator|.
name|createNlsStringType
argument_list|(
name|typeFactory
argument_list|,
name|str
argument_list|)
decl_stmt|;
return|return
name|makeLiteral
argument_list|(
name|str
argument_list|,
name|type
argument_list|,
name|SqlTypeName
operator|.
name|CHAR
argument_list|)
return|;
block|}
comment|/**    * Creates a Date literal.    */
specifier|public
name|RexLiteral
name|makeDateLiteral
parameter_list|(
name|Calendar
name|date
parameter_list|)
block|{
assert|assert
name|date
operator|!=
literal|null
assert|;
return|return
name|makeLiteral
argument_list|(
name|date
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DATE
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|DATE
argument_list|)
return|;
block|}
comment|/**    * Creates a Time literal.    */
specifier|public
name|RexLiteral
name|makeTimeLiteral
parameter_list|(
name|Calendar
name|time
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
assert|assert
name|time
operator|!=
literal|null
assert|;
return|return
name|makeLiteral
argument_list|(
name|time
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIME
argument_list|,
name|precision
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|TIME
argument_list|)
return|;
block|}
comment|/**    * Creates a Timestamp literal.    */
specifier|public
name|RexLiteral
name|makeTimestampLiteral
parameter_list|(
name|Calendar
name|timestamp
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
assert|assert
name|timestamp
operator|!=
literal|null
assert|;
return|return
name|makeLiteral
argument_list|(
name|timestamp
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|,
name|precision
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|)
return|;
block|}
comment|/**    * Creates an interval literal.    */
specifier|public
name|RexLiteral
name|makeIntervalLiteral
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
assert|assert
name|intervalQualifier
operator|!=
literal|null
assert|;
return|return
name|makeFlag
argument_list|(
name|intervalQualifier
operator|.
name|timeUnitRange
argument_list|)
return|;
block|}
comment|/**    * Creates an interval literal.    */
specifier|public
name|RexLiteral
name|makeIntervalLiteral
parameter_list|(
name|BigDecimal
name|v
parameter_list|,
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
name|makeLiteral
argument_list|(
name|v
argument_list|,
name|typeFactory
operator|.
name|createSqlIntervalType
argument_list|(
name|intervalQualifier
argument_list|)
argument_list|,
name|intervalQualifier
operator|.
name|isYearMonth
argument_list|()
condition|?
name|SqlTypeName
operator|.
name|INTERVAL_YEAR_MONTH
else|:
name|SqlTypeName
operator|.
name|INTERVAL_DAY_TIME
argument_list|)
return|;
block|}
comment|/**    * Creates a reference to a dynamic parameter    *    * @param type  Type of dynamic parameter    * @param index Index of dynamic parameter    * @return Expression referencing dynamic parameter    */
specifier|public
name|RexDynamicParam
name|makeDynamicParam
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
operator|new
name|RexDynamicParam
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/**    * Creates an expression corresponding to a null literal, cast to a specific    * type and precision    *    * @param typeName  name of the type that the null will be cast to    * @param precision precision of the type    * @return created expression    */
specifier|public
name|RexNode
name|makeNullLiteral
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|,
name|precision
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|makeCast
argument_list|(
name|type
argument_list|,
name|constantNull
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a literal whose value is NULL, with a particular type.    *    *<p>The typing is necessary because RexNodes are strictly typed. For    * example, in the Rex world the<code>NULL</code> parameter to<code>    * SUBSTRING(NULL FROM 2 FOR 4)</code> must have a valid VARCHAR type so    * that the result type can be determined.    *    * @param typeName Type to cast NULL to    * @return NULL literal of given type    */
specifier|public
name|RexNode
name|makeNullLiteral
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|makeCast
argument_list|(
name|type
argument_list|,
name|constantNull
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a copy of an expression, which may have been created using a    * different RexBuilder and/or {@link RelDataTypeFactory}, using this    * RexBuilder.    *    * @param expr Expression    * @return Copy of expression    * @see RelDataTypeFactory#copyType(RelDataType)    */
specifier|public
name|RexNode
name|copy
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
return|return
name|expr
operator|.
name|accept
argument_list|(
operator|new
name|RexCopier
argument_list|(
name|this
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a literal of the default value for the given type.    *    *<p>This value is:</p>    *    *<ul>    *<li>0 for numeric types;    *<li>FALSE for BOOLEAN;    *<li>The epoch for TIMESTAMP and DATE;    *<li>Midnight for TIME;    *<li>The empty string for string types (CHAR, BINARY, VARCHAR, VARBINARY).    *</ul>    *    * @param type      Type    * @return Simple literal, or cast simple literal    */
specifier|public
name|RexNode
name|makeZeroLiteral
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|makeLiteral
argument_list|(
name|zeroValue
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Comparable
name|zeroValue
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|CHAR
case|:
return|return
operator|new
name|NlsString
argument_list|(
name|Spaces
operator|.
name|of
argument_list|(
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
case|case
name|VARCHAR
case|:
return|return
operator|new
name|NlsString
argument_list|(
literal|""
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
case|case
name|BINARY
case|:
return|return
operator|new
name|ByteString
argument_list|(
operator|new
name|byte
index|[
name|type
operator|.
name|getPrecision
argument_list|()
index|]
argument_list|)
return|;
case|case
name|VARBINARY
case|:
return|return
name|ByteString
operator|.
name|EMPTY
return|;
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
case|case
name|FLOAT
case|:
case|case
name|REAL
case|:
case|case
name|DOUBLE
case|:
return|return
name|BigDecimal
operator|.
name|ZERO
return|;
case|case
name|BOOLEAN
case|:
return|return
literal|false
return|;
case|case
name|TIME
case|:
case|case
name|DATE
case|:
case|case
name|TIMESTAMP
case|:
return|return
name|DateTimeUtils
operator|.
name|ZERO_CALENDAR
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Creates a literal of a given type. The value is assumed to be    * compatible with the type.    *    * @param value     Value    * @param type      Type    * @param allowCast Whether to allow a cast. If false, value is always a    *                  {@link RexLiteral} but may not be the exact type    * @return Simple literal, or cast simple literal    */
specifier|public
name|RexNode
name|makeLiteral
parameter_list|(
name|Object
name|value
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|boolean
name|allowCast
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
name|makeCast
argument_list|(
name|type
argument_list|,
name|constantNull
argument_list|)
return|;
block|}
if|if
condition|(
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
specifier|final
name|RelDataType
name|typeNotNull
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|RexNode
name|literalNotNull
init|=
name|makeLiteral
argument_list|(
name|value
argument_list|,
name|typeNotNull
argument_list|,
name|allowCast
argument_list|)
decl_stmt|;
return|return
name|makeAbstractCast
argument_list|(
name|type
argument_list|,
name|literalNotNull
argument_list|)
return|;
block|}
name|value
operator|=
name|clean
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|RexLiteral
name|literal
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
decl_stmt|;
switch|switch
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|CHAR
case|:
return|return
name|makeCharLiteral
argument_list|(
name|padRight
argument_list|(
operator|(
name|NlsString
operator|)
name|value
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|VARCHAR
case|:
name|literal
operator|=
name|makeCharLiteral
argument_list|(
operator|(
name|NlsString
operator|)
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowCast
condition|)
block|{
return|return
name|makeCast
argument_list|(
name|type
argument_list|,
name|literal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|literal
return|;
block|}
case|case
name|BINARY
case|:
return|return
name|makeBinaryLiteral
argument_list|(
name|padRight
argument_list|(
operator|(
name|ByteString
operator|)
name|value
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|VARBINARY
case|:
name|literal
operator|=
name|makeBinaryLiteral
argument_list|(
operator|(
name|ByteString
operator|)
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowCast
condition|)
block|{
return|return
name|makeCast
argument_list|(
name|type
argument_list|,
name|literal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|literal
return|;
block|}
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
return|return
name|makeExactLiteral
argument_list|(
operator|(
name|BigDecimal
operator|)
name|value
argument_list|,
name|type
argument_list|)
return|;
case|case
name|FLOAT
case|:
case|case
name|REAL
case|:
case|case
name|DOUBLE
case|:
return|return
name|makeApproxLiteral
argument_list|(
operator|(
name|BigDecimal
operator|)
name|value
argument_list|,
name|type
argument_list|)
return|;
case|case
name|BOOLEAN
case|:
return|return
operator|(
name|Boolean
operator|)
name|value
condition|?
name|booleanTrue
else|:
name|booleanFalse
return|;
case|case
name|TIME
case|:
return|return
name|makeTimeLiteral
argument_list|(
operator|(
name|Calendar
operator|)
name|value
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
return|;
case|case
name|DATE
case|:
return|return
name|makeDateLiteral
argument_list|(
operator|(
name|Calendar
operator|)
name|value
argument_list|)
return|;
case|case
name|TIMESTAMP
case|:
return|return
name|makeTimestampLiteral
argument_list|(
operator|(
name|Calendar
operator|)
name|value
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
return|;
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_DAY_TIME
case|:
return|return
name|makeIntervalLiteral
argument_list|(
operator|(
name|BigDecimal
operator|)
name|value
argument_list|,
name|type
operator|.
name|getIntervalQualifier
argument_list|()
argument_list|)
return|;
case|case
name|MAP
case|:
specifier|final
name|MapSqlType
name|mapType
init|=
operator|(
name|MapSqlType
operator|)
name|type
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|(
name|Map
operator|)
name|value
decl_stmt|;
name|operands
operator|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|operands
operator|.
name|add
argument_list|(
name|makeLiteral
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|mapType
operator|.
name|getKeyType
argument_list|()
argument_list|,
name|allowCast
argument_list|)
argument_list|)
expr_stmt|;
name|operands
operator|.
name|add
argument_list|(
name|makeLiteral
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|mapType
operator|.
name|getValueType
argument_list|()
argument_list|,
name|allowCast
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MAP_VALUE_CONSTRUCTOR
argument_list|,
name|operands
argument_list|)
return|;
case|case
name|ARRAY
case|:
specifier|final
name|ArraySqlType
name|arrayType
init|=
operator|(
name|ArraySqlType
operator|)
name|type
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|listValue
init|=
operator|(
name|List
operator|)
name|value
decl_stmt|;
name|operands
operator|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Object
name|entry
range|:
name|listValue
control|)
block|{
name|operands
operator|.
name|add
argument_list|(
name|makeLiteral
argument_list|(
name|entry
argument_list|,
name|arrayType
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|allowCast
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ARRAY_VALUE_CONSTRUCTOR
argument_list|,
name|operands
argument_list|)
return|;
case|case
name|ANY
case|:
return|return
name|makeLiteral
argument_list|(
name|value
argument_list|,
name|guessType
argument_list|(
name|value
argument_list|)
argument_list|,
name|allowCast
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/** Converts the type of a value to comply with    * {@link org.apache.calcite.rex.RexLiteral#valueMatchesType}. */
specifier|private
specifier|static
name|Object
name|clean
parameter_list|(
name|Object
name|o
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Calendar
name|calendar
decl_stmt|;
switch|switch
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_DAY_TIME
case|:
if|if
condition|(
name|o
operator|instanceof
name|BigDecimal
condition|)
block|{
return|return
name|o
return|;
block|}
return|return
operator|new
name|BigDecimal
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|o
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
return|;
case|case
name|FLOAT
case|:
case|case
name|REAL
case|:
case|case
name|DOUBLE
case|:
if|if
condition|(
name|o
operator|instanceof
name|BigDecimal
condition|)
block|{
return|return
name|o
return|;
block|}
return|return
operator|new
name|BigDecimal
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|o
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
return|;
case|case
name|CHAR
case|:
case|case
name|VARCHAR
case|:
if|if
condition|(
name|o
operator|instanceof
name|NlsString
condition|)
block|{
return|return
name|o
return|;
block|}
return|return
operator|new
name|NlsString
argument_list|(
operator|(
name|String
operator|)
name|o
argument_list|,
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|type
operator|.
name|getCollation
argument_list|()
argument_list|)
return|;
case|case
name|TIME
case|:
if|if
condition|(
name|o
operator|instanceof
name|Calendar
condition|)
block|{
return|return
name|o
return|;
block|}
name|calendar
operator|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|DateTimeUtils
operator|.
name|GMT_ZONE
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|setTimeInMillis
argument_list|(
operator|(
name|Integer
operator|)
name|o
argument_list|)
expr_stmt|;
return|return
name|calendar
return|;
case|case
name|DATE
case|:
if|if
condition|(
name|o
operator|instanceof
name|Calendar
condition|)
block|{
return|return
name|o
return|;
block|}
name|calendar
operator|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|DateTimeUtils
operator|.
name|GMT_ZONE
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|setTimeInMillis
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|add
argument_list|(
name|Calendar
operator|.
name|DAY_OF_YEAR
argument_list|,
operator|(
name|Integer
operator|)
name|o
argument_list|)
expr_stmt|;
return|return
name|calendar
return|;
case|case
name|TIMESTAMP
case|:
if|if
condition|(
name|o
operator|instanceof
name|Calendar
condition|)
block|{
return|return
name|o
return|;
block|}
name|calendar
operator|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|DateTimeUtils
operator|.
name|GMT_ZONE
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|setTimeInMillis
argument_list|(
operator|(
name|Long
operator|)
name|o
argument_list|)
expr_stmt|;
return|return
name|calendar
return|;
default|default:
return|return
name|o
return|;
block|}
block|}
specifier|private
name|RelDataType
name|guessType
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
name|value
operator|instanceof
name|Float
operator|||
name|value
operator|instanceof
name|Double
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
return|;
block|}
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
return|;
block|}
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
return|;
block|}
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|,
operator|(
operator|(
name|String
operator|)
name|value
operator|)
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|value
operator|instanceof
name|ByteString
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BINARY
argument_list|,
operator|(
operator|(
name|ByteString
operator|)
name|value
operator|)
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unknown type "
operator|+
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
comment|/** Returns an {@link NlsString} with spaces to make it at least a given    * length. */
specifier|private
specifier|static
name|NlsString
name|padRight
parameter_list|(
name|NlsString
name|s
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|getValue
argument_list|()
operator|.
name|length
argument_list|()
operator|>=
name|length
condition|)
block|{
return|return
name|s
return|;
block|}
return|return
name|s
operator|.
name|copy
argument_list|(
name|padRight
argument_list|(
name|s
operator|.
name|getValue
argument_list|()
argument_list|,
name|length
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns a string padded with spaces to make it at least a given length. */
specifier|private
specifier|static
name|String
name|padRight
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>=
name|length
condition|)
block|{
return|return
name|s
return|;
block|}
return|return
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
name|s
argument_list|)
operator|.
name|append
argument_list|(
name|Spaces
operator|.
name|MAX
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|,
name|length
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Returns a byte-string padded with zero bytes to make it at least a given    * length, */
specifier|private
specifier|static
name|ByteString
name|padRight
parameter_list|(
name|ByteString
name|s
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>=
name|length
condition|)
block|{
return|return
name|s
return|;
block|}
return|return
operator|new
name|ByteString
argument_list|(
name|Arrays
operator|.
name|copyOf
argument_list|(
name|s
operator|.
name|getBytes
argument_list|()
argument_list|,
name|length
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|// End RexBuilder.java
end_comment

end_unit

