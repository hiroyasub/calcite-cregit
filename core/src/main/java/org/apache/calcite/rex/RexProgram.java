begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|rex
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * A collection of expressions which read inputs, compute output expressions,  * and optionally use a condition to filter rows.  *  *<p>Programs are immutable. It may help to use a {@link RexProgramBuilder},  * which has the same relationship to {@link RexProgram} as {@link StringBuffer}  * does has to {@link String}.  *  *<p>A program can contain aggregate functions. If it does, the arguments to  * each aggregate function must be an {@link RexInputRef}.  *  * @see RexProgramBuilder  */
end_comment

begin_class
specifier|public
class|class
name|RexProgram
block|{
comment|//~ Instance fields --------------------------------------------------------
comment|/**    * First stage of expression evaluation. The expressions in this array can    * refer to inputs (using input ordinal #0) or previous expressions in the    * array (using input ordinal #1).    */
specifier|private
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
decl_stmt|;
comment|/**    * With {@link #condition}, the second stage of expression evaluation.    */
specifier|private
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projects
decl_stmt|;
comment|/**    * The optional condition. If null, the calculator does not filter rows.    */
specifier|private
specifier|final
name|RexLocalRef
name|condition
decl_stmt|;
specifier|private
specifier|final
name|RelDataType
name|inputRowType
decl_stmt|;
specifier|private
specifier|final
name|RelDataType
name|outputRowType
decl_stmt|;
comment|/**    * Reference counts for each expression, computed on demand.    */
specifier|private
name|int
index|[]
name|refCounts
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a program.    *    *<p>The expressions must be valid: they must not contain common expressions,    * forward references, or non-trivial aggregates.</p>    *    * @param inputRowType  Input row type    * @param exprs         Common expressions    * @param projects      Projection expressions    * @param condition     Condition expression. If null, calculator does not    *                      filter rows    * @param outputRowType Description of the row produced by the program    */
specifier|public
name|RexProgram
parameter_list|(
name|RelDataType
name|inputRowType
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projects
parameter_list|,
name|RexLocalRef
name|condition
parameter_list|,
name|RelDataType
name|outputRowType
parameter_list|)
block|{
name|this
operator|.
name|inputRowType
operator|=
name|inputRowType
expr_stmt|;
name|this
operator|.
name|exprs
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|exprs
argument_list|)
expr_stmt|;
name|this
operator|.
name|projects
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|projects
argument_list|)
expr_stmt|;
name|this
operator|.
name|condition
operator|=
name|condition
expr_stmt|;
name|this
operator|.
name|outputRowType
operator|=
name|outputRowType
expr_stmt|;
assert|assert
name|isValid
argument_list|(
literal|true
argument_list|)
assert|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|// REVIEW jvs 16-Oct-2006:  The description below is confusing.  I
comment|// think it means "none of the entries are null, there may be none,
comment|// and there is no further reduction into smaller common sub-expressions
comment|// possible"?
comment|/**    * Returns the common sub-expressions of this program.    *    *<p>The list is never null but may be empty; each the expression in the    * list is not null; and no further reduction into smaller common    * sub-expressions is possible.    */
specifier|public
name|List
argument_list|<
name|RexNode
argument_list|>
name|getExprList
parameter_list|()
block|{
return|return
name|exprs
return|;
block|}
comment|/**    * Returns an array of references to the expressions which this program is    * to project. Never null, may be empty.    */
specifier|public
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|getProjectList
parameter_list|()
block|{
return|return
name|projects
return|;
block|}
comment|/**    * Returns a list of project expressions and their field names.    */
specifier|public
name|List
argument_list|<
name|Pair
argument_list|<
name|RexLocalRef
argument_list|,
name|String
argument_list|>
argument_list|>
name|getNamedProjects
parameter_list|()
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|Pair
argument_list|<
name|RexLocalRef
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|projects
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|Pair
argument_list|<
name|RexLocalRef
argument_list|,
name|String
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|projects
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|outputRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns the field reference of this program's filter condition, or null    * if there is no condition.    */
specifier|public
name|RexLocalRef
name|getCondition
parameter_list|()
block|{
return|return
name|condition
return|;
block|}
comment|/**    * Creates a program which calculates projections and filters rows based    * upon a condition. Does not attempt to eliminate common sub-expressions.    *    * @param projectExprs  Project expressions    * @param conditionExpr Condition on which to filter rows, or null if rows    *                      are not to be filtered    * @param outputRowType Output row type    * @param rexBuilder    Builder of rex expressions    * @return A program    */
specifier|public
specifier|static
name|RexProgram
name|create
parameter_list|(
name|RelDataType
name|inputRowType
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|projectExprs
parameter_list|,
name|RexNode
name|conditionExpr
parameter_list|,
name|RelDataType
name|outputRowType
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|inputRowType
argument_list|,
name|projectExprs
argument_list|,
name|conditionExpr
argument_list|,
name|outputRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|,
name|rexBuilder
argument_list|)
return|;
block|}
comment|/**    * Creates a program which calculates projections and filters rows based    * upon a condition. Does not attempt to eliminate common sub-expressions.    *    * @param projectExprs  Project expressions    * @param conditionExpr Condition on which to filter rows, or null if rows    *                      are not to be filtered    * @param fieldNames    Names of projected fields    * @param rexBuilder    Builder of rex expressions    * @return A program    */
specifier|public
specifier|static
name|RexProgram
name|create
parameter_list|(
name|RelDataType
name|inputRowType
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|projectExprs
parameter_list|,
name|RexNode
name|conditionExpr
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
if|if
condition|(
name|fieldNames
operator|==
literal|null
condition|)
block|{
name|fieldNames
operator|=
name|Collections
operator|.
name|nCopies
argument_list|(
name|projectExprs
operator|.
name|size
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|fieldNames
operator|.
name|size
argument_list|()
operator|==
name|projectExprs
operator|.
name|size
argument_list|()
operator|:
literal|"fieldNames="
operator|+
name|fieldNames
operator|+
literal|", exprs="
operator|+
name|projectExprs
assert|;
block|}
specifier|final
name|RexProgramBuilder
name|programBuilder
init|=
operator|new
name|RexProgramBuilder
argument_list|(
name|inputRowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projectExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|programBuilder
operator|.
name|addProject
argument_list|(
name|projectExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conditionExpr
operator|!=
literal|null
condition|)
block|{
name|programBuilder
operator|.
name|addCondition
argument_list|(
name|conditionExpr
argument_list|)
expr_stmt|;
block|}
return|return
name|programBuilder
operator|.
name|getProgram
argument_list|()
return|;
block|}
comment|// description of this calc, chiefly intended for debugging
specifier|public
name|String
name|toString
parameter_list|()
block|{
comment|// Intended to produce similar output to explainCalc,
comment|// but without requiring a RelNode or RelOptPlanWriter.
specifier|final
name|RelWriterImpl
name|pw
init|=
operator|new
name|RelWriterImpl
argument_list|(
operator|new
name|PrintWriter
argument_list|(
operator|new
name|StringWriter
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|collectExplainTerms
argument_list|(
literal|""
argument_list|,
name|pw
argument_list|)
expr_stmt|;
return|return
name|pw
operator|.
name|simple
argument_list|()
return|;
block|}
comment|/**    * Writes an explanation of the expressions in this program to a plan    * writer.    *    * @param pw Plan writer    */
specifier|public
name|RelWriter
name|explainCalc
parameter_list|(
name|RelWriter
name|pw
parameter_list|)
block|{
return|return
name|collectExplainTerms
argument_list|(
literal|""
argument_list|,
name|pw
argument_list|,
name|pw
operator|.
name|getDetailLevel
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|RelWriter
name|collectExplainTerms
parameter_list|(
name|String
name|prefix
parameter_list|,
name|RelWriter
name|pw
parameter_list|)
block|{
return|return
name|collectExplainTerms
argument_list|(
name|prefix
argument_list|,
name|pw
argument_list|,
name|SqlExplainLevel
operator|.
name|EXPPLAN_ATTRIBUTES
argument_list|)
return|;
block|}
comment|/**    * Collects the expressions in this program into a list of terms and values.    *    * @param prefix Prefix for term names, usually the empty string, but useful    *               if a relational expression contains more than one program    * @param pw     Plan writer    */
specifier|public
name|RelWriter
name|collectExplainTerms
parameter_list|(
name|String
name|prefix
parameter_list|,
name|RelWriter
name|pw
parameter_list|,
name|SqlExplainLevel
name|level
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|inFields
init|=
name|inputRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|outFields
init|=
name|outputRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|outFields
operator|.
name|size
argument_list|()
operator|==
name|projects
operator|.
name|size
argument_list|()
operator|:
literal|"outFields.length="
operator|+
name|outFields
operator|.
name|size
argument_list|()
operator|+
literal|", projects.length="
operator|+
name|projects
operator|.
name|size
argument_list|()
assert|;
name|pw
operator|.
name|item
argument_list|(
name|prefix
operator|+
literal|"expr#0"
operator|+
operator|(
operator|(
name|inFields
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
condition|?
operator|(
literal|".."
operator|+
operator|(
name|inFields
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
operator|)
else|:
literal|""
operator|)
argument_list|,
literal|"{inputs}"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|inFields
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|pw
operator|.
name|item
argument_list|(
name|prefix
operator|+
literal|"expr#"
operator|+
name|i
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If a lot of the fields are simply projections of the underlying
comment|// expression, try to be a bit less verbose.
name|int
name|trivialCount
init|=
literal|0
decl_stmt|;
comment|// Do not use the trivialCount optimization if computing digest for the
comment|// optimizer (as opposed to doing an explain plan).
if|if
condition|(
name|level
operator|!=
name|SqlExplainLevel
operator|.
name|DIGEST_ATTRIBUTES
condition|)
block|{
name|trivialCount
operator|=
name|countTrivial
argument_list|(
name|projects
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|trivialCount
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|trivialCount
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|pw
operator|.
name|item
argument_list|(
name|prefix
operator|+
literal|"proj#0.."
operator|+
operator|(
name|trivialCount
operator|-
literal|1
operator|)
argument_list|,
literal|"{exprs}"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Print the non-trivial fields with their names as they appear in the
comment|// output row type.
for|for
control|(
name|int
name|i
init|=
name|trivialCount
init|;
name|i
operator|<
name|projects
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|pw
operator|.
name|item
argument_list|(
name|prefix
operator|+
name|outFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
name|projects
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|condition
operator|!=
literal|null
condition|)
block|{
name|pw
operator|.
name|item
argument_list|(
name|prefix
operator|+
literal|"$condition"
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
return|return
name|pw
return|;
block|}
comment|/**    * Returns the number of expressions at the front of an array which are    * simply projections of the same field.    *    * @param refs References    */
specifier|private
specifier|static
name|int
name|countTrivial
parameter_list|(
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|refs
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|refs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexLocalRef
name|ref
init|=
name|refs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|.
name|getIndex
argument_list|()
operator|!=
name|i
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
name|refs
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Returns the number of expressions in this program.    */
specifier|public
name|int
name|getExprCount
parameter_list|()
block|{
return|return
name|exprs
operator|.
name|size
argument_list|()
operator|+
name|projects
operator|.
name|size
argument_list|()
operator|+
operator|(
operator|(
name|condition
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
comment|/**    * Creates the identity program.    */
specifier|public
specifier|static
name|RexProgram
name|createIdentity
parameter_list|(
name|RelDataType
name|rowType
parameter_list|)
block|{
return|return
name|createIdentity
argument_list|(
name|rowType
argument_list|,
name|rowType
argument_list|)
return|;
block|}
comment|/**    * Creates a program that projects its input fields but with possibly    * different names for the output fields.    */
specifier|public
specifier|static
name|RexProgram
name|createIdentity
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|RelDataType
name|outputRowType
parameter_list|)
block|{
if|if
condition|(
name|rowType
operator|!=
name|outputRowType
operator|&&
operator|!
name|Pair
operator|.
name|right
argument_list|(
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|Pair
operator|.
name|right
argument_list|(
name|outputRowType
operator|.
name|getFieldList
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field type mismatch: "
operator|+
name|rowType
operator|+
literal|" vs. "
operator|+
name|outputRowType
argument_list|)
throw|;
block|}
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexLocalRef
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|refs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexInputRef
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexInputRef
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
name|i
argument_list|,
name|fields
argument_list|)
decl_stmt|;
name|refs
operator|.
name|add
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|projectRefs
operator|.
name|add
argument_list|(
operator|new
name|RexLocalRef
argument_list|(
name|i
argument_list|,
name|ref
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RexProgram
argument_list|(
name|rowType
argument_list|,
name|refs
argument_list|,
name|projectRefs
argument_list|,
literal|null
argument_list|,
name|outputRowType
argument_list|)
return|;
block|}
comment|/**    * Returns the type of the input row to the program.    *    * @return input row type    */
specifier|public
name|RelDataType
name|getInputRowType
parameter_list|()
block|{
return|return
name|inputRowType
return|;
block|}
comment|/**    * Returns whether this program contains windowed aggregate functions    *    * @return whether this program contains windowed aggregate functions    */
specifier|public
name|boolean
name|containsAggs
parameter_list|()
block|{
return|return
name|RexOver
operator|.
name|containsOver
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Returns the type of the output row from this program.    *    * @return output row type    */
specifier|public
name|RelDataType
name|getOutputRowType
parameter_list|()
block|{
return|return
name|outputRowType
return|;
block|}
comment|/**    * Checks that this program is valid.    *    *<p>If<code>fail</code> is true, executes<code>assert false</code>, so    * will throw an {@link AssertionError} if assertions are enabled. If<code>    * fail</code> is false, merely returns whether the program is valid.    *    * @param fail Whether to fail    * @return Whether the program is valid    * @throws AssertionError if program is invalid and<code>fail</code> is    *                        true and assertions are enabled    */
specifier|public
name|boolean
name|isValid
parameter_list|(
name|boolean
name|fail
parameter_list|)
block|{
if|if
condition|(
name|inputRowType
operator|==
literal|null
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|exprs
operator|==
literal|null
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|projects
operator|==
literal|null
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|outputRowType
operator|==
literal|null
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
comment|// If the input row type is a struct (contains fields) then the leading
comment|// expressions must be references to those fields. But we don't require
comment|// this if the input row type is, say, a java class.
if|if
condition|(
name|inputRowType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|containIdentity
argument_list|(
name|exprs
argument_list|,
name|inputRowType
argument_list|,
name|fail
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
comment|// None of the other fields should be inputRefs.
for|for
control|(
name|int
name|i
init|=
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|RexInputRef
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// todo: enable
comment|// CHECKSTYLE: IGNORE 1
if|if
condition|(
literal|false
operator|&&
name|RexUtil
operator|.
name|containCommonExprs
argument_list|(
name|exprs
argument_list|,
name|fail
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|RexUtil
operator|.
name|containForwardRefs
argument_list|(
name|exprs
argument_list|,
name|inputRowType
argument_list|,
name|fail
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|RexUtil
operator|.
name|containNonTrivialAggs
argument_list|(
name|exprs
argument_list|,
name|fail
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
specifier|final
name|Checker
name|checker
init|=
operator|new
name|Checker
argument_list|(
name|fail
argument_list|,
name|inputRowType
argument_list|,
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|exprs
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getType
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|exprs
operator|.
name|size
argument_list|()
return|;
block|}
comment|// CHECKSTYLE: IGNORE 1
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|condition
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|inBooleanFamily
argument_list|(
name|condition
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"condition must be boolean"
assert|;
return|return
literal|false
return|;
block|}
name|condition
operator|.
name|accept
argument_list|(
name|checker
argument_list|)
expr_stmt|;
if|if
condition|(
name|checker
operator|.
name|failCount
operator|>
literal|0
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projects
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|projects
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|accept
argument_list|(
name|checker
argument_list|)
expr_stmt|;
if|if
condition|(
name|checker
operator|.
name|failCount
operator|>
literal|0
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|accept
argument_list|(
name|checker
argument_list|)
expr_stmt|;
if|if
condition|(
name|checker
operator|.
name|failCount
operator|>
literal|0
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether an expression always evaluates to null.    *    *<p>Like {@link RexUtil#isNull(RexNode)}, null literals are null, and                                                         |    * casts of null literals are null. But this method also regards references    * to null expressions as null.</p>    *    * @param expr Expression    * @return Whether expression always evaluates to null    */
specifier|public
name|boolean
name|isNull
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
switch|switch
condition|(
name|expr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LITERAL
case|:
return|return
operator|(
operator|(
name|RexLiteral
operator|)
name|expr
operator|)
operator|.
name|getValue2
argument_list|()
operator|==
literal|null
return|;
case|case
name|LOCAL_REF
case|:
name|RexLocalRef
name|inputRef
init|=
operator|(
name|RexLocalRef
operator|)
name|expr
decl_stmt|;
return|return
name|isNull
argument_list|(
name|exprs
operator|.
name|get
argument_list|(
name|inputRef
operator|.
name|index
argument_list|)
argument_list|)
return|;
case|case
name|CAST
case|:
return|return
name|isNull
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Fully expands a RexLocalRef back into a pure RexNode tree containing no    * RexLocalRefs (reversing the effect of common subexpression elimination).    * For example,<code>program.expandLocalRef(program.getCondition())</code>    * will return the expansion of a program's condition.    *    * @param ref a RexLocalRef from this program    * @return expanded form    */
specifier|public
name|RexNode
name|expandLocalRef
parameter_list|(
name|RexLocalRef
name|ref
parameter_list|)
block|{
comment|// TODO jvs 19-Apr-2006:  assert that ref is part of
comment|// this program
name|ExpansionShuttle
name|shuttle
init|=
operator|new
name|ExpansionShuttle
argument_list|()
decl_stmt|;
return|return
name|ref
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
comment|/** Splits this program into a list of project expressions and a list of    * filter expressions.    *    *<p>Neither list is null.    * The filters are evaluated first. */
specifier|public
name|Pair
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|split
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
if|if
condition|(
name|condition
operator|!=
literal|null
condition|)
block|{
name|RelOptUtil
operator|.
name|decomposeConjunction
argument_list|(
name|expandLocalRef
argument_list|(
name|condition
argument_list|)
argument_list|,
name|filters
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RexLocalRef
name|project
range|:
name|this
operator|.
name|projects
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|expandLocalRef
argument_list|(
name|project
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|projects
operator|.
name|build
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|filters
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Given a list of collations which hold for the input to this program,    * returns a list of collations which hold for its output. The result is    * mutable.    */
specifier|public
name|List
argument_list|<
name|RelCollation
argument_list|>
name|getCollations
parameter_list|(
name|List
argument_list|<
name|RelCollation
argument_list|>
name|inputCollations
parameter_list|)
block|{
name|List
argument_list|<
name|RelCollation
argument_list|>
name|outputCollations
init|=
operator|new
name|ArrayList
argument_list|<
name|RelCollation
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|deduceCollations
argument_list|(
name|outputCollations
argument_list|,
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|projects
argument_list|,
name|inputCollations
argument_list|)
expr_stmt|;
return|return
name|outputCollations
return|;
block|}
comment|/**    * Given a list of expressions and a description of which are ordered,    * computes a list of collations. The result is mutable.    */
specifier|public
specifier|static
name|void
name|deduceCollations
parameter_list|(
name|List
argument_list|<
name|RelCollation
argument_list|>
name|outputCollations
parameter_list|,
specifier|final
name|int
name|sourceCount
parameter_list|,
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|refs
parameter_list|,
name|List
argument_list|<
name|RelCollation
argument_list|>
name|inputCollations
parameter_list|)
block|{
name|int
index|[]
name|targets
init|=
operator|new
name|int
index|[
name|sourceCount
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|targets
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|refs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexLocalRef
name|ref
init|=
name|refs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|source
init|=
name|ref
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|source
operator|<
name|sourceCount
operator|)
operator|&&
operator|(
name|targets
index|[
name|source
index|]
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|targets
index|[
name|source
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
name|loop
label|:
for|for
control|(
name|RelCollation
name|collation
range|:
name|inputCollations
control|)
block|{
specifier|final
name|ArrayList
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
operator|new
name|ArrayList
argument_list|<
name|RelFieldCollation
argument_list|>
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|fieldCollation
range|:
name|collation
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
specifier|final
name|int
name|source
init|=
name|fieldCollation
operator|.
name|getFieldIndex
argument_list|()
decl_stmt|;
specifier|final
name|int
name|target
init|=
name|targets
index|[
name|source
index|]
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|0
condition|)
block|{
continue|continue
name|loop
continue|;
block|}
name|fieldCollations
operator|.
name|add
argument_list|(
name|fieldCollation
operator|.
name|copy
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Success -- all of the source fields of this key are mapped
comment|// to the output.
name|outputCollations
operator|.
name|add
argument_list|(
name|RelCollationImpl
operator|.
name|of
argument_list|(
name|fieldCollations
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns whether the fields on the leading edge of the project list are    * the input fields.    *    * @param fail Whether to throw an assert failure if does not project    *             identity    */
specifier|public
name|boolean
name|projectsIdentity
parameter_list|(
specifier|final
name|boolean
name|fail
parameter_list|)
block|{
specifier|final
name|int
name|fieldCount
init|=
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|projects
operator|.
name|size
argument_list|()
operator|<
name|fieldCount
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"program '"
operator|+
name|toString
argument_list|()
operator|+
literal|"' does not project identity for input row type '"
operator|+
name|inputRowType
operator|+
literal|"'"
assert|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldCount
condition|;
name|i
operator|++
control|)
block|{
name|RexLocalRef
name|project
init|=
name|projects
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|project
operator|.
name|index
operator|!=
name|i
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"program "
operator|+
name|toString
argument_list|()
operator|+
literal|"' does not project identity for input row type '"
operator|+
name|inputRowType
operator|+
literal|"', field #"
operator|+
name|i
assert|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether this program projects precisely its input fields. It may    * or may not apply a condition.    */
specifier|public
name|boolean
name|projectsOnlyIdentity
parameter_list|()
block|{
if|if
condition|(
name|projects
operator|.
name|size
argument_list|()
operator|!=
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projects
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexLocalRef
name|project
init|=
name|projects
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|project
operator|.
name|index
operator|!=
name|i
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether this program returns its input exactly.    *    *<p>This is a stronger condition than {@link #projectsIdentity(boolean)}.    */
specifier|public
name|boolean
name|isTrivial
parameter_list|()
block|{
return|return
name|getCondition
argument_list|()
operator|==
literal|null
operator|&&
name|projectsOnlyIdentity
argument_list|()
return|;
block|}
comment|/**    * Gets reference counts for each expression in the program, where the    * references are detected from later expressions in the same program, as    * well as the project list and condition. Expressions with references    * counts greater than 1 are true common sub-expressions.    *    * @return array of reference counts; the ith element in the returned array    * is the number of references to getExprList()[i]    */
specifier|public
name|int
index|[]
name|getReferenceCounts
parameter_list|()
block|{
if|if
condition|(
name|refCounts
operator|!=
literal|null
condition|)
block|{
return|return
name|refCounts
return|;
block|}
name|refCounts
operator|=
operator|new
name|int
index|[
name|exprs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|ReferenceCounter
name|refCounter
init|=
operator|new
name|ReferenceCounter
argument_list|()
decl_stmt|;
name|apply
argument_list|(
name|refCounter
argument_list|,
name|exprs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|condition
operator|!=
literal|null
condition|)
block|{
name|refCounter
operator|.
name|visitLocalRef
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RexLocalRef
name|project
range|:
name|projects
control|)
block|{
name|refCounter
operator|.
name|visitLocalRef
argument_list|(
name|project
argument_list|)
expr_stmt|;
block|}
return|return
name|refCounts
return|;
block|}
comment|/**    * Applies a visitor to an array of expressions and, if specified, a single    * expression.    *    * @param visitor Visitor    * @param exprs   Array of expressions    * @param expr    Single expression, may be null    */
specifier|public
specifier|static
name|void
name|apply
parameter_list|(
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|RexNode
name|expr
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|expr0
range|:
name|exprs
control|)
block|{
name|expr0
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns whether an expression is constant.    */
specifier|public
name|boolean
name|isConstant
parameter_list|(
name|RexNode
name|ref
parameter_list|)
block|{
return|return
name|ref
operator|.
name|accept
argument_list|(
operator|new
name|ConstantFinder
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|gatherExpr
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
return|return
name|expr
operator|.
name|accept
argument_list|(
operator|new
name|Marshaller
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the input field that an output field is populated from, or -1 if    * it is populated from an expression.    */
specifier|public
name|int
name|getSourceField
parameter_list|(
name|int
name|outputOrdinal
parameter_list|)
block|{
assert|assert
operator|(
name|outputOrdinal
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|outputOrdinal
operator|<
name|this
operator|.
name|projects
operator|.
name|size
argument_list|()
operator|)
assert|;
name|RexLocalRef
name|project
init|=
name|projects
operator|.
name|get
argument_list|(
name|outputOrdinal
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|project
operator|.
name|index
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|RexNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|RexCall
operator|&&
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|IN_FENNEL
condition|)
block|{
comment|// drill through identity function
name|expr
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|instanceof
name|RexLocalRef
condition|)
block|{
name|index
operator|=
operator|(
operator|(
name|RexLocalRef
operator|)
name|expr
operator|)
operator|.
name|index
expr_stmt|;
block|}
if|else if
condition|(
name|expr
operator|instanceof
name|RexInputRef
condition|)
block|{
return|return
operator|(
operator|(
name|RexInputRef
operator|)
name|expr
operator|)
operator|.
name|index
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
comment|/**    * Returns whether this program is a permutation of its inputs.    */
specifier|public
name|boolean
name|isPermutation
parameter_list|()
block|{
if|if
condition|(
name|projects
operator|.
name|size
argument_list|()
operator|!=
name|inputRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|getSourceField
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns a permutation, if this program is a permutation, otherwise null.    */
specifier|public
name|Permutation
name|getPermutation
parameter_list|()
block|{
name|Permutation
name|permutation
init|=
operator|new
name|Permutation
argument_list|(
name|projects
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|projects
operator|.
name|size
argument_list|()
operator|!=
name|inputRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|sourceField
init|=
name|getSourceField
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceField
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|permutation
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|sourceField
argument_list|)
expr_stmt|;
block|}
return|return
name|permutation
return|;
block|}
comment|/**    * Returns the set of correlation variables used (read) by this program.    *    * @return set of correlation variable names    */
specifier|public
name|HashSet
argument_list|<
name|String
argument_list|>
name|getCorrelVariableNames
parameter_list|()
block|{
specifier|final
name|HashSet
argument_list|<
name|String
argument_list|>
name|paramIdSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|apply
argument_list|(
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
specifier|public
name|Void
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|correlVariable
parameter_list|)
block|{
name|paramIdSet
operator|.
name|add
argument_list|(
name|correlVariable
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|,
name|exprs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|paramIdSet
return|;
block|}
comment|/**    * Returns whether this program is in canonical form.    *    * @param fail       Whether to throw an assertion error if not in canonical    *                   form    * @param rexBuilder Rex builder    * @return whether in canonical form    */
specifier|public
name|boolean
name|isNormalized
parameter_list|(
name|boolean
name|fail
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
specifier|final
name|RexProgram
name|normalizedProgram
init|=
name|RexProgramBuilder
operator|.
name|normalize
argument_list|(
name|rexBuilder
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|String
name|normalized
init|=
name|normalizedProgram
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|string
init|=
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|normalized
operator|.
name|equals
argument_list|(
name|string
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"Program is not normalized:\n"
operator|+
literal|"program:    "
operator|+
name|string
operator|+
literal|"\n"
operator|+
literal|"normalized: "
operator|+
name|normalized
operator|+
literal|"\n"
assert|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Visitor which walks over a program and checks validity.    */
specifier|static
class|class
name|Checker
extends|extends
name|RexChecker
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|internalExprTypeList
decl_stmt|;
comment|/**      * Creates a Checker.      *      * @param fail                 Whether to fail      * @param inputRowType         Types of the input fields      * @param internalExprTypeList Types of the internal expressions      */
specifier|public
name|Checker
parameter_list|(
name|boolean
name|fail
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|internalExprTypeList
parameter_list|)
block|{
name|super
argument_list|(
name|inputRowType
argument_list|,
name|fail
argument_list|)
expr_stmt|;
name|this
operator|.
name|internalExprTypeList
operator|=
name|internalExprTypeList
expr_stmt|;
block|}
comment|// override RexChecker; RexLocalRef is illegal in most rex expressions,
comment|// but legal in a program
specifier|public
name|Boolean
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|localRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|internalExprTypeList
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
operator|++
name|failCount
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|RelOptUtil
operator|.
name|eq
argument_list|(
literal|"type1"
argument_list|,
name|localRef
operator|.
name|getType
argument_list|()
argument_list|,
literal|"type2"
argument_list|,
name|internalExprTypeList
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|fail
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
operator|++
name|failCount
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/**    * A RexShuttle used in the implementation of {@link    * RexProgram#expandLocalRef}.    */
specifier|private
class|class
name|ExpansionShuttle
extends|extends
name|RexShuttle
block|{
specifier|public
name|RexNode
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
name|RexNode
name|tree
init|=
name|getExprList
argument_list|()
operator|.
name|get
argument_list|(
name|localRef
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|tree
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Walks over an expression and determines whether it is constant.    */
specifier|private
class|class
name|ConstantFinder
implements|implements
name|RexVisitor
argument_list|<
name|Boolean
argument_list|>
block|{
specifier|private
name|ConstantFinder
parameter_list|()
block|{
block|}
specifier|public
name|Boolean
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|Boolean
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|localRef
operator|.
name|index
argument_list|)
decl_stmt|;
return|return
name|expr
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|public
name|Boolean
name|visitOver
parameter_list|(
name|RexOver
name|over
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|correlVariable
parameter_list|)
block|{
comment|// Correlating variables are constant WITHIN A RESTART, so that's
comment|// good enough.
return|return
literal|true
return|;
block|}
specifier|public
name|Boolean
name|visitDynamicParam
parameter_list|(
name|RexDynamicParam
name|dynamicParam
parameter_list|)
block|{
comment|// Dynamic parameters are constant WITHIN A RESTART, so that's
comment|// good enough.
return|return
literal|true
return|;
block|}
specifier|public
name|Boolean
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
comment|// Constant if operator is deterministic and all operands are
comment|// constant.
return|return
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|isDeterministic
argument_list|()
operator|&&
name|RexVisitorImpl
operator|.
name|visitArrayAnd
argument_list|(
name|this
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|Boolean
name|visitRangeRef
parameter_list|(
name|RexRangeRef
name|rangeRef
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
comment|// "<expr>.FIELD" is constant iff "<expr>" is constant.
return|return
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Given an expression in a program, creates a clone of the expression with    * sub-expressions (represented by {@link RexLocalRef}s) fully expanded.    */
specifier|private
class|class
name|Marshaller
extends|extends
name|RexVisitorImpl
argument_list|<
name|RexNode
argument_list|>
block|{
name|Marshaller
parameter_list|()
block|{
name|super
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
return|return
name|inputRef
return|;
block|}
specifier|public
name|RexNode
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|localRef
operator|.
name|index
argument_list|)
decl_stmt|;
return|return
name|expr
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
return|return
name|literal
return|;
block|}
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newOperands
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|newOperands
operator|.
name|add
argument_list|(
name|operand
operator|.
name|accept
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|call
operator|.
name|clone
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|newOperands
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitOver
parameter_list|(
name|RexOver
name|over
parameter_list|)
block|{
return|return
name|visitCall
argument_list|(
name|over
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|correlVariable
parameter_list|)
block|{
return|return
name|correlVariable
return|;
block|}
specifier|public
name|RexNode
name|visitDynamicParam
parameter_list|(
name|RexDynamicParam
name|dynamicParam
parameter_list|)
block|{
return|return
name|dynamicParam
return|;
block|}
specifier|public
name|RexNode
name|visitRangeRef
parameter_list|(
name|RexRangeRef
name|rangeRef
parameter_list|)
block|{
return|return
name|rangeRef
return|;
block|}
specifier|public
name|RexNode
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
specifier|final
name|RexNode
name|referenceExpr
init|=
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
operator|.
name|accept
argument_list|(
name|this
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexFieldAccess
argument_list|(
name|referenceExpr
argument_list|,
name|fieldAccess
operator|.
name|getField
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Visitor which marks which expressions are used.    */
specifier|private
class|class
name|ReferenceCounter
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
name|ReferenceCounter
parameter_list|()
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Void
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|localRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|refCounts
index|[
name|index
index|]
operator|++
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End RexProgram.java
end_comment

end_unit

