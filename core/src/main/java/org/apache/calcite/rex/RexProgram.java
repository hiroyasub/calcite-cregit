begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|externalize
operator|.
name|RelJsonWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|externalize
operator|.
name|RelWriterImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Permutation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|MappingType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|errorprone
operator|.
name|annotations
operator|.
name|CheckReturnValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|initialization
operator|.
name|qual
operator|.
name|UnknownInitialization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|MonotonicNonNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|dataflow
operator|.
name|qual
operator|.
name|Pure
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Nullness
operator|.
name|castNonNull
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * A collection of expressions which read inputs, compute output expressions,  * and optionally use a condition to filter rows.  *  *<p>Programs are immutable. It may help to use a {@link RexProgramBuilder},  * which has the same relationship to {@link RexProgram} as {@link StringBuilder}  * has to {@link String}.  *  *<p>A program can contain aggregate functions. If it does, the arguments to  * each aggregate function must be an {@link RexInputRef}.  *  * @see RexProgramBuilder  */
end_comment

begin_class
specifier|public
class|class
name|RexProgram
block|{
comment|//~ Instance fields --------------------------------------------------------
comment|/**    * First stage of expression evaluation. The expressions in this array can    * refer to inputs (using input ordinal #0) or previous expressions in the    * array (using input ordinal #1).    */
specifier|private
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
decl_stmt|;
comment|/**    * With {@link #condition}, the second stage of expression evaluation.    */
specifier|private
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projects
decl_stmt|;
comment|/**    * The optional condition. If null, the calculator does not filter rows.    */
specifier|private
specifier|final
annotation|@
name|Nullable
name|RexLocalRef
name|condition
decl_stmt|;
specifier|private
specifier|final
name|RelDataType
name|inputRowType
decl_stmt|;
specifier|private
specifier|final
name|RelDataType
name|outputRowType
decl_stmt|;
comment|/**    * Reference counts for each expression, computed on demand.    */
specifier|private
name|int
annotation|@
name|MonotonicNonNull
type|[]
name|refCounts
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a program.    *    *<p>The expressions must be valid: they must not contain common expressions,    * forward references, or non-trivial aggregates.</p>    *    * @param inputRowType  Input row type    * @param exprs         Common expressions    * @param projects      Projection expressions    * @param condition     Condition expression. If null, calculator does not    *                      filter rows    * @param outputRowType Description of the row produced by the program    */
specifier|public
name|RexProgram
parameter_list|(
name|RelDataType
name|inputRowType
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projects
parameter_list|,
annotation|@
name|Nullable
name|RexLocalRef
name|condition
parameter_list|,
name|RelDataType
name|outputRowType
parameter_list|)
block|{
name|this
operator|.
name|inputRowType
operator|=
name|inputRowType
expr_stmt|;
name|this
operator|.
name|exprs
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|exprs
argument_list|)
expr_stmt|;
name|this
operator|.
name|projects
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|projects
argument_list|)
expr_stmt|;
name|this
operator|.
name|condition
operator|=
name|condition
expr_stmt|;
name|this
operator|.
name|outputRowType
operator|=
name|outputRowType
expr_stmt|;
assert|assert
name|isValid
argument_list|(
name|Litmus
operator|.
name|THROW
argument_list|,
literal|null
argument_list|)
assert|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|// REVIEW jvs 16-Oct-2006:  The description below is confusing.  I
comment|// think it means "none of the entries are null, there may be none,
comment|// and there is no further reduction into smaller common sub-expressions
comment|// possible"?
comment|/**    * Returns the common sub-expressions of this program.    *    *<p>The list is never null but may be empty; each the expression in the    * list is not null; and no further reduction into smaller common    * sub-expressions is possible.    */
specifier|public
name|List
argument_list|<
name|RexNode
argument_list|>
name|getExprList
parameter_list|()
block|{
return|return
name|exprs
return|;
block|}
comment|/**    * Returns an array of references to the expressions which this program is    * to project. Never null, may be empty.    */
specifier|public
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|getProjectList
parameter_list|()
block|{
return|return
name|projects
return|;
block|}
comment|/**    * Returns a list of project expressions and their field names.    */
specifier|public
name|List
argument_list|<
name|Pair
argument_list|<
name|RexLocalRef
argument_list|,
name|String
argument_list|>
argument_list|>
name|getNamedProjects
parameter_list|()
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|Pair
argument_list|<
name|RexLocalRef
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|projects
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|RexLocalRef
argument_list|,
name|String
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|projects
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|outputRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns the field reference of this program's filter condition, or null    * if there is no condition.    */
annotation|@
name|Pure
specifier|public
annotation|@
name|Nullable
name|RexLocalRef
name|getCondition
parameter_list|()
block|{
return|return
name|condition
return|;
block|}
comment|/**    * Creates a program which calculates projections and filters rows based    * upon a condition. Does not attempt to eliminate common sub-expressions.    *    * @param projectExprs  Project expressions    * @param conditionExpr Condition on which to filter rows, or null if rows    *                      are not to be filtered    * @param outputRowType Output row type    * @param rexBuilder    Builder of rex expressions    * @return A program    */
specifier|public
specifier|static
name|RexProgram
name|create
parameter_list|(
name|RelDataType
name|inputRowType
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|projectExprs
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|conditionExpr
parameter_list|,
name|RelDataType
name|outputRowType
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|inputRowType
argument_list|,
name|projectExprs
argument_list|,
name|conditionExpr
argument_list|,
name|outputRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|,
name|rexBuilder
argument_list|)
return|;
block|}
comment|/**    * Creates a program which calculates projections and filters rows based    * upon a condition. Does not attempt to eliminate common sub-expressions.    *    * @param projectExprs  Project expressions    * @param conditionExpr Condition on which to filter rows, or null if rows    *                      are not to be filtered    * @param fieldNames    Names of projected fields    * @param rexBuilder    Builder of rex expressions    * @return A program    */
specifier|public
specifier|static
name|RexProgram
name|create
argument_list|(
name|RelDataType
name|inputRowType
argument_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|projectExprs
argument_list|,
annotation|@
name|Nullable
name|RexNode
name|conditionExpr
argument_list|,
annotation|@
name|Nullable
name|List
operator|<
condition|?
then|extends @
name|Nullable
name|String
operator|>
name|fieldNames
argument_list|,
name|RexBuilder
name|rexBuilder
argument_list|)
block|{
if|if
condition|(
name|fieldNames
operator|==
literal|null
condition|)
block|{
name|fieldNames
operator|=
name|Collections
operator|.
name|nCopies
argument_list|(
name|projectExprs
operator|.
name|size
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|fieldNames
operator|.
name|size
argument_list|()
operator|==
name|projectExprs
operator|.
name|size
argument_list|()
operator|:
literal|"fieldNames="
operator|+
name|fieldNames
operator|+
literal|", exprs="
operator|+
name|projectExprs
assert|;
block|}
specifier|final
name|RexProgramBuilder
name|programBuilder
init|=
operator|new
name|RexProgramBuilder
argument_list|(
name|inputRowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projectExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|programBuilder
operator|.
name|addProject
argument_list|(
name|projectExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conditionExpr
operator|!=
literal|null
condition|)
block|{
name|programBuilder
operator|.
name|addCondition
argument_list|(
name|conditionExpr
argument_list|)
expr_stmt|;
block|}
return|return
name|programBuilder
operator|.
name|getProgram
argument_list|()
return|;
block|}
comment|/**    * Create a program from serialized output.    * In this case, the input is mainly from the output json string of {@link RelJsonWriter}    */
specifier|public
specifier|static
name|RexProgram
name|create
parameter_list|(
name|RelInput
name|input
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|requireNonNull
argument_list|(
name|input
operator|.
name|getExpressionList
argument_list|(
literal|"exprs"
argument_list|)
argument_list|,
literal|"exprs"
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|projectRexNodes
init|=
name|requireNonNull
argument_list|(
name|input
operator|.
name|getExpressionList
argument_list|(
literal|"projects"
argument_list|)
argument_list|,
literal|"projects"
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|projectRexNodes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|rexNode
range|:
name|projectRexNodes
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
operator|(
name|RexLocalRef
operator|)
name|rexNode
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataType
name|inputType
init|=
name|input
operator|.
name|getRowType
argument_list|(
literal|"inputRowType"
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|outputType
init|=
name|input
operator|.
name|getRowType
argument_list|(
literal|"outputRowType"
argument_list|)
decl_stmt|;
specifier|final
name|RexLocalRef
name|condition
init|=
operator|(
name|RexLocalRef
operator|)
name|input
operator|.
name|getExpression
argument_list|(
literal|"condition"
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexProgram
argument_list|(
name|inputType
argument_list|,
name|exprs
argument_list|,
name|projects
argument_list|,
name|condition
argument_list|,
name|outputType
argument_list|)
return|;
block|}
comment|// description of this calc, chiefly intended for debugging
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
comment|// Intended to produce similar output to explainCalc,
comment|// but without requiring a RelNode or RelOptPlanWriter.
specifier|final
name|RelWriterImpl
name|pw
init|=
operator|new
name|RelWriterImpl
argument_list|(
operator|new
name|PrintWriter
argument_list|(
operator|new
name|StringWriter
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|collectExplainTerms
argument_list|(
literal|""
argument_list|,
name|pw
argument_list|)
expr_stmt|;
return|return
name|pw
operator|.
name|simple
argument_list|()
return|;
block|}
comment|/**    * Writes an explanation of the expressions in this program to a plan    * writer.    *    * @param pw Plan writer    */
specifier|public
name|RelWriter
name|explainCalc
parameter_list|(
name|RelWriter
name|pw
parameter_list|)
block|{
if|if
condition|(
name|pw
operator|instanceof
name|RelJsonWriter
condition|)
block|{
return|return
name|pw
operator|.
name|item
argument_list|(
literal|"exprs"
argument_list|,
name|exprs
argument_list|)
operator|.
name|item
argument_list|(
literal|"projects"
argument_list|,
name|projects
argument_list|)
operator|.
name|item
argument_list|(
literal|"condition"
argument_list|,
name|condition
argument_list|)
operator|.
name|item
argument_list|(
literal|"inputRowType"
argument_list|,
name|inputRowType
argument_list|)
operator|.
name|item
argument_list|(
literal|"outputRowType"
argument_list|,
name|outputRowType
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|collectExplainTerms
argument_list|(
literal|""
argument_list|,
name|pw
argument_list|,
name|pw
operator|.
name|getDetailLevel
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|public
name|RelWriter
name|collectExplainTerms
parameter_list|(
name|String
name|prefix
parameter_list|,
name|RelWriter
name|pw
parameter_list|)
block|{
return|return
name|collectExplainTerms
argument_list|(
name|prefix
argument_list|,
name|pw
argument_list|,
name|SqlExplainLevel
operator|.
name|EXPPLAN_ATTRIBUTES
argument_list|)
return|;
block|}
comment|/**    * Collects the expressions in this program into a list of terms and values.    *    * @param prefix Prefix for term names, usually the empty string, but useful    *               if a relational expression contains more than one program    * @param pw     Plan writer    */
specifier|public
name|RelWriter
name|collectExplainTerms
parameter_list|(
name|String
name|prefix
parameter_list|,
name|RelWriter
name|pw
parameter_list|,
name|SqlExplainLevel
name|level
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|inFields
init|=
name|inputRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|outFields
init|=
name|outputRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|outFields
operator|.
name|size
argument_list|()
operator|==
name|projects
operator|.
name|size
argument_list|()
operator|:
literal|"outFields.length="
operator|+
name|outFields
operator|.
name|size
argument_list|()
operator|+
literal|", projects.length="
operator|+
name|projects
operator|.
name|size
argument_list|()
assert|;
name|pw
operator|.
name|item
argument_list|(
name|prefix
operator|+
literal|"expr#0"
operator|+
operator|(
operator|(
name|inFields
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
condition|?
operator|(
literal|".."
operator|+
operator|(
name|inFields
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
operator|)
else|:
literal|""
operator|)
argument_list|,
literal|"{inputs}"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|inFields
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|pw
operator|.
name|item
argument_list|(
name|prefix
operator|+
literal|"expr#"
operator|+
name|i
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If a lot of the fields are simply projections of the underlying
comment|// expression, try to be a bit less verbose.
name|int
name|trivialCount
init|=
name|countTrivial
argument_list|(
name|projects
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|trivialCount
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|trivialCount
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|pw
operator|.
name|item
argument_list|(
name|prefix
operator|+
literal|"proj#0.."
operator|+
operator|(
name|trivialCount
operator|-
literal|1
operator|)
argument_list|,
literal|"{exprs}"
argument_list|)
expr_stmt|;
break|break;
block|}
specifier|final
name|boolean
name|withFieldNames
init|=
name|level
operator|!=
name|SqlExplainLevel
operator|.
name|DIGEST_ATTRIBUTES
decl_stmt|;
comment|// Print the non-trivial fields with their names as they appear in the
comment|// output row type.
for|for
control|(
name|int
name|i
init|=
name|trivialCount
init|;
name|i
operator|<
name|projects
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|fieldName
init|=
name|withFieldNames
condition|?
name|prefix
operator|+
name|outFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
else|:
name|prefix
operator|+
name|i
decl_stmt|;
name|pw
operator|.
name|item
argument_list|(
name|fieldName
argument_list|,
name|projects
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|condition
operator|!=
literal|null
condition|)
block|{
name|pw
operator|.
name|item
argument_list|(
name|prefix
operator|+
literal|"$condition"
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
return|return
name|pw
return|;
block|}
comment|/**    * Returns the number of expressions at the front of an array which are    * simply projections of the same field.    *    * @param refs References    */
specifier|private
specifier|static
name|int
name|countTrivial
parameter_list|(
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|refs
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|refs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexLocalRef
name|ref
init|=
name|refs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|.
name|getIndex
argument_list|()
operator|!=
name|i
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
name|refs
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Returns the number of expressions in this program.    */
specifier|public
name|int
name|getExprCount
parameter_list|()
block|{
return|return
name|exprs
operator|.
name|size
argument_list|()
operator|+
name|projects
operator|.
name|size
argument_list|()
operator|+
operator|(
operator|(
name|condition
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
comment|/**    * Creates the identity program.    */
specifier|public
specifier|static
name|RexProgram
name|createIdentity
parameter_list|(
name|RelDataType
name|rowType
parameter_list|)
block|{
return|return
name|createIdentity
argument_list|(
name|rowType
argument_list|,
name|rowType
argument_list|)
return|;
block|}
comment|/**    * Creates a program that projects its input fields but with possibly    * different names for the output fields.    */
specifier|public
specifier|static
name|RexProgram
name|createIdentity
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|RelDataType
name|outputRowType
parameter_list|)
block|{
if|if
condition|(
name|rowType
operator|!=
name|outputRowType
operator|&&
operator|!
name|Pair
operator|.
name|right
argument_list|(
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|Pair
operator|.
name|right
argument_list|(
name|outputRowType
operator|.
name|getFieldList
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field type mismatch: "
operator|+
name|rowType
operator|+
literal|" vs. "
operator|+
name|outputRowType
argument_list|)
throw|;
block|}
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|refs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexInputRef
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
name|i
argument_list|,
name|fields
argument_list|)
decl_stmt|;
name|refs
operator|.
name|add
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|projectRefs
operator|.
name|add
argument_list|(
operator|new
name|RexLocalRef
argument_list|(
name|i
argument_list|,
name|ref
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RexProgram
argument_list|(
name|rowType
argument_list|,
name|refs
argument_list|,
name|projectRefs
argument_list|,
literal|null
argument_list|,
name|outputRowType
argument_list|)
return|;
block|}
comment|/**    * Returns the type of the input row to the program.    *    * @return input row type    */
specifier|public
name|RelDataType
name|getInputRowType
parameter_list|()
block|{
return|return
name|inputRowType
return|;
block|}
comment|/**    * Returns whether this program contains windowed aggregate functions.    *    * @return whether this program contains windowed aggregate functions    */
specifier|public
name|boolean
name|containsAggs
parameter_list|()
block|{
return|return
name|RexOver
operator|.
name|containsOver
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Returns the type of the output row from this program.    *    * @return output row type    */
specifier|public
name|RelDataType
name|getOutputRowType
parameter_list|()
block|{
return|return
name|outputRowType
return|;
block|}
comment|/**    * Checks that this program is valid.    *    *<p>If<code>fail</code> is true, executes<code>assert false</code>, so    * will throw an {@link AssertionError} if assertions are enabled. If<code>    * fail</code> is false, merely returns whether the program is valid.    *    * @param litmus What to do if an error is detected    * @param context Context of enclosing {@link RelNode}, for validity checking,    *                or null if not known    * @return Whether the program is valid    */
specifier|public
name|boolean
name|isValid
argument_list|(
annotation|@
name|UnknownInitialization
name|RexProgram
name|this
argument_list|,
name|Litmus
name|litmus
argument_list|,
name|RelNode
operator|.
expr|@
name|Nullable
name|Context
name|context
argument_list|)
block|{
if|if
condition|(
name|inputRowType
operator|==
literal|null
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
if|if
condition|(
name|exprs
operator|==
literal|null
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
if|if
condition|(
name|projects
operator|==
literal|null
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
if|if
condition|(
name|outputRowType
operator|==
literal|null
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|// If the input row type is a struct (contains fields) then the leading
comment|// expressions must be references to those fields. But we don't require
comment|// this if the input row type is, say, a java class.
if|if
condition|(
name|inputRowType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|containIdentity
argument_list|(
name|exprs
argument_list|,
name|inputRowType
argument_list|,
name|litmus
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|// None of the other fields should be inputRefs.
for|for
control|(
name|int
name|i
init|=
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|RexInputRef
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
block|}
comment|// todo: enable
comment|// CHECKSTYLE: IGNORE 1
if|if
condition|(
literal|false
operator|&&
name|RexUtil
operator|.
name|containNoCommonExprs
argument_list|(
name|exprs
argument_list|,
name|litmus
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|containNoForwardRefs
argument_list|(
name|exprs
argument_list|,
name|inputRowType
argument_list|,
name|litmus
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|containNoNonTrivialAggs
argument_list|(
name|exprs
argument_list|,
name|litmus
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
specifier|final
name|Checker
name|checker
init|=
operator|new
name|Checker
argument_list|(
name|inputRowType
argument_list|,
name|RexUtil
operator|.
name|types
argument_list|(
name|exprs
argument_list|)
argument_list|,
literal|null
argument_list|,
name|litmus
argument_list|)
decl_stmt|;
if|if
condition|(
name|condition
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|inBooleanFamily
argument_list|(
name|condition
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"condition must be boolean"
argument_list|)
return|;
block|}
name|condition
operator|.
name|accept
argument_list|(
name|checker
argument_list|)
expr_stmt|;
if|if
condition|(
name|checker
operator|.
name|failCount
operator|>
literal|0
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
for|for
control|(
name|RexLocalRef
name|project
range|:
name|projects
control|)
block|{
name|project
operator|.
name|accept
argument_list|(
name|checker
argument_list|)
expr_stmt|;
if|if
condition|(
name|checker
operator|.
name|failCount
operator|>
literal|0
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
name|expr
operator|.
name|accept
argument_list|(
name|checker
argument_list|)
expr_stmt|;
if|if
condition|(
name|checker
operator|.
name|failCount
operator|>
literal|0
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Returns whether an expression always evaluates to null.    *    *<p>Like {@link RexUtil#isNull(RexNode)}, null literals are null, and    * casts of null literals are null. But this method also regards references    * to null expressions as null.</p>    *    * @param expr Expression    * @return Whether expression always evaluates to null    */
specifier|public
name|boolean
name|isNull
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
switch|switch
condition|(
name|expr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LITERAL
case|:
return|return
operator|(
operator|(
name|RexLiteral
operator|)
name|expr
operator|)
operator|.
name|getValue2
argument_list|()
operator|==
literal|null
return|;
case|case
name|LOCAL_REF
case|:
name|RexLocalRef
name|inputRef
init|=
operator|(
name|RexLocalRef
operator|)
name|expr
decl_stmt|;
return|return
name|isNull
argument_list|(
name|exprs
operator|.
name|get
argument_list|(
name|inputRef
operator|.
name|index
argument_list|)
argument_list|)
return|;
case|case
name|CAST
case|:
return|return
name|isNull
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Fully expands a RexLocalRef back into a pure RexNode tree containing no    * RexLocalRefs (reversing the effect of common subexpression elimination).    * For example,<code>program.expandLocalRef(program.getCondition())</code>    * will return the expansion of a program's condition.    *    * @param ref a RexLocalRef from this program    * @return expanded form    */
specifier|public
name|RexNode
name|expandLocalRef
parameter_list|(
name|RexLocalRef
name|ref
parameter_list|)
block|{
return|return
name|ref
operator|.
name|accept
argument_list|(
operator|new
name|ExpansionShuttle
argument_list|(
name|exprs
argument_list|)
argument_list|)
return|;
block|}
comment|/** Expands a list of expressions that may contain {@link RexLocalRef}s. */
specifier|public
name|List
argument_list|<
name|RexNode
argument_list|>
name|expandList
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
operator|new
name|ExpansionShuttle
argument_list|(
name|exprs
argument_list|)
operator|.
name|visitList
argument_list|(
name|nodes
argument_list|)
return|;
block|}
comment|/** Splits this program into a list of project expressions and a list of    * filter expressions.    *    *<p>Neither list is null.    * The filters are evaluated first. */
specifier|public
name|Pair
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|split
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|condition
operator|!=
literal|null
condition|)
block|{
name|RelOptUtil
operator|.
name|decomposeConjunction
argument_list|(
name|expandLocalRef
argument_list|(
name|condition
argument_list|)
argument_list|,
name|filters
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RexLocalRef
name|project
range|:
name|this
operator|.
name|projects
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|expandLocalRef
argument_list|(
name|project
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|projects
operator|.
name|build
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|filters
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Given a list of collations which hold for the input to this program,    * returns a list of collations which hold for its output. The result is    * mutable and sorted.    */
specifier|public
name|List
argument_list|<
name|RelCollation
argument_list|>
name|getCollations
parameter_list|(
name|List
argument_list|<
name|RelCollation
argument_list|>
name|inputCollations
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelCollation
argument_list|>
name|outputCollations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|deduceCollations
argument_list|(
name|outputCollations
argument_list|,
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|projects
argument_list|,
name|inputCollations
argument_list|)
expr_stmt|;
return|return
name|outputCollations
return|;
block|}
comment|/**    * Given a list of expressions and a description of which are ordered,    * populates a list of collations, sorted in natural order.    */
specifier|public
specifier|static
name|void
name|deduceCollations
parameter_list|(
name|List
argument_list|<
name|RelCollation
argument_list|>
name|outputCollations
parameter_list|,
specifier|final
name|int
name|sourceCount
parameter_list|,
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|refs
parameter_list|,
name|List
argument_list|<
name|RelCollation
argument_list|>
name|inputCollations
parameter_list|)
block|{
name|int
index|[]
name|targets
init|=
operator|new
name|int
index|[
name|sourceCount
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|targets
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|refs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexLocalRef
name|ref
init|=
name|refs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|source
init|=
name|ref
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|source
operator|<
name|sourceCount
operator|)
operator|&&
operator|(
name|targets
index|[
name|source
index|]
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|targets
index|[
name|source
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
name|loop
label|:
for|for
control|(
name|RelCollation
name|collation
range|:
name|inputCollations
control|)
block|{
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|fieldCollation
range|:
name|collation
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
specifier|final
name|int
name|source
init|=
name|fieldCollation
operator|.
name|getFieldIndex
argument_list|()
decl_stmt|;
specifier|final
name|int
name|target
init|=
name|targets
index|[
name|source
index|]
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|0
condition|)
block|{
continue|continue
name|loop
continue|;
block|}
name|fieldCollations
operator|.
name|add
argument_list|(
name|fieldCollation
operator|.
name|withFieldIndex
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Success -- all of the source fields of this key are mapped
comment|// to the output.
name|outputCollations
operator|.
name|add
argument_list|(
name|RelCollations
operator|.
name|of
argument_list|(
name|fieldCollations
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|outputCollations
operator|.
name|sort
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns whether the fields on the leading edge of the project list are    * the input fields.    *    * @param fail Whether to throw an assert failure if does not project    *             identity    */
specifier|public
name|boolean
name|projectsIdentity
parameter_list|(
specifier|final
name|boolean
name|fail
parameter_list|)
block|{
specifier|final
name|int
name|fieldCount
init|=
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|projects
operator|.
name|size
argument_list|()
operator|<
name|fieldCount
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"program '"
operator|+
name|toString
argument_list|()
operator|+
literal|"' does not project identity for input row type '"
operator|+
name|inputRowType
operator|+
literal|"'"
assert|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldCount
condition|;
name|i
operator|++
control|)
block|{
name|RexLocalRef
name|project
init|=
name|projects
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|project
operator|.
name|index
operator|!=
name|i
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"program "
operator|+
name|toString
argument_list|()
operator|+
literal|"' does not project identity for input row type '"
operator|+
name|inputRowType
operator|+
literal|"', field #"
operator|+
name|i
assert|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether this program projects precisely its input fields. It may    * or may not apply a condition.    */
specifier|public
name|boolean
name|projectsOnlyIdentity
parameter_list|()
block|{
if|if
condition|(
name|projects
operator|.
name|size
argument_list|()
operator|!=
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projects
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexLocalRef
name|project
init|=
name|projects
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|project
operator|.
name|index
operator|!=
name|i
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether this program returns its input exactly.    *    *<p>This is a stronger condition than {@link #projectsIdentity(boolean)}.    */
specifier|public
name|boolean
name|isTrivial
parameter_list|()
block|{
return|return
name|getCondition
argument_list|()
operator|==
literal|null
operator|&&
name|projectsOnlyIdentity
argument_list|()
return|;
block|}
comment|/**    * Gets reference counts for each expression in the program, where the    * references are detected from later expressions in the same program, as    * well as the project list and condition. Expressions with references    * counts greater than 1 are true common sub-expressions.    *    * @return array of reference counts; the ith element in the returned array    * is the number of references to getExprList()[i]    */
specifier|public
name|int
index|[]
name|getReferenceCounts
parameter_list|()
block|{
if|if
condition|(
name|refCounts
operator|!=
literal|null
condition|)
block|{
return|return
name|refCounts
return|;
block|}
name|refCounts
operator|=
operator|new
name|int
index|[
name|exprs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|ReferenceCounter
name|refCounter
init|=
operator|new
name|ReferenceCounter
argument_list|(
name|refCounts
argument_list|)
decl_stmt|;
name|RexUtil
operator|.
name|apply
argument_list|(
name|refCounter
argument_list|,
name|exprs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|condition
operator|!=
literal|null
condition|)
block|{
name|refCounter
operator|.
name|visitLocalRef
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RexLocalRef
name|project
range|:
name|projects
control|)
block|{
name|refCounter
operator|.
name|visitLocalRef
argument_list|(
name|project
argument_list|)
expr_stmt|;
block|}
return|return
name|refCounts
return|;
block|}
comment|/**    * Returns whether an expression is constant.    */
specifier|public
name|boolean
name|isConstant
parameter_list|(
name|RexNode
name|ref
parameter_list|)
block|{
return|return
name|ref
operator|.
name|accept
argument_list|(
operator|new
name|ConstantFinder
argument_list|()
argument_list|)
return|;
block|}
specifier|public
annotation|@
name|Nullable
name|RexNode
name|gatherExpr
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
return|return
name|expr
operator|.
name|accept
argument_list|(
operator|new
name|Marshaller
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the input field that an output field is populated from, or -1 if    * it is populated from an expression.    */
specifier|public
name|int
name|getSourceField
parameter_list|(
name|int
name|outputOrdinal
parameter_list|)
block|{
assert|assert
operator|(
name|outputOrdinal
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|outputOrdinal
operator|<
name|this
operator|.
name|projects
operator|.
name|size
argument_list|()
operator|)
assert|;
name|RexLocalRef
name|project
init|=
name|projects
operator|.
name|get
argument_list|(
name|outputOrdinal
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|project
operator|.
name|index
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|RexNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|RexCall
operator|&&
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|IN_FENNEL
condition|)
block|{
comment|// drill through identity function
name|expr
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|instanceof
name|RexLocalRef
condition|)
block|{
name|index
operator|=
operator|(
operator|(
name|RexLocalRef
operator|)
name|expr
operator|)
operator|.
name|index
expr_stmt|;
block|}
if|else if
condition|(
name|expr
operator|instanceof
name|RexInputRef
condition|)
block|{
return|return
operator|(
operator|(
name|RexInputRef
operator|)
name|expr
operator|)
operator|.
name|index
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
comment|/**    * Returns whether this program is a permutation of its inputs.    */
specifier|public
name|boolean
name|isPermutation
parameter_list|()
block|{
if|if
condition|(
name|projects
operator|.
name|size
argument_list|()
operator|!=
name|inputRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|getSourceField
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns a permutation, if this program is a permutation, otherwise null.    */
annotation|@
name|CheckReturnValue
specifier|public
annotation|@
name|Nullable
name|Permutation
name|getPermutation
parameter_list|()
block|{
name|Permutation
name|permutation
init|=
operator|new
name|Permutation
argument_list|(
name|projects
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|projects
operator|.
name|size
argument_list|()
operator|!=
name|inputRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|sourceField
init|=
name|getSourceField
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceField
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|permutation
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|sourceField
argument_list|)
expr_stmt|;
block|}
return|return
name|permutation
return|;
block|}
comment|/**    * Returns the set of correlation variables used (read) by this program.    *    * @return set of correlation variable names    */
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getCorrelVariableNames
parameter_list|()
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|paramIdSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|RexUtil
operator|.
name|apply
argument_list|(
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|correlVariable
parameter_list|)
block|{
name|paramIdSet
operator|.
name|add
argument_list|(
name|correlVariable
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|,
name|exprs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|paramIdSet
return|;
block|}
comment|/**    * Returns whether this program is in canonical form.    *    * @param litmus     What to do if an error is detected (program is not in    *                   canonical form)    * @param rexBuilder Rex builder    * @return whether in canonical form    */
specifier|public
name|boolean
name|isNormalized
parameter_list|(
name|Litmus
name|litmus
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
specifier|final
name|RexProgram
name|normalizedProgram
init|=
name|normalize
argument_list|(
name|rexBuilder
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|String
name|normalized
init|=
name|normalizedProgram
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|string
init|=
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|normalized
operator|.
name|equals
argument_list|(
name|string
argument_list|)
condition|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Program is not normalized:\n"
operator|+
literal|"program:    {}\n"
operator|+
literal|"normalized: {}\n"
decl_stmt|;
return|return
name|litmus
operator|.
name|fail
argument_list|(
name|message
argument_list|,
name|string
argument_list|,
name|normalized
argument_list|)
return|;
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Creates a simplified/normalized copy of this program.    *    * @param rexBuilder Rex builder    * @param simplify Simplifier to simplify (in addition to normalizing),    *     or null to not simplify    * @return Normalized program    */
specifier|public
name|RexProgram
name|normalize
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
annotation|@
name|Nullable
name|RexSimplify
name|simplify
parameter_list|)
block|{
comment|// Normalize program by creating program builder from the program, then
comment|// converting to a program. getProgram does not need to normalize
comment|// because the builder was normalized on creation.
assert|assert
name|isValid
argument_list|(
name|Litmus
operator|.
name|THROW
argument_list|,
literal|null
argument_list|)
assert|;
specifier|final
name|RexProgramBuilder
name|builder
init|=
name|RexProgramBuilder
operator|.
name|create
argument_list|(
name|rexBuilder
argument_list|,
name|inputRowType
argument_list|,
name|exprs
argument_list|,
name|projects
argument_list|,
name|condition
argument_list|,
name|outputRowType
argument_list|,
literal|true
argument_list|,
name|simplify
argument_list|)
decl_stmt|;
return|return
name|builder
operator|.
name|getProgram
argument_list|(
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|RexProgram
name|normalize
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|boolean
name|simplify
parameter_list|)
block|{
specifier|final
name|RelOptPredicateList
name|predicates
init|=
name|RelOptPredicateList
operator|.
name|EMPTY
decl_stmt|;
return|return
name|normalize
argument_list|(
name|rexBuilder
argument_list|,
name|simplify
condition|?
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|predicates
argument_list|,
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
else|:
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns a partial mapping of a set of project expressions.    *    *<p>The mapping is an inverse function.    * Every target has a source field, but    * a source might have 0, 1 or more targets.    * Project expressions that do not consist of    * a mapping are ignored.    *    * @param inputFieldCount Number of input fields    * @return Mapping of a set of project expressions, never null    */
specifier|public
name|Mappings
operator|.
name|TargetMapping
name|getPartialMapping
parameter_list|(
name|int
name|inputFieldCount
parameter_list|)
block|{
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|INVERSE_FUNCTION
argument_list|,
name|inputFieldCount
argument_list|,
name|projects
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RexLocalRef
argument_list|>
name|exp
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|projects
argument_list|)
control|)
block|{
name|RexNode
name|rexNode
init|=
name|expandLocalRef
argument_list|(
name|exp
operator|.
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|rexNode
operator|instanceof
name|RexInputRef
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|rexNode
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|,
name|exp
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|mapping
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Visitor which walks over a program and checks validity.    */
specifier|static
class|class
name|Checker
extends|extends
name|RexChecker
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|internalExprTypeList
decl_stmt|;
comment|/**      * Creates a Checker.      *      * @param inputRowType         Types of the input fields      * @param internalExprTypeList Types of the internal expressions      * @param context              Context of the enclosing {@link RelNode},      *                             or null      * @param litmus               Whether to fail      */
name|Checker
argument_list|(
name|RelDataType
name|inputRowType
argument_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|internalExprTypeList
argument_list|,
name|RelNode
operator|.
expr|@
name|Nullable
name|Context
name|context
argument_list|,
name|Litmus
name|litmus
argument_list|)
block|{
name|super
argument_list|(
name|inputRowType
argument_list|,
name|context
argument_list|,
name|litmus
argument_list|)
block|;
name|this
operator|.
name|internalExprTypeList
operator|=
name|internalExprTypeList
block|;     }
comment|/** Overrides {@link RexChecker} method, because {@link RexLocalRef} is      * is illegal in most rex expressions, but legal in a program. */
expr|@
name|Override
specifier|public
name|Boolean
name|visitLocalRef
argument_list|(
name|RexLocalRef
name|localRef
argument_list|)
block|{
name|final
name|int
name|index
operator|=
name|localRef
operator|.
name|getIndex
argument_list|()
block|;
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|internalExprTypeList
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
operator|++
name|failCount
expr_stmt|;
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|RelOptUtil
operator|.
name|eq
argument_list|(
literal|"type1"
argument_list|,
name|localRef
operator|.
name|getType
argument_list|()
argument_list|,
literal|"type2"
argument_list|,
name|internalExprTypeList
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|litmus
argument_list|)
condition|)
block|{
operator|++
name|failCount
expr_stmt|;
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * A RexShuttle used in the implementation of    * {@link RexProgram#expandLocalRef}.    */
end_comment

begin_class
specifier|static
class|class
name|ExpansionShuttle
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
decl_stmt|;
name|ExpansionShuttle
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|)
block|{
name|this
operator|.
name|exprs
operator|=
name|exprs
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
name|RexNode
name|tree
init|=
name|exprs
operator|.
name|get
argument_list|(
name|localRef
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|tree
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Walks over an expression and determines whether it is constant.    */
end_comment

begin_class
specifier|private
class|class
name|ConstantFinder
extends|extends
name|RexUtil
operator|.
name|ConstantFinder
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|localRef
operator|.
name|index
argument_list|)
decl_stmt|;
return|return
name|expr
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitOver
parameter_list|(
name|RexOver
name|over
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|correlVariable
parameter_list|)
block|{
comment|// Correlating variables are constant WITHIN A RESTART, so that's
comment|// good enough.
return|return
literal|true
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Given an expression in a program, creates a clone of the expression with    * sub-expressions (represented by {@link RexLocalRef}s) fully expanded.    */
end_comment

begin_class
specifier|private
class|class
name|Marshaller
extends|extends
name|RexVisitorImpl
argument_list|<
annotation|@
name|Nullable
name|RexNode
argument_list|>
block|{
name|Marshaller
parameter_list|()
block|{
name|super
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
return|return
name|inputRef
return|;
block|}
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|RexNode
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|localRef
operator|.
name|index
argument_list|)
decl_stmt|;
return|return
name|expr
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
return|return
name|literal
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|newOperands
operator|.
name|add
argument_list|(
name|castNonNull
argument_list|(
name|operand
operator|.
name|accept
argument_list|(
name|this
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|call
operator|.
name|clone
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|newOperands
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitOver
parameter_list|(
name|RexOver
name|over
parameter_list|)
block|{
return|return
name|visitCall
argument_list|(
name|over
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|correlVariable
parameter_list|)
block|{
return|return
name|correlVariable
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitDynamicParam
parameter_list|(
name|RexDynamicParam
name|dynamicParam
parameter_list|)
block|{
return|return
name|dynamicParam
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitRangeRef
parameter_list|(
name|RexRangeRef
name|rangeRef
parameter_list|)
block|{
return|return
name|rangeRef
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
specifier|final
name|RexNode
name|referenceExpr
init|=
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
operator|.
name|accept
argument_list|(
name|this
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexFieldAccess
argument_list|(
name|requireNonNull
argument_list|(
name|referenceExpr
argument_list|,
literal|"referenceExpr must not be null"
argument_list|)
argument_list|,
name|fieldAccess
operator|.
name|getField
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Visitor which marks which expressions are used.    */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|ReferenceCounter
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|int
index|[]
name|refCounts
decl_stmt|;
name|ReferenceCounter
parameter_list|(
name|int
index|[]
name|refCounts
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|refCounts
operator|=
name|refCounts
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|localRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|refCounts
index|[
name|index
index|]
operator|++
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
end_class

unit|}
end_unit

