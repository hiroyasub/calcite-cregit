begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteSystemProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apiguardian
operator|.
name|api
operator|.
name|API
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * Context required to normalize a row-expression.  *  *<p>Currently, only simple normalization is supported, such as:  *  *<ul>  *<li>$2 = $1&rarr; $1 = $2</li>  *<li>$2&gt; $1&rarr; $1&lt; $2</li>  *<li>1.23 = $1&rarr; $1 = 1.23</li>  *<li>OR(OR(udf($1), $2), $3)&rarr; OR($3, OR($2, udf($1)))</li>  *</ul>  *  *<p>In the future, this component may extend to support more normalization cases  * for general promotion. e.g. the strategy to decide which operand is more complex  * should be more smart.  *  *<p>There is no one normalization strategy that works for all cases, and no consensus about what  * the desired strategies should be. So by default, the normalization is disabled. We do force  * normalization when computing the digest of {@link RexCall}s during planner planning.  */
end_comment

begin_class
specifier|public
class|class
name|RexNormalize
block|{
specifier|private
name|RexNormalize
parameter_list|()
block|{
block|}
comment|/**    * Normalizes the variables of a rex call.    *    * @param operator The operator    * @param operands The operands    *    * @return normalized variables of the call or the original    * if there is no need to normalize    */
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.24"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
specifier|static
name|Pair
argument_list|<
name|SqlOperator
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|normalize
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
specifier|final
name|Pair
argument_list|<
name|SqlOperator
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|original
init|=
name|Pair
operator|.
name|of
argument_list|(
name|operator
argument_list|,
name|operands
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowsNormalize
argument_list|()
operator|||
name|operands
operator|.
name|size
argument_list|()
operator|!=
literal|2
condition|)
block|{
return|return
name|original
return|;
block|}
specifier|final
name|RexNode
name|operand0
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|operand1
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// If arguments are the same, then we normalize< vs>
comment|// '<' == 60, '>' == 62, so we prefer<.
specifier|final
name|SqlKind
name|kind
init|=
name|operator
operator|.
name|getKind
argument_list|()
decl_stmt|;
specifier|final
name|SqlKind
name|reversedKind
init|=
name|kind
operator|.
name|reverse
argument_list|()
decl_stmt|;
specifier|final
name|int
name|x
init|=
name|reversedKind
operator|.
name|compareTo
argument_list|(
name|kind
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|requireNonNull
argument_list|(
name|operator
operator|.
name|reverse
argument_list|()
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|operand1
argument_list|,
name|operand0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|x
operator|>
literal|0
condition|)
block|{
return|return
name|original
return|;
block|}
if|if
condition|(
operator|!
name|isSymmetricalCall
argument_list|(
name|operator
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
condition|)
block|{
return|return
name|original
return|;
block|}
if|if
condition|(
name|reorderOperands
argument_list|(
name|operand0
argument_list|,
name|operand1
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// $0=$1 is the same as $1=$0, so we make sure the digest is the same for them.
comment|// When $1> $0 is normalized, the operation needs to be flipped
comment|// so we sort arguments first, then flip the sign.
return|return
name|Pair
operator|.
name|of
argument_list|(
name|requireNonNull
argument_list|(
name|operator
operator|.
name|reverse
argument_list|()
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|operand1
argument_list|,
name|operand0
argument_list|)
argument_list|)
return|;
block|}
return|return
name|original
return|;
block|}
comment|/**    * Computes the hashCode of a rex call. We ignore the operands sequence when the call is    * symmetrical.    *    *<p>Note that the logic to decide whether operands need reordering    * should be strictly same with {@link #normalize}.    */
specifier|public
specifier|static
name|int
name|hashCode
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
if|if
condition|(
operator|!
name|allowsNormalize
argument_list|()
operator|||
name|operands
operator|.
name|size
argument_list|()
operator|!=
literal|2
condition|)
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|operator
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|// If arguments are the same, then we normalize< vs>
comment|// '<' == 60, '>' == 62, so we prefer<.
specifier|final
name|SqlKind
name|kind
init|=
name|operator
operator|.
name|getKind
argument_list|()
decl_stmt|;
specifier|final
name|SqlKind
name|reversedKind
init|=
name|kind
operator|.
name|reverse
argument_list|()
decl_stmt|;
specifier|final
name|int
name|x
init|=
name|reversedKind
operator|.
name|compareTo
argument_list|(
name|kind
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|requireNonNull
argument_list|(
name|operator
operator|.
name|reverse
argument_list|()
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|isSymmetricalCall
argument_list|(
name|operator
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|operator
argument_list|,
name|unorderedHash
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|operator
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|/**    * Compares two operands to see which one should be normalized to be in front of the other.    *    *<p>We can always use the #hashCode to reorder the operands, do it as a fallback to keep    * good readability.    *    * @param operand0  First operand    * @param operand1  Second operand    *    * @return non-negative (>=0) if {@code operand0} should be in the front,    * negative if {@code operand1} should be in the front    */
specifier|private
specifier|static
name|int
name|reorderOperands
parameter_list|(
name|RexNode
name|operand0
parameter_list|,
name|RexNode
name|operand1
parameter_list|)
block|{
comment|// Reorder the operands based on the SqlKind enumeration sequence,
comment|// smaller is in the behind, e.g. the literal is behind of input ref and AND, OR.
name|int
name|x
init|=
name|operand0
operator|.
name|getKind
argument_list|()
operator|.
name|compareTo
argument_list|(
name|operand1
operator|.
name|getKind
argument_list|()
argument_list|)
decl_stmt|;
comment|// If the operands are same kind, use the hashcode to reorder.
comment|// Note: the RexInputRef's hash code is its index.
return|return
name|x
operator|!=
literal|0
condition|?
name|x
else|:
name|operand1
operator|.
name|hashCode
argument_list|()
operator|-
name|operand0
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/** Returns whether a call is symmetrical. **/
specifier|private
specifier|static
name|boolean
name|isSymmetricalCall
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|RexNode
name|operand0
parameter_list|,
name|RexNode
name|operand1
parameter_list|)
block|{
return|return
name|operator
operator|.
name|isSymmetrical
argument_list|()
operator|||
name|SqlKind
operator|.
name|SYMMETRICAL_SAME_ARG_TYPE
operator|.
name|contains
argument_list|(
name|operator
operator|.
name|getKind
argument_list|()
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|equalSansNullability
argument_list|(
name|operand0
operator|.
name|getType
argument_list|()
argument_list|,
name|operand1
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
comment|/** Compute a hash that is symmetric in its arguments - that is a hash    *  where the order of appearance of elements does not matter.    *  This is useful for hashing symmetrical rex calls, for example.    */
specifier|private
specifier|static
name|int
name|unorderedHash
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|xs
parameter_list|)
block|{
name|int
name|a
init|=
literal|0
decl_stmt|;
name|int
name|b
init|=
literal|0
decl_stmt|;
name|int
name|c
init|=
literal|1
decl_stmt|;
for|for
control|(
name|Object
name|x
range|:
name|xs
control|)
block|{
name|int
name|h
init|=
name|Objects
operator|.
name|hashCode
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|a
operator|+=
name|h
expr_stmt|;
name|b
operator|^=
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|!=
literal|0
condition|)
block|{
name|c
operator|*=
name|h
expr_stmt|;
block|}
block|}
return|return
operator|(
name|a
operator|*
literal|17
operator|+
name|b
operator|)
operator|*
literal|17
operator|+
name|c
return|;
block|}
comment|/**    * The digest of {@code RexNode} is normalized by default.    *    * @return true if the digest allows normalization    */
specifier|private
specifier|static
name|boolean
name|allowsNormalize
parameter_list|()
block|{
return|return
name|CalciteSystemProperty
operator|.
name|ENABLE_REX_DIGEST_NORMALIZE
operator|.
name|value
argument_list|()
return|;
block|}
block|}
end_class

end_unit

