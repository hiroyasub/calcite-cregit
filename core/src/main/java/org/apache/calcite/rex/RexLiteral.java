begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|DateTimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteSystemProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|CompositeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ConversionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|DateString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NlsString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimeString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimestampString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_comment
comment|/**  * Constant value in a row-expression.  *  *<p>There are several methods for creating literals in {@link RexBuilder}:  * {@link RexBuilder#makeLiteral(boolean)} and so forth.</p>  *  *<p>How is the value stored? In that respect, the class is somewhat of a black  * box. There is a {@link #getValue} method which returns the value as an  * object, but the type of that value is implementation detail, and it is best  * that your code does not depend upon that knowledge. It is better to use  * task-oriented methods such as {@link #getValue2} and  * {@link #toJavaString}.</p>  *  *<p>The allowable types and combinations are:</p>  *  *<table>  *<caption>Allowable types for RexLiteral instances</caption>  *<tr>  *<th>TypeName</th>  *<th>Meaning</th>  *<th>Value type</th>  *</tr>  *<tr>  *<td>{@link SqlTypeName#NULL}</td>  *<td>The null value. It has its own special type.</td>  *<td>null</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#BOOLEAN}</td>  *<td>Boolean, namely<code>TRUE</code>,<code>FALSE</code> or<code>  * UNKNOWN</code>.</td>  *<td>{@link Boolean}, or null represents the UNKNOWN value</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#DECIMAL}</td>  *<td>Exact number, for example<code>0</code>,<code>-.5</code>,<code>  * 12345</code>.</td>  *<td>{@link BigDecimal}</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#DOUBLE}</td>  *<td>Approximate number, for example<code>6.023E-23</code>.</td>  *<td>{@link BigDecimal}</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#DATE}</td>  *<td>Date, for example<code>DATE '1969-04'29'</code></td>  *<td>{@link Calendar};  *     also {@link Calendar} (UTC time zone)  *     and {@link Integer} (days since POSIX epoch)</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#TIME}</td>  *<td>Time, for example<code>TIME '18:37:42.567'</code></td>  *<td>{@link Calendar};  *     also {@link Calendar} (UTC time zone)  *     and {@link Integer} (milliseconds since midnight)</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#TIMESTAMP}</td>  *<td>Timestamp, for example<code>TIMESTAMP '1969-04-29  * 18:37:42.567'</code></td>  *<td>{@link TimestampString};  *     also {@link Calendar} (UTC time zone)  *     and {@link Long} (milliseconds since POSIX epoch)</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#INTERVAL_DAY},  *     {@link SqlTypeName#INTERVAL_DAY_HOUR},  *     {@link SqlTypeName#INTERVAL_DAY_MINUTE},  *     {@link SqlTypeName#INTERVAL_DAY_SECOND},  *     {@link SqlTypeName#INTERVAL_HOUR},  *     {@link SqlTypeName#INTERVAL_HOUR_MINUTE},  *     {@link SqlTypeName#INTERVAL_HOUR_SECOND},  *     {@link SqlTypeName#INTERVAL_MINUTE},  *     {@link SqlTypeName#INTERVAL_MINUTE_SECOND},  *     {@link SqlTypeName#INTERVAL_SECOND}</td>  *<td>Interval, for example<code>INTERVAL '4:3:2' HOUR TO SECOND</code></td>  *<td>{@link BigDecimal};  *     also {@link Long} (milliseconds)</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#INTERVAL_YEAR},  *     {@link SqlTypeName#INTERVAL_YEAR_MONTH},  *     {@link SqlTypeName#INTERVAL_MONTH}</td>  *<td>Interval, for example<code>INTERVAL '2-3' YEAR TO MONTH</code></td>  *<td>{@link BigDecimal};  *     also {@link Integer} (months)</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#CHAR}</td>  *<td>Character constant, for example<code>'Hello, world!'</code>,<code>  * ''</code>,<code>_N'Bonjour'</code>,<code>_ISO-8859-1'It''s superman!'  * COLLATE SHIFT_JIS$ja_JP$2</code>. These are always CHAR, never VARCHAR.</td>  *<td>{@link NlsString};  *     also {@link String}</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#BINARY}</td>  *<td>Binary constant, for example<code>X'7F34'</code>. (The number of hexits  * must be even; see above.) These constants are always BINARY, never  * VARBINARY.</td>  *<td>{@link ByteBuffer};  *     also {@code byte[]}</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#SYMBOL}</td>  *<td>A symbol is a special type used to make parsing easier; it is not part of  * the SQL standard, and is not exposed to end-users. It is used to hold a flag,  * such as the LEADING flag in a call to the function<code>  * TRIM([LEADING|TRAILING|BOTH] chars FROM string)</code>.</td>  *<td>An enum class</td>  *</tr>  *</table>  */
end_comment

begin_class
specifier|public
class|class
name|RexLiteral
extends|extends
name|RexNode
block|{
comment|//~ Instance fields --------------------------------------------------------
comment|/**    * The value of this literal. Must be consistent with its type, as per    * {@link #valueMatchesType}. For example, you can't store an    * {@link Integer} value here just because you feel like it -- all numbers are    * represented by a {@link BigDecimal}. But since this field is private, it    * doesn't really matter how the values are stored.    */
specifier|private
specifier|final
name|Comparable
name|value
decl_stmt|;
comment|/**    * The real type of this literal, as reported by {@link #getType}.    */
specifier|private
specifier|final
name|RelDataType
name|type
decl_stmt|;
comment|// TODO jvs 26-May-2006:  Use SqlTypeFamily instead; it exists
comment|// for exactly this purpose (to avoid the confusion which results
comment|// from overloading SqlTypeName).
comment|/**    * An indication of the broad type of this literal -- even if its type isn't    * a SQL type. Sometimes this will be different than the SQL type; for    * example, all exact numbers, including integers have typeName    * {@link SqlTypeName#DECIMAL}. See {@link #valueMatchesType} for the    * definitive story.    */
specifier|private
specifier|final
name|SqlTypeName
name|typeName
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|TimeUnit
argument_list|>
name|TIME_UNITS
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|TimeUnit
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a<code>RexLiteral</code>.    */
name|RexLiteral
parameter_list|(
name|Comparable
name|value
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|this
operator|.
name|typeName
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|valueMatchesType
argument_list|(
name|value
argument_list|,
name|typeName
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|(
name|value
operator|==
literal|null
operator|)
operator|==
name|type
operator|.
name|isNullable
argument_list|()
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|typeName
operator|!=
name|SqlTypeName
operator|.
name|ANY
argument_list|)
expr_stmt|;
name|this
operator|.
name|digest
operator|=
name|computeDigest
argument_list|(
name|RexDigestIncludeType
operator|.
name|OPTIONAL
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Returns a string which concisely describes the definition of this    * rex literal. Two literals are equivalent if and only if their digests are the same.    *    *<p>The digest does not contain the expression's identity, but does include the identity    * of children.    *    *<p>Technically speaking 1:INT differs from 1:FLOAT, so we need data type in the literal's    * digest, however we want to avoid extra verbosity of the {@link RelNode#getDigest()} for    * readability purposes, so we omit type info in certain cases.    * For instance, 1:INT becomes 1 (INT is implied by default), however 1:BIGINT always holds    * the type    *    *<p>Here's a non-exhaustive list of the "well known cases":    *<ul><li>Hide "NOT NULL" for not null literals    *<li>Hide INTEGER, BOOLEAN, SYMBOL, TIME(0), TIMESTAMP(0), DATE(0) types    *<li>Hide collation when it matches IMPLICIT/COERCIBLE    *<li>Hide charset when it matches default    *<li>Hide CHAR(xx) when literal length is equal to the precision of the type.    * In other words, use 'Bob' instead of 'Bob':CHAR(3)    *<li>Hide BOOL for AND/OR arguments. In other words, AND(true, null) means    * null is BOOL.    *<li>Hide types for literals in simple binary operations (e.g. +, -, *, /,    * comparison) when type of the other argument is clear.    * See {@link RexCall#computeDigest(boolean)}    * For instance: =(true. null) means null is BOOL. =($0, null) means the type    * of null matches the type of $0.    *</ul>    *    * @param includeType whether the digest should include type or not    * @return digest    */
specifier|public
specifier|final
name|String
name|computeDigest
parameter_list|(
name|RexDigestIncludeType
name|includeType
parameter_list|)
block|{
if|if
condition|(
name|includeType
operator|==
name|RexDigestIncludeType
operator|.
name|OPTIONAL
condition|)
block|{
if|if
condition|(
name|digest
operator|!=
literal|null
condition|)
block|{
comment|// digest is initialized with OPTIONAL, so cached value matches for
comment|// includeType=OPTIONAL as well
return|return
name|digest
return|;
block|}
comment|// Compute we should include the type or not
name|includeType
operator|=
name|digestIncludesType
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|digest
operator|!=
literal|null
operator|&&
name|includeType
operator|==
name|digestIncludesType
argument_list|()
condition|)
block|{
comment|// The digest is always computed with includeType=OPTIONAL
comment|// If it happened to omit the type, we want to optimize computeDigest(NO_TYPE) as well
comment|// If the digest includes the type, we want to optimize computeDigest(ALWAYS)
return|return
name|digest
return|;
block|}
return|return
name|toJavaString
argument_list|(
name|value
argument_list|,
name|typeName
argument_list|,
name|type
argument_list|,
name|includeType
argument_list|)
return|;
block|}
comment|/**    * Returns true if {@link RexDigestIncludeType#OPTIONAL} digest would include data type.    *    * @see RexCall#computeDigest(boolean)    * @return true if {@link RexDigestIncludeType#OPTIONAL} digest would include data type    */
name|RexDigestIncludeType
name|digestIncludesType
parameter_list|()
block|{
return|return
name|shouldIncludeType
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**    * @return whether value is appropriate for its type (we have rules about    * these things)    */
specifier|public
specifier|static
name|boolean
name|valueMatchesType
parameter_list|(
name|Comparable
name|value
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|boolean
name|strict
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|BOOLEAN
case|:
comment|// Unlike SqlLiteral, we do not allow boolean null.
return|return
name|value
operator|instanceof
name|Boolean
return|;
case|case
name|NULL
case|:
return|return
literal|false
return|;
comment|// value should have been null
case|case
name|INTEGER
case|:
comment|// not allowed -- use Decimal
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
if|if
condition|(
name|strict
condition|)
block|{
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|typeName
argument_list|)
throw|;
block|}
comment|// fall through
case|case
name|DECIMAL
case|:
case|case
name|DOUBLE
case|:
case|case
name|FLOAT
case|:
case|case
name|REAL
case|:
case|case
name|BIGINT
case|:
return|return
name|value
operator|instanceof
name|BigDecimal
return|;
case|case
name|DATE
case|:
return|return
name|value
operator|instanceof
name|DateString
return|;
case|case
name|TIME
case|:
return|return
name|value
operator|instanceof
name|TimeString
return|;
case|case
name|TIME_WITH_LOCAL_TIME_ZONE
case|:
return|return
name|value
operator|instanceof
name|TimeString
return|;
case|case
name|TIMESTAMP
case|:
return|return
name|value
operator|instanceof
name|TimestampString
return|;
case|case
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
case|:
return|return
name|value
operator|instanceof
name|TimestampString
return|;
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
comment|// The value of a DAY-TIME interval (whatever the start and end units,
comment|// even say HOUR TO MINUTE) is in milliseconds (perhaps fractional
comment|// milliseconds). The value of a YEAR-MONTH interval is in months.
return|return
name|value
operator|instanceof
name|BigDecimal
return|;
case|case
name|VARBINARY
case|:
comment|// not allowed -- use Binary
if|if
condition|(
name|strict
condition|)
block|{
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|typeName
argument_list|)
throw|;
block|}
comment|// fall through
case|case
name|BINARY
case|:
return|return
name|value
operator|instanceof
name|ByteString
return|;
case|case
name|VARCHAR
case|:
comment|// not allowed -- use Char
if|if
condition|(
name|strict
condition|)
block|{
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|typeName
argument_list|)
throw|;
block|}
comment|// fall through
case|case
name|CHAR
case|:
comment|// A SqlLiteral's charset and collation are optional; not so a
comment|// RexLiteral.
return|return
operator|(
name|value
operator|instanceof
name|NlsString
operator|)
operator|&&
operator|(
operator|(
operator|(
name|NlsString
operator|)
name|value
operator|)
operator|.
name|getCharset
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|(
operator|(
name|NlsString
operator|)
name|value
operator|)
operator|.
name|getCollation
argument_list|()
operator|!=
literal|null
operator|)
return|;
case|case
name|SYMBOL
case|:
return|return
name|value
operator|instanceof
name|Enum
return|;
case|case
name|ROW
case|:
case|case
name|MULTISET
case|:
return|return
name|value
operator|instanceof
name|List
return|;
case|case
name|ANY
case|:
comment|// Literal of type ANY is not legal. "CAST(2 AS ANY)" remains
comment|// an integer literal surrounded by a cast function.
return|return
literal|false
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|typeName
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|String
name|toJavaString
parameter_list|(
name|Comparable
name|value
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|RexDigestIncludeType
name|includeType
parameter_list|)
block|{
assert|assert
name|includeType
operator|!=
name|RexDigestIncludeType
operator|.
name|OPTIONAL
operator|:
literal|"toJavaString must not be called with includeType=OPTIONAL"
assert|;
name|String
name|fullTypeString
init|=
name|type
operator|.
name|getFullTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
name|includeType
operator|==
name|RexDigestIncludeType
operator|.
name|NO_TYPE
condition|?
literal|"null"
else|:
literal|"null:"
operator|+
name|fullTypeString
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|appendAsJava
argument_list|(
name|value
argument_list|,
name|sb
argument_list|,
name|typeName
argument_list|,
literal|false
argument_list|,
name|includeType
argument_list|)
expr_stmt|;
if|if
condition|(
name|includeType
operator|!=
name|RexDigestIncludeType
operator|.
name|NO_TYPE
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fullTypeString
operator|.
name|endsWith
argument_list|(
literal|"NOT NULL"
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|fullTypeString
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Trim " NOT NULL". Apparently, the literal is not null, so we just print the data type.
name|sb
operator|.
name|append
argument_list|(
name|fullTypeString
argument_list|,
literal|0
argument_list|,
name|fullTypeString
operator|.
name|length
argument_list|()
operator|-
literal|9
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Computes if data type can be omitted from the digset.    *<p>For instance, {@code 1:BIGINT} has to keep data type while {@code 1:INT}    * should be represented as just {@code 1}.    *    *<p>Implementation assumption: this method should be fast. In fact might call    * {@link NlsString#getValue()} which could decode the string, however we rely on the cache there.    *    * @see RexLiteral#computeDigest(RexDigestIncludeType)    * @param value value of the literal    * @param type type of the literal    * @return NO_TYPE when type can be omitted, ALWAYS otherwise    */
specifier|private
specifier|static
name|RexDigestIncludeType
name|shouldIncludeType
parameter_list|(
name|Comparable
name|value
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
comment|// This means "null literal", so we require a type for it
comment|// There might be exceptions like AND(null, true) which are handled by RexCall#computeDigest
return|return
name|RexDigestIncludeType
operator|.
name|ALWAYS
return|;
block|}
comment|// The variable here simplifies debugging (one can set a breakpoint at return)
comment|// final ensures we set the value in all the branches, and it ensures the value is set just once
specifier|final
name|RexDigestIncludeType
name|includeType
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|BOOLEAN
operator|||
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|INTEGER
operator|||
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|SYMBOL
condition|)
block|{
comment|// We don't want false:BOOLEAN NOT NULL, so we don't print type information for
comment|// non-nullable BOOLEAN and INTEGER
name|includeType
operator|=
name|RexDigestIncludeType
operator|.
name|NO_TYPE
expr_stmt|;
block|}
if|else if
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|CHAR
operator|&&
name|value
operator|instanceof
name|NlsString
condition|)
block|{
name|NlsString
name|nlsString
init|=
operator|(
name|NlsString
operator|)
name|value
decl_stmt|;
comment|// Ignore type information for 'Bar':CHAR(3)
if|if
condition|(
operator|(
operator|(
name|nlsString
operator|.
name|getCharset
argument_list|()
operator|!=
literal|null
operator|&&
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|equals
argument_list|(
name|nlsString
operator|.
name|getCharset
argument_list|()
argument_list|)
operator|)
operator|||
operator|(
name|nlsString
operator|.
name|getCharset
argument_list|()
operator|==
literal|null
operator|&&
name|SqlCollation
operator|.
name|IMPLICIT
operator|.
name|getCharset
argument_list|()
operator|.
name|equals
argument_list|(
name|type
operator|.
name|getCharset
argument_list|()
argument_list|)
operator|)
operator|)
operator|&&
name|nlsString
operator|.
name|getCollation
argument_list|()
operator|.
name|equals
argument_list|(
name|type
operator|.
name|getCollation
argument_list|()
argument_list|)
operator|&&
operator|(
operator|(
name|NlsString
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
operator|.
name|length
argument_list|()
operator|==
name|type
operator|.
name|getPrecision
argument_list|()
condition|)
block|{
name|includeType
operator|=
name|RexDigestIncludeType
operator|.
name|NO_TYPE
expr_stmt|;
block|}
else|else
block|{
name|includeType
operator|=
name|RexDigestIncludeType
operator|.
name|ALWAYS
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|type
operator|.
name|getPrecision
argument_list|()
operator|==
literal|0
operator|&&
operator|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|TIME
operator|||
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|TIMESTAMP
operator|||
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|DATE
operator|)
condition|)
block|{
comment|// Ignore type information for '12:23:20':TIME(0)
comment|// Note that '12:23:20':TIME WITH LOCAL TIME ZONE
name|includeType
operator|=
name|RexDigestIncludeType
operator|.
name|NO_TYPE
expr_stmt|;
block|}
else|else
block|{
name|includeType
operator|=
name|RexDigestIncludeType
operator|.
name|ALWAYS
expr_stmt|;
block|}
return|return
name|includeType
return|;
block|}
comment|/** Returns whether a value is valid as a constant value, using the same    * criteria as {@link #valueMatchesType}. */
specifier|public
specifier|static
name|boolean
name|validConstant
parameter_list|(
name|Object
name|o
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|o
operator|instanceof
name|BigDecimal
operator|||
name|o
operator|instanceof
name|NlsString
operator|||
name|o
operator|instanceof
name|ByteString
condition|)
block|{
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
if|else if
condition|(
name|o
operator|instanceof
name|List
condition|)
block|{
name|List
name|list
init|=
operator|(
name|List
operator|)
name|o
decl_stmt|;
for|for
control|(
name|Object
name|o1
range|:
name|list
control|)
block|{
if|if
condition|(
operator|!
name|validConstant
argument_list|(
name|o1
argument_list|,
name|litmus
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"not a constant: {}"
argument_list|,
name|o1
argument_list|)
return|;
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
if|else if
condition|(
name|o
operator|instanceof
name|Map
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|(
name|Map
operator|)
name|o
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|validConstant
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|litmus
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"not a constant: {}"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|validConstant
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|litmus
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"not a constant: {}"
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"not a constant: {}"
argument_list|,
name|o
argument_list|)
return|;
block|}
block|}
comment|/** Returns a list of the time units covered by an interval type such    * as HOUR TO SECOND. Adds MILLISECOND if the end is SECOND, to deal with    * fractional seconds. */
specifier|private
specifier|static
name|List
argument_list|<
name|TimeUnit
argument_list|>
name|getTimeUnits
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|)
block|{
specifier|final
name|TimeUnit
name|start
init|=
name|typeName
operator|.
name|getStartUnit
argument_list|()
decl_stmt|;
specifier|final
name|TimeUnit
name|end
init|=
name|typeName
operator|.
name|getEndUnit
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|TimeUnit
argument_list|>
name|list
init|=
name|TIME_UNITS
operator|.
name|subList
argument_list|(
name|start
operator|.
name|ordinal
argument_list|()
argument_list|,
name|end
operator|.
name|ordinal
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
name|TimeUnit
operator|.
name|SECOND
condition|)
block|{
return|return
name|CompositeList
operator|.
name|of
argument_list|(
name|list
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|TimeUnit
operator|.
name|MILLISECOND
argument_list|)
argument_list|)
return|;
block|}
return|return
name|list
return|;
block|}
specifier|private
name|String
name|intervalString
parameter_list|(
name|BigDecimal
name|v
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|TimeUnit
argument_list|>
name|timeUnits
init|=
name|getTimeUnits
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|TimeUnit
name|timeUnit
range|:
name|timeUnits
control|)
block|{
specifier|final
name|BigDecimal
index|[]
name|result
init|=
name|v
operator|.
name|divideAndRemainder
argument_list|(
name|timeUnit
operator|.
name|multiplier
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
name|timeUnit
operator|.
name|separator
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|width
init|=
name|b
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|?
operator|-
literal|1
else|:
name|width
argument_list|(
name|timeUnit
argument_list|)
decl_stmt|;
comment|// don't pad 1st
name|pad
argument_list|(
name|b
argument_list|,
name|result
index|[
literal|0
index|]
operator|.
name|toString
argument_list|()
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|v
operator|=
name|result
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|Util
operator|.
name|last
argument_list|(
name|timeUnits
argument_list|)
operator|==
name|TimeUnit
operator|.
name|MILLISECOND
condition|)
block|{
while|while
condition|(
name|b
operator|.
name|toString
argument_list|()
operator|.
name|matches
argument_list|(
literal|".*\\.[0-9]*0"
argument_list|)
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".0"
argument_list|)
condition|)
block|{
name|b
operator|.
name|setLength
argument_list|(
name|b
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|// remove ".0"
block|}
else|else
block|{
name|b
operator|.
name|setLength
argument_list|(
name|b
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// remove "0"
block|}
block|}
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|pad
parameter_list|(
name|StringBuilder
name|b
parameter_list|,
name|String
name|s
parameter_list|,
name|int
name|width
parameter_list|)
block|{
if|if
condition|(
name|width
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|s
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|int
name|width
parameter_list|(
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
switch|switch
condition|(
name|timeUnit
condition|)
block|{
case|case
name|MILLISECOND
case|:
return|return
literal|3
return|;
case|case
name|HOUR
case|:
case|case
name|MINUTE
case|:
case|case
name|SECOND
case|:
return|return
literal|2
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/**    * Prints the value this literal as a Java string constant.    */
specifier|public
name|void
name|printAsJava
parameter_list|(
name|PrintWriter
name|pw
parameter_list|)
block|{
name|appendAsJava
argument_list|(
name|value
argument_list|,
name|pw
argument_list|,
name|typeName
argument_list|,
literal|true
argument_list|,
name|RexDigestIncludeType
operator|.
name|NO_TYPE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Appends the specified value in the provided destination as a Java string. The value must be    * consistent with the type, as per {@link #valueMatchesType}.    *    *<p>Typical return values:</p>    *    *<ul>    *<li>true</li>    *<li>null</li>    *<li>"Hello, world!"</li>    *<li>1.25</li>    *<li>1234ABCD</li>    *</ul>    *    *<p>The destination where the value is appended must not incur I/O operations. This method is    * not meant to be used for writing the values to permanent storage.</p>    *    * @param value a value to be appended to the provided destination as a Java string    * @param destination a destination where to append the specified value    * @param typeName a type name to be used for the transformation of the value to a Java string    * @param includeType an indicator whether to include the data type in the Java representation    * @throws IllegalStateException if the appending to the destination<code>Appendable</code> fails    *         due to I/O    */
specifier|private
specifier|static
name|void
name|appendAsJava
parameter_list|(
name|Comparable
name|value
parameter_list|,
name|Appendable
name|destination
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|boolean
name|java
parameter_list|,
name|RexDigestIncludeType
name|includeType
parameter_list|)
block|{
try|try
block|{
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|CHAR
case|:
name|NlsString
name|nlsString
init|=
operator|(
name|NlsString
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|java
condition|)
block|{
name|Util
operator|.
name|printJavaString
argument_list|(
name|destination
argument_list|,
name|nlsString
operator|.
name|getValue
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|includeCharset
init|=
operator|(
name|nlsString
operator|.
name|getCharsetName
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|nlsString
operator|.
name|getCharsetName
argument_list|()
operator|.
name|equals
argument_list|(
name|CalciteSystemProperty
operator|.
name|DEFAULT_CHARSET
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
name|destination
operator|.
name|append
argument_list|(
name|nlsString
operator|.
name|asSql
argument_list|(
name|includeCharset
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BOOLEAN
case|:
assert|assert
name|value
operator|instanceof
name|Boolean
assert|;
name|destination
operator|.
name|append
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIMAL
case|:
assert|assert
name|value
operator|instanceof
name|BigDecimal
assert|;
name|destination
operator|.
name|append
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
assert|assert
name|value
operator|instanceof
name|BigDecimal
assert|;
name|destination
operator|.
name|append
argument_list|(
name|Util
operator|.
name|toScientificNotation
argument_list|(
operator|(
name|BigDecimal
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIGINT
case|:
assert|assert
name|value
operator|instanceof
name|BigDecimal
assert|;
name|long
name|narrowLong
init|=
operator|(
operator|(
name|BigDecimal
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
decl_stmt|;
name|destination
operator|.
name|append
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|narrowLong
argument_list|)
argument_list|)
expr_stmt|;
name|destination
operator|.
name|append
argument_list|(
literal|'L'
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINARY
case|:
assert|assert
name|value
operator|instanceof
name|ByteString
assert|;
name|destination
operator|.
name|append
argument_list|(
literal|"X'"
argument_list|)
expr_stmt|;
name|destination
operator|.
name|append
argument_list|(
operator|(
operator|(
name|ByteString
operator|)
name|value
operator|)
operator|.
name|toString
argument_list|(
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|destination
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NULL
case|:
assert|assert
name|value
operator|==
literal|null
assert|;
name|destination
operator|.
name|append
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL
case|:
assert|assert
name|value
operator|instanceof
name|Enum
assert|;
name|destination
operator|.
name|append
argument_list|(
literal|"FLAG("
argument_list|)
expr_stmt|;
name|destination
operator|.
name|append
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|destination
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATE
case|:
assert|assert
name|value
operator|instanceof
name|DateString
assert|;
name|destination
operator|.
name|append
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIME
case|:
assert|assert
name|value
operator|instanceof
name|TimeString
assert|;
name|destination
operator|.
name|append
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIME_WITH_LOCAL_TIME_ZONE
case|:
assert|assert
name|value
operator|instanceof
name|TimeString
assert|;
name|destination
operator|.
name|append
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIMESTAMP
case|:
assert|assert
name|value
operator|instanceof
name|TimestampString
assert|;
name|destination
operator|.
name|append
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
case|:
assert|assert
name|value
operator|instanceof
name|TimestampString
assert|;
name|destination
operator|.
name|append
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
assert|assert
name|value
operator|instanceof
name|BigDecimal
assert|;
name|destination
operator|.
name|append
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULTISET
case|:
case|case
name|ROW
case|:
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|list
init|=
operator|(
name|List
operator|)
name|value
decl_stmt|;
name|destination
operator|.
name|append
argument_list|(
operator|(
operator|new
name|AbstractList
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
specifier|public
name|String
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|computeDigest
argument_list|(
name|includeType
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|list
operator|.
name|size
argument_list|()
return|;
block|}
block|}
operator|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
assert|assert
name|valueMatchesType
argument_list|(
name|value
argument_list|,
name|typeName
argument_list|,
literal|true
argument_list|)
assert|;
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|typeName
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The destination Appendable should not incur I/O."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Converts a Jdbc string into a RexLiteral. This method accepts a string,    * as returned by the Jdbc method ResultSet.getString(), and restores the    * string into an equivalent RexLiteral. It allows one to use Jdbc strings    * as a common format for data.    *    *<p>If a null literal is provided, then a null pointer will be returned.    *    * @param type     data type of literal to be read    * @param typeName type family of literal    * @param literal  the (non-SQL encoded) string representation, as returned    *                 by the Jdbc call to return a column as a string    * @return a typed RexLiteral, or null    */
specifier|public
specifier|static
name|RexLiteral
name|fromJdbcString
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|String
name|literal
parameter_list|)
block|{
if|if
condition|(
name|literal
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|CHAR
case|:
name|Charset
name|charset
init|=
name|type
operator|.
name|getCharset
argument_list|()
decl_stmt|;
name|SqlCollation
name|collation
init|=
name|type
operator|.
name|getCollation
argument_list|()
decl_stmt|;
name|NlsString
name|str
init|=
operator|new
name|NlsString
argument_list|(
name|literal
argument_list|,
name|charset
operator|.
name|name
argument_list|()
argument_list|,
name|collation
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexLiteral
argument_list|(
name|str
argument_list|,
name|type
argument_list|,
name|typeName
argument_list|)
return|;
case|case
name|BOOLEAN
case|:
name|boolean
name|b
init|=
name|ConversionUtil
operator|.
name|toBoolean
argument_list|(
name|literal
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexLiteral
argument_list|(
name|b
argument_list|,
name|type
argument_list|,
name|typeName
argument_list|)
return|;
case|case
name|DECIMAL
case|:
case|case
name|DOUBLE
case|:
name|BigDecimal
name|d
init|=
operator|new
name|BigDecimal
argument_list|(
name|literal
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexLiteral
argument_list|(
name|d
argument_list|,
name|type
argument_list|,
name|typeName
argument_list|)
return|;
case|case
name|BINARY
case|:
name|byte
index|[]
name|bytes
init|=
name|ConversionUtil
operator|.
name|toByteArrayFromString
argument_list|(
name|literal
argument_list|,
literal|16
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexLiteral
argument_list|(
operator|new
name|ByteString
argument_list|(
name|bytes
argument_list|)
argument_list|,
name|type
argument_list|,
name|typeName
argument_list|)
return|;
case|case
name|NULL
case|:
return|return
operator|new
name|RexLiteral
argument_list|(
literal|null
argument_list|,
name|type
argument_list|,
name|typeName
argument_list|)
return|;
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
name|long
name|millis
init|=
name|SqlParserUtil
operator|.
name|intervalToMillis
argument_list|(
name|literal
argument_list|,
name|type
operator|.
name|getIntervalQualifier
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|millis
argument_list|)
argument_list|,
name|type
argument_list|,
name|typeName
argument_list|)
return|;
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
name|long
name|months
init|=
name|SqlParserUtil
operator|.
name|intervalToMonths
argument_list|(
name|literal
argument_list|,
name|type
operator|.
name|getIntervalQualifier
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|months
argument_list|)
argument_list|,
name|type
argument_list|,
name|typeName
argument_list|)
return|;
case|case
name|DATE
case|:
case|case
name|TIME
case|:
case|case
name|TIMESTAMP
case|:
name|String
name|format
init|=
name|getCalendarFormat
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
name|TimeZone
name|tz
init|=
name|DateTimeUtils
operator|.
name|UTC_ZONE
decl_stmt|;
specifier|final
name|Comparable
name|v
decl_stmt|;
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|DATE
case|:
specifier|final
name|Calendar
name|cal
init|=
name|DateTimeUtils
operator|.
name|parseDateFormat
argument_list|(
name|literal
argument_list|,
operator|new
name|SimpleDateFormat
argument_list|(
name|format
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|,
name|tz
argument_list|)
decl_stmt|;
if|if
condition|(
name|cal
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"fromJdbcString: invalid date/time value '"
operator|+
name|literal
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|v
operator|=
name|DateString
operator|.
name|fromCalendarFields
argument_list|(
name|cal
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Allow fractional seconds for times and timestamps
assert|assert
name|format
operator|!=
literal|null
assert|;
specifier|final
name|DateTimeUtils
operator|.
name|PrecisionTime
name|ts
init|=
name|DateTimeUtils
operator|.
name|parsePrecisionDateTimeLiteral
argument_list|(
name|literal
argument_list|,
operator|new
name|SimpleDateFormat
argument_list|(
name|format
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|,
name|tz
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"fromJdbcString: invalid date/time value '"
operator|+
name|literal
operator|+
literal|"'"
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TIMESTAMP
case|:
name|v
operator|=
name|TimestampString
operator|.
name|fromCalendarFields
argument_list|(
name|ts
operator|.
name|getCalendar
argument_list|()
argument_list|)
operator|.
name|withFraction
argument_list|(
name|ts
operator|.
name|getFraction
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIME
case|:
name|v
operator|=
name|TimeString
operator|.
name|fromCalendarFields
argument_list|(
name|ts
operator|.
name|getCalendar
argument_list|()
argument_list|)
operator|.
name|withFraction
argument_list|(
name|ts
operator|.
name|getFraction
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
return|return
operator|new
name|RexLiteral
argument_list|(
name|v
argument_list|,
name|type
argument_list|,
name|typeName
argument_list|)
return|;
case|case
name|SYMBOL
case|:
comment|// Symbols are for internal use
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"fromJdbcString: unsupported type"
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|String
name|getCalendarFormat
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|)
block|{
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|DATE
case|:
return|return
name|DateTimeUtils
operator|.
name|DATE_FORMAT_STRING
return|;
case|case
name|TIME
case|:
return|return
name|DateTimeUtils
operator|.
name|TIME_FORMAT_STRING
return|;
case|case
name|TIMESTAMP
case|:
return|return
name|DateTimeUtils
operator|.
name|TIMESTAMP_FORMAT_STRING
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"getCalendarFormat: unknown type"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|SqlTypeName
name|getTypeName
parameter_list|()
block|{
return|return
name|typeName
return|;
block|}
specifier|public
name|RelDataType
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlKind
name|getKind
parameter_list|()
block|{
return|return
name|SqlKind
operator|.
name|LITERAL
return|;
block|}
comment|/**    * Returns whether this literal's value is null.    */
specifier|public
name|boolean
name|isNull
parameter_list|()
block|{
return|return
name|value
operator|==
literal|null
return|;
block|}
comment|/**    * Returns the value of this literal.    *    *<p>For backwards compatibility, returns DATE. TIME and TIMESTAMP as a    * {@link Calendar} value in UTC time zone.    */
specifier|public
name|Comparable
name|getValue
parameter_list|()
block|{
assert|assert
name|valueMatchesType
argument_list|(
name|value
argument_list|,
name|typeName
argument_list|,
literal|true
argument_list|)
operator|:
name|value
assert|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TIME
case|:
case|case
name|DATE
case|:
case|case
name|TIMESTAMP
case|:
return|return
name|getValueAs
argument_list|(
name|Calendar
operator|.
name|class
argument_list|)
return|;
default|default:
return|return
name|value
return|;
block|}
block|}
comment|/**    * Returns the value of this literal, in the form that the calculator    * program builder wants it.    */
specifier|public
name|Object
name|getValue2
parameter_list|()
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|CHAR
case|:
return|return
name|getValueAs
argument_list|(
name|String
operator|.
name|class
argument_list|)
return|;
case|case
name|DECIMAL
case|:
case|case
name|TIMESTAMP
case|:
case|case
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
case|:
return|return
name|getValueAs
argument_list|(
name|Long
operator|.
name|class
argument_list|)
return|;
case|case
name|DATE
case|:
case|case
name|TIME
case|:
case|case
name|TIME_WITH_LOCAL_TIME_ZONE
case|:
return|return
name|getValueAs
argument_list|(
name|Integer
operator|.
name|class
argument_list|)
return|;
default|default:
return|return
name|value
return|;
block|}
block|}
comment|/**    * Returns the value of this literal, in the form that the rex-to-lix    * translator wants it.    */
specifier|public
name|Object
name|getValue3
parameter_list|()
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|DECIMAL
case|:
assert|assert
name|value
operator|instanceof
name|BigDecimal
assert|;
return|return
name|value
return|;
default|default:
return|return
name|getValue2
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns the value of this literal, in the form that {@link RexInterpreter}    * wants it.    */
specifier|public
name|Comparable
name|getValue4
parameter_list|()
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TIMESTAMP
case|:
case|case
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
case|:
return|return
name|getValueAs
argument_list|(
name|Long
operator|.
name|class
argument_list|)
return|;
case|case
name|DATE
case|:
case|case
name|TIME
case|:
case|case
name|TIME_WITH_LOCAL_TIME_ZONE
case|:
return|return
name|getValueAs
argument_list|(
name|Integer
operator|.
name|class
argument_list|)
return|;
default|default:
return|return
name|value
return|;
block|}
block|}
comment|/** Returns the value of this literal as an instance of the specified class.    *    *<p>The following SQL types allow more than one form:    *    *<ul>    *<li>CHAR as {@link NlsString} or {@link String}    *<li>TIME as {@link TimeString},    *   {@link Integer} (milliseconds since midnight),    *   {@link Calendar} (in UTC)    *<li>DATE as {@link DateString},    *   {@link Integer} (days since 1970-01-01),    *   {@link Calendar}    *<li>TIMESTAMP as {@link TimestampString},    *   {@link Long} (milliseconds since 1970-01-01 00:00:00),    *   {@link Calendar}    *<li>DECIMAL as {@link BigDecimal} or {@link Long}    *</ul>    *    *<p>Called with {@code clazz} = {@link Comparable}, returns the value in    * its native form.    *    * @param clazz Desired return type    * @param<T> Return type    * @return Value of this literal in the desired type    */
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|getValueAs
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|clazz
operator|.
name|isInstance
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
name|value
argument_list|)
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|BINARY
case|:
if|if
condition|(
name|clazz
operator|==
name|byte
index|[]
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|ByteString
operator|)
name|value
operator|)
operator|.
name|getBytes
argument_list|()
argument_list|)
return|;
block|}
break|break;
case|case
name|CHAR
case|:
if|if
condition|(
name|clazz
operator|==
name|String
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|NlsString
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Character
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|NlsString
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|VARCHAR
case|:
if|if
condition|(
name|clazz
operator|==
name|String
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|NlsString
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
break|break;
case|case
name|DECIMAL
case|:
if|if
condition|(
name|clazz
operator|==
name|Long
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|BigDecimal
operator|)
name|value
operator|)
operator|.
name|unscaledValue
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
return|;
block|}
comment|// fall through
case|case
name|BIGINT
case|:
case|case
name|INTEGER
case|:
case|case
name|SMALLINT
case|:
case|case
name|TINYINT
case|:
case|case
name|DOUBLE
case|:
case|case
name|REAL
case|:
case|case
name|FLOAT
case|:
if|if
condition|(
name|clazz
operator|==
name|Long
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|BigDecimal
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Integer
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|BigDecimal
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Short
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|BigDecimal
operator|)
name|value
operator|)
operator|.
name|shortValue
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Byte
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|BigDecimal
operator|)
name|value
operator|)
operator|.
name|byteValue
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Double
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|BigDecimal
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Float
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|BigDecimal
operator|)
name|value
operator|)
operator|.
name|floatValue
argument_list|()
argument_list|)
return|;
block|}
break|break;
case|case
name|DATE
case|:
if|if
condition|(
name|clazz
operator|==
name|Integer
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|DateString
operator|)
name|value
operator|)
operator|.
name|getDaysSinceEpoch
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Calendar
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|DateString
operator|)
name|value
operator|)
operator|.
name|toCalendar
argument_list|()
argument_list|)
return|;
block|}
break|break;
case|case
name|TIME
case|:
if|if
condition|(
name|clazz
operator|==
name|Integer
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|TimeString
operator|)
name|value
operator|)
operator|.
name|getMillisOfDay
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Calendar
operator|.
name|class
condition|)
block|{
comment|// Note: Nanos are ignored
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|TimeString
operator|)
name|value
operator|)
operator|.
name|toCalendar
argument_list|()
argument_list|)
return|;
block|}
break|break;
case|case
name|TIME_WITH_LOCAL_TIME_ZONE
case|:
if|if
condition|(
name|clazz
operator|==
name|Integer
operator|.
name|class
condition|)
block|{
comment|// Milliseconds since 1970-01-01 00:00:00
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|TimeString
operator|)
name|value
operator|)
operator|.
name|getMillisOfDay
argument_list|()
argument_list|)
return|;
block|}
break|break;
case|case
name|TIMESTAMP
case|:
if|if
condition|(
name|clazz
operator|==
name|Long
operator|.
name|class
condition|)
block|{
comment|// Milliseconds since 1970-01-01 00:00:00
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|TimestampString
operator|)
name|value
operator|)
operator|.
name|getMillisSinceEpoch
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Calendar
operator|.
name|class
condition|)
block|{
comment|// Note: Nanos are ignored
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|TimestampString
operator|)
name|value
operator|)
operator|.
name|toCalendar
argument_list|()
argument_list|)
return|;
block|}
break|break;
case|case
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
case|:
if|if
condition|(
name|clazz
operator|==
name|Long
operator|.
name|class
condition|)
block|{
comment|// Milliseconds since 1970-01-01 00:00:00
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|TimestampString
operator|)
name|value
operator|)
operator|.
name|getMillisSinceEpoch
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Calendar
operator|.
name|class
condition|)
block|{
comment|// Note: Nanos are ignored
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|TimestampString
operator|)
name|value
operator|)
operator|.
name|toCalendar
argument_list|()
argument_list|)
return|;
block|}
break|break;
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
if|if
condition|(
name|clazz
operator|==
name|Integer
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|BigDecimal
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Long
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
operator|(
operator|(
name|BigDecimal
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|String
operator|.
name|class
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
name|intervalString
argument_list|(
name|getValueAs
argument_list|(
name|BigDecimal
operator|.
name|class
argument_list|)
operator|.
name|abs
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Boolean
operator|.
name|class
condition|)
block|{
comment|// return whether negative
return|return
name|clazz
operator|.
name|cast
argument_list|(
name|getValueAs
argument_list|(
name|BigDecimal
operator|.
name|class
argument_list|)
operator|.
name|signum
argument_list|()
operator|<
literal|0
argument_list|)
return|;
block|}
break|break;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"cannot convert "
operator|+
name|typeName
operator|+
literal|" literal to "
operator|+
name|clazz
argument_list|)
throw|;
block|}
specifier|public
specifier|static
name|boolean
name|booleanValue
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
operator|(
name|Boolean
operator|)
operator|(
operator|(
name|RexLiteral
operator|)
name|node
operator|)
operator|.
name|value
return|;
block|}
specifier|public
name|boolean
name|isAlwaysTrue
parameter_list|()
block|{
if|if
condition|(
name|typeName
operator|!=
name|SqlTypeName
operator|.
name|BOOLEAN
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|booleanValue
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isAlwaysFalse
parameter_list|()
block|{
if|if
condition|(
name|typeName
operator|!=
name|SqlTypeName
operator|.
name|BOOLEAN
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|!
name|booleanValue
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
operator|(
name|obj
operator|instanceof
name|RexLiteral
operator|)
operator|&&
name|equals
argument_list|(
operator|(
operator|(
name|RexLiteral
operator|)
name|obj
operator|)
operator|.
name|value
argument_list|,
name|value
argument_list|)
operator|&&
name|equals
argument_list|(
operator|(
operator|(
name|RexLiteral
operator|)
name|obj
operator|)
operator|.
name|type
argument_list|,
name|type
argument_list|)
return|;
block|}
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Comparable
name|value
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|findValue
argument_list|(
name|node
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|intValue
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
specifier|final
name|Comparable
name|value
init|=
name|findValue
argument_list|(
name|node
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|String
name|stringValue
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
specifier|final
name|Comparable
name|value
init|=
name|findValue
argument_list|(
name|node
argument_list|)
decl_stmt|;
return|return
operator|(
name|value
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
operator|(
operator|(
name|NlsString
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|Comparable
name|findValue
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|RexLiteral
condition|)
block|{
return|return
operator|(
operator|(
name|RexLiteral
operator|)
name|node
operator|)
operator|.
name|value
return|;
block|}
if|if
condition|(
name|node
operator|instanceof
name|RexCall
condition|)
block|{
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
specifier|final
name|SqlOperator
name|operator
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|CAST
condition|)
block|{
return|return
name|findValue
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|UNARY_MINUS
condition|)
block|{
specifier|final
name|BigDecimal
name|value
init|=
operator|(
name|BigDecimal
operator|)
name|findValue
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|value
operator|.
name|negate
argument_list|()
return|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"not a literal: "
operator|+
name|node
argument_list|)
throw|;
block|}
specifier|public
specifier|static
name|boolean
name|isNullLiteral
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|instanceof
name|RexLiteral
operator|)
operator|&&
operator|(
operator|(
operator|(
name|RexLiteral
operator|)
name|node
operator|)
operator|.
name|value
operator|==
literal|null
operator|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|equals
parameter_list|(
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
return|;
block|}
specifier|public
parameter_list|<
name|R
parameter_list|>
name|R
name|accept
parameter_list|(
name|RexVisitor
argument_list|<
name|R
argument_list|>
name|visitor
parameter_list|)
block|{
return|return
name|visitor
operator|.
name|visitLiteral
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|public
parameter_list|<
name|R
parameter_list|,
name|P
parameter_list|>
name|R
name|accept
parameter_list|(
name|RexBiVisitor
argument_list|<
name|R
argument_list|,
name|P
argument_list|>
name|visitor
parameter_list|,
name|P
name|arg
parameter_list|)
block|{
return|return
name|visitor
operator|.
name|visitLiteral
argument_list|(
name|this
argument_list|,
name|arg
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|// End RexLiteral.java
end_comment

end_unit

