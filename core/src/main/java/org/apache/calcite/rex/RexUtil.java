begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Predicate1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Strong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|PredicateImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Schemas
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ControlFlowException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ArrayListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Utility methods concerning row-expressions.  */
end_comment

begin_class
specifier|public
class|class
name|RexUtil
block|{
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|?
super|super
name|RexNode
argument_list|,
name|?
extends|extends
name|RexNode
argument_list|>
name|ADD_NOT
init|=
operator|new
name|Function
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
specifier|public
name|RexNode
name|apply
parameter_list|(
name|RexNode
name|input
parameter_list|)
block|{
return|return
operator|new
name|RexCall
argument_list|(
name|input
operator|.
name|getType
argument_list|()
argument_list|,
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|input
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Predicate1
argument_list|<
name|RexNode
argument_list|>
name|IS_FLAT_PREDICATE
init|=
operator|new
name|Predicate1
argument_list|<
name|RexNode
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|apply
parameter_list|(
name|RexNode
name|v1
parameter_list|)
block|{
return|return
name|isFlat
argument_list|(
name|v1
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Object
argument_list|,
name|String
argument_list|>
name|TO_STRING
init|=
operator|new
name|Function
argument_list|<
name|Object
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
specifier|public
name|String
name|apply
parameter_list|(
name|Object
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|RexNode
argument_list|,
name|RelDataType
argument_list|>
name|TYPE_FN
init|=
operator|new
name|Function
argument_list|<
name|RexNode
argument_list|,
name|RelDataType
argument_list|>
argument_list|()
block|{
specifier|public
name|RelDataType
name|apply
parameter_list|(
name|RexNode
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getType
argument_list|()
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|RelDataType
argument_list|,
name|RelDataTypeFamily
argument_list|>
name|FAMILY_FN
init|=
operator|new
name|Function
argument_list|<
name|RelDataType
argument_list|,
name|RelDataTypeFamily
argument_list|>
argument_list|()
block|{
specifier|public
name|RelDataTypeFamily
name|apply
parameter_list|(
name|RelDataType
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getFamily
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/** Executor for a bit of constant reduction. The user can pass in another executor. */
specifier|public
specifier|static
specifier|final
name|RexExecutor
name|EXECUTOR
init|=
operator|new
name|RexExecutorImpl
argument_list|(
name|Schemas
operator|.
name|createDataContext
argument_list|(
literal|null
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
name|RexUtil
parameter_list|()
block|{
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Returns a guess for the selectivity of an expression.    *    * @param exp expression of interest, or null for none (implying a    *            selectivity of 1.0)    * @return guessed selectivity    */
specifier|public
specifier|static
name|double
name|getSelectivity
parameter_list|(
name|RexNode
name|exp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|exp
operator|==
literal|null
operator|)
operator|||
name|exp
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return
literal|1d
return|;
block|}
return|return
literal|0.1d
return|;
block|}
comment|/**    * Generates a cast from one row type to another    *    * @param rexBuilder RexBuilder to use for constructing casts    * @param lhsRowType target row type    * @param rhsRowType source row type; fields must be 1-to-1 with lhsRowType,    *                   in same order    * @return cast expressions    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|generateCastExpressions
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelDataType
name|lhsRowType
parameter_list|,
name|RelDataType
name|rhsRowType
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fieldList
init|=
name|rhsRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|fieldList
operator|.
name|size
argument_list|()
decl_stmt|;
assert|assert
name|n
operator|==
name|lhsRowType
operator|.
name|getFieldCount
argument_list|()
operator|:
literal|"field count: lhs ["
operator|+
name|lhsRowType
operator|+
literal|"] rhs ["
operator|+
name|rhsRowType
operator|+
literal|"]"
assert|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rhsExps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|fieldList
control|)
block|{
name|rhsExps
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|generateCastExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|lhsRowType
argument_list|,
name|rhsExps
argument_list|)
return|;
block|}
comment|/**    * Generates a cast for a row type.    *    * @param rexBuilder RexBuilder to use for constructing casts    * @param lhsRowType target row type    * @param rhsExps    expressions to be cast    * @return cast expressions    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|generateCastExpressions
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelDataType
name|lhsRowType
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rhsExps
parameter_list|)
block|{
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|lhsFields
init|=
name|lhsRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|castExps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RexNode
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|lhsFields
argument_list|,
name|rhsExps
argument_list|,
literal|true
argument_list|)
control|)
block|{
name|RelDataTypeField
name|lhsField
init|=
name|pair
operator|.
name|left
decl_stmt|;
name|RelDataType
name|lhsType
init|=
name|lhsField
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|rhsExp
init|=
name|pair
operator|.
name|right
decl_stmt|;
name|RelDataType
name|rhsType
init|=
name|rhsExp
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|lhsType
operator|.
name|equals
argument_list|(
name|rhsType
argument_list|)
condition|)
block|{
name|castExps
operator|.
name|add
argument_list|(
name|rhsExp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|castExps
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|lhsType
argument_list|,
name|rhsExp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|castExps
return|;
block|}
comment|/**    * Returns whether a node represents the NULL value.    *    *<p>Examples:    *    *<ul>    *<li>For {@link org.apache.calcite.rex.RexLiteral} Unknown, returns false.    *<li>For<code>CAST(NULL AS<i>type</i>)</code>, returns true if<code>    * allowCast</code> is true, false otherwise.    *<li>For<code>CAST(CAST(NULL AS<i>type</i>) AS<i>type</i>))</code>,    * returns false.    *</ul>    */
specifier|public
specifier|static
name|boolean
name|isNullLiteral
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|boolean
name|allowCast
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|RexLiteral
condition|)
block|{
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
condition|)
block|{
assert|assert
literal|null
operator|==
name|literal
operator|.
name|getValue
argument_list|()
assert|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// We don't regard UNKNOWN -- SqlLiteral(null,Boolean) -- as
comment|// NULL.
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|allowCast
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|isNullLiteral
argument_list|(
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// node is "CAST(NULL as type)"
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether a node represents the NULL value or a series of nested    * {@code CAST(NULL AS type)} calls. For example:    *<code>isNull(CAST(CAST(NULL as INTEGER) AS VARCHAR(1)))</code>    * returns {@code true}.    */
specifier|public
specifier|static
name|boolean
name|isNull
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
switch|switch
condition|(
name|expr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LITERAL
case|:
return|return
operator|(
operator|(
name|RexLiteral
operator|)
name|expr
operator|)
operator|.
name|getValue2
argument_list|()
operator|==
literal|null
return|;
case|case
name|CAST
case|:
return|return
name|isNull
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Returns whether a node represents a literal.    *    *<p>Examples:    *    *<ul>    *<li>For<code>CAST(literal AS<i>type</i>)</code>, returns true if<code>    * allowCast</code> is true, false otherwise.    *<li>For<code>CAST(CAST(literal AS<i>type</i>) AS<i>type</i>))</code>,    * returns false.    *</ul>    *    * @param node The node, never null.    * @param allowCast whether to regard CAST(literal) as a literal    * @return Whether the node is a literal    */
specifier|public
specifier|static
name|boolean
name|isLiteral
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|boolean
name|allowCast
parameter_list|)
block|{
assert|assert
name|node
operator|!=
literal|null
assert|;
if|if
condition|(
name|node
operator|instanceof
name|RexLiteral
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|allowCast
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|isLiteral
argument_list|(
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// node is "CAST(literal as type)"
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether a node represents an input reference or field access.    *    * @param node The node, never null.    * @param allowCast whether to regard CAST(x) as true    * @return Whether the node is a reference or access    */
specifier|public
specifier|static
name|boolean
name|isReferenceOrAccess
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|boolean
name|allowCast
parameter_list|)
block|{
assert|assert
name|node
operator|!=
literal|null
assert|;
if|if
condition|(
name|node
operator|instanceof
name|RexInputRef
operator|||
name|node
operator|instanceof
name|RexFieldAccess
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|allowCast
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
return|return
name|isReferenceOrAccess
argument_list|(
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Returns whether an expression is a cast just for the purposes of    * nullability, not changing any other aspect of the type. */
specifier|public
specifier|static
name|boolean
name|isNullabilityCast
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CAST
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
specifier|final
name|RexNode
name|arg0
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|SqlTypeUtil
operator|.
name|equalSansNullability
argument_list|(
name|typeFactory
argument_list|,
name|arg0
operator|.
name|getType
argument_list|()
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Creates a map containing each (e, constant) pair that occurs within    * a predicate list.    *    * @param clazz Class of expression that is considered constant    * @param rexBuilder Rex builder    * @param predicates Predicate list    * @param<C> what to consider a constant: {@link RexLiteral} to use a narrow    *           definition of constant, or {@link RexNode} to use    *           {@link RexUtil#isConstant(RexNode)}    * @return Map from values to constants    */
specifier|public
specifier|static
parameter_list|<
name|C
extends|extends
name|RexNode
parameter_list|>
name|ImmutableMap
argument_list|<
name|RexNode
argument_list|,
name|C
argument_list|>
name|predicateConstants
parameter_list|(
name|Class
argument_list|<
name|C
argument_list|>
name|clazz
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|predicates
parameter_list|)
block|{
comment|// We cannot use an ImmutableMap.Builder here. If there are multiple entries
comment|// with the same key (e.g. "WHERE deptno = 1 AND deptno = 2"), it doesn't
comment|// matter which we take, so the latter will replace the former.
comment|// The basic idea is to find all the pairs of RexNode = RexLiteral
comment|// (1) If 'predicates' contain a non-EQUALS, we bail out.
comment|// (2) It is OK if a RexNode is equal to the same RexLiteral several times,
comment|// (e.g. "WHERE deptno = 1 AND deptno = 1")
comment|// (3) It will return false if there are inconsistent constraints (e.g.
comment|// "WHERE deptno = 1 AND deptno = 2")
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|C
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|excludeSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|predicate
range|:
name|predicates
control|)
block|{
name|gatherConstraints
argument_list|(
name|clazz
argument_list|,
name|predicate
argument_list|,
name|map
argument_list|,
name|excludeSet
argument_list|,
name|rexBuilder
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|,
name|C
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|RexNode
argument_list|,
name|C
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|RexNode
name|rexNode
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|overlap
argument_list|(
name|rexNode
argument_list|,
name|excludeSet
argument_list|)
condition|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|rexNode
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|boolean
name|overlap
parameter_list|(
name|RexNode
name|rexNode
parameter_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
name|set
parameter_list|)
block|{
if|if
condition|(
name|rexNode
operator|instanceof
name|RexCall
condition|)
block|{
for|for
control|(
name|RexNode
name|r
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexNode
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
if|if
condition|(
name|overlap
argument_list|(
name|r
argument_list|,
name|set
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|set
operator|.
name|contains
argument_list|(
name|rexNode
argument_list|)
return|;
block|}
block|}
comment|/** Tries to decompose the RexNode which is a RexCall into non-literal    * RexNodes. */
specifier|private
specifier|static
name|void
name|decompose
parameter_list|(
name|Set
argument_list|<
name|RexNode
argument_list|>
name|set
parameter_list|,
name|RexNode
name|rexNode
parameter_list|)
block|{
if|if
condition|(
name|rexNode
operator|instanceof
name|RexCall
condition|)
block|{
for|for
control|(
name|RexNode
name|r
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexNode
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|decompose
argument_list|(
name|set
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
operator|!
operator|(
name|rexNode
operator|instanceof
name|RexLiteral
operator|)
condition|)
block|{
name|set
operator|.
name|add
argument_list|(
name|rexNode
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|C
extends|extends
name|RexNode
parameter_list|>
name|void
name|gatherConstraints
parameter_list|(
name|Class
argument_list|<
name|C
argument_list|>
name|clazz
parameter_list|,
name|RexNode
name|predicate
parameter_list|,
name|Map
argument_list|<
name|RexNode
argument_list|,
name|C
argument_list|>
name|map
parameter_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
name|excludeSet
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
if|if
condition|(
name|predicate
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|EQUALS
operator|&&
name|predicate
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|IS_NULL
condition|)
block|{
name|decompose
argument_list|(
name|excludeSet
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|predicate
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|!=
literal|2
operator|&&
name|predicate
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
name|decompose
argument_list|(
name|excludeSet
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// if it reaches here, we have rexNode equals rexNode
specifier|final
name|RexNode
name|left
decl_stmt|;
specifier|final
name|RexNode
name|right
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
name|left
operator|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|left
operator|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|left
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Note that literals are immutable too, and they can only be compared
comment|// through values.
name|gatherConstraint
argument_list|(
name|clazz
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|map
argument_list|,
name|excludeSet
argument_list|,
name|rexBuilder
argument_list|)
expr_stmt|;
name|gatherConstraint
argument_list|(
name|clazz
argument_list|,
name|right
argument_list|,
name|left
argument_list|,
name|map
argument_list|,
name|excludeSet
argument_list|,
name|rexBuilder
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
parameter_list|<
name|C
extends|extends
name|RexNode
parameter_list|>
name|void
name|gatherConstraint
parameter_list|(
name|Class
argument_list|<
name|C
argument_list|>
name|clazz
parameter_list|,
name|RexNode
name|left
parameter_list|,
name|RexNode
name|right
parameter_list|,
name|Map
argument_list|<
name|RexNode
argument_list|,
name|C
argument_list|>
name|map
parameter_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
name|excludeSet
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
if|if
condition|(
operator|!
name|clazz
operator|.
name|isInstance
argument_list|(
name|right
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|isConstant
argument_list|(
name|right
argument_list|)
condition|)
block|{
return|return;
block|}
name|C
name|constant
init|=
name|clazz
operator|.
name|cast
argument_list|(
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|excludeSet
operator|.
name|contains
argument_list|(
name|left
argument_list|)
condition|)
block|{
return|return;
block|}
specifier|final
name|C
name|existedValue
init|=
name|map
operator|.
name|get
argument_list|(
name|left
argument_list|)
decl_stmt|;
if|if
condition|(
name|existedValue
operator|==
literal|null
condition|)
block|{
switch|switch
condition|(
name|left
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CAST
case|:
comment|// Convert "CAST(c) = literal" to "c = literal", as long as it is a
comment|// widening cast.
specifier|final
name|RexNode
name|operand
init|=
operator|(
operator|(
name|RexCall
operator|)
name|left
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|canAssignFrom
argument_list|(
name|left
operator|.
name|getType
argument_list|()
argument_list|,
name|operand
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
specifier|final
name|RexNode
name|castRight
init|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|operand
operator|.
name|getType
argument_list|()
argument_list|,
name|constant
argument_list|)
decl_stmt|;
if|if
condition|(
name|castRight
operator|instanceof
name|RexLiteral
condition|)
block|{
name|left
operator|=
name|operand
expr_stmt|;
name|constant
operator|=
name|clazz
operator|.
name|cast
argument_list|(
name|castRight
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|map
operator|.
name|put
argument_list|(
name|left
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|existedValue
operator|instanceof
name|RexLiteral
operator|&&
name|constant
operator|instanceof
name|RexLiteral
operator|&&
operator|!
operator|(
operator|(
name|RexLiteral
operator|)
name|existedValue
operator|)
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|RexLiteral
operator|)
name|constant
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
comment|// we found conflicting values, e.g. left = 10 and left = 20
name|map
operator|.
name|remove
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|excludeSet
operator|.
name|add
argument_list|(
name|left
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Returns whether a value of {@code type2} can be assigned to a variable    * of {@code type1}.    *    *<p>For example:    *<ul>    *<li>{@code canAssignFrom(BIGINT, TINYINT)} returns {@code true}</li>    *<li>{@code canAssignFrom(TINYINT, BIGINT)} returns {@code false}</li>    *<li>{@code canAssignFrom(BIGINT, VARCHAR)} returns {@code false}</li>    *</ul>    */
specifier|private
specifier|static
name|boolean
name|canAssignFrom
parameter_list|(
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
specifier|final
name|SqlTypeName
name|name1
init|=
name|type1
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
specifier|final
name|SqlTypeName
name|name2
init|=
name|type2
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name1
operator|.
name|getFamily
argument_list|()
operator|==
name|name2
operator|.
name|getFamily
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|name1
operator|.
name|getFamily
argument_list|()
condition|)
block|{
case|case
name|NUMERIC
case|:
return|return
name|name1
operator|.
name|compareTo
argument_list|(
name|name2
argument_list|)
operator|>=
literal|0
return|;
default|default:
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Walks over an expression and determines whether it is constant.    */
specifier|static
class|class
name|ConstantFinder
implements|implements
name|RexVisitor
argument_list|<
name|Boolean
argument_list|>
block|{
specifier|static
specifier|final
name|ConstantFinder
name|INSTANCE
init|=
operator|new
name|ConstantFinder
argument_list|()
decl_stmt|;
specifier|public
name|Boolean
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|Boolean
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitOver
parameter_list|(
name|RexOver
name|over
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitSubQuery
parameter_list|(
name|RexSubQuery
name|subQuery
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitPatternFieldRef
parameter_list|(
name|RexPatternFieldRef
name|fieldRef
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|correlVariable
parameter_list|)
block|{
comment|// Correlating variables change when there is an internal restart.
comment|// Not good enough for our purposes.
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitDynamicParam
parameter_list|(
name|RexDynamicParam
name|dynamicParam
parameter_list|)
block|{
comment|// Dynamic parameters are constant WITHIN AN EXECUTION, so that's
comment|// good enough.
return|return
literal|true
return|;
block|}
specifier|public
name|Boolean
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
comment|// Constant if operator is deterministic and all operands are
comment|// constant.
return|return
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|isDeterministic
argument_list|()
operator|&&
name|RexVisitorImpl
operator|.
name|visitArrayAnd
argument_list|(
name|this
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|Boolean
name|visitRangeRef
parameter_list|(
name|RexRangeRef
name|rangeRef
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
comment|// "<expr>.FIELD" is constant iff "<expr>" is constant.
return|return
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns whether node is made up of constants.    *    * @param node Node to inspect    * @return true if node is made up of constants, false otherwise    */
specifier|public
specifier|static
name|boolean
name|isConstant
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|node
operator|.
name|accept
argument_list|(
name|ConstantFinder
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
comment|/**    * Returns whether a given expression is deterministic.    *    * @param e Expression    * @return true if tree result is deterministic, false otherwise    */
specifier|public
specifier|static
name|boolean
name|isDeterministic
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
try|try
block|{
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
init|=
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
operator|!
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|isDeterministic
argument_list|()
condition|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|e
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|ex
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Returns whether a given node contains a RexCall with a specified operator    *    * @param operator Operator to look for    * @param node     a RexNode tree    */
specifier|public
specifier|static
name|RexCall
name|findOperatorCall
parameter_list|(
specifier|final
name|SqlOperator
name|operator
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
try|try
block|{
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
init|=
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|equals
argument_list|(
name|operator
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|call
argument_list|)
throw|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|node
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
operator|(
name|RexCall
operator|)
name|e
operator|.
name|getNode
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns whether a given tree contains any {link RexInputRef} nodes.    *    * @param node a RexNode tree    */
specifier|public
specifier|static
name|boolean
name|containsInputRef
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
try|try
block|{
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
init|=
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|inputRef
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
name|node
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Returns whether a given tree contains any    * {@link org.apache.calcite.rex.RexFieldAccess} nodes.    *    * @param node a RexNode tree    */
specifier|public
specifier|static
name|boolean
name|containsFieldAccess
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
try|try
block|{
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
init|=
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
specifier|public
name|Void
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|fieldAccess
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
name|node
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Determines whether a {@link RexCall} requires decimal expansion. It    * usually requires expansion if it has decimal operands.    *    *<p>Exceptions to this rule are:    *    *<ul>    *<li>isNull doesn't require expansion    *<li>It's okay to cast decimals to and from char types    *<li>It's okay to cast nulls as decimals    *<li>Casts require expansion if their return type is decimal    *<li>Reinterpret casts can handle a decimal operand    *</ul>    *    * @param expr    expression possibly in need of expansion    * @param recurse whether to check nested calls    * @return whether the expression requires expansion    */
specifier|public
specifier|static
name|boolean
name|requiresDecimalExpansion
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|boolean
name|recurse
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|expr
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|expr
decl_stmt|;
name|boolean
name|localCheck
init|=
literal|true
decl_stmt|;
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|REINTERPRET
case|:
case|case
name|IS_NULL
case|:
name|localCheck
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|CAST
case|:
name|RelDataType
name|lhsType
init|=
name|call
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|rhsType
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|rhsType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|lhsType
argument_list|)
operator|||
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|rhsType
argument_list|)
condition|)
block|{
name|localCheck
operator|=
literal|false
expr_stmt|;
block|}
if|else if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|lhsType
argument_list|)
operator|&&
operator|(
name|lhsType
operator|!=
name|rhsType
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
default|default:
name|localCheck
operator|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|requiresDecimalExpansion
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|localCheck
condition|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
comment|// NOTE jvs 27-Mar-2007: Depending on the type factory, the
comment|// result of a division may be decimal, even though both inputs
comment|// are integer.
return|return
literal|true
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|call
operator|.
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
name|recurse
operator|&&
name|requiresDecimalExpansion
argument_list|(
name|call
operator|.
name|operands
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Determines whether any operand of a set requires decimal expansion    */
specifier|public
specifier|static
name|boolean
name|requiresDecimalExpansion
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|,
name|boolean
name|recurse
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|operands
control|)
block|{
if|if
condition|(
name|operand
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|operand
decl_stmt|;
if|if
condition|(
name|requiresDecimalExpansion
argument_list|(
name|call
argument_list|,
name|recurse
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether a {@link RexProgram} contains expressions which require    * decimal expansion.    */
specifier|public
specifier|static
name|boolean
name|requiresDecimalExpansion
parameter_list|(
name|RexProgram
name|program
parameter_list|,
name|boolean
name|recurse
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
name|program
operator|.
name|getExprList
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|exprList
control|)
block|{
if|if
condition|(
name|requiresDecimalExpansion
argument_list|(
name|expr
argument_list|,
name|recurse
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|boolean
name|canReinterpretOverflow
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|REINTERPRET
argument_list|)
operator|:
literal|"call is not a reinterpret"
assert|;
return|return
name|call
operator|.
name|operands
operator|.
name|size
argument_list|()
operator|>
literal|1
return|;
block|}
comment|/**    * Returns whether an array of expressions has any common sub-expressions.    */
specifier|public
specifier|static
name|boolean
name|containNoCommonExprs
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
specifier|final
name|ExpressionNormalizer
name|visitor
init|=
operator|new
name|ExpressionNormalizer
argument_list|(
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
try|try
block|{
name|expr
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExpressionNormalizer
operator|.
name|SubExprExistsException
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Returns whether an array of expressions contains no forward references.    * That is, if expression #i contains a {@link RexInputRef} referencing    * field i or greater.    *    * @param exprs        Array of expressions    * @param inputRowType Input row type    * @param litmus       What to do if an error is detected (there is a    *                     forward reference)    *    * @return Whether there is a forward reference    */
specifier|public
specifier|static
name|boolean
name|containNoForwardRefs
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
specifier|final
name|ForwardRefFinder
name|visitor
init|=
operator|new
name|ForwardRefFinder
argument_list|(
name|inputRowType
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|visitor
operator|.
name|setLimit
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// field cannot refer to self or later field
try|try
block|{
name|expr
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ForwardRefFinder
operator|.
name|IllegalForwardRefException
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"illegal forward reference in {}"
argument_list|,
name|expr
argument_list|)
return|;
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Returns whether an array of exp contains no aggregate function calls whose    * arguments are not {@link RexInputRef}s.    *    * @param exprs Expressions    * @param litmus  Whether to assert if there is such a function call    */
specifier|static
name|boolean
name|containNoNonTrivialAggs
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|rexCall
init|=
operator|(
name|RexCall
operator|)
name|expr
decl_stmt|;
if|if
condition|(
name|rexCall
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlAggFunction
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|rexCall
operator|.
name|operands
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|operand
operator|instanceof
name|RexLocalRef
operator|)
operator|&&
operator|!
operator|(
name|operand
operator|instanceof
name|RexLiteral
operator|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"contains non trivial agg: {}"
argument_list|,
name|operand
argument_list|)
return|;
block|}
block|}
block|}
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Returns whether a list of expressions contains complex expressions, that    * is, a call whose arguments are not {@link RexVariable} (or a subtype such    * as {@link RexInputRef}) or {@link RexLiteral}.    */
specifier|public
specifier|static
name|boolean
name|containComplexExprs
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|RexCall
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|operands
control|)
block|{
if|if
condition|(
operator|!
name|isAtomic
argument_list|(
name|operand
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isAtomic
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
return|return
operator|(
name|expr
operator|instanceof
name|RexLiteral
operator|)
operator|||
operator|(
name|expr
operator|instanceof
name|RexVariable
operator|)
return|;
block|}
comment|/**    * Returns whether a {@link RexNode node} is a {@link RexCall call} to a    * given {@link SqlOperator operator}.    */
specifier|public
specifier|static
name|boolean
name|isCallTo
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|SqlOperator
name|op
parameter_list|)
block|{
return|return
operator|(
name|expr
operator|instanceof
name|RexCall
operator|)
operator|&&
operator|(
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|op
operator|)
return|;
block|}
comment|/**    * Creates a record type with anonymous field names.    *    * @param typeFactory Type factory    * @param exprs       Expressions    * @return Record type    */
specifier|public
specifier|static
name|RelDataType
name|createStructType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|)
block|{
return|return
name|createStructType
argument_list|(
name|typeFactory
argument_list|,
name|exprs
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates a record type with specified field names.    *    *<p>The array of field names may be null, or any of the names within it    * can be null. We recommend using explicit names where possible, because it    * makes it much easier to figure out the intent of fields when looking at    * planner output.    *    * @param typeFactory Type factory    * @param exprs       Expressions    * @param names       Field names, may be null, or elements may be null    * @param suggester   Generates alternative names if {@code names} is not    *                    null and its elements are not unique    * @return Record type    */
specifier|public
specifier|static
name|RelDataType
name|createStructType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|,
name|SqlValidatorUtil
operator|.
name|Suggester
name|suggester
parameter_list|)
block|{
if|if
condition|(
name|names
operator|!=
literal|null
operator|&&
name|suggester
operator|!=
literal|null
condition|)
block|{
name|names
operator|=
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|names
argument_list|,
name|suggester
argument_list|,
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|isSchemaCaseSensitive
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataTypeFactory
operator|.
name|FieldInfoBuilder
name|builder
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
decl_stmt|;
if|if
condition|(
name|names
operator|==
literal|null
operator|||
operator|(
name|name
operator|=
name|names
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|name
operator|=
literal|"$f"
operator|+
name|i
expr_stmt|;
block|}
name|builder
operator|.
name|add
argument_list|(
name|name
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelDataType
name|createStructType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
block|{
return|return
name|createStructType
argument_list|(
name|typeFactory
argument_list|,
name|exprs
argument_list|,
name|names
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns whether the type of an array of expressions is compatible with a    * struct type.    *    * @param exprs Array of expressions    * @param type  Type    * @param litmus What to do if an error is detected (there is a mismatch)    *    * @return Whether every expression has the same type as the corresponding    * member of the struct type    *    * @see RelOptUtil#eq(String, RelDataType, String, RelDataType, org.apache.calcite.util.Litmus)    */
specifier|public
specifier|static
name|boolean
name|compatibleTypes
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|type
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
if|if
condition|(
name|exprs
operator|.
name|size
argument_list|()
operator|!=
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"rowtype mismatches expressions"
argument_list|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataType
name|exprType
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|fieldType
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RelOptUtil
operator|.
name|eq
argument_list|(
literal|"type1"
argument_list|,
name|exprType
argument_list|,
literal|"type2"
argument_list|,
name|fieldType
argument_list|,
name|litmus
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Creates a key for {@link RexNode} which is the same as another key of    * another RexNode only if the two have both the same type and textual    * representation. For example, "10" integer and "10" bigint result in    * different keys.    */
specifier|public
specifier|static
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|makeKey
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|expr
operator|.
name|toString
argument_list|()
argument_list|,
name|expr
operator|.
name|getType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns whether the leading edge of a given array of expressions is    * wholly {@link RexInputRef} objects with types corresponding to the    * underlying datatype.    */
specifier|public
specifier|static
name|boolean
name|containIdentity
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
if|if
condition|(
name|exprs
operator|.
name|size
argument_list|()
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"exprs/rowType length mismatch"
argument_list|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"expr[{}] is not a RexInputRef"
argument_list|,
name|i
argument_list|)
return|;
block|}
name|RexInputRef
name|inputRef
init|=
operator|(
name|RexInputRef
operator|)
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|!=
name|i
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"expr[{}] has ordinal {}"
argument_list|,
name|i
argument_list|,
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|RelOptUtil
operator|.
name|eq
argument_list|(
literal|"type1"
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
literal|"type2"
argument_list|,
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|litmus
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/** Returns whether a list of expressions projects the incoming fields. */
specifier|public
specifier|static
name|boolean
name|isIdentity
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exps
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|)
block|{
return|return
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
operator|==
name|exps
operator|.
name|size
argument_list|()
operator|&&
name|containIdentity
argument_list|(
name|exps
argument_list|,
name|inputRowType
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
return|;
block|}
comment|/**    * Converts a collection of expressions into an AND.    * If there are zero expressions, returns TRUE.    * If there is one expression, returns just that expression.    * Removes expressions that always evaluate to TRUE.    * Returns null only if {@code nullOnEmpty} and expression is TRUE.    */
specifier|public
specifier|static
name|RexNode
name|composeConjunction
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|boolean
name|nullOnEmpty
parameter_list|)
block|{
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|flattenAnd
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
name|nullOnEmpty
condition|?
literal|null
else|:
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
default|default:
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|list
argument_list|)
return|;
block|}
block|}
comment|/** Flattens a list of AND nodes.    *    *<p>Treats null nodes as literal TRUE (i.e. ignores them). */
specifier|public
specifier|static
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|flattenAnd
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|instanceof
name|Collection
operator|&&
operator|(
operator|(
name|Collection
operator|)
name|nodes
operator|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Optimize common case
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|digests
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
comment|// to eliminate duplicates
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|addAnd
argument_list|(
name|builder
argument_list|,
name|digests
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|addAnd
parameter_list|(
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|digests
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|addAnd
argument_list|(
name|builder
argument_list|,
name|digests
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
if|if
condition|(
operator|!
name|node
operator|.
name|isAlwaysTrue
argument_list|()
operator|&&
name|digests
operator|.
name|add
argument_list|(
name|node
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Converts a collection of expressions into an OR.    * If there are zero expressions, returns FALSE.    * If there is one expression, returns just that expression.    * Removes expressions that always evaluate to FALSE.    * Flattens expressions that are ORs.    */
specifier|public
specifier|static
name|RexNode
name|composeDisjunction
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|boolean
name|nullOnEmpty
parameter_list|)
block|{
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|flattenOr
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
name|nullOnEmpty
condition|?
literal|null
else|:
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
default|default:
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|list
argument_list|)
return|;
block|}
block|}
comment|/** Flattens a list of OR nodes. */
specifier|public
specifier|static
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|flattenOr
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|instanceof
name|Collection
operator|&&
operator|(
operator|(
name|Collection
operator|)
name|nodes
operator|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Optimize common case
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|digests
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
comment|// to eliminate duplicates
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
name|addOr
argument_list|(
name|builder
argument_list|,
name|digests
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|addOr
parameter_list|(
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|digests
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|OR
case|:
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|addOr
argument_list|(
name|builder
argument_list|,
name|digests
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
if|if
condition|(
operator|!
name|node
operator|.
name|isAlwaysFalse
argument_list|()
operator|&&
name|digests
operator|.
name|add
argument_list|(
name|node
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Applies a mapping to a collation list.    *    * @param mapping       Mapping    * @param collationList Collation list    * @return collation list with mapping applied to each field    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelCollation
argument_list|>
name|apply
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|List
argument_list|<
name|RelCollation
argument_list|>
name|collationList
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelCollation
argument_list|>
name|newCollationList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelCollation
name|collation
range|:
name|collationList
control|)
block|{
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|newFieldCollationList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|fieldCollation
range|:
name|collation
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
specifier|final
name|RelFieldCollation
name|newFieldCollation
init|=
name|apply
argument_list|(
name|mapping
argument_list|,
name|fieldCollation
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFieldCollation
operator|==
literal|null
condition|)
block|{
comment|// This field is not mapped. Stop here. The leading edge
comment|// of the collation is still valid (although it's useless
comment|// if it's empty).
break|break;
block|}
name|newFieldCollationList
operator|.
name|add
argument_list|(
name|newFieldCollation
argument_list|)
expr_stmt|;
block|}
comment|// Truncation to collations to their leading edge creates empty
comment|// and duplicate collations. Ignore these.
if|if
condition|(
operator|!
name|newFieldCollationList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|RelCollation
name|newCollation
init|=
name|RelCollations
operator|.
name|of
argument_list|(
name|newFieldCollationList
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newCollationList
operator|.
name|contains
argument_list|(
name|newCollation
argument_list|)
condition|)
block|{
name|newCollationList
operator|.
name|add
argument_list|(
name|newCollation
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// REVIEW: There might be redundant collations in the list. For example,
comment|// in {(x), (x, y)}, (x) is redundant because it is a leading edge of
comment|// another collation in the list. Could remove redundant collations.
return|return
name|newCollationList
return|;
block|}
comment|/**    * Applies a mapping to a collation.    *    * @param mapping   Mapping    * @param collation Collation    * @return collation with mapping applied    */
specifier|public
specifier|static
name|RelCollation
name|apply
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|RelCollation
name|collation
parameter_list|)
block|{
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
name|applyFields
argument_list|(
name|mapping
argument_list|,
name|collation
operator|.
name|getFieldCollations
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|fieldCollations
operator|.
name|equals
argument_list|(
name|collation
operator|.
name|getFieldCollations
argument_list|()
argument_list|)
condition|?
name|collation
else|:
name|RelCollations
operator|.
name|of
argument_list|(
name|fieldCollations
argument_list|)
return|;
block|}
comment|/**    * Applies a mapping to a field collation.    *    *<p>If the field is not mapped, returns null.    *    * @param mapping        Mapping    * @param fieldCollation Field collation    * @return collation with mapping applied    */
specifier|public
specifier|static
name|RelFieldCollation
name|apply
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|RelFieldCollation
name|fieldCollation
parameter_list|)
block|{
specifier|final
name|int
name|target
init|=
name|mapping
operator|.
name|getTargetOpt
argument_list|(
name|fieldCollation
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|fieldCollation
operator|.
name|copy
argument_list|(
name|target
argument_list|)
return|;
block|}
comment|/**    * Applies a mapping to a list of field collations.    *    * @param mapping         Mapping    * @param fieldCollations Field collations    * @return collations with mapping applied    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|applyFields
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|newFieldCollations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|fieldCollation
range|:
name|fieldCollations
control|)
block|{
name|newFieldCollations
operator|.
name|add
argument_list|(
name|apply
argument_list|(
name|mapping
argument_list|,
name|fieldCollation
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|newFieldCollations
return|;
block|}
comment|/**    * Applies a mapping to an expression.    */
specifier|public
specifier|static
name|RexNode
name|apply
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|node
operator|.
name|accept
argument_list|(
name|RexPermuteInputsShuttle
operator|.
name|of
argument_list|(
name|mapping
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Applies a mapping to an iterable over expressions.    */
specifier|public
specifier|static
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|apply
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|RexPermuteInputsShuttle
name|shuttle
init|=
name|RexPermuteInputsShuttle
operator|.
name|of
argument_list|(
name|mapping
argument_list|)
decl_stmt|;
return|return
name|Iterables
operator|.
name|transform
argument_list|(
name|nodes
argument_list|,
operator|new
name|Function
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
specifier|public
name|RexNode
name|apply
parameter_list|(
name|RexNode
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Applies a shuttle to an array of expressions. Creates a copy first.    *    * @param shuttle Shuttle    * @param exprs   Array of expressions    */
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|RexNode
parameter_list|>
name|T
index|[]
name|apply
parameter_list|(
name|RexVisitor
argument_list|<
name|T
argument_list|>
name|shuttle
parameter_list|,
name|T
index|[]
name|exprs
parameter_list|)
block|{
name|T
index|[]
name|newExprs
init|=
name|exprs
operator|.
name|clone
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newExprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|newExprs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|expr
operator|!=
literal|null
condition|)
block|{
name|newExprs
index|[
name|i
index|]
operator|=
name|expr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newExprs
return|;
block|}
comment|/**    * Applies a visitor to an array of expressions and, if specified, a single    * expression.    *    * @param visitor Visitor    * @param exprs   Array of expressions    * @param expr    Single expression, may be null    */
specifier|public
specifier|static
name|void
name|apply
parameter_list|(
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
parameter_list|,
name|RexNode
index|[]
name|exprs
parameter_list|,
name|RexNode
name|expr
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|e
range|:
name|exprs
control|)
block|{
name|e
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Applies a visitor to a list of expressions and, if specified, a single    * expression.    *    * @param visitor Visitor    * @param exprs   List of expressions    * @param expr    Single expression, may be null    */
specifier|public
specifier|static
name|void
name|apply
parameter_list|(
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|RexNode
name|expr
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|e
range|:
name|exprs
control|)
block|{
name|e
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Flattens an expression.    *    *<p>Returns the same expression if it is already flat. */
specifier|public
specifier|static
name|RexNode
name|flatten
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|flattenedOperands
init|=
name|flatten
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isFlat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|,
name|op
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|op
argument_list|,
name|flattenedOperands
argument_list|)
return|;
block|}
block|}
return|return
name|node
return|;
block|}
comment|/**    * Converts a list of operands into a list that is flat with respect to    * the given operator. The operands are assumed to be flat already.    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|flatten
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|SqlOperator
name|op
parameter_list|)
block|{
if|if
condition|(
name|isFlat
argument_list|(
name|exprs
argument_list|,
name|op
argument_list|)
condition|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|List
operator|)
name|exprs
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|flattenRecurse
argument_list|(
name|list
argument_list|,
name|exprs
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|/**    * Returns whether a call to {@code op} with {@code exprs} as arguments    * would be considered "flat".    *    *<p>For example, {@code isFlat([w, AND[x, y], z, AND)} returns false;    *<p>{@code isFlat([w, x, y, z], AND)} returns true.</p>    */
specifier|private
specifier|static
name|boolean
name|isFlat
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
specifier|final
name|SqlOperator
name|op
parameter_list|)
block|{
return|return
operator|!
name|isAssociative
argument_list|(
name|op
argument_list|)
operator|||
operator|!
name|exists
argument_list|(
name|exprs
argument_list|,
operator|new
name|Predicate1
argument_list|<
name|RexNode
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|apply
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
return|return
name|isCallTo
argument_list|(
name|expr
argument_list|,
name|op
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Returns false if the expression can be optimized by flattening    * calls to an associative operator such as AND and OR.    */
specifier|public
specifier|static
name|boolean
name|isFlat
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|expr
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|expr
decl_stmt|;
return|return
name|isFlat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|,
name|call
operator|.
name|getOperator
argument_list|()
argument_list|)
operator|&&
name|all
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|,
name|IS_FLAT_PREDICATE
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|flattenRecurse
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|SqlOperator
name|op
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|RexCall
operator|&&
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|op
condition|)
block|{
name|flattenRecurse
argument_list|(
name|list
argument_list|,
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Converts an expression to conjunctive normal form (CNF).    *    *<p>The following expression is in CNF:    *    *<blockquote>(a OR b) AND (c OR d)</blockquote>    *    *<p>The following expression is not in CNF:    *    *<blockquote>(a AND b) OR c</blockquote>    *    * but can be converted to CNF:    *    *<blockquote>(a OR c) AND (b OR c)</blockquote>    *    *<p>The following expression is not in CNF:    *    *<blockquote>NOT (a OR NOT b)</blockquote>    *    * but can be converted to CNF by applying de Morgan's theorem:    *    *<blockquote>NOT a AND b</blockquote>    *    *<p>Expressions not involving AND, OR or NOT at the top level are in CNF.    */
specifier|public
specifier|static
name|RexNode
name|toCnf
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
return|return
operator|new
name|CnfHelper
argument_list|(
name|rexBuilder
argument_list|,
operator|-
literal|1
argument_list|)
operator|.
name|toCnf
argument_list|(
name|rex
argument_list|)
return|;
block|}
comment|/**    * Similar to {@link #toCnf(RexBuilder, RexNode)}; however, it lets you    * specify a threshold in the number of nodes that can be created out of    * the conversion.    *    *<p>If the number of resulting nodes exceeds that threshold,    * stops conversion and returns the original expression.    *    *<p>If the threshold is negative it is ignored.    *    *<p>Leaf nodes in the expression do not count towards the threshold.    */
specifier|public
specifier|static
name|RexNode
name|toCnf
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|int
name|maxCnfNodeCount
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
return|return
operator|new
name|CnfHelper
argument_list|(
name|rexBuilder
argument_list|,
name|maxCnfNodeCount
argument_list|)
operator|.
name|toCnf
argument_list|(
name|rex
argument_list|)
return|;
block|}
comment|/** Converts an expression to disjunctive normal form (DNF).    *    *<p>DNF: It is a form of logical formula which is disjunction of conjunctive    * clauses.    *    *<p>All logical formulas can be converted into DNF.    *    *<p>The following expression is in DNF:    *    *<blockquote>(a AND b) OR (c AND d)</blockquote>    *    *<p>The following expression is not in CNF:    *    *<blockquote>(a OR b) AND c</blockquote>    *    * but can be converted to DNF:    *    *<blockquote>(a AND c) OR (b AND c)</blockquote>    *    *<p>The following expression is not in CNF:    *    *<blockquote>NOT (a OR NOT b)</blockquote>    *    * but can be converted to DNF by applying de Morgan's theorem:    *    *<blockquote>NOT a AND b</blockquote>    *    *<p>Expressions not involving AND, OR or NOT at the top level are in DNF.    */
specifier|public
specifier|static
name|RexNode
name|toDnf
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
return|return
operator|new
name|DnfHelper
argument_list|(
name|rexBuilder
argument_list|)
operator|.
name|toDnf
argument_list|(
name|rex
argument_list|)
return|;
block|}
comment|/**    * Returns whether an operator is associative. AND is associative,    * which means that "(x AND y) and z" is equivalent to "x AND (y AND z)".    * We might well flatten the tree, and write "AND(x, y, z)".    */
specifier|private
specifier|static
name|boolean
name|isAssociative
parameter_list|(
name|SqlOperator
name|op
parameter_list|)
block|{
return|return
name|op
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
operator|||
name|op
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|OR
return|;
block|}
comment|/**    * Returns whether there is an element in {@code list} for which    * {@code predicate} is true.    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|exists
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|list
parameter_list|,
name|Predicate1
argument_list|<
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
for|for
control|(
name|E
name|e
range|:
name|list
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|e
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether {@code predicate} is true for all elements of    * {@code list}.    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|all
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|list
parameter_list|,
name|Predicate1
argument_list|<
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
for|for
control|(
name|E
name|e
range|:
name|list
control|)
block|{
if|if
condition|(
operator|!
name|predicate
operator|.
name|apply
argument_list|(
name|e
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Shifts every {@link RexInputRef} in an expression by {@code offset}.    */
specifier|public
specifier|static
name|RexNode
name|shift
parameter_list|(
name|RexNode
name|node
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
return|return
name|node
return|;
block|}
return|return
name|node
operator|.
name|accept
argument_list|(
operator|new
name|RexShiftShuttle
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Shifts every {@link RexInputRef} in an expression by {@code offset}.    */
specifier|public
specifier|static
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|shift
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
operator|new
name|RexShiftShuttle
argument_list|(
name|offset
argument_list|)
operator|.
name|apply
argument_list|(
name|nodes
argument_list|)
return|;
block|}
comment|/**    * Shifts every {@link RexInputRef} in an expression higher than {@code start}    * by {@code offset}.    */
specifier|public
specifier|static
name|RexNode
name|shift
parameter_list|(
name|RexNode
name|node
parameter_list|,
specifier|final
name|int
name|start
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
return|return
name|node
operator|.
name|accept
argument_list|(
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|input
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|input
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|<
name|start
condition|)
block|{
return|return
name|input
return|;
block|}
return|return
operator|new
name|RexInputRef
argument_list|(
name|index
operator|+
name|offset
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/** Creates an equivalent version of a node where common factors among ORs    * are pulled up.    *    *<p>For example,    *    *<blockquote>(a AND b) OR (a AND c AND d)</blockquote>    *    *<p>becomes    *    *<blockquote>a AND (b OR (c AND d))</blockquote>    *    *<p>Note that this result is not in CNF    * (see {@link #toCnf(RexBuilder, RexNode)}) because there is an AND inside an    * OR.    *    *<p>This form is useful if, say, {@code a} contains columns from only the    * left-hand side of a join, and can be pushed to the left input.    *    * @param rexBuilder Rex builder    * @param node Expression to transform    * @return Equivalent expression with common factors pulled up    */
specifier|public
specifier|static
name|RexNode
name|pullFactors
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
return|return
operator|new
name|CnfHelper
argument_list|(
name|rexBuilder
argument_list|,
operator|-
literal|1
argument_list|)
operator|.
name|pull
argument_list|(
name|node
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|fixUp
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
specifier|final
name|RelDataType
name|rowType
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
init|=
name|RelOptUtil
operator|.
name|getFieldTypeList
argument_list|(
name|rowType
argument_list|)
decl_stmt|;
return|return
name|fixUp
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|,
name|typeList
argument_list|)
return|;
block|}
comment|/** Fixes up the type of all {@link RexInputRef}s in an    * expression to match differences in nullability.    *    *<p>Such differences in nullability occur when expressions are moved    * through outer joins.    *    *<p>Throws if there any greater inconsistencies of type. */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|fixUp
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|fieldTypes
parameter_list|)
block|{
return|return
operator|new
name|FixNullabilityShuttle
argument_list|(
name|rexBuilder
argument_list|,
name|fieldTypes
argument_list|)
operator|.
name|apply
argument_list|(
name|nodes
argument_list|)
return|;
block|}
comment|/** Transforms a list of expressions into a list of their types. */
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
name|nodes
argument_list|,
name|TYPE_FN
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataTypeFamily
argument_list|>
name|families
parameter_list|(
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
name|types
argument_list|,
name|FAMILY_FN
argument_list|)
return|;
block|}
comment|/** Removes all expressions from a list that are equivalent to a given    * expression. Returns whether any were removed. */
specifier|public
specifier|static
name|boolean
name|removeAll
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|targets
parameter_list|,
name|RexNode
name|e
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|RexNode
argument_list|>
name|iterator
init|=
name|targets
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RexNode
name|next
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|eq
argument_list|(
name|next
argument_list|,
name|e
argument_list|)
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|count
operator|>
literal|0
return|;
block|}
comment|/** Returns whether two {@link RexNode}s are structurally equal.    *    *<p>This method considers structure, not semantics. 'x&lt; y' is not    * equivalent to 'y&gt; x'.    */
specifier|public
specifier|static
name|boolean
name|eq
parameter_list|(
name|RexNode
name|e1
parameter_list|,
name|RexNode
name|e2
parameter_list|)
block|{
return|return
name|e1
operator|==
name|e2
operator|||
name|e1
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|e2
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/** Simplifies a boolean expression, always preserving its type and its    * nullability.    *    *<p>This is useful if you are simplifying expressions in a    * {@link Project}. */
specifier|public
specifier|static
name|RexNode
name|simplifyPreservingType
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e
parameter_list|,
name|RexExecutor
name|executor
parameter_list|)
block|{
specifier|final
name|RexNode
name|e2
init|=
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|e
argument_list|,
literal|false
argument_list|,
name|executor
argument_list|)
decl_stmt|;
if|if
condition|(
name|e2
operator|.
name|getType
argument_list|()
operator|==
name|e
operator|.
name|getType
argument_list|()
condition|)
block|{
return|return
name|e2
return|;
block|}
specifier|final
name|RexNode
name|e3
init|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|e
operator|.
name|getType
argument_list|()
argument_list|,
name|e2
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|e3
operator|.
name|equals
argument_list|(
name|e
argument_list|)
condition|)
block|{
return|return
name|e
return|;
block|}
return|return
name|e3
return|;
block|}
comment|/**    * Simplifies a boolean expression, leaving UNKNOWN values as UNKNOWN, and    * using the default executor.    */
specifier|public
specifier|static
name|RexNode
name|simplify
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e
parameter_list|)
block|{
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|e
argument_list|,
literal|false
argument_list|,
name|EXECUTOR
argument_list|)
return|;
block|}
comment|/**    * Simplifies a boolean expression,    * using the default executor.    */
specifier|public
specifier|static
name|RexNode
name|simplify
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e
parameter_list|,
name|boolean
name|unknownAsFalse
parameter_list|)
block|{
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|e
argument_list|,
name|unknownAsFalse
argument_list|,
name|EXECUTOR
argument_list|)
return|;
block|}
comment|/**    * Simplifies a boolean expression.    *    *<p>In particular:</p>    *<ul>    *<li>{@code simplify(x = 1 AND y = 2 AND NOT x = 1)}    * returns {@code y = 2}</li>    *<li>{@code simplify(x = 1 AND FALSE)}    * returns {@code FALSE}</li>    *</ul>    *    *<p>If the expression is a predicate in a WHERE clause, UNKNOWN values have    * the same effect as FALSE. In situations like this, specify    * {@code unknownAsFalse = true}, so and we can switch from 3-valued logic to    * simpler 2-valued logic and make more optimizations.    *    * @param rexBuilder Rex builder    * @param e Expression to simplify    * @param unknownAsFalse Whether to convert UNKNOWN values to FALSE    * @param executor Executor for constant reduction, not null    */
specifier|public
specifier|static
name|RexNode
name|simplify
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e
parameter_list|,
name|boolean
name|unknownAsFalse
parameter_list|,
name|RexExecutor
name|executor
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|executor
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
return|return
name|simplifyAnd
argument_list|(
name|rexBuilder
argument_list|,
operator|(
name|RexCall
operator|)
name|e
argument_list|,
name|unknownAsFalse
argument_list|)
return|;
case|case
name|OR
case|:
return|return
name|simplifyOr
argument_list|(
name|rexBuilder
argument_list|,
operator|(
name|RexCall
operator|)
name|e
argument_list|)
return|;
case|case
name|NOT
case|:
return|return
name|simplifyNot
argument_list|(
name|rexBuilder
argument_list|,
operator|(
name|RexCall
operator|)
name|e
argument_list|)
return|;
case|case
name|CASE
case|:
return|return
name|simplifyCase
argument_list|(
name|rexBuilder
argument_list|,
operator|(
name|RexCall
operator|)
name|e
argument_list|,
name|unknownAsFalse
argument_list|)
return|;
case|case
name|CAST
case|:
return|return
name|simplifyCast
argument_list|(
name|rexBuilder
argument_list|,
operator|(
name|RexCall
operator|)
name|e
argument_list|,
name|executor
argument_list|)
return|;
case|case
name|IS_NULL
case|:
case|case
name|IS_NOT_NULL
case|:
case|case
name|IS_TRUE
case|:
case|case
name|IS_NOT_TRUE
case|:
case|case
name|IS_FALSE
case|:
case|case
name|IS_NOT_FALSE
case|:
assert|assert
name|e
operator|instanceof
name|RexCall
assert|;
return|return
name|simplifyIs
argument_list|(
name|rexBuilder
argument_list|,
operator|(
name|RexCall
operator|)
name|e
argument_list|)
return|;
case|case
name|EQUALS
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|LESS_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
case|case
name|NOT_EQUALS
case|:
return|return
name|simplifyComparison
argument_list|(
name|rexBuilder
argument_list|,
operator|(
name|RexCall
operator|)
name|e
argument_list|,
name|unknownAsFalse
argument_list|)
return|;
default|default:
return|return
name|e
return|;
block|}
block|}
comment|// e must be a comparison (=,>,>=,<,<=, !=)
specifier|private
specifier|static
name|RexNode
name|simplifyComparison
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexCall
name|e
parameter_list|,
name|boolean
name|unknownAsFalse
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|e
operator|.
name|operands
argument_list|)
decl_stmt|;
name|simplifyList
argument_list|(
name|rexBuilder
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|// Simplify "x<op> x"
specifier|final
name|RexNode
name|o0
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|o1
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|RexUtil
operator|.
name|eq
argument_list|(
name|o0
argument_list|,
name|o1
argument_list|)
operator|&&
operator|(
name|unknownAsFalse
operator|||
operator|(
operator|!
name|o0
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
operator|&&
operator|!
name|o1
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
comment|// "x = x" simplifies to "x is not null" (similarly<= and>=)
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|o0
argument_list|)
argument_list|)
return|;
default|default:
comment|// "x != x" simplifies to "false" (similarly< and>)
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
block|}
comment|// Simplify "<literal1><op><literal2>"
comment|// For example, "1 = 2" becomes FALSE;
comment|// "1 != 1" becomes FALSE;
comment|// "1 != NULL" becomes UNKNOWN (or FALSE if unknownAsFalse);
comment|// "1 != '1'" is unchanged because the types are not the same.
if|if
condition|(
name|o0
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|LITERAL
argument_list|)
operator|&&
name|o1
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|LITERAL
argument_list|)
operator|&&
name|o0
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|o1
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
specifier|final
name|Comparable
name|v0
init|=
operator|(
operator|(
name|RexLiteral
operator|)
name|o0
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|Comparable
name|v1
init|=
operator|(
operator|(
name|RexLiteral
operator|)
name|o1
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|v0
operator|==
literal|null
operator|||
name|v1
operator|==
literal|null
condition|)
block|{
return|return
name|unknownAsFalse
condition|?
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
else|:
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|e
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|int
name|comparisonResult
init|=
name|v0
operator|.
name|compareTo
argument_list|(
name|v1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|comparisonResult
operator|==
literal|0
argument_list|)
return|;
case|case
name|GREATER_THAN
case|:
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|comparisonResult
operator|>
literal|0
argument_list|)
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|comparisonResult
operator|>=
literal|0
argument_list|)
return|;
case|case
name|LESS_THAN
case|:
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|comparisonResult
operator|<
literal|0
argument_list|)
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|comparisonResult
operator|<=
literal|0
argument_list|)
return|;
case|case
name|NOT_EQUALS
case|:
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|comparisonResult
operator|!=
literal|0
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
comment|// If none of the arguments were simplified, return the call unchanged.
if|if
condition|(
name|operands
operator|.
name|equals
argument_list|(
name|e
operator|.
name|operands
argument_list|)
condition|)
block|{
return|return
name|e
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|e
operator|.
name|op
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|/**    * Simplifies a conjunction of boolean expressions.    */
specifier|public
specifier|static
name|RexNode
name|simplifyAnds
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|simplifyAnds
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RexNode
name|simplifyAnds
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|boolean
name|unknownAsFalse
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|terms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|notTerms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|nodes
control|)
block|{
name|RelOptUtil
operator|.
name|decomposeConjunction
argument_list|(
name|e
argument_list|,
name|terms
argument_list|,
name|notTerms
argument_list|)
expr_stmt|;
block|}
name|simplifyList
argument_list|(
name|rexBuilder
argument_list|,
name|terms
argument_list|)
expr_stmt|;
name|simplifyList
argument_list|(
name|rexBuilder
argument_list|,
name|notTerms
argument_list|)
expr_stmt|;
if|if
condition|(
name|unknownAsFalse
condition|)
block|{
return|return
name|simplifyAnd2ForUnknownAsFalse
argument_list|(
name|rexBuilder
argument_list|,
name|terms
argument_list|,
name|notTerms
argument_list|)
return|;
block|}
return|return
name|simplifyAnd2
argument_list|(
name|rexBuilder
argument_list|,
name|terms
argument_list|,
name|notTerms
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|simplifyList
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|terms
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|terms
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|terms
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|terms
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|RexNode
name|simplifyNot
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexCall
name|call
parameter_list|)
block|{
specifier|final
name|RexNode
name|a
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|a
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|NOT
case|:
comment|// NOT NOT x ==> x
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
operator|(
operator|(
name|RexCall
operator|)
name|a
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
specifier|final
name|SqlKind
name|negateKind
init|=
name|a
operator|.
name|getKind
argument_list|()
operator|.
name|negate
argument_list|()
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|getKind
argument_list|()
operator|!=
name|negateKind
condition|)
block|{
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|(
name|negateKind
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|a
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|final
name|SqlKind
name|negateKind2
init|=
name|a
operator|.
name|getKind
argument_list|()
operator|.
name|negateNullSafe
argument_list|()
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|getKind
argument_list|()
operator|!=
name|negateKind2
condition|)
block|{
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|(
name|negateKind2
argument_list|)
argument_list|,
operator|(
operator|(
name|RexCall
operator|)
name|a
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|a
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
condition|)
block|{
comment|// NOT distributivity for AND
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|a
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|newOperands
operator|.
name|add
argument_list|(
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|operand
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|newOperands
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|a
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|OR
condition|)
block|{
comment|// NOT distributivity for OR
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|a
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|newOperands
operator|.
name|add
argument_list|(
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|operand
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|newOperands
argument_list|)
argument_list|)
return|;
block|}
return|return
name|call
return|;
block|}
comment|/** Negates a logical expression by adding or removing a NOT. */
specifier|public
specifier|static
name|RexNode
name|not
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|NOT
case|:
return|return
operator|(
operator|(
name|RexCall
operator|)
name|e
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
default|default:
return|return
operator|new
name|RexCall
argument_list|(
name|e
operator|.
name|getType
argument_list|()
argument_list|,
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|e
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|RexNode
name|simplifyIs
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlKind
name|kind
init|=
name|call
operator|.
name|getKind
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|a
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|simplified
init|=
name|simplifyIs2
argument_list|(
name|rexBuilder
argument_list|,
name|kind
argument_list|,
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|simplified
operator|!=
literal|null
condition|)
block|{
return|return
name|simplified
return|;
block|}
return|return
name|call
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|simplifyIs2
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|SqlKind
name|kind
parameter_list|,
name|RexNode
name|a
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|IS_NULL
case|:
comment|// x IS NULL ==> FALSE (if x is not nullable)
if|if
condition|(
operator|!
name|a
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
break|break;
case|case
name|IS_NOT_NULL
case|:
comment|// x IS NOT NULL ==> TRUE (if x is not nullable)
name|RexNode
name|simplified
init|=
name|simplifyIsNotNull
argument_list|(
name|rexBuilder
argument_list|,
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|simplified
operator|!=
literal|null
condition|)
block|{
return|return
name|simplified
return|;
block|}
break|break;
case|case
name|IS_TRUE
case|:
case|case
name|IS_NOT_FALSE
case|:
comment|// x IS TRUE ==> x (if x is not nullable)
comment|// x IS NOT FALSE ==> x (if x is not nullable)
if|if
condition|(
operator|!
name|a
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|a
argument_list|)
return|;
block|}
break|break;
case|case
name|IS_FALSE
case|:
case|case
name|IS_NOT_TRUE
case|:
comment|// x IS NOT TRUE ==> NOT x (if x is not nullable)
comment|// x IS FALSE ==> NOT x (if x is not nullable)
if|if
condition|(
operator|!
name|a
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|a
argument_list|)
argument_list|)
return|;
block|}
break|break;
block|}
switch|switch
condition|(
name|a
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|NOT
case|:
comment|// (NOT x) IS TRUE ==> x IS FALSE
comment|// Similarly for IS NOT TRUE, IS FALSE, etc.
comment|//
comment|// Note that
comment|//   (NOT x) IS TRUE !=> x IS FALSE
comment|// because of null values.
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|(
name|kind
operator|.
name|negate
argument_list|()
argument_list|)
argument_list|,
operator|(
operator|(
name|RexCall
operator|)
name|a
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|RexNode
name|a2
init|=
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|!=
name|a2
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|(
name|kind
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|a2
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|null
return|;
comment|// cannot be simplified
block|}
specifier|private
specifier|static
name|RexNode
name|simplifyIsNotNull
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|a
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
block|}
switch|switch
condition|(
name|Strong
operator|.
name|policy
argument_list|(
name|a
operator|.
name|getKind
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|ANY
case|:
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|a
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
specifier|final
name|RexNode
name|simplified
init|=
name|simplifyIsNotNull
argument_list|(
name|rexBuilder
argument_list|,
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|simplified
operator|==
literal|null
condition|)
block|{
name|operands
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|simplified
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
else|else
block|{
name|operands
operator|.
name|add
argument_list|(
name|simplified
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|operands
argument_list|,
literal|false
argument_list|)
return|;
case|case
name|CUSTOM
case|:
switch|switch
condition|(
name|a
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LITERAL
case|:
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|(
operator|(
name|RexLiteral
operator|)
name|a
operator|)
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"every CUSTOM policy needs a handler, "
operator|+
name|a
operator|.
name|getKind
argument_list|()
argument_list|)
throw|;
block|}
case|case
name|AS_IS
case|:
default|default:
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
name|SqlOperator
name|op
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|IS_FALSE
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_FALSE
return|;
case|case
name|IS_TRUE
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
return|;
case|case
name|IS_UNKNOWN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_UNKNOWN
return|;
case|case
name|IS_NULL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_NULL
return|;
case|case
name|IS_NOT_FALSE
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_NOT_FALSE
return|;
case|case
name|IS_NOT_TRUE
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_NOT_TRUE
return|;
case|case
name|IS_NOT_NULL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
return|;
case|case
name|EQUALS
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|EQUALS
return|;
case|case
name|NOT_EQUALS
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
return|;
case|case
name|LESS_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
return|;
case|case
name|GREATER_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|kind
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|RexNode
name|simplifyCase
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|boolean
name|unknownAsFalse
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|values
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|operand
init|=
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCasePredicate
argument_list|(
name|call
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|operand
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// Predicate is always TRUE. Make value the ELSE and quit.
name|newOperands
operator|.
name|add
argument_list|(
name|operands
operator|.
name|get
argument_list|(
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unknownAsFalse
operator|&&
name|isNull
argument_list|(
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|values
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|values
operator|.
name|add
argument_list|(
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|else if
condition|(
name|operand
operator|.
name|isAlwaysFalse
argument_list|()
operator|||
name|isNull
argument_list|(
name|operand
argument_list|)
condition|)
block|{
comment|// Predicate is always FALSE or NULL. Skip predicate and value.
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
name|unknownAsFalse
operator|&&
name|isNull
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|values
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|values
operator|.
name|add
argument_list|(
name|operand
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|newOperands
operator|.
name|add
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
assert|assert
name|newOperands
operator|.
name|size
argument_list|()
operator|%
literal|2
operator|==
literal|1
assert|;
if|if
condition|(
name|newOperands
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|||
name|values
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
specifier|final
name|RexNode
name|last
init|=
name|Util
operator|.
name|last
argument_list|(
name|newOperands
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|call
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|last
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeAbstractCast
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|last
argument_list|)
return|;
block|}
return|return
name|last
return|;
block|}
name|trueFalse
label|:
if|if
condition|(
name|call
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|BOOLEAN
condition|)
block|{
comment|// Optimize CASE where every branch returns constant true or constant
comment|// false.
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
argument_list|>
name|pairs
init|=
name|casePairs
argument_list|(
name|rexBuilder
argument_list|,
name|newOperands
argument_list|)
decl_stmt|;
comment|// 1) Possible simplification if unknown is treated as false:
comment|//   CASE
comment|//   WHEN p1 THEN TRUE
comment|//   WHEN p2 THEN TRUE
comment|//   ELSE FALSE
comment|//   END
comment|// can be rewritten to: (p1 or p2)
if|if
condition|(
name|unknownAsFalse
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|terms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|pos
operator|<
name|pairs
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
comment|// True block
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|pair
init|=
name|pairs
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pair
operator|.
name|getValue
argument_list|()
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
break|break;
block|}
name|terms
operator|.
name|add
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|pos
operator|<
name|pairs
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
comment|// False block
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|pair
init|=
name|pairs
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pair
operator|.
name|getValue
argument_list|()
operator|.
name|isAlwaysFalse
argument_list|()
operator|&&
operator|!
name|isNull
argument_list|(
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|pos
operator|==
name|pairs
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|final
name|RexNode
name|disjunction
init|=
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|terms
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|call
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|disjunction
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|disjunction
argument_list|)
return|;
block|}
return|return
name|disjunction
return|;
block|}
block|}
comment|// 2) Another simplification
comment|//   CASE
comment|//   WHEN p1 THEN TRUE
comment|//   WHEN p2 THEN FALSE
comment|//   WHEN p3 THEN TRUE
comment|//   ELSE FALSE
comment|//   END
comment|// if p1...pn cannot be nullable
for|for
control|(
name|Ord
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
argument_list|>
name|pair
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|pairs
argument_list|)
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
break|break
name|trueFalse
break|;
block|}
if|if
condition|(
operator|!
name|pair
operator|.
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|isAlwaysTrue
argument_list|()
operator|&&
operator|!
name|pair
operator|.
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|isAlwaysFalse
argument_list|()
operator|&&
operator|(
operator|!
name|unknownAsFalse
operator|||
operator|!
name|isNull
argument_list|(
name|pair
operator|.
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
operator|)
condition|)
block|{
break|break
name|trueFalse
break|;
block|}
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|terms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|notTerms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
argument_list|>
name|pair
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|pairs
argument_list|)
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|terms
operator|.
name|add
argument_list|(
name|andNot
argument_list|(
name|rexBuilder
argument_list|,
name|pair
operator|.
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|notTerms
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notTerms
operator|.
name|add
argument_list|(
name|pair
operator|.
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|RexNode
name|disjunction
init|=
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|terms
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|call
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|disjunction
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|disjunction
argument_list|)
return|;
block|}
return|return
name|disjunction
return|;
block|}
if|if
condition|(
name|newOperands
operator|.
name|equals
argument_list|(
name|operands
argument_list|)
condition|)
block|{
return|return
name|call
return|;
block|}
return|return
name|call
operator|.
name|clone
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|newOperands
argument_list|)
return|;
block|}
comment|/** Given "CASE WHEN p1 THEN v1 ... ELSE e END"    * returns [(p1, v1), ..., (true, e)]. */
specifier|private
specifier|static
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
argument_list|>
name|casePairs
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|operands
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
operator|(
name|RexNode
operator|)
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|operands
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|RexNode
name|simplifyAnd
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexCall
name|e
parameter_list|,
name|boolean
name|unknownAsFalse
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|terms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|notTerms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|RelOptUtil
operator|.
name|decomposeConjunction
argument_list|(
name|e
argument_list|,
name|terms
argument_list|,
name|notTerms
argument_list|)
expr_stmt|;
name|simplifyList
argument_list|(
name|rexBuilder
argument_list|,
name|terms
argument_list|)
expr_stmt|;
name|simplifyList
argument_list|(
name|rexBuilder
argument_list|,
name|notTerms
argument_list|)
expr_stmt|;
if|if
condition|(
name|unknownAsFalse
condition|)
block|{
return|return
name|simplifyAnd2ForUnknownAsFalse
argument_list|(
name|rexBuilder
argument_list|,
name|terms
argument_list|,
name|notTerms
argument_list|)
return|;
block|}
return|return
name|simplifyAnd2
argument_list|(
name|rexBuilder
argument_list|,
name|terms
argument_list|,
name|notTerms
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RexNode
name|simplifyAnd2
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|terms
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|notTerms
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|term
range|:
name|terms
control|)
block|{
if|if
condition|(
name|term
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|terms
operator|.
name|isEmpty
argument_list|()
operator|&&
name|notTerms
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
block|}
if|if
condition|(
name|terms
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|notTerms
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Make sure "x OR y OR x" (a single-term conjunction) gets simplified.
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|terms
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|// If one of the not-disjunctions is a disjunction that is wholly
comment|// contained in the disjunctions list, the expression is not
comment|// satisfiable.
comment|//
comment|// Example #1. x AND y AND z AND NOT (x AND y)  - not satisfiable
comment|// Example #2. x AND y AND NOT (x AND y)        - not satisfiable
comment|// Example #3. x AND y AND NOT (x AND y AND z)  - may be satisfiable
for|for
control|(
name|RexNode
name|notDisjunction
range|:
name|notTerms
control|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|terms2
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|notDisjunction
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|.
name|containsAll
argument_list|(
name|terms2
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
block|}
comment|// Add the NOT disjunctions back in.
for|for
control|(
name|RexNode
name|notDisjunction
range|:
name|notTerms
control|)
block|{
name|terms
operator|.
name|add
argument_list|(
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|notDisjunction
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|terms
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** As {@link #simplifyAnd2(RexBuilder, List, List)} but we assume that if the expression returns    * UNKNOWN it will be interpreted as FALSE. */
specifier|public
specifier|static
name|RexNode
name|simplifyAnd2ForUnknownAsFalse
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|terms
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|notTerms
parameter_list|)
block|{
specifier|final
name|RexExecutor
name|executor
init|=
name|EXECUTOR
decl_stmt|;
for|for
control|(
name|RexNode
name|term
range|:
name|terms
control|)
block|{
if|if
condition|(
name|term
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|terms
operator|.
name|isEmpty
argument_list|()
operator|&&
name|notTerms
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
block|}
if|if
condition|(
name|terms
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|notTerms
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Make sure "x OR y OR x" (a single-term conjunction) gets simplified.
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|terms
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|// Try to simplify the expression
specifier|final
name|Multimap
argument_list|<
name|String
argument_list|,
name|Pair
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
argument_list|>
name|equalityTerms
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|equalityConstantTerms
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|negatedTerms
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|nullOperands
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|notNullOperands
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|comparedOperands
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|terms
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|term
init|=
name|terms
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isDeterministic
argument_list|(
name|term
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// Simplify BOOLEAN expressions if possible
while|while
condition|(
name|term
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|term
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|term
operator|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|terms
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|term
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|else if
condition|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|term
operator|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|terms
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|term
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
switch|switch
condition|(
name|term
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
case|case
name|NOT_EQUALS
case|:
case|case
name|LESS_THAN
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|term
decl_stmt|;
name|RexNode
name|left
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|comparedOperands
operator|.
name|add
argument_list|(
name|left
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// if it is a cast, we include the inner reference
if|if
condition|(
name|left
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
condition|)
block|{
name|RexCall
name|leftCast
init|=
operator|(
name|RexCall
operator|)
name|left
decl_stmt|;
name|comparedOperands
operator|.
name|add
argument_list|(
name|leftCast
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|right
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|comparedOperands
operator|.
name|add
argument_list|(
name|right
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// if it is a cast, we include the inner reference
if|if
condition|(
name|right
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
condition|)
block|{
name|RexCall
name|rightCast
init|=
operator|(
name|RexCall
operator|)
name|right
decl_stmt|;
name|comparedOperands
operator|.
name|add
argument_list|(
name|rightCast
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Check for equality on different constants. If the same ref or CAST(ref)
comment|// is equal to different constants, this condition cannot be satisfied,
comment|// and hence it can be evaluated to FALSE
if|if
condition|(
name|term
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
specifier|final
name|boolean
name|leftRef
init|=
name|isReferenceOrAccess
argument_list|(
name|left
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|rightRef
init|=
name|isReferenceOrAccess
argument_list|(
name|right
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|right
operator|instanceof
name|RexLiteral
operator|&&
name|leftRef
condition|)
block|{
specifier|final
name|String
name|literal
init|=
name|right
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|String
name|prevLiteral
init|=
name|equalityConstantTerms
operator|.
name|put
argument_list|(
name|left
operator|.
name|toString
argument_list|()
argument_list|,
name|literal
argument_list|)
decl_stmt|;
if|if
condition|(
name|prevLiteral
operator|!=
literal|null
operator|&&
operator|!
name|literal
operator|.
name|equals
argument_list|(
name|prevLiteral
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
block|}
if|else if
condition|(
name|left
operator|instanceof
name|RexLiteral
operator|&&
name|rightRef
condition|)
block|{
specifier|final
name|String
name|literal
init|=
name|left
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|String
name|prevLiteral
init|=
name|equalityConstantTerms
operator|.
name|put
argument_list|(
name|right
operator|.
name|toString
argument_list|()
argument_list|,
name|literal
argument_list|)
decl_stmt|;
if|if
condition|(
name|prevLiteral
operator|!=
literal|null
operator|&&
operator|!
name|literal
operator|.
name|equals
argument_list|(
name|prevLiteral
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
block|}
if|else if
condition|(
name|leftRef
operator|&&
name|rightRef
condition|)
block|{
name|equalityTerms
operator|.
name|put
argument_list|(
name|left
operator|.
name|toString
argument_list|()
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
name|right
operator|.
name|toString
argument_list|()
argument_list|,
name|term
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Assume the expression a> 5 is part of a Filter condition.
comment|// Then we can derive the negated term: a<= 5.
comment|// But as the comparison is string based and thus operands order dependent,
comment|// we should also add the inverted negated term: 5>= a.
comment|// Observe that for creating the inverted term we invert the list of operands.
name|RexNode
name|negatedTerm
init|=
name|negate
argument_list|(
name|rexBuilder
argument_list|,
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|negatedTerm
operator|!=
literal|null
condition|)
block|{
name|negatedTerms
operator|.
name|add
argument_list|(
name|negatedTerm
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|RexNode
name|invertNegatedTerm
init|=
name|invert
argument_list|(
name|rexBuilder
argument_list|,
operator|(
name|RexCall
operator|)
name|negatedTerm
argument_list|)
decl_stmt|;
if|if
condition|(
name|invertNegatedTerm
operator|!=
literal|null
condition|)
block|{
name|negatedTerms
operator|.
name|add
argument_list|(
name|invertNegatedTerm
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IN
case|:
name|comparedOperands
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|term
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|BETWEEN
case|:
name|comparedOperands
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|term
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|IS_NOT_NULL
case|:
name|notNullOperands
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|term
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|terms
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
break|break;
case|case
name|IS_NULL
case|:
name|nullOperands
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|term
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If one column should be null and is in a comparison predicate,
comment|// it is not satisfiable.
comment|// Example. IS NULL(x) AND x< 5  - not satisfiable
if|if
condition|(
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|nullOperands
argument_list|,
name|comparedOperands
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|// Check for equality of two refs wrt equality with constants
comment|// Example #1. x=5 AND y=5 AND x=y : x=5 AND y=5
comment|// Example #2. x=5 AND y=6 AND x=y - not satisfiable
for|for
control|(
name|String
name|ref1
range|:
name|equalityTerms
operator|.
name|keySet
argument_list|()
control|)
block|{
specifier|final
name|String
name|literal1
init|=
name|equalityConstantTerms
operator|.
name|get
argument_list|(
name|ref1
argument_list|)
decl_stmt|;
if|if
condition|(
name|literal1
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|Collection
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
argument_list|>
name|references
init|=
name|equalityTerms
operator|.
name|get
argument_list|(
name|ref1
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|ref2
range|:
name|references
control|)
block|{
specifier|final
name|String
name|literal2
init|=
name|equalityConstantTerms
operator|.
name|get
argument_list|(
name|ref2
operator|.
name|left
argument_list|)
decl_stmt|;
if|if
condition|(
name|literal2
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|literal1
operator|.
name|equals
argument_list|(
name|literal2
argument_list|)
condition|)
block|{
comment|// If an expression is equal to two different constants,
comment|// it is not satisfiable
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|// Otherwise we can remove the term, as we already know that
comment|// the expression is equal to two constants
name|terms
operator|.
name|remove
argument_list|(
name|ref2
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Remove not necessary IS NOT NULL expressions.
comment|//
comment|// Example. IS NOT NULL(x) AND x< 5  : x< 5
for|for
control|(
name|RexNode
name|operand
range|:
name|notNullOperands
control|)
block|{
if|if
condition|(
operator|!
name|comparedOperands
operator|.
name|contains
argument_list|(
name|operand
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|terms
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If one of the not-disjunctions is a disjunction that is wholly
comment|// contained in the disjunctions list, the expression is not
comment|// satisfiable.
comment|//
comment|// Example #1. x AND y AND z AND NOT (x AND y)  - not satisfiable
comment|// Example #2. x AND y AND NOT (x AND y)        - not satisfiable
comment|// Example #3. x AND y AND NOT (x AND y AND z)  - may be satisfiable
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|termsSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|strings
argument_list|(
name|terms
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|notDisjunction
range|:
name|notTerms
control|)
block|{
if|if
condition|(
operator|!
name|isDeterministic
argument_list|(
name|notDisjunction
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|terms2Set
init|=
name|strings
argument_list|(
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|notDisjunction
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|termsSet
operator|.
name|containsAll
argument_list|(
name|terms2Set
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
block|}
comment|// Add the NOT disjunctions back in.
for|for
control|(
name|RexNode
name|notDisjunction
range|:
name|notTerms
control|)
block|{
specifier|final
name|RexNode
name|call
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|notDisjunction
argument_list|)
decl_stmt|;
name|terms
operator|.
name|add
argument_list|(
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|call
argument_list|,
literal|true
argument_list|,
name|executor
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// The negated terms: only deterministic expressions
for|for
control|(
name|String
name|negatedTerm
range|:
name|negatedTerms
control|)
block|{
if|if
condition|(
name|termsSet
operator|.
name|contains
argument_list|(
name|negatedTerm
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
block|}
return|return
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|terms
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RexNode
name|negate
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexCall
name|call
parameter_list|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
case|case
name|NOT_EQUALS
case|:
case|case
name|LESS_THAN
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
specifier|final
name|SqlOperator
name|op
init|=
name|op
argument_list|(
name|call
operator|.
name|getKind
argument_list|()
operator|.
name|negateNullSafe
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
specifier|static
name|RexNode
name|invert
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexCall
name|call
parameter_list|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
case|case
name|NOT_EQUALS
case|:
case|case
name|LESS_THAN
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
specifier|final
name|SqlOperator
name|op
init|=
name|op
argument_list|(
name|call
operator|.
name|getKind
argument_list|()
operator|.
name|reverse
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|,
name|Lists
operator|.
name|reverse
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Simplifies OR(x, x) into x, and similar. */
specifier|public
specifier|static
name|RexNode
name|simplifyOr
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexCall
name|call
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|OR
assert|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|terms
init|=
name|RelOptUtil
operator|.
name|disjunctions
argument_list|(
name|call
argument_list|)
decl_stmt|;
return|return
name|simplifyOrs
argument_list|(
name|rexBuilder
argument_list|,
name|terms
argument_list|)
return|;
block|}
comment|/** Simplifies a list of terms and combines them into an OR.    * Modifies the list in place. */
specifier|public
specifier|static
name|RexNode
name|simplifyOrs
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|terms
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|terms
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexNode
name|term
init|=
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|terms
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|term
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LITERAL
case|:
if|if
condition|(
operator|!
name|RexLiteral
operator|.
name|isNullLiteral
argument_list|(
name|term
argument_list|)
condition|)
block|{
if|if
condition|(
name|RexLiteral
operator|.
name|booleanValue
argument_list|(
name|term
argument_list|)
condition|)
block|{
return|return
name|term
return|;
comment|// true
block|}
else|else
block|{
name|terms
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|terms
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
return|return
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|terms
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Creates the expression {@code e1 AND NOT notTerm1 AND NOT notTerm2 ...}.    */
specifier|public
specifier|static
name|RexNode
name|andNot
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e
parameter_list|,
name|RexNode
modifier|...
name|notTerms
parameter_list|)
block|{
return|return
name|andNot
argument_list|(
name|rexBuilder
argument_list|,
name|e
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|notTerms
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates the expression {@code e1 AND NOT notTerm1 AND NOT notTerm2 ...}.    *    *<p>Examples:    *<ul>    *<li>andNot(p) returns "p"    *<li>andNot(p, n1, n2) returns "p AND NOT n1 AND NOT n2"    *<li>andNot(x = 10, x = 20, y = 30, x = 30)    *       returns "x = 10 AND NOT (y = 30)"    *</ul>    */
specifier|public
specifier|static
name|RexNode
name|andNot
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|notTerms
parameter_list|)
block|{
comment|// If "e" is of the form "x = literal", remove all "x = otherLiteral"
comment|// terms from notTerms.
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|e
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexLiteral
condition|)
block|{
name|notTerms
operator|=
name|Iterables
operator|.
name|filter
argument_list|(
name|notTerms
argument_list|,
operator|new
name|PredicateImpl
argument_list|<
name|RexNode
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|test
parameter_list|(
name|RexNode
name|input
parameter_list|)
block|{
switch|switch
condition|(
name|input
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
name|RexCall
name|call2
init|=
operator|(
name|RexCall
operator|)
name|input
decl_stmt|;
if|if
condition|(
name|call2
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equals
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|call2
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexLiteral
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|Iterables
operator|.
name|concat
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|e
argument_list|)
argument_list|,
name|Iterables
operator|.
name|transform
argument_list|(
name|notTerms
argument_list|,
name|notFn
argument_list|(
name|rexBuilder
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Returns whether a given operand of a CASE expression is a predicate.    *    *<p>A switched case (CASE x WHEN x1 THEN v1 ... ELSE e END) has an even    * number of arguments and odd-numbered arguments are predicates.    *    *<p>A condition case (CASE WHEN p1 THEN v1 ... ELSE e END) has an odd    * number of arguments and even-numbered arguments are predicates, except for    * the last argument. */
specifier|public
specifier|static
name|boolean
name|isCasePredicate
parameter_list|(
name|RexCall
name|call
parameter_list|,
name|int
name|i
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CASE
assert|;
return|return
name|i
operator|<
name|call
operator|.
name|operands
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|&&
operator|(
name|call
operator|.
name|operands
operator|.
name|size
argument_list|()
operator|-
name|i
operator|)
operator|%
literal|2
operator|==
literal|1
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|simplifyCast
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexCall
name|e
parameter_list|,
name|RexExecutor
name|executor
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|executor
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|operand
init|=
name|e
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|operand
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LITERAL
case|:
specifier|final
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|operand
decl_stmt|;
specifier|final
name|Comparable
name|value
init|=
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|SqlTypeName
name|typeName
init|=
name|literal
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
comment|// First, try to remove the cast without changing the value.
comment|// makeCast and canRemoveCastFromLiteral have the same logic, so we are
comment|// sure to be able to remove the cast.
if|if
condition|(
name|rexBuilder
operator|.
name|canRemoveCastFromLiteral
argument_list|(
name|e
operator|.
name|getType
argument_list|()
argument_list|,
name|value
argument_list|,
name|typeName
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|e
operator|.
name|getType
argument_list|()
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|// Next, try to convert the value to a different type,
comment|// e.g. CAST('123' as integer)
switch|switch
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
condition|)
block|{
case|case
name|TIME
case|:
switch|switch
condition|(
name|e
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|TIMESTAMP
case|:
return|return
name|e
return|;
block|}
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|reducedValues
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|executor
operator|.
name|reduce
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RexNode
operator|>
name|of
argument_list|(
name|e
argument_list|)
argument_list|,
name|reducedValues
argument_list|)
expr_stmt|;
return|return
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|reducedValues
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|e
return|;
block|}
block|}
comment|/** Returns a function that applies NOT to its argument. */
specifier|public
specifier|static
name|Function
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|notFn
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
return|return
operator|new
name|Function
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
specifier|public
name|RexNode
name|apply
parameter_list|(
name|RexNode
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|isAlwaysTrue
argument_list|()
condition|?
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
else|:
name|input
operator|.
name|isAlwaysFalse
argument_list|()
condition|?
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
else|:
name|input
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|NOT
condition|?
operator|(
operator|(
name|RexCall
operator|)
name|input
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
else|:
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|input
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Returns whether an expression contains a {@link RexCorrelVariable}. */
specifier|public
specifier|static
name|boolean
name|containsCorrelation
parameter_list|(
name|RexNode
name|condition
parameter_list|)
block|{
try|try
block|{
name|condition
operator|.
name|accept
argument_list|(
name|CorrelationFinder
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Walks over expressions and builds a bank of common sub-expressions.    */
specifier|private
specifier|static
class|class
name|ExpressionNormalizer
extends|extends
name|RexVisitorImpl
argument_list|<
name|RexNode
argument_list|>
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|mapDigestToExpr
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|allowDups
decl_stmt|;
specifier|protected
name|ExpressionNormalizer
parameter_list|(
name|boolean
name|allowDups
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|allowDups
operator|=
name|allowDups
expr_stmt|;
block|}
specifier|protected
name|RexNode
name|register
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
specifier|final
name|String
name|key
init|=
name|expr
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|previous
init|=
name|mapDigestToExpr
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowDups
operator|&&
operator|(
name|previous
operator|!=
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|SubExprExistsException
argument_list|(
name|expr
argument_list|)
throw|;
block|}
return|return
name|expr
return|;
block|}
specifier|protected
name|RexNode
name|lookup
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
return|return
name|mapDigestToExpr
operator|.
name|get
argument_list|(
name|expr
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
return|return
name|register
argument_list|(
name|inputRef
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
return|return
name|register
argument_list|(
name|literal
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|correlVariable
parameter_list|)
block|{
return|return
name|register
argument_list|(
name|correlVariable
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|normalizedOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|diffCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|operand
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|normalizedOperand
init|=
name|lookup
argument_list|(
name|operand
argument_list|)
decl_stmt|;
name|normalizedOperands
operator|.
name|add
argument_list|(
name|normalizedOperand
argument_list|)
expr_stmt|;
if|if
condition|(
name|normalizedOperand
operator|!=
name|operand
condition|)
block|{
operator|++
name|diffCount
expr_stmt|;
block|}
block|}
if|if
condition|(
name|diffCount
operator|>
literal|0
condition|)
block|{
name|call
operator|=
name|call
operator|.
name|clone
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|normalizedOperands
argument_list|)
expr_stmt|;
block|}
return|return
name|register
argument_list|(
name|call
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitDynamicParam
parameter_list|(
name|RexDynamicParam
name|dynamicParam
parameter_list|)
block|{
return|return
name|register
argument_list|(
name|dynamicParam
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitRangeRef
parameter_list|(
name|RexRangeRef
name|rangeRef
parameter_list|)
block|{
return|return
name|register
argument_list|(
name|rangeRef
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
decl_stmt|;
name|expr
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|normalizedExpr
init|=
name|lookup
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|normalizedExpr
operator|!=
name|expr
condition|)
block|{
name|fieldAccess
operator|=
operator|new
name|RexFieldAccess
argument_list|(
name|normalizedExpr
argument_list|,
name|fieldAccess
operator|.
name|getField
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|register
argument_list|(
name|fieldAccess
argument_list|)
return|;
block|}
comment|/**      * Thrown if there is a sub-expression.      */
specifier|private
specifier|static
class|class
name|SubExprExistsException
extends|extends
name|ControlFlowException
block|{
name|SubExprExistsException
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
name|Util
operator|.
name|discard
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Walks over an expression and throws an exception if it finds an    * {@link RexInputRef} with an ordinal beyond the number of fields in the    * input row type, or a {@link RexLocalRef} with ordinal greater than that set    * using {@link #setLimit(int)}.    */
specifier|private
specifier|static
class|class
name|ForwardRefFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
name|int
name|limit
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|final
name|RelDataType
name|inputRowType
decl_stmt|;
specifier|public
name|ForwardRefFinder
parameter_list|(
name|RelDataType
name|inputRowType
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputRowType
operator|=
name|inputRowType
expr_stmt|;
block|}
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|super
operator|.
name|visitInputRef
argument_list|(
name|inputRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|>=
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalForwardRefException
argument_list|()
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|Void
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|inputRef
parameter_list|)
block|{
name|super
operator|.
name|visitLocalRef
argument_list|(
name|inputRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|>=
name|limit
condition|)
block|{
throw|throw
operator|new
name|IllegalForwardRefException
argument_list|()
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|void
name|setLimit
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
name|this
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
block|}
comment|/** Thrown to abort a visit when we find an illegal forward reference.      * It changes control flow but is not considered an error. */
specifier|static
class|class
name|IllegalForwardRefException
extends|extends
name|ControlFlowException
block|{     }
block|}
comment|/**    * Visitor which builds a bitmap of the inputs used by an expression.    */
specifier|public
specifier|static
class|class
name|FieldAccessFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|RexFieldAccess
argument_list|>
name|fieldAccessList
decl_stmt|;
specifier|public
name|FieldAccessFinder
parameter_list|()
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|fieldAccessList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
specifier|public
name|Void
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
name|fieldAccessList
operator|.
name|add
argument_list|(
name|fieldAccess
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|operands
control|)
block|{
name|operand
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|List
argument_list|<
name|RexFieldAccess
argument_list|>
name|getFieldAccessList
parameter_list|()
block|{
return|return
name|fieldAccessList
return|;
block|}
block|}
comment|/** Helps {@link org.apache.calcite.rex.RexUtil#toCnf}. */
specifier|private
specifier|static
class|class
name|CnfHelper
block|{
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
name|int
name|currentCount
decl_stmt|;
specifier|final
name|int
name|maxNodeCount
decl_stmt|;
comment|// negative means no limit
specifier|private
name|CnfHelper
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|int
name|maxNodeCount
parameter_list|)
block|{
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
name|this
operator|.
name|maxNodeCount
operator|=
name|maxNodeCount
expr_stmt|;
block|}
specifier|public
name|RexNode
name|toCnf
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|currentCount
operator|=
literal|0
expr_stmt|;
return|return
name|toCnf2
argument_list|(
name|rex
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|OverflowError
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|rex
return|;
block|}
block|}
specifier|private
name|RexNode
name|toCnf2
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
decl_stmt|;
switch|switch
condition|(
name|rex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
name|incrementAndCheck
argument_list|()
expr_stmt|;
name|operands
operator|=
name|flattenAnd
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|cnfOperands
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|operands
control|)
block|{
name|RexNode
name|cnf
init|=
name|toCnf2
argument_list|(
name|node
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cnf
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
name|incrementAndCheck
argument_list|()
expr_stmt|;
name|cnfOperands
operator|.
name|addAll
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|cnf
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|incrementAndCheck
argument_list|()
expr_stmt|;
name|cnfOperands
operator|.
name|add
argument_list|(
name|cnf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|and
argument_list|(
name|cnfOperands
argument_list|)
return|;
case|case
name|OR
case|:
name|incrementAndCheck
argument_list|()
expr_stmt|;
name|operands
operator|=
name|flattenOr
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|head
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|headCnf
init|=
name|toCnf2
argument_list|(
name|head
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|headCnfs
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|headCnf
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|tail
init|=
name|or
argument_list|(
name|Util
operator|.
name|skip
argument_list|(
name|operands
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|tailCnf
init|=
name|toCnf2
argument_list|(
name|tail
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|tailCnfs
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|tailCnf
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|h
range|:
name|headCnfs
control|)
block|{
for|for
control|(
name|RexNode
name|t
range|:
name|tailCnfs
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|or
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|h
argument_list|,
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|and
argument_list|(
name|list
argument_list|)
return|;
case|case
name|NOT
case|:
specifier|final
name|RexNode
name|arg
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|arg
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|NOT
case|:
return|return
name|toCnf2
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|arg
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|OR
case|:
name|operands
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|arg
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
return|return
name|toCnf2
argument_list|(
name|and
argument_list|(
name|Lists
operator|.
name|transform
argument_list|(
name|flattenOr
argument_list|(
name|operands
argument_list|)
argument_list|,
name|ADD_NOT
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|AND
case|:
name|operands
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|arg
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
return|return
name|toCnf2
argument_list|(
name|or
argument_list|(
name|Lists
operator|.
name|transform
argument_list|(
name|flattenAnd
argument_list|(
name|operands
argument_list|)
argument_list|,
name|ADD_NOT
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|incrementAndCheck
argument_list|()
expr_stmt|;
return|return
name|rex
return|;
block|}
default|default:
name|incrementAndCheck
argument_list|()
expr_stmt|;
return|return
name|rex
return|;
block|}
block|}
specifier|private
name|void
name|incrementAndCheck
parameter_list|()
block|{
if|if
condition|(
name|maxNodeCount
operator|>=
literal|0
operator|&&
operator|++
name|currentCount
operator|>
name|maxNodeCount
condition|)
block|{
throw|throw
name|OverflowError
operator|.
name|INSTANCE
throw|;
block|}
block|}
comment|/** Exception to catch when we pass the limit. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|private
specifier|static
class|class
name|OverflowError
extends|extends
name|ControlFlowException
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ThrowableInstanceNeverThrown"
argument_list|)
specifier|protected
specifier|static
specifier|final
name|OverflowError
name|INSTANCE
init|=
operator|new
name|OverflowError
argument_list|()
decl_stmt|;
specifier|private
name|OverflowError
parameter_list|()
block|{
block|}
block|}
specifier|private
name|RexNode
name|pull
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
decl_stmt|;
switch|switch
condition|(
name|rex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
name|operands
operator|=
name|flattenAnd
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|and
argument_list|(
name|pullList
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
case|case
name|OR
case|:
name|operands
operator|=
name|flattenOr
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|factors
init|=
name|commonFactors
argument_list|(
name|operands
argument_list|)
decl_stmt|;
if|if
condition|(
name|factors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|or
argument_list|(
name|operands
argument_list|)
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|operands
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|removeFactor
argument_list|(
name|factors
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|and
argument_list|(
name|Iterables
operator|.
name|concat
argument_list|(
name|factors
operator|.
name|values
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|or
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|rex
return|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|pullList
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
name|RexNode
name|pulled
init|=
name|pull
argument_list|(
name|node
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|pulled
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
name|list
operator|.
name|addAll
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|pulled
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|list
operator|.
name|add
argument_list|(
name|pulled
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|commonFactors
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|i
operator|++
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|RexNode
name|conjunction
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|node
argument_list|)
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|conjunction
operator|.
name|toString
argument_list|()
argument_list|,
name|conjunction
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|retainAll
argument_list|(
name|strings
argument_list|(
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
return|;
block|}
specifier|private
name|RexNode
name|removeFactor
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|factors
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|node
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|factors
operator|.
name|containsKey
argument_list|(
name|operand
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|and
argument_list|(
name|list
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|and
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|or
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
comment|/** Transforms a list of expressions to the list of digests. */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|strings
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
name|list
argument_list|,
name|TO_STRING
argument_list|)
return|;
block|}
comment|/** Helps {@link org.apache.calcite.rex.RexUtil#toDnf}. */
specifier|private
specifier|static
class|class
name|DnfHelper
block|{
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|private
name|DnfHelper
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
block|}
specifier|public
name|RexNode
name|toDnf
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
decl_stmt|;
switch|switch
condition|(
name|rex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
name|operands
operator|=
name|flattenAnd
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|head
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|headDnf
init|=
name|toDnf
argument_list|(
name|head
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|headDnfs
init|=
name|RelOptUtil
operator|.
name|disjunctions
argument_list|(
name|headDnf
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|tail
init|=
name|and
argument_list|(
name|Util
operator|.
name|skip
argument_list|(
name|operands
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|tailDnf
init|=
name|toDnf
argument_list|(
name|tail
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|tailDnfs
init|=
name|RelOptUtil
operator|.
name|disjunctions
argument_list|(
name|tailDnf
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|h
range|:
name|headDnfs
control|)
block|{
for|for
control|(
name|RexNode
name|t
range|:
name|tailDnfs
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|and
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|h
argument_list|,
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|or
argument_list|(
name|list
argument_list|)
return|;
case|case
name|OR
case|:
name|operands
operator|=
name|flattenOr
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|or
argument_list|(
name|toDnfs
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
case|case
name|NOT
case|:
specifier|final
name|RexNode
name|arg
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|arg
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|NOT
case|:
return|return
name|toDnf
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|arg
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|OR
case|:
name|operands
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|arg
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
return|return
name|toDnf
argument_list|(
name|and
argument_list|(
name|Lists
operator|.
name|transform
argument_list|(
name|flattenOr
argument_list|(
name|operands
argument_list|)
argument_list|,
name|ADD_NOT
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|AND
case|:
name|operands
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|arg
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
return|return
name|toDnf
argument_list|(
name|or
argument_list|(
name|Lists
operator|.
name|transform
argument_list|(
name|flattenAnd
argument_list|(
name|operands
argument_list|)
argument_list|,
name|ADD_NOT
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|rex
return|;
block|}
default|default:
return|return
name|rex
return|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|toDnfs
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
name|RexNode
name|dnf
init|=
name|toDnf
argument_list|(
name|node
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|dnf
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|OR
case|:
name|list
operator|.
name|addAll
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|dnf
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|list
operator|.
name|add
argument_list|(
name|dnf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
specifier|private
name|RexNode
name|and
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|or
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
comment|/** Shuttle that adds {@code offset} to each {@link RexInputRef} in an    * expression. */
specifier|private
specifier|static
class|class
name|RexShiftShuttle
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|int
name|offset
decl_stmt|;
specifier|public
name|RexShiftShuttle
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|input
parameter_list|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|input
operator|.
name|getIndex
argument_list|()
operator|+
name|offset
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Visitor that throws {@link org.apache.calcite.util.Util.FoundOne} if    * applied to an expression that contains a {@link RexCorrelVariable}. */
specifier|private
specifier|static
class|class
name|CorrelationFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|static
specifier|final
name|CorrelationFinder
name|INSTANCE
init|=
operator|new
name|CorrelationFinder
argument_list|()
decl_stmt|;
specifier|private
name|CorrelationFinder
parameter_list|()
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|var
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
block|}
comment|/** Shuttle that fixes up an expression to match changes in nullability of    * input fields. */
specifier|public
specifier|static
class|class
name|FixNullabilityShuttle
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
decl_stmt|;
specifier|private
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|public
name|FixNullabilityShuttle
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
parameter_list|)
block|{
name|this
operator|.
name|typeList
operator|=
name|typeList
expr_stmt|;
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|ref
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rightType
init|=
name|typeList
operator|.
name|get
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|refType
init|=
name|ref
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|refType
operator|==
name|rightType
condition|)
block|{
return|return
name|ref
return|;
block|}
specifier|final
name|RelDataType
name|refType2
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|refType
argument_list|,
name|rightType
operator|.
name|isNullable
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|refType2
operator|==
name|rightType
condition|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|,
name|refType2
argument_list|)
return|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"mismatched type "
operator|+
name|ref
operator|+
literal|" "
operator|+
name|rightType
argument_list|)
throw|;
block|}
block|}
comment|/** Visitor that throws {@link org.apache.calcite.util.Util.FoundOne} if    * applied to an expression that contains a {@link RexSubQuery}. */
specifier|public
specifier|static
class|class
name|SubQueryFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|SubQueryFinder
name|INSTANCE
init|=
operator|new
name|SubQueryFinder
argument_list|()
decl_stmt|;
comment|/** Returns whether a {@link Project} contains a sub-query. */
specifier|public
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Project
argument_list|>
name|PROJECT_PREDICATE
init|=
operator|new
name|PredicateImpl
argument_list|<
name|Project
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|test
parameter_list|(
name|Project
name|project
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|node
range|:
name|project
operator|.
name|getProjects
argument_list|()
control|)
block|{
try|try
block|{
name|node
operator|.
name|accept
argument_list|(
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
comment|/** Returns whether a {@link Filter} contains a sub-query. */
specifier|public
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Filter
argument_list|>
name|FILTER_PREDICATE
init|=
operator|new
name|PredicateImpl
argument_list|<
name|Filter
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|test
parameter_list|(
name|Filter
name|filter
parameter_list|)
block|{
try|try
block|{
name|filter
operator|.
name|getCondition
argument_list|()
operator|.
name|accept
argument_list|(
name|INSTANCE
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
decl_stmt|;
comment|/** Returns whether a {@link Join} contains a sub-query. */
specifier|public
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Join
argument_list|>
name|JOIN_PREDICATE
init|=
operator|new
name|PredicateImpl
argument_list|<
name|Join
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|test
parameter_list|(
name|Join
name|join
parameter_list|)
block|{
try|try
block|{
name|join
operator|.
name|getCondition
argument_list|()
operator|.
name|accept
argument_list|(
name|INSTANCE
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
decl_stmt|;
specifier|private
name|SubQueryFinder
parameter_list|()
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitSubQuery
parameter_list|(
name|RexSubQuery
name|subQuery
parameter_list|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|subQuery
argument_list|)
throw|;
block|}
specifier|public
specifier|static
name|RexSubQuery
name|find
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
try|try
block|{
name|node
operator|.
name|accept
argument_list|(
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
operator|(
name|RexSubQuery
operator|)
name|e
operator|.
name|getNode
argument_list|()
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
specifier|static
name|RexSubQuery
name|find
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
try|try
block|{
name|node
operator|.
name|accept
argument_list|(
name|INSTANCE
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
operator|(
name|RexSubQuery
operator|)
name|e
operator|.
name|getNode
argument_list|()
return|;
block|}
block|}
block|}
comment|/** Deep expressions simplifier. */
specifier|public
specifier|static
class|class
name|ExprSimplifier
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|private
specifier|final
name|RexExecutor
name|executor
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|unknownAsFalse
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Boolean
argument_list|>
name|unknownAsFalseMap
decl_stmt|;
specifier|public
name|ExprSimplifier
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|boolean
name|unknownAsFalse
parameter_list|,
name|RexExecutor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|rexBuilder
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|rexBuilder
argument_list|)
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|executor
argument_list|)
expr_stmt|;
name|this
operator|.
name|unknownAsFalse
operator|=
name|unknownAsFalse
expr_stmt|;
name|this
operator|.
name|unknownAsFalseMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|Boolean
name|unknownAsFalseCall
init|=
name|unknownAsFalse
decl_stmt|;
if|if
condition|(
name|unknownAsFalseCall
condition|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
case|case
name|CASE
case|:
name|unknownAsFalseCall
operator|=
name|this
operator|.
name|unknownAsFalseMap
operator|.
name|get
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|unknownAsFalseCall
operator|==
literal|null
condition|)
block|{
comment|// Top operator
name|unknownAsFalseCall
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
name|unknownAsFalseCall
operator|=
literal|false
expr_stmt|;
block|}
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|operands
control|)
block|{
name|this
operator|.
name|unknownAsFalseMap
operator|.
name|put
argument_list|(
name|operand
argument_list|,
name|unknownAsFalseCall
argument_list|)
expr_stmt|;
block|}
block|}
name|RexNode
name|node
init|=
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|RexNode
name|simplifiedNode
init|=
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|node
argument_list|,
name|unknownAsFalseCall
argument_list|,
name|executor
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|simplifiedNode
condition|)
block|{
return|return
name|node
return|;
block|}
if|if
condition|(
name|simplifiedNode
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|simplifiedNode
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|simplifiedNode
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End RexUtil.java
end_comment

end_unit

