begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Predicate1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
operator|.
name|RelTableRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Schemas
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ControlFlowException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apiguardian
operator|.
name|api
operator|.
name|API
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_comment
comment|/**  * Utility methods concerning row-expressions.  */
end_comment

begin_class
specifier|public
class|class
name|RexUtil
block|{
comment|/** Executor for a bit of constant reduction. The user can pass in another executor. */
specifier|public
specifier|static
specifier|final
name|RexExecutor
name|EXECUTOR
init|=
operator|new
name|RexExecutorImpl
argument_list|(
name|Schemas
operator|.
name|createDataContext
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
name|RexUtil
parameter_list|()
block|{
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Returns a guess for the selectivity of an expression.    *    * @param exp expression of interest, or null for none (implying a    *            selectivity of 1.0)    * @return guessed selectivity    */
specifier|public
specifier|static
name|double
name|getSelectivity
parameter_list|(
name|RexNode
name|exp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|exp
operator|==
literal|null
operator|)
operator|||
name|exp
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return
literal|1d
return|;
block|}
return|return
literal|0.1d
return|;
block|}
comment|/**    * Generates a cast from one row type to another.    *    * @param rexBuilder RexBuilder to use for constructing casts    * @param lhsRowType target row type    * @param rhsRowType source row type; fields must be 1-to-1 with lhsRowType,    *                   in same order    * @return cast expressions    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|generateCastExpressions
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelDataType
name|lhsRowType
parameter_list|,
name|RelDataType
name|rhsRowType
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fieldList
init|=
name|rhsRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|fieldList
operator|.
name|size
argument_list|()
decl_stmt|;
assert|assert
name|n
operator|==
name|lhsRowType
operator|.
name|getFieldCount
argument_list|()
operator|:
literal|"field count: lhs ["
operator|+
name|lhsRowType
operator|+
literal|"] rhs ["
operator|+
name|rhsRowType
operator|+
literal|"]"
assert|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rhsExps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|fieldList
control|)
block|{
name|rhsExps
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|generateCastExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|lhsRowType
argument_list|,
name|rhsExps
argument_list|)
return|;
block|}
comment|/**    * Generates a cast for a row type.    *    * @param rexBuilder RexBuilder to use for constructing casts    * @param lhsRowType target row type    * @param rhsExps    expressions to be cast    * @return cast expressions    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|generateCastExpressions
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelDataType
name|lhsRowType
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rhsExps
parameter_list|)
block|{
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|lhsFields
init|=
name|lhsRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|castExps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RexNode
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|lhsFields
argument_list|,
name|rhsExps
argument_list|,
literal|true
argument_list|)
control|)
block|{
name|RelDataTypeField
name|lhsField
init|=
name|pair
operator|.
name|left
decl_stmt|;
name|RelDataType
name|lhsType
init|=
name|lhsField
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|rhsExp
init|=
name|pair
operator|.
name|right
decl_stmt|;
name|RelDataType
name|rhsType
init|=
name|rhsExp
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|lhsType
operator|.
name|equals
argument_list|(
name|rhsType
argument_list|)
condition|)
block|{
name|castExps
operator|.
name|add
argument_list|(
name|rhsExp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|castExps
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|lhsType
argument_list|,
name|rhsExp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|castExps
return|;
block|}
comment|/**    * Returns whether a node represents the NULL value.    *    *<p>Examples:    *    *<ul>    *<li>For {@link org.apache.calcite.rex.RexLiteral} Unknown, returns false.    *<li>For<code>CAST(NULL AS<i>type</i>)</code>, returns true if<code>    * allowCast</code> is true, false otherwise.    *<li>For<code>CAST(CAST(NULL AS<i>type</i>) AS<i>type</i>))</code>,    * returns false.    *</ul>    */
specifier|public
specifier|static
name|boolean
name|isNullLiteral
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|boolean
name|allowCast
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|RexLiteral
condition|)
block|{
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
condition|)
block|{
assert|assert
literal|null
operator|==
name|literal
operator|.
name|getValue
argument_list|()
assert|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// We don't regard UNKNOWN -- SqlLiteral(null,Boolean) -- as
comment|// NULL.
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|allowCast
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|isNullLiteral
argument_list|(
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// node is "CAST(NULL as type)"
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether a node represents the NULL value or a series of nested    * {@code CAST(NULL AS type)} calls. For example:    *<code>isNull(CAST(CAST(NULL as INTEGER) AS VARCHAR(1)))</code>    * returns {@code true}.    */
specifier|public
specifier|static
name|boolean
name|isNull
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
switch|switch
condition|(
name|expr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LITERAL
case|:
return|return
operator|(
operator|(
name|RexLiteral
operator|)
name|expr
operator|)
operator|.
name|getValue2
argument_list|()
operator|==
literal|null
return|;
case|case
name|CAST
case|:
return|return
name|isNull
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Returns whether a node represents a literal.    *    *<p>Examples:    *    *<ul>    *<li>For<code>CAST(literal AS<i>type</i>)</code>, returns true if<code>    * allowCast</code> is true, false otherwise.    *<li>For<code>CAST(CAST(literal AS<i>type</i>) AS<i>type</i>))</code>,    * returns false.    *</ul>    *    * @param node The node, never null.    * @param allowCast whether to regard CAST(literal) as a literal    * @return Whether the node is a literal    */
specifier|public
specifier|static
name|boolean
name|isLiteral
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|boolean
name|allowCast
parameter_list|)
block|{
assert|assert
name|node
operator|!=
literal|null
assert|;
if|if
condition|(
name|node
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|LITERAL
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|allowCast
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|isLiteral
argument_list|(
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// node is "CAST(literal as type)"
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether every expression in a list is a literal.    *    * @param expressionOperands list of expressions to check    * @return true if every expression from the specified list is literal.    */
specifier|public
specifier|static
name|boolean
name|allLiterals
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|expressionOperands
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|rexNode
range|:
name|expressionOperands
control|)
block|{
if|if
condition|(
operator|!
name|isLiteral
argument_list|(
name|rexNode
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether a node represents an input reference or field access.    *    * @param node The node, never null.    * @param allowCast whether to regard CAST(x) as true    * @return Whether the node is a reference or access    */
specifier|public
specifier|static
name|boolean
name|isReferenceOrAccess
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|boolean
name|allowCast
parameter_list|)
block|{
assert|assert
name|node
operator|!=
literal|null
assert|;
if|if
condition|(
name|node
operator|instanceof
name|RexInputRef
operator|||
name|node
operator|instanceof
name|RexFieldAccess
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|allowCast
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
return|return
name|isReferenceOrAccess
argument_list|(
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Returns whether an expression is a cast just for the purposes of    * nullability, not changing any other aspect of the type. */
specifier|public
specifier|static
name|boolean
name|isNullabilityCast
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CAST
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
specifier|final
name|RexNode
name|arg0
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|SqlTypeUtil
operator|.
name|equalSansNullability
argument_list|(
name|typeFactory
argument_list|,
name|arg0
operator|.
name|getType
argument_list|()
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Removes any casts that change nullability but not type.    *    *<p>For example, {@code CAST(1 = 0 AS BOOLEAN)} becomes {@code 1 = 0}. */
specifier|public
specifier|static
name|RexNode
name|removeNullabilityCast
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
while|while
condition|(
name|isNullabilityCast
argument_list|(
name|typeFactory
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|node
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
comment|/** Removes any casts.    *    *<p>For example, {@code CAST('1' AS INTEGER)} becomes {@code '1'}. */
specifier|public
specifier|static
name|RexNode
name|removeCast
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CAST
case|:
name|e
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|e
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|e
return|;
block|}
block|}
block|}
comment|/** Creates a map containing each (e, constant) pair that occurs within    * a predicate list.    *    * @param clazz Class of expression that is considered constant    * @param rexBuilder Rex builder    * @param predicates Predicate list    * @param<C> what to consider a constant: {@link RexLiteral} to use a narrow    *           definition of constant, or {@link RexNode} to use    *           {@link RexUtil#isConstant(RexNode)}    * @return Map from values to constants    */
specifier|public
specifier|static
parameter_list|<
name|C
extends|extends
name|RexNode
parameter_list|>
name|ImmutableMap
argument_list|<
name|RexNode
argument_list|,
name|C
argument_list|>
name|predicateConstants
parameter_list|(
name|Class
argument_list|<
name|C
argument_list|>
name|clazz
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|predicates
parameter_list|)
block|{
comment|// We cannot use an ImmutableMap.Builder here. If there are multiple entries
comment|// with the same key (e.g. "WHERE deptno = 1 AND deptno = 2"), it doesn't
comment|// matter which we take, so the latter will replace the former.
comment|// The basic idea is to find all the pairs of RexNode = RexLiteral
comment|// (1) If 'predicates' contain a non-EQUALS, we bail out.
comment|// (2) It is OK if a RexNode is equal to the same RexLiteral several times,
comment|// (e.g. "WHERE deptno = 1 AND deptno = 1")
comment|// (3) It will return false if there are inconsistent constraints (e.g.
comment|// "WHERE deptno = 1 AND deptno = 2")
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|C
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|excludeSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|predicate
range|:
name|predicates
control|)
block|{
name|gatherConstraints
argument_list|(
name|clazz
argument_list|,
name|predicate
argument_list|,
name|map
argument_list|,
name|excludeSet
argument_list|,
name|rexBuilder
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|,
name|C
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|RexNode
argument_list|,
name|C
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|RexNode
name|rexNode
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|overlap
argument_list|(
name|rexNode
argument_list|,
name|excludeSet
argument_list|)
condition|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|rexNode
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|boolean
name|overlap
parameter_list|(
name|RexNode
name|rexNode
parameter_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
name|set
parameter_list|)
block|{
if|if
condition|(
name|rexNode
operator|instanceof
name|RexCall
condition|)
block|{
for|for
control|(
name|RexNode
name|r
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexNode
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
if|if
condition|(
name|overlap
argument_list|(
name|r
argument_list|,
name|set
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|set
operator|.
name|contains
argument_list|(
name|rexNode
argument_list|)
return|;
block|}
block|}
comment|/** Tries to decompose the RexNode which is a RexCall into non-literal    * RexNodes. */
specifier|private
specifier|static
name|void
name|decompose
parameter_list|(
name|Set
argument_list|<
name|RexNode
argument_list|>
name|set
parameter_list|,
name|RexNode
name|rexNode
parameter_list|)
block|{
if|if
condition|(
name|rexNode
operator|instanceof
name|RexCall
condition|)
block|{
for|for
control|(
name|RexNode
name|r
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexNode
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|decompose
argument_list|(
name|set
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
operator|!
operator|(
name|rexNode
operator|instanceof
name|RexLiteral
operator|)
condition|)
block|{
name|set
operator|.
name|add
argument_list|(
name|rexNode
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|C
extends|extends
name|RexNode
parameter_list|>
name|void
name|gatherConstraints
parameter_list|(
name|Class
argument_list|<
name|C
argument_list|>
name|clazz
parameter_list|,
name|RexNode
name|predicate
parameter_list|,
name|Map
argument_list|<
name|RexNode
argument_list|,
name|C
argument_list|>
name|map
parameter_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
name|excludeSet
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
if|if
condition|(
name|predicate
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|EQUALS
operator|&&
name|predicate
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|IS_NULL
condition|)
block|{
name|decompose
argument_list|(
name|excludeSet
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|predicate
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|left
decl_stmt|;
specifier|final
name|RexNode
name|right
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
name|left
operator|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// is null
name|left
operator|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|left
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
comment|// There's no sense in inferring $0=null when $0 is not nullable
return|return;
block|}
name|right
operator|=
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|left
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Note that literals are immutable too, and they can only be compared
comment|// through values.
name|gatherConstraint
argument_list|(
name|clazz
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|map
argument_list|,
name|excludeSet
argument_list|,
name|rexBuilder
argument_list|)
expr_stmt|;
name|gatherConstraint
argument_list|(
name|clazz
argument_list|,
name|right
argument_list|,
name|left
argument_list|,
name|map
argument_list|,
name|excludeSet
argument_list|,
name|rexBuilder
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
parameter_list|<
name|C
extends|extends
name|RexNode
parameter_list|>
name|void
name|gatherConstraint
parameter_list|(
name|Class
argument_list|<
name|C
argument_list|>
name|clazz
parameter_list|,
name|RexNode
name|left
parameter_list|,
name|RexNode
name|right
parameter_list|,
name|Map
argument_list|<
name|RexNode
argument_list|,
name|C
argument_list|>
name|map
parameter_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
name|excludeSet
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
if|if
condition|(
operator|!
name|clazz
operator|.
name|isInstance
argument_list|(
name|right
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|isConstant
argument_list|(
name|right
argument_list|)
condition|)
block|{
return|return;
block|}
name|C
name|constant
init|=
name|clazz
operator|.
name|cast
argument_list|(
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|excludeSet
operator|.
name|contains
argument_list|(
name|left
argument_list|)
condition|)
block|{
return|return;
block|}
specifier|final
name|C
name|existedValue
init|=
name|map
operator|.
name|get
argument_list|(
name|left
argument_list|)
decl_stmt|;
if|if
condition|(
name|existedValue
operator|==
literal|null
condition|)
block|{
switch|switch
condition|(
name|left
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CAST
case|:
comment|// Convert "CAST(c) = literal" to "c = literal", as long as it is a
comment|// widening cast.
specifier|final
name|RexNode
name|operand
init|=
operator|(
operator|(
name|RexCall
operator|)
name|left
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|canAssignFrom
argument_list|(
name|left
operator|.
name|getType
argument_list|()
argument_list|,
name|operand
operator|.
name|getType
argument_list|()
argument_list|,
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
condition|)
block|{
specifier|final
name|RexNode
name|castRight
init|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|operand
operator|.
name|getType
argument_list|()
argument_list|,
name|constant
argument_list|)
decl_stmt|;
if|if
condition|(
name|castRight
operator|instanceof
name|RexLiteral
condition|)
block|{
name|left
operator|=
name|operand
expr_stmt|;
name|constant
operator|=
name|clazz
operator|.
name|cast
argument_list|(
name|castRight
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|map
operator|.
name|put
argument_list|(
name|left
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|existedValue
operator|instanceof
name|RexLiteral
operator|&&
name|constant
operator|instanceof
name|RexLiteral
operator|&&
operator|!
name|Objects
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|RexLiteral
operator|)
name|existedValue
operator|)
operator|.
name|getValue
argument_list|()
argument_list|,
operator|(
operator|(
name|RexLiteral
operator|)
name|constant
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
comment|// we found conflicting values, e.g. left = 10 and left = 20
name|map
operator|.
name|remove
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|excludeSet
operator|.
name|add
argument_list|(
name|left
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Returns whether a value of {@code type2} can be assigned to a variable    * of {@code type1}.    *    *<p>For example:    *<ul>    *<li>{@code canAssignFrom(BIGINT, TINYINT)} returns {@code true}</li>    *<li>{@code canAssignFrom(TINYINT, BIGINT)} returns {@code false}</li>    *<li>{@code canAssignFrom(BIGINT, VARCHAR)} returns {@code false}</li>    *</ul>    */
specifier|private
specifier|static
name|boolean
name|canAssignFrom
parameter_list|(
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
specifier|final
name|SqlTypeName
name|name1
init|=
name|type1
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
specifier|final
name|SqlTypeName
name|name2
init|=
name|type2
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name1
operator|.
name|getFamily
argument_list|()
operator|==
name|name2
operator|.
name|getFamily
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|name1
operator|.
name|getFamily
argument_list|()
condition|)
block|{
case|case
name|NUMERIC
case|:
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|int
name|precision1
decl_stmt|;
name|int
name|scale1
decl_stmt|;
if|if
condition|(
name|name1
operator|==
name|SqlTypeName
operator|.
name|DECIMAL
condition|)
block|{
name|type1
operator|=
name|typeFactory
operator|.
name|decimalOf
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|precision1
operator|=
name|type1
operator|.
name|getPrecision
argument_list|()
expr_stmt|;
name|scale1
operator|=
name|type1
operator|.
name|getScale
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|precision1
operator|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|getMaxPrecision
argument_list|(
name|name1
argument_list|)
expr_stmt|;
name|scale1
operator|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|getMaxScale
argument_list|(
name|name1
argument_list|)
expr_stmt|;
block|}
name|int
name|precision2
decl_stmt|;
name|int
name|scale2
decl_stmt|;
if|if
condition|(
name|name2
operator|==
name|SqlTypeName
operator|.
name|DECIMAL
condition|)
block|{
name|type2
operator|=
name|typeFactory
operator|.
name|decimalOf
argument_list|(
name|type2
argument_list|)
expr_stmt|;
name|precision2
operator|=
name|type2
operator|.
name|getPrecision
argument_list|()
expr_stmt|;
name|scale2
operator|=
name|type2
operator|.
name|getScale
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|precision2
operator|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|getMaxPrecision
argument_list|(
name|name2
argument_list|)
expr_stmt|;
name|scale2
operator|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|getMaxScale
argument_list|(
name|name2
argument_list|)
expr_stmt|;
block|}
return|return
name|precision1
operator|>=
name|precision2
operator|&&
name|scale1
operator|>=
name|scale2
return|;
block|}
if|else if
condition|(
name|SqlTypeUtil
operator|.
name|isApproximateNumeric
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isApproximateNumeric
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
name|type1
operator|.
name|getPrecision
argument_list|()
operator|>=
name|type2
operator|.
name|getPrecision
argument_list|()
operator|&&
name|type1
operator|.
name|getScale
argument_list|()
operator|>=
name|type2
operator|.
name|getScale
argument_list|()
return|;
block|}
break|break;
default|default:
comment|// getPrecision() will return:
comment|// - number of decimal digits for fractional seconds for datetime types
comment|// - length in characters for character types
comment|// - length in bytes for binary types
comment|// - RelDataType.PRECISION_NOT_SPECIFIED (-1) if not applicable for this type
return|return
name|type1
operator|.
name|getPrecision
argument_list|()
operator|>=
name|type2
operator|.
name|getPrecision
argument_list|()
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Returns the number of nodes (including leaves) in a list of    * expressions.    *    * @see RexNode#nodeCount() */
specifier|public
specifier|static
name|int
name|nodeCount
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|nodeCount
argument_list|(
literal|0
argument_list|,
name|nodes
argument_list|)
return|;
block|}
specifier|static
name|int
name|nodeCount
parameter_list|(
name|int
name|n
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|nodes
control|)
block|{
name|n
operator|+=
name|operand
operator|.
name|nodeCount
argument_list|()
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
comment|/** Returns a visitor that finds nodes of a given {@link SqlKind}. */
specifier|public
specifier|static
name|RexFinder
name|find
parameter_list|(
specifier|final
name|SqlKind
name|kind
parameter_list|)
block|{
return|return
operator|new
name|RexFinder
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|kind
condition|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Returns a visitor that finds nodes of given {@link SqlKind}s. */
specifier|public
specifier|static
name|RexFinder
name|find
parameter_list|(
specifier|final
name|Set
argument_list|<
name|SqlKind
argument_list|>
name|kinds
parameter_list|)
block|{
return|return
operator|new
name|RexFinder
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|kinds
operator|.
name|contains
argument_list|(
name|call
operator|.
name|getKind
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Returns a visitor that finds a particular {@link RexInputRef}. */
specifier|public
specifier|static
name|RexFinder
name|find
parameter_list|(
specifier|final
name|RexInputRef
name|ref
parameter_list|)
block|{
return|return
operator|new
name|RexFinder
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
if|if
condition|(
name|ref
operator|.
name|equals
argument_list|(
name|inputRef
argument_list|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
return|return
name|super
operator|.
name|visitInputRef
argument_list|(
name|inputRef
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Walks over an expression and determines whether it is constant.    */
specifier|static
class|class
name|ConstantFinder
implements|implements
name|RexVisitor
argument_list|<
name|Boolean
argument_list|>
block|{
specifier|static
specifier|final
name|ConstantFinder
name|INSTANCE
init|=
operator|new
name|ConstantFinder
argument_list|()
decl_stmt|;
specifier|public
name|Boolean
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|Boolean
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitOver
parameter_list|(
name|RexOver
name|over
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitSubQuery
parameter_list|(
name|RexSubQuery
name|subQuery
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitTableInputRef
parameter_list|(
name|RexTableInputRef
name|ref
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitPatternFieldRef
parameter_list|(
name|RexPatternFieldRef
name|fieldRef
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|correlVariable
parameter_list|)
block|{
comment|// Correlating variables change when there is an internal restart.
comment|// Not good enough for our purposes.
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitDynamicParam
parameter_list|(
name|RexDynamicParam
name|dynamicParam
parameter_list|)
block|{
comment|// Dynamic parameters are constant WITHIN AN EXECUTION, so that's
comment|// good enough.
return|return
literal|true
return|;
block|}
specifier|public
name|Boolean
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
comment|// Constant if operator meets the following conditions:
comment|// 1. It is deterministic;
comment|// 2. All its operands are constant.
return|return
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|isDeterministic
argument_list|()
operator|&&
name|RexVisitorImpl
operator|.
name|visitArrayAnd
argument_list|(
name|this
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|Boolean
name|visitRangeRef
parameter_list|(
name|RexRangeRef
name|rangeRef
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
comment|// "<expr>.FIELD" is constant iff "<expr>" is constant.
return|return
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns whether node is made up of constants.    *    * @param node Node to inspect    * @return true if node is made up of constants, false otherwise    */
specifier|public
specifier|static
name|boolean
name|isConstant
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|node
operator|.
name|accept
argument_list|(
name|ConstantFinder
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
comment|/**    * Returns whether a given expression is deterministic.    *    * @param e Expression    * @return true if tree result is deterministic, false otherwise    */
specifier|public
specifier|static
name|boolean
name|isDeterministic
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
try|try
block|{
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
init|=
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
operator|!
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|isDeterministic
argument_list|()
condition|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|e
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|ex
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|retainDeterministic
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|conjuctions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|x
range|:
name|list
control|)
block|{
if|if
condition|(
name|isDeterministic
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|conjuctions
operator|.
name|add
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|conjuctions
return|;
block|}
comment|/**    * Returns whether a given node contains a RexCall with a specified operator.    *    * @param operator Operator to look for    * @param node     a RexNode tree    */
specifier|public
specifier|static
name|RexCall
name|findOperatorCall
parameter_list|(
specifier|final
name|SqlOperator
name|operator
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
try|try
block|{
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
init|=
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|equals
argument_list|(
name|operator
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|call
argument_list|)
throw|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|node
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
operator|(
name|RexCall
operator|)
name|e
operator|.
name|getNode
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns whether a given tree contains any {link RexInputRef} nodes.    *    * @param node a RexNode tree    */
specifier|public
specifier|static
name|boolean
name|containsInputRef
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
try|try
block|{
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
init|=
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|inputRef
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
name|node
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Returns whether a given tree contains any    * {@link org.apache.calcite.rex.RexFieldAccess} nodes.    *    * @param node a RexNode tree    */
specifier|public
specifier|static
name|boolean
name|containsFieldAccess
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
try|try
block|{
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
init|=
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
specifier|public
name|Void
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|fieldAccess
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
name|node
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Determines whether a {@link RexCall} requires decimal expansion. It    * usually requires expansion if it has decimal operands.    *    *<p>Exceptions to this rule are:    *    *<ul>    *<li>isNull doesn't require expansion    *<li>It's okay to cast decimals to and from char types    *<li>It's okay to cast nulls as decimals    *<li>Casts require expansion if their return type is decimal    *<li>Reinterpret casts can handle a decimal operand    *</ul>    *    * @param expr    expression possibly in need of expansion    * @param recurse whether to check nested calls    * @return whether the expression requires expansion    */
specifier|public
specifier|static
name|boolean
name|requiresDecimalExpansion
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|boolean
name|recurse
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|expr
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|expr
decl_stmt|;
name|boolean
name|localCheck
init|=
literal|true
decl_stmt|;
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|REINTERPRET
case|:
case|case
name|IS_NULL
case|:
name|localCheck
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|CAST
case|:
name|RelDataType
name|lhsType
init|=
name|call
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|rhsType
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|rhsType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|lhsType
argument_list|)
operator|||
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|rhsType
argument_list|)
condition|)
block|{
name|localCheck
operator|=
literal|false
expr_stmt|;
block|}
if|else if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|lhsType
argument_list|)
operator|&&
operator|(
name|lhsType
operator|!=
name|rhsType
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
default|default:
name|localCheck
operator|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|requiresDecimalExpansion
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|localCheck
condition|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
comment|// NOTE jvs 27-Mar-2007: Depending on the type factory, the
comment|// result of a division may be decimal, even though both inputs
comment|// are integer.
return|return
literal|true
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|call
operator|.
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
name|recurse
operator|&&
name|requiresDecimalExpansion
argument_list|(
name|call
operator|.
name|operands
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Determines whether any operand of a set requires decimal expansion.    */
specifier|public
specifier|static
name|boolean
name|requiresDecimalExpansion
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|,
name|boolean
name|recurse
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|operands
control|)
block|{
if|if
condition|(
name|operand
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|operand
decl_stmt|;
if|if
condition|(
name|requiresDecimalExpansion
argument_list|(
name|call
argument_list|,
name|recurse
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether a {@link RexProgram} contains expressions which require    * decimal expansion.    */
specifier|public
specifier|static
name|boolean
name|requiresDecimalExpansion
parameter_list|(
name|RexProgram
name|program
parameter_list|,
name|boolean
name|recurse
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
name|program
operator|.
name|getExprList
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|exprList
control|)
block|{
if|if
condition|(
name|requiresDecimalExpansion
argument_list|(
name|expr
argument_list|,
name|recurse
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|boolean
name|canReinterpretOverflow
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|REINTERPRET
argument_list|)
operator|:
literal|"call is not a reinterpret"
assert|;
return|return
name|call
operator|.
name|operands
operator|.
name|size
argument_list|()
operator|>
literal|1
return|;
block|}
comment|/**    * Returns whether an array of expressions has any common sub-expressions.    */
specifier|public
specifier|static
name|boolean
name|containNoCommonExprs
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
specifier|final
name|ExpressionNormalizer
name|visitor
init|=
operator|new
name|ExpressionNormalizer
argument_list|(
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
try|try
block|{
name|expr
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExpressionNormalizer
operator|.
name|SubExprExistsException
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Returns whether an array of expressions contains no forward references.    * That is, if expression #i contains a {@link RexInputRef} referencing    * field i or greater.    *    * @param exprs        Array of expressions    * @param inputRowType Input row type    * @param litmus       What to do if an error is detected (there is a    *                     forward reference)    *    * @return Whether there is a forward reference    */
specifier|public
specifier|static
name|boolean
name|containNoForwardRefs
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
specifier|final
name|ForwardRefFinder
name|visitor
init|=
operator|new
name|ForwardRefFinder
argument_list|(
name|inputRowType
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|visitor
operator|.
name|setLimit
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// field cannot refer to self or later field
try|try
block|{
name|expr
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ForwardRefFinder
operator|.
name|IllegalForwardRefException
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"illegal forward reference in {}"
argument_list|,
name|expr
argument_list|)
return|;
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Returns whether an array of exp contains no aggregate function calls whose    * arguments are not {@link RexInputRef}s.    *    * @param exprs Expressions    * @param litmus  Whether to assert if there is such a function call    */
specifier|static
name|boolean
name|containNoNonTrivialAggs
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|rexCall
init|=
operator|(
name|RexCall
operator|)
name|expr
decl_stmt|;
if|if
condition|(
name|rexCall
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlAggFunction
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|rexCall
operator|.
name|operands
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|operand
operator|instanceof
name|RexLocalRef
operator|)
operator|&&
operator|!
operator|(
name|operand
operator|instanceof
name|RexLiteral
operator|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"contains non trivial agg: {}"
argument_list|,
name|operand
argument_list|)
return|;
block|}
block|}
block|}
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Returns whether a list of expressions contains complex expressions, that    * is, a call whose arguments are not {@link RexVariable} (or a subtype such    * as {@link RexInputRef}) or {@link RexLiteral}.    */
specifier|public
specifier|static
name|boolean
name|containComplexExprs
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|RexCall
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|operands
control|)
block|{
if|if
condition|(
operator|!
name|isAtomic
argument_list|(
name|operand
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether any of the given expression trees contains a    * {link RexTableInputRef} node.    *    * @param nodes a list of RexNode trees    * @return true if at least one was found, otherwise false    */
specifier|public
specifier|static
name|boolean
name|containsTableInputRef
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|e
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|containsTableInputRef
argument_list|(
name|e
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether a given tree contains any {link RexTableInputRef} nodes.    *    * @param node a RexNode tree    * @return first such node found or null if it there is no such node    */
specifier|public
specifier|static
name|RexTableInputRef
name|containsTableInputRef
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
try|try
block|{
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
init|=
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
specifier|public
name|Void
name|visitTableInputRef
parameter_list|(
name|RexTableInputRef
name|inputRef
parameter_list|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|inputRef
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
name|node
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
operator|(
name|RexTableInputRef
operator|)
name|e
operator|.
name|getNode
argument_list|()
return|;
block|}
block|}
specifier|public
specifier|static
name|boolean
name|isAtomic
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
return|return
operator|(
name|expr
operator|instanceof
name|RexLiteral
operator|)
operator|||
operator|(
name|expr
operator|instanceof
name|RexVariable
operator|)
return|;
block|}
comment|/**    * Returns whether a {@link RexNode node} is a {@link RexCall call} to a    * given {@link SqlOperator operator}.    */
specifier|public
specifier|static
name|boolean
name|isCallTo
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|SqlOperator
name|op
parameter_list|)
block|{
return|return
operator|(
name|expr
operator|instanceof
name|RexCall
operator|)
operator|&&
operator|(
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|op
operator|)
return|;
block|}
comment|/**    * Creates a record type with anonymous field names.    *    * @param typeFactory Type factory    * @param exprs       Expressions    * @return Record type    */
specifier|public
specifier|static
name|RelDataType
name|createStructType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|)
block|{
return|return
name|createStructType
argument_list|(
name|typeFactory
argument_list|,
name|exprs
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates a record type with specified field names.    *    *<p>The array of field names may be null, or any of the names within it    * can be null. We recommend using explicit names where possible, because it    * makes it much easier to figure out the intent of fields when looking at    * planner output.    *    * @param typeFactory Type factory    * @param exprs       Expressions    * @param names       Field names, may be null, or elements may be null    * @param suggester   Generates alternative names if {@code names} is not    *                    null and its elements are not unique    * @return Record type    */
specifier|public
specifier|static
name|RelDataType
name|createStructType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|,
name|SqlValidatorUtil
operator|.
name|Suggester
name|suggester
parameter_list|)
block|{
if|if
condition|(
name|names
operator|!=
literal|null
operator|&&
name|suggester
operator|!=
literal|null
condition|)
block|{
name|names
operator|=
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|names
argument_list|,
name|suggester
argument_list|,
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
operator|.
name|isSchemaCaseSensitive
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|builder
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
decl_stmt|;
if|if
condition|(
name|names
operator|==
literal|null
operator|||
operator|(
name|name
operator|=
name|names
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|name
operator|=
literal|"$f"
operator|+
name|i
expr_stmt|;
block|}
name|builder
operator|.
name|add
argument_list|(
name|name
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RelDataType
name|createStructType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
block|{
return|return
name|createStructType
argument_list|(
name|typeFactory
argument_list|,
name|exprs
argument_list|,
name|names
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns whether the type of an array of expressions is compatible with a    * struct type.    *    * @param exprs Array of expressions    * @param type  Type    * @param litmus What to do if an error is detected (there is a mismatch)    *    * @return Whether every expression has the same type as the corresponding    * member of the struct type    *    * @see RelOptUtil#eq(String, RelDataType, String, RelDataType, org.apache.calcite.util.Litmus)    */
specifier|public
specifier|static
name|boolean
name|compatibleTypes
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|type
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
if|if
condition|(
name|exprs
operator|.
name|size
argument_list|()
operator|!=
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"rowtype mismatches expressions"
argument_list|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataType
name|exprType
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|fieldType
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RelOptUtil
operator|.
name|eq
argument_list|(
literal|"type1"
argument_list|,
name|exprType
argument_list|,
literal|"type2"
argument_list|,
name|fieldType
argument_list|,
name|litmus
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/**    * Creates a key for {@link RexNode} which is the same as another key of    * another RexNode only if the two have both the same type and textual    * representation. For example, "10" integer and "10" bigint result in    * different keys.    */
specifier|public
specifier|static
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|makeKey
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|expr
argument_list|,
name|expr
operator|.
name|getType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns whether the leading edge of a given array of expressions is    * wholly {@link RexInputRef} objects with types corresponding to the    * underlying datatype.    */
specifier|public
specifier|static
name|boolean
name|containIdentity
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
if|if
condition|(
name|exprs
operator|.
name|size
argument_list|()
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"exprs/rowType length mismatch"
argument_list|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"expr[{}] is not a RexInputRef"
argument_list|,
name|i
argument_list|)
return|;
block|}
name|RexInputRef
name|inputRef
init|=
operator|(
name|RexInputRef
operator|)
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|!=
name|i
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"expr[{}] has ordinal {}"
argument_list|,
name|i
argument_list|,
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|RelOptUtil
operator|.
name|eq
argument_list|(
literal|"type1"
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
literal|"type2"
argument_list|,
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|litmus
argument_list|)
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
comment|/** Returns whether a list of expressions projects the incoming fields. */
specifier|public
specifier|static
name|boolean
name|isIdentity
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exps
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|)
block|{
return|return
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
operator|==
name|exps
operator|.
name|size
argument_list|()
operator|&&
name|containIdentity
argument_list|(
name|exps
argument_list|,
name|inputRowType
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
return|;
block|}
comment|/** As {@link #composeConjunction(RexBuilder, Iterable, boolean)} but never    * returns null. */
specifier|public
specifier|static
annotation|@
name|Nonnull
name|RexNode
name|composeConjunction
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|RexNode
name|e
init|=
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|/**    * Converts a collection of expressions into an AND.    * If there are zero expressions, returns TRUE.    * If there is one expression, returns just that expression.    * If any of the expressions are FALSE, returns FALSE.    * Removes expressions that always evaluate to TRUE.    * Returns null only if {@code nullOnEmpty} and expression is TRUE.    */
specifier|public
specifier|static
name|RexNode
name|composeConjunction
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|boolean
name|nullOnEmpty
parameter_list|)
block|{
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|flattenAnd
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
name|nullOnEmpty
condition|?
literal|null
else|:
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
default|default:
if|if
condition|(
name|containsFalse
argument_list|(
name|list
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|list
argument_list|)
return|;
block|}
block|}
comment|/** Flattens a list of AND nodes.    *    *<p>Treats null nodes as literal TRUE (i.e. ignores them). */
specifier|public
specifier|static
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|flattenAnd
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|instanceof
name|Collection
operator|&&
operator|(
operator|(
name|Collection
operator|)
name|nodes
operator|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Optimize common case
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// to eliminate duplicates
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|addAnd
argument_list|(
name|builder
argument_list|,
name|set
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|addAnd
parameter_list|(
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
parameter_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
name|digests
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|addAnd
argument_list|(
name|builder
argument_list|,
name|digests
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
if|if
condition|(
operator|!
name|node
operator|.
name|isAlwaysTrue
argument_list|()
operator|&&
name|digests
operator|.
name|add
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Converts a collection of expressions into an OR.    * If there are zero expressions, returns FALSE.    * If there is one expression, returns just that expression.    * If any of the expressions are TRUE, returns TRUE.    * Removes expressions that always evaluate to FALSE.    * Flattens expressions that are ORs.    */
annotation|@
name|Nonnull
specifier|public
specifier|static
name|RexNode
name|composeDisjunction
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|RexNode
name|e
init|=
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|/**    * Converts a collection of expressions into an OR,    * optionally returning null if the list is empty.    */
specifier|public
specifier|static
name|RexNode
name|composeDisjunction
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|boolean
name|nullOnEmpty
parameter_list|)
block|{
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|flattenOr
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
name|nullOnEmpty
condition|?
literal|null
else|:
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
default|default:
if|if
condition|(
name|containsTrue
argument_list|(
name|list
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|list
argument_list|)
return|;
block|}
block|}
comment|/** Flattens a list of OR nodes. */
specifier|public
specifier|static
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|flattenOr
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|instanceof
name|Collection
operator|&&
operator|(
operator|(
name|Collection
operator|)
name|nodes
operator|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Optimize common case
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// to eliminate duplicates
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
name|addOr
argument_list|(
name|builder
argument_list|,
name|set
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|addOr
parameter_list|(
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
parameter_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
name|set
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|OR
case|:
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|addOr
argument_list|(
name|builder
argument_list|,
name|set
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
if|if
condition|(
operator|!
name|node
operator|.
name|isAlwaysFalse
argument_list|()
operator|&&
name|set
operator|.
name|add
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Applies a mapping to a collation list.    *    * @param mapping       Mapping    * @param collationList Collation list    * @return collation list with mapping applied to each field    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelCollation
argument_list|>
name|apply
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|List
argument_list|<
name|RelCollation
argument_list|>
name|collationList
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelCollation
argument_list|>
name|newCollationList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelCollation
name|collation
range|:
name|collationList
control|)
block|{
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|newFieldCollationList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|fieldCollation
range|:
name|collation
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
specifier|final
name|RelFieldCollation
name|newFieldCollation
init|=
name|apply
argument_list|(
name|mapping
argument_list|,
name|fieldCollation
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFieldCollation
operator|==
literal|null
condition|)
block|{
comment|// This field is not mapped. Stop here. The leading edge
comment|// of the collation is still valid (although it's useless
comment|// if it's empty).
break|break;
block|}
name|newFieldCollationList
operator|.
name|add
argument_list|(
name|newFieldCollation
argument_list|)
expr_stmt|;
block|}
comment|// Truncation to collations to their leading edge creates empty
comment|// and duplicate collations. Ignore these.
if|if
condition|(
operator|!
name|newFieldCollationList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|RelCollation
name|newCollation
init|=
name|RelCollations
operator|.
name|of
argument_list|(
name|newFieldCollationList
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newCollationList
operator|.
name|contains
argument_list|(
name|newCollation
argument_list|)
condition|)
block|{
name|newCollationList
operator|.
name|add
argument_list|(
name|newCollation
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// REVIEW: There might be redundant collations in the list. For example,
comment|// in {(x), (x, y)}, (x) is redundant because it is a leading edge of
comment|// another collation in the list. Could remove redundant collations.
return|return
name|newCollationList
return|;
block|}
comment|/**    * Applies a mapping to a collation.    *    * @param mapping   Mapping    * @param collation Collation    * @return collation with mapping applied    */
specifier|public
specifier|static
name|RelCollation
name|apply
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|RelCollation
name|collation
parameter_list|)
block|{
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
name|applyFields
argument_list|(
name|mapping
argument_list|,
name|collation
operator|.
name|getFieldCollations
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|fieldCollations
operator|.
name|equals
argument_list|(
name|collation
operator|.
name|getFieldCollations
argument_list|()
argument_list|)
condition|?
name|collation
else|:
name|RelCollations
operator|.
name|of
argument_list|(
name|fieldCollations
argument_list|)
return|;
block|}
comment|/**    * Applies a mapping to a field collation.    *    *<p>If the field is not mapped, returns null.    *    * @param mapping        Mapping    * @param fieldCollation Field collation    * @return collation with mapping applied    */
specifier|public
specifier|static
name|RelFieldCollation
name|apply
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|RelFieldCollation
name|fieldCollation
parameter_list|)
block|{
specifier|final
name|int
name|target
init|=
name|mapping
operator|.
name|getTargetOpt
argument_list|(
name|fieldCollation
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|fieldCollation
operator|.
name|withFieldIndex
argument_list|(
name|target
argument_list|)
return|;
block|}
comment|/**    * Applies a mapping to a list of field collations.    *    * @param mapping         Mapping    * @param fieldCollations Field collations    * @return collations with mapping applied    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|applyFields
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|newFieldCollations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|fieldCollation
range|:
name|fieldCollations
control|)
block|{
name|RelFieldCollation
name|newFieldCollation
init|=
name|apply
argument_list|(
name|mapping
argument_list|,
name|fieldCollation
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFieldCollation
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|newFieldCollations
operator|.
name|add
argument_list|(
name|newFieldCollation
argument_list|)
expr_stmt|;
block|}
return|return
name|newFieldCollations
return|;
block|}
comment|/**    * Applies a mapping to an expression.    */
specifier|public
specifier|static
name|RexNode
name|apply
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|node
operator|.
name|accept
argument_list|(
name|RexPermuteInputsShuttle
operator|.
name|of
argument_list|(
name|mapping
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Applies a mapping to an iterable over expressions.    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|apply
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|RexPermuteInputsShuttle
operator|.
name|of
argument_list|(
name|mapping
argument_list|)
operator|.
name|visitList
argument_list|(
name|nodes
argument_list|)
return|;
block|}
comment|/**    * Applies a shuttle to an array of expressions. Creates a copy first.    *    * @param shuttle Shuttle    * @param exprs   Array of expressions    */
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|RexNode
parameter_list|>
name|T
index|[]
name|apply
parameter_list|(
name|RexVisitor
argument_list|<
name|T
argument_list|>
name|shuttle
parameter_list|,
name|T
index|[]
name|exprs
parameter_list|)
block|{
name|T
index|[]
name|newExprs
init|=
name|exprs
operator|.
name|clone
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newExprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|newExprs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|expr
operator|!=
literal|null
condition|)
block|{
name|newExprs
index|[
name|i
index|]
operator|=
name|expr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newExprs
return|;
block|}
comment|/**    * Applies a visitor to an array of expressions and, if specified, a single    * expression.    *    * @param visitor Visitor    * @param exprs   Array of expressions    * @param expr    Single expression, may be null    */
specifier|public
specifier|static
name|void
name|apply
parameter_list|(
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
parameter_list|,
name|RexNode
index|[]
name|exprs
parameter_list|,
name|RexNode
name|expr
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|e
range|:
name|exprs
control|)
block|{
name|e
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Applies a visitor to a list of expressions and, if specified, a single    * expression.    *    * @param visitor Visitor    * @param exprs   List of expressions    * @param expr    Single expression, may be null    */
specifier|public
specifier|static
name|void
name|apply
parameter_list|(
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|RexNode
name|expr
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|e
range|:
name|exprs
control|)
block|{
name|e
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Flattens an expression.    *    *<p>Returns the same expression if it is already flat. */
specifier|public
specifier|static
name|RexNode
name|flatten
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|flattenedOperands
init|=
name|flatten
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isFlat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|,
name|op
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|op
argument_list|,
name|flattenedOperands
argument_list|)
return|;
block|}
block|}
return|return
name|node
return|;
block|}
comment|/**    * Converts a list of operands into a list that is flat with respect to    * the given operator. The operands are assumed to be flat already.    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|flatten
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|SqlOperator
name|op
parameter_list|)
block|{
if|if
condition|(
name|isFlat
argument_list|(
name|exprs
argument_list|,
name|op
argument_list|)
condition|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|List
operator|)
name|exprs
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|flattenRecurse
argument_list|(
name|list
argument_list|,
name|exprs
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|/**    * Returns whether a call to {@code op} with {@code exprs} as arguments    * would be considered "flat".    *    *<p>For example, {@code isFlat([w, AND[x, y], z, AND)} returns false;    *<p>{@code isFlat([w, x, y, z], AND)} returns true.</p>    */
specifier|private
specifier|static
name|boolean
name|isFlat
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
specifier|final
name|SqlOperator
name|op
parameter_list|)
block|{
return|return
operator|!
name|isAssociative
argument_list|(
name|op
argument_list|)
operator|||
operator|!
name|exists
argument_list|(
name|exprs
argument_list|,
operator|(
name|Predicate1
argument_list|<
name|RexNode
argument_list|>
operator|)
name|expr
lambda|->
name|isCallTo
argument_list|(
name|expr
argument_list|,
name|op
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns false if the expression can be optimized by flattening    * calls to an associative operator such as AND and OR.    */
specifier|public
specifier|static
name|boolean
name|isFlat
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|expr
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|expr
decl_stmt|;
return|return
name|isFlat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|,
name|call
operator|.
name|getOperator
argument_list|()
argument_list|)
operator|&&
name|all
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|,
name|RexUtil
operator|::
name|isFlat
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|flattenRecurse
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|SqlOperator
name|op
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|RexCall
operator|&&
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|op
condition|)
block|{
name|flattenRecurse
argument_list|(
name|list
argument_list|,
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns whether the input is a 'loss-less' cast, that is, a cast from which    * the original value of the field can be certainly recovered.    *    *<p>For instance, int&rarr; bigint is loss-less (as you can cast back to    * int without loss of information), but bigint&rarr; int is not loss-less.    *    *<p>The implementation of this method does not return false positives.    * However, it is not complete.    * @param node input node to verify if it represents a loss-less cast    * @return true iff the node is a loss-less cast    */
specifier|public
specifier|static
name|boolean
name|isLosslessCast
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|isLosslessCast
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|node
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns whether the conversion from {@code source} to {@code target} type    * is a 'loss-less' cast, that is, a cast from which    * the original value of the field can be certainly recovered.    *    *<p>For instance, int&rarr; bigint is loss-less (as you can cast back to    * int without loss of information), but bigint&rarr; int is not loss-less.    *    *<p>The implementation of this method does not return false positives.    * However, it is not complete.    * @param source source type    * @param target target type    * @return true iff the conversion is a loss-less cast    */
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.22"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
specifier|static
name|boolean
name|isLosslessCast
parameter_list|(
name|RelDataType
name|source
parameter_list|,
name|RelDataType
name|target
parameter_list|)
block|{
specifier|final
name|SqlTypeName
name|sourceSqlTypeName
init|=
name|source
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
specifier|final
name|SqlTypeName
name|targetSqlTypeName
init|=
name|target
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
comment|// 1) Both INT numeric types
if|if
condition|(
name|SqlTypeFamily
operator|.
name|INTEGER
operator|.
name|getTypeNames
argument_list|()
operator|.
name|contains
argument_list|(
name|sourceSqlTypeName
argument_list|)
operator|&&
name|SqlTypeFamily
operator|.
name|INTEGER
operator|.
name|getTypeNames
argument_list|()
operator|.
name|contains
argument_list|(
name|targetSqlTypeName
argument_list|)
condition|)
block|{
return|return
name|targetSqlTypeName
operator|.
name|compareTo
argument_list|(
name|sourceSqlTypeName
argument_list|)
operator|>=
literal|0
return|;
block|}
comment|// 2) Both CHARACTER types: it depends on the precision (length)
if|if
condition|(
name|SqlTypeFamily
operator|.
name|CHARACTER
operator|.
name|getTypeNames
argument_list|()
operator|.
name|contains
argument_list|(
name|sourceSqlTypeName
argument_list|)
operator|&&
name|SqlTypeFamily
operator|.
name|CHARACTER
operator|.
name|getTypeNames
argument_list|()
operator|.
name|contains
argument_list|(
name|targetSqlTypeName
argument_list|)
condition|)
block|{
return|return
name|targetSqlTypeName
operator|.
name|compareTo
argument_list|(
name|sourceSqlTypeName
argument_list|)
operator|>=
literal|0
operator|&&
name|source
operator|.
name|getPrecision
argument_list|()
operator|<=
name|target
operator|.
name|getPrecision
argument_list|()
return|;
block|}
comment|// 3) From NUMERIC family to CHARACTER family: it depends on the precision/scale
if|if
condition|(
name|sourceSqlTypeName
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|NUMERIC
operator|&&
name|targetSqlTypeName
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
condition|)
block|{
name|int
name|sourceLength
init|=
name|source
operator|.
name|getPrecision
argument_list|()
operator|+
literal|1
decl_stmt|;
comment|// include sign
if|if
condition|(
name|source
operator|.
name|getScale
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|source
operator|.
name|getScale
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|sourceLength
operator|+=
name|source
operator|.
name|getScale
argument_list|()
operator|+
literal|1
expr_stmt|;
comment|// include decimal mark
block|}
return|return
name|target
operator|.
name|getPrecision
argument_list|()
operator|>=
name|sourceLength
return|;
block|}
comment|// Return FALSE by default
return|return
literal|false
return|;
block|}
comment|/** Converts an expression to conjunctive normal form (CNF).    *    *<p>The following expression is in CNF:    *    *<blockquote>(a OR b) AND (c OR d)</blockquote>    *    *<p>The following expression is not in CNF:    *    *<blockquote>(a AND b) OR c</blockquote>    *    *<p>but can be converted to CNF:    *    *<blockquote>(a OR c) AND (b OR c)</blockquote>    *    *<p>The following expression is not in CNF:    *    *<blockquote>NOT (a OR NOT b)</blockquote>    *    *<p>but can be converted to CNF by applying de Morgan's theorem:    *    *<blockquote>NOT a AND b</blockquote>    *    *<p>Expressions not involving AND, OR or NOT at the top level are in CNF.    */
specifier|public
specifier|static
name|RexNode
name|toCnf
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
return|return
operator|new
name|CnfHelper
argument_list|(
name|rexBuilder
argument_list|,
operator|-
literal|1
argument_list|)
operator|.
name|toCnf
argument_list|(
name|rex
argument_list|)
return|;
block|}
comment|/**    * Similar to {@link #toCnf(RexBuilder, RexNode)}; however, it lets you    * specify a threshold in the number of nodes that can be created out of    * the conversion.    *    *<p>If the number of resulting nodes exceeds that threshold,    * stops conversion and returns the original expression.    *    *<p>If the threshold is negative it is ignored.    *    *<p>Leaf nodes in the expression do not count towards the threshold.    */
specifier|public
specifier|static
name|RexNode
name|toCnf
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|int
name|maxCnfNodeCount
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
return|return
operator|new
name|CnfHelper
argument_list|(
name|rexBuilder
argument_list|,
name|maxCnfNodeCount
argument_list|)
operator|.
name|toCnf
argument_list|(
name|rex
argument_list|)
return|;
block|}
comment|/** Converts an expression to disjunctive normal form (DNF).    *    *<p>DNF: It is a form of logical formula which is disjunction of conjunctive    * clauses.    *    *<p>All logical formulas can be converted into DNF.    *    *<p>The following expression is in DNF:    *    *<blockquote>(a AND b) OR (c AND d)</blockquote>    *    *<p>The following expression is not in CNF:    *    *<blockquote>(a OR b) AND c</blockquote>    *    *<p>but can be converted to DNF:    *    *<blockquote>(a AND c) OR (b AND c)</blockquote>    *    *<p>The following expression is not in CNF:    *    *<blockquote>NOT (a OR NOT b)</blockquote>    *    *<p>but can be converted to DNF by applying de Morgan's theorem:    *    *<blockquote>NOT a AND b</blockquote>    *    *<p>Expressions not involving AND, OR or NOT at the top level are in DNF.    */
specifier|public
specifier|static
name|RexNode
name|toDnf
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
return|return
operator|new
name|DnfHelper
argument_list|(
name|rexBuilder
argument_list|)
operator|.
name|toDnf
argument_list|(
name|rex
argument_list|)
return|;
block|}
comment|/**    * Returns whether an operator is associative. AND is associative,    * which means that "(x AND y) and z" is equivalent to "x AND (y AND z)".    * We might well flatten the tree, and write "AND(x, y, z)".    */
specifier|private
specifier|static
name|boolean
name|isAssociative
parameter_list|(
name|SqlOperator
name|op
parameter_list|)
block|{
return|return
name|op
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
operator|||
name|op
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|OR
return|;
block|}
comment|/**    * Returns whether there is an element in {@code list} for which    * {@code predicate} is true.    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|exists
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|list
parameter_list|,
name|Predicate1
argument_list|<
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
for|for
control|(
name|E
name|e
range|:
name|list
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|e
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether {@code predicate} is true for all elements of    * {@code list}.    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|all
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|list
parameter_list|,
name|Predicate1
argument_list|<
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
for|for
control|(
name|E
name|e
range|:
name|list
control|)
block|{
if|if
condition|(
operator|!
name|predicate
operator|.
name|apply
argument_list|(
name|e
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Shifts every {@link RexInputRef} in an expression by {@code offset}.    */
specifier|public
specifier|static
name|RexNode
name|shift
parameter_list|(
name|RexNode
name|node
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
return|return
name|node
return|;
block|}
return|return
name|node
operator|.
name|accept
argument_list|(
operator|new
name|RexShiftShuttle
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Shifts every {@link RexInputRef} in an expression by {@code offset}.    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|shift
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
operator|new
name|RexShiftShuttle
argument_list|(
name|offset
argument_list|)
operator|.
name|visitList
argument_list|(
name|nodes
argument_list|)
return|;
block|}
comment|/**    * Shifts every {@link RexInputRef} in an expression higher than {@code start}    * by {@code offset}.    */
specifier|public
specifier|static
name|RexNode
name|shift
parameter_list|(
name|RexNode
name|node
parameter_list|,
specifier|final
name|int
name|start
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
return|return
name|node
operator|.
name|accept
argument_list|(
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|input
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|input
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|<
name|start
condition|)
block|{
return|return
name|input
return|;
block|}
return|return
operator|new
name|RexInputRef
argument_list|(
name|index
operator|+
name|offset
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/** Creates an equivalent version of a node where common factors among ORs    * are pulled up.    *    *<p>For example,    *    *<blockquote>(a AND b) OR (a AND c AND d)</blockquote>    *    *<p>becomes    *    *<blockquote>a AND (b OR (c AND d))</blockquote>    *    *<p>Note that this result is not in CNF    * (see {@link #toCnf(RexBuilder, RexNode)}) because there is an AND inside an    * OR.    *    *<p>This form is useful if, say, {@code a} contains columns from only the    * left-hand side of a join, and can be pushed to the left input.    *    * @param rexBuilder Rex builder    * @param node Expression to transform    * @return Equivalent expression with common factors pulled up    */
specifier|public
specifier|static
name|RexNode
name|pullFactors
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
return|return
operator|new
name|CnfHelper
argument_list|(
name|rexBuilder
argument_list|,
operator|-
literal|1
argument_list|)
operator|.
name|pull
argument_list|(
name|node
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|fixUp
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
specifier|final
name|RelDataType
name|rowType
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
init|=
name|RelOptUtil
operator|.
name|getFieldTypeList
argument_list|(
name|rowType
argument_list|)
decl_stmt|;
return|return
name|fixUp
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|,
name|typeList
argument_list|)
return|;
block|}
comment|/** Fixes up the type of all {@link RexInputRef}s in an    * expression to match differences in nullability.    *    *<p>Such differences in nullability occur when expressions are moved    * through outer joins.    *    *<p>Throws if there any greater inconsistencies of type. */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|fixUp
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|fieldTypes
parameter_list|)
block|{
return|return
operator|new
name|FixNullabilityShuttle
argument_list|(
name|rexBuilder
argument_list|,
name|fieldTypes
argument_list|)
operator|.
name|apply
argument_list|(
name|nodes
argument_list|)
return|;
block|}
comment|/** Transforms a list of expressions into a list of their types. */
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
name|nodes
argument_list|,
name|RexNode
operator|::
name|getType
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataTypeFamily
argument_list|>
name|families
parameter_list|(
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
name|types
argument_list|,
name|RelDataType
operator|::
name|getFamily
argument_list|)
return|;
block|}
comment|/** Removes all expressions from a list that are equivalent to a given    * expression. Returns whether any were removed. */
specifier|public
specifier|static
name|boolean
name|removeAll
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|targets
parameter_list|,
name|RexNode
name|e
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|RexNode
argument_list|>
name|iterator
init|=
name|targets
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RexNode
name|next
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|.
name|equals
argument_list|(
name|e
argument_list|)
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|count
operator|>
literal|0
return|;
block|}
comment|/** Returns whether two {@link RexNode}s are structurally equal.    *    *<p>This method considers structure, not semantics. 'x&lt; y' is not    * equivalent to 'y&gt; x'.    */
annotation|@
name|Deprecated
comment|// use e1.equals(e2)
specifier|public
specifier|static
name|boolean
name|eq
parameter_list|(
name|RexNode
name|e1
parameter_list|,
name|RexNode
name|e2
parameter_list|)
block|{
return|return
name|e1
operator|==
name|e2
operator|||
name|e1
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|e2
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/** Simplifies a boolean expression, always preserving its type and its    * nullability.    *    *<p>This is useful if you are simplifying expressions in a    * {@link Project}.    *    * @deprecated Use {@link RexSimplify#simplifyPreservingType(RexNode)},    * which allows you to specify an {@link RexExecutor}. */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RexNode
name|simplifyPreservingType
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e
parameter_list|)
block|{
return|return
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
name|EXECUTOR
argument_list|)
operator|.
name|simplifyPreservingType
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|/**    * Simplifies a boolean expression, leaving UNKNOWN values as UNKNOWN, and    * using the default executor.    *    * @deprecated Create a {@link RexSimplify}, then call its    * {@link RexSimplify#simplify(RexNode, RexUnknownAs)} method.    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RexNode
name|simplify
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e
parameter_list|)
block|{
return|return
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
name|EXECUTOR
argument_list|)
operator|.
name|simplify
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|/**    * Simplifies a boolean expression,    * using the default executor.    *    *<p>In particular:</p>    *<ul>    *<li>{@code simplify(x = 1 AND y = 2 AND NOT x = 1)}    * returns {@code y = 2}</li>    *<li>{@code simplify(x = 1 AND FALSE)}    * returns {@code FALSE}</li>    *</ul>    *    *<p>If the expression is a predicate in a WHERE clause, UNKNOWN values have    * the same effect as FALSE. In situations like this, specify    * {@code unknownAsFalse = true}, so and we can switch from 3-valued logic to    * simpler 2-valued logic and make more optimizations.    *    * @param rexBuilder Rex builder    * @param e Expression to simplify    * @param unknownAsFalse Whether to convert UNKNOWN values to FALSE    *    * @deprecated Create a {@link RexSimplify}, then call its    * {@link RexSimplify#simplify(RexNode, RexUnknownAs)} method.    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RexNode
name|simplify
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e
parameter_list|,
name|boolean
name|unknownAsFalse
parameter_list|)
block|{
return|return
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
name|EXECUTOR
argument_list|)
operator|.
name|simplifyUnknownAs
argument_list|(
name|e
argument_list|,
name|RexUnknownAs
operator|.
name|falseIf
argument_list|(
name|unknownAsFalse
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Simplifies a conjunction of boolean expressions.    *    * @deprecated Use    * {@link RexSimplify#simplifyAnds(Iterable, RexUnknownAs)}.    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RexNode
name|simplifyAnds
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
name|EXECUTOR
argument_list|)
operator|.
name|simplifyAnds
argument_list|(
name|nodes
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RexNode
name|simplifyAnds
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|boolean
name|unknownAsFalse
parameter_list|)
block|{
return|return
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
name|EXECUTOR
argument_list|)
operator|.
name|simplifyAnds
argument_list|(
name|nodes
argument_list|,
name|RexUnknownAs
operator|.
name|falseIf
argument_list|(
name|unknownAsFalse
argument_list|)
argument_list|)
return|;
block|}
comment|/** Negates a logical expression by adding or removing a NOT. */
specifier|public
specifier|static
name|RexNode
name|not
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|NOT
case|:
return|return
operator|(
operator|(
name|RexCall
operator|)
name|e
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
default|default:
return|return
name|addNot
argument_list|(
name|e
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|RexNode
name|addNot
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
return|return
operator|new
name|RexCall
argument_list|(
name|e
operator|.
name|getType
argument_list|()
argument_list|,
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|e
argument_list|)
argument_list|)
return|;
block|}
specifier|static
name|SqlOperator
name|op
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|IS_FALSE
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_FALSE
return|;
case|case
name|IS_TRUE
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
return|;
case|case
name|IS_UNKNOWN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_UNKNOWN
return|;
case|case
name|IS_NULL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_NULL
return|;
case|case
name|IS_NOT_FALSE
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_NOT_FALSE
return|;
case|case
name|IS_NOT_TRUE
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_NOT_TRUE
return|;
case|case
name|IS_NOT_NULL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
return|;
case|case
name|IS_DISTINCT_FROM
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_DISTINCT_FROM
return|;
case|case
name|IS_NOT_DISTINCT_FROM
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
return|;
case|case
name|EQUALS
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|EQUALS
return|;
case|case
name|NOT_EQUALS
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
return|;
case|case
name|LESS_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
return|;
case|case
name|GREATER_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
return|;
case|case
name|AND
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|AND
return|;
case|case
name|OR
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|OR
return|;
case|case
name|COALESCE
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|COALESCE
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|kind
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RexNode
name|simplifyAnd
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexCall
name|e
parameter_list|,
name|boolean
name|unknownAsFalse
parameter_list|)
block|{
return|return
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
name|EXECUTOR
argument_list|)
operator|.
name|simplifyAnd
argument_list|(
name|e
argument_list|,
name|RexUnknownAs
operator|.
name|falseIf
argument_list|(
name|unknownAsFalse
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RexNode
name|simplifyAnd2
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|terms
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|notTerms
parameter_list|)
block|{
return|return
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
name|EXECUTOR
argument_list|)
operator|.
name|simplifyAnd2
argument_list|(
name|terms
argument_list|,
name|notTerms
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RexNode
name|simplifyAnd2ForUnknownAsFalse
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|terms
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|notTerms
parameter_list|)
block|{
return|return
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
name|EXECUTOR
argument_list|)
operator|.
name|simplifyAnd2ForUnknownAsFalse
argument_list|(
name|terms
argument_list|,
name|notTerms
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RexNode
name|negate
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexCall
name|call
parameter_list|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
case|case
name|NOT_EQUALS
case|:
case|case
name|LESS_THAN
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
specifier|final
name|SqlOperator
name|op
init|=
name|op
argument_list|(
name|call
operator|.
name|getKind
argument_list|()
operator|.
name|negateNullSafe
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
specifier|static
name|RexNode
name|invert
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexCall
name|call
parameter_list|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
case|case
name|NOT_EQUALS
case|:
case|case
name|LESS_THAN
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
specifier|final
name|SqlOperator
name|op
init|=
name|op
argument_list|(
name|call
operator|.
name|getKind
argument_list|()
operator|.
name|reverse
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|,
name|Lists
operator|.
name|reverse
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RexNode
name|simplifyOr
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexCall
name|call
parameter_list|)
block|{
return|return
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
name|EXECUTOR
argument_list|)
operator|.
name|simplifyUnknownAs
argument_list|(
name|call
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|RexNode
name|simplifyOrs
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|terms
parameter_list|)
block|{
return|return
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
name|EXECUTOR
argument_list|)
operator|.
name|simplifyUnknownAs
argument_list|(
name|RexUtil
operator|.
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|terms
argument_list|)
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
return|;
block|}
comment|/**    * Creates the expression {@code e1 AND NOT notTerm1 AND NOT notTerm2 ...}.    */
specifier|public
specifier|static
name|RexNode
name|andNot
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e
parameter_list|,
name|RexNode
modifier|...
name|notTerms
parameter_list|)
block|{
return|return
name|andNot
argument_list|(
name|rexBuilder
argument_list|,
name|e
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|notTerms
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates the expression {@code e1 AND NOT notTerm1 AND NOT notTerm2 ...}.    *    *<p>Examples:    *<ul>    *<li>andNot(p) returns "p"    *<li>andNot(p, n1, n2) returns "p AND NOT n1 AND NOT n2"    *<li>andNot(x = 10, x = 20, y = 30, x = 30)    *       returns "x = 10 AND NOT (y = 30)"    *</ul>    */
specifier|public
specifier|static
annotation|@
name|Nonnull
name|RexNode
name|andNot
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|notTerms
parameter_list|)
block|{
comment|// If "e" is of the form "x = literal", remove all "x = otherLiteral"
comment|// terms from notTerms.
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|e
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexLiteral
condition|)
block|{
name|notTerms
operator|=
name|Util
operator|.
name|filter
argument_list|(
name|notTerms
argument_list|,
name|e2
lambda|->
block|{
switch|switch
condition|(
name|e2
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
name|RexCall
name|call2
init|=
operator|(
name|RexCall
operator|)
name|e2
decl_stmt|;
if|if
condition|(
name|call2
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equals
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|call2
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexLiteral
operator|&&
operator|!
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|equals
argument_list|(
name|call2
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|Iterables
operator|.
name|concat
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|e
argument_list|)
argument_list|,
name|Iterables
operator|.
name|transform
argument_list|(
name|notTerms
argument_list|,
name|e2
lambda|->
name|not
argument_list|(
name|rexBuilder
argument_list|,
name|e2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns whether a given operand of a CASE expression is a predicate.    *    *<p>A switched case (CASE x WHEN x1 THEN v1 ... ELSE e END) has an even    * number of arguments and odd-numbered arguments are predicates.    *    *<p>A condition case (CASE WHEN p1 THEN v1 ... ELSE e END) has an odd    * number of arguments and even-numbered arguments are predicates, except for    * the last argument. */
specifier|public
specifier|static
name|boolean
name|isCasePredicate
parameter_list|(
name|RexCall
name|call
parameter_list|,
name|int
name|i
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CASE
assert|;
return|return
name|i
operator|<
name|call
operator|.
name|operands
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|&&
operator|(
name|call
operator|.
name|operands
operator|.
name|size
argument_list|()
operator|-
name|i
operator|)
operator|%
literal|2
operator|==
literal|1
return|;
block|}
specifier|private
specifier|static
name|boolean
name|containsFalse
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|node
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
name|boolean
name|containsTrue
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|node
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Returns a function that applies NOT to its argument.    *    * @deprecated Use {@link #not} */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"Guava"
argument_list|)
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|notFn
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
return|return
name|e
lambda|->
name|not
argument_list|(
name|rexBuilder
argument_list|,
name|e
argument_list|)
return|;
block|}
comment|/** Applies NOT to an expression. */
specifier|static
name|RexNode
name|not
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|isAlwaysTrue
argument_list|()
condition|?
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
else|:
name|input
operator|.
name|isAlwaysFalse
argument_list|()
condition|?
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
else|:
name|input
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|NOT
condition|?
operator|(
operator|(
name|RexCall
operator|)
name|input
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
else|:
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|input
argument_list|)
return|;
block|}
comment|/** Returns whether an expression contains a {@link RexCorrelVariable}. */
specifier|public
specifier|static
name|boolean
name|containsCorrelation
parameter_list|(
name|RexNode
name|condition
parameter_list|)
block|{
try|try
block|{
name|condition
operator|.
name|accept
argument_list|(
name|CorrelationFinder
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Given an expression, it will swap the table references contained in its    * {@link RexTableInputRef} using the contents in the map.    */
specifier|public
specifier|static
name|RexNode
name|swapTableReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RexNode
name|node
parameter_list|,
specifier|final
name|Map
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|)
block|{
return|return
name|swapTableColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|node
argument_list|,
name|tableMapping
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Given an expression, it will swap its column references {@link RexTableInputRef}    * using the contents in the map (in particular, the first element of the set in the    * map value).    */
specifier|public
specifier|static
name|RexNode
name|swapColumnReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RexNode
name|node
parameter_list|,
specifier|final
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|ec
parameter_list|)
block|{
return|return
name|swapTableColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|node
argument_list|,
literal|null
argument_list|,
name|ec
argument_list|)
return|;
block|}
comment|/**    * Given an expression, it will swap the table references contained in its    * {@link RexTableInputRef} using the contents in the first map, and then    * it will swap the column references {@link RexTableInputRef} using the contents    * in the second map (in particular, the first element of the set in the map value).    */
specifier|public
specifier|static
name|RexNode
name|swapTableColumnReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RexNode
name|node
parameter_list|,
specifier|final
name|Map
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
specifier|final
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|ec
parameter_list|)
block|{
name|RexShuttle
name|visitor
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitTableInputRef
parameter_list|(
name|RexTableInputRef
name|inputRef
parameter_list|)
block|{
if|if
condition|(
name|tableMapping
operator|!=
literal|null
condition|)
block|{
name|inputRef
operator|=
name|RexTableInputRef
operator|.
name|of
argument_list|(
name|tableMapping
operator|.
name|get
argument_list|(
name|inputRef
operator|.
name|getTableRef
argument_list|()
argument_list|)
argument_list|,
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|,
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ec
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|s
init|=
name|ec
operator|.
name|get
argument_list|(
name|inputRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|inputRef
operator|=
name|s
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|inputRef
return|;
block|}
block|}
decl_stmt|;
return|return
name|visitor
operator|.
name|apply
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/**    * Given an expression, it will swap the column references {@link RexTableInputRef}    * using the contents in the first map (in particular, the first element of the set    * in the map value), and then it will swap the table references contained in its    * {@link RexTableInputRef} using the contents in the second map.    */
specifier|public
specifier|static
name|RexNode
name|swapColumnTableReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RexNode
name|node
parameter_list|,
specifier|final
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|ec
parameter_list|,
specifier|final
name|Map
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|)
block|{
name|RexShuttle
name|visitor
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitTableInputRef
parameter_list|(
name|RexTableInputRef
name|inputRef
parameter_list|)
block|{
if|if
condition|(
name|ec
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|s
init|=
name|ec
operator|.
name|get
argument_list|(
name|inputRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|inputRef
operator|=
name|s
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tableMapping
operator|!=
literal|null
condition|)
block|{
name|inputRef
operator|=
name|RexTableInputRef
operator|.
name|of
argument_list|(
name|tableMapping
operator|.
name|get
argument_list|(
name|inputRef
operator|.
name|getTableRef
argument_list|()
argument_list|)
argument_list|,
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|,
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|inputRef
return|;
block|}
block|}
decl_stmt|;
return|return
name|visitor
operator|.
name|apply
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/**    * Gather all table references in input expressions.    *    * @param nodes expressions    * @return set of table references    */
specifier|public
specifier|static
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|gatherTableReferences
parameter_list|(
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|occurrences
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitTableInputRef
parameter_list|(
name|RexTableInputRef
name|ref
parameter_list|)
block|{
name|occurrences
operator|.
name|add
argument_list|(
name|ref
operator|.
name|getTableRef
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|visitTableInputRef
argument_list|(
name|ref
argument_list|)
return|;
block|}
block|}
operator|.
name|visitEach
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
return|return
name|occurrences
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Walks over expressions and builds a bank of common sub-expressions.    */
specifier|private
specifier|static
class|class
name|ExpressionNormalizer
extends|extends
name|RexVisitorImpl
argument_list|<
name|RexNode
argument_list|>
block|{
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|allowDups
decl_stmt|;
specifier|protected
name|ExpressionNormalizer
parameter_list|(
name|boolean
name|allowDups
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|allowDups
operator|=
name|allowDups
expr_stmt|;
block|}
specifier|protected
name|RexNode
name|register
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
specifier|final
name|RexNode
name|previous
init|=
name|map
operator|.
name|put
argument_list|(
name|expr
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowDups
operator|&&
operator|(
name|previous
operator|!=
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|SubExprExistsException
argument_list|(
name|expr
argument_list|)
throw|;
block|}
return|return
name|expr
return|;
block|}
specifier|protected
name|RexNode
name|lookup
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
return|return
name|map
operator|.
name|get
argument_list|(
name|expr
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
return|return
name|register
argument_list|(
name|inputRef
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
return|return
name|register
argument_list|(
name|literal
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|correlVariable
parameter_list|)
block|{
return|return
name|register
argument_list|(
name|correlVariable
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|normalizedOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|diffCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|operand
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|normalizedOperand
init|=
name|lookup
argument_list|(
name|operand
argument_list|)
decl_stmt|;
name|normalizedOperands
operator|.
name|add
argument_list|(
name|normalizedOperand
argument_list|)
expr_stmt|;
if|if
condition|(
name|normalizedOperand
operator|!=
name|operand
condition|)
block|{
operator|++
name|diffCount
expr_stmt|;
block|}
block|}
if|if
condition|(
name|diffCount
operator|>
literal|0
condition|)
block|{
name|call
operator|=
name|call
operator|.
name|clone
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|normalizedOperands
argument_list|)
expr_stmt|;
block|}
return|return
name|register
argument_list|(
name|call
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitDynamicParam
parameter_list|(
name|RexDynamicParam
name|dynamicParam
parameter_list|)
block|{
return|return
name|register
argument_list|(
name|dynamicParam
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitRangeRef
parameter_list|(
name|RexRangeRef
name|rangeRef
parameter_list|)
block|{
return|return
name|register
argument_list|(
name|rangeRef
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
decl_stmt|;
name|expr
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|normalizedExpr
init|=
name|lookup
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|normalizedExpr
operator|!=
name|expr
condition|)
block|{
name|fieldAccess
operator|=
operator|new
name|RexFieldAccess
argument_list|(
name|normalizedExpr
argument_list|,
name|fieldAccess
operator|.
name|getField
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|register
argument_list|(
name|fieldAccess
argument_list|)
return|;
block|}
comment|/**      * Thrown if there is a sub-expression.      */
specifier|private
specifier|static
class|class
name|SubExprExistsException
extends|extends
name|ControlFlowException
block|{
name|SubExprExistsException
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
name|Util
operator|.
name|discard
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Walks over an expression and throws an exception if it finds an    * {@link RexInputRef} with an ordinal beyond the number of fields in the    * input row type, or a {@link RexLocalRef} with ordinal greater than that set    * using {@link #setLimit(int)}.    */
specifier|private
specifier|static
class|class
name|ForwardRefFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
name|int
name|limit
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|final
name|RelDataType
name|inputRowType
decl_stmt|;
name|ForwardRefFinder
parameter_list|(
name|RelDataType
name|inputRowType
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputRowType
operator|=
name|inputRowType
expr_stmt|;
block|}
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|super
operator|.
name|visitInputRef
argument_list|(
name|inputRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|>=
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalForwardRefException
argument_list|()
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|Void
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|inputRef
parameter_list|)
block|{
name|super
operator|.
name|visitLocalRef
argument_list|(
name|inputRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|>=
name|limit
condition|)
block|{
throw|throw
operator|new
name|IllegalForwardRefException
argument_list|()
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|void
name|setLimit
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
name|this
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
block|}
comment|/** Thrown to abort a visit when we find an illegal forward reference.      * It changes control flow but is not considered an error. */
specifier|static
class|class
name|IllegalForwardRefException
extends|extends
name|ControlFlowException
block|{     }
block|}
comment|/**    * Visitor which builds a bitmap of the inputs used by an expression.    */
specifier|public
specifier|static
class|class
name|FieldAccessFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|RexFieldAccess
argument_list|>
name|fieldAccessList
decl_stmt|;
specifier|public
name|FieldAccessFinder
parameter_list|()
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|fieldAccessList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
specifier|public
name|Void
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
name|fieldAccessList
operator|.
name|add
argument_list|(
name|fieldAccess
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|visitEach
argument_list|(
name|call
operator|.
name|operands
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|public
name|List
argument_list|<
name|RexFieldAccess
argument_list|>
name|getFieldAccessList
parameter_list|()
block|{
return|return
name|fieldAccessList
return|;
block|}
block|}
comment|/** Helps {@link org.apache.calcite.rex.RexUtil#toCnf}. */
specifier|private
specifier|static
class|class
name|CnfHelper
block|{
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
name|int
name|currentCount
decl_stmt|;
specifier|final
name|int
name|maxNodeCount
decl_stmt|;
comment|// negative means no limit
specifier|private
name|CnfHelper
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|int
name|maxNodeCount
parameter_list|)
block|{
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
name|this
operator|.
name|maxNodeCount
operator|=
name|maxNodeCount
expr_stmt|;
block|}
specifier|public
name|RexNode
name|toCnf
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|currentCount
operator|=
literal|0
expr_stmt|;
return|return
name|toCnf2
argument_list|(
name|rex
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|OverflowError
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|rex
return|;
block|}
block|}
specifier|private
name|RexNode
name|toCnf2
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
decl_stmt|;
switch|switch
condition|(
name|rex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
name|incrementAndCheck
argument_list|()
expr_stmt|;
name|operands
operator|=
name|flattenAnd
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|cnfOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|operands
control|)
block|{
name|RexNode
name|cnf
init|=
name|toCnf2
argument_list|(
name|node
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cnf
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
name|incrementAndCheck
argument_list|()
expr_stmt|;
name|cnfOperands
operator|.
name|addAll
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|cnf
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|incrementAndCheck
argument_list|()
expr_stmt|;
name|cnfOperands
operator|.
name|add
argument_list|(
name|cnf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|and
argument_list|(
name|cnfOperands
argument_list|)
return|;
case|case
name|OR
case|:
name|incrementAndCheck
argument_list|()
expr_stmt|;
name|operands
operator|=
name|flattenOr
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|head
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|headCnf
init|=
name|toCnf2
argument_list|(
name|head
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|headCnfs
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|headCnf
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|tail
init|=
name|or
argument_list|(
name|Util
operator|.
name|skip
argument_list|(
name|operands
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|tailCnf
init|=
name|toCnf2
argument_list|(
name|tail
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|tailCnfs
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|tailCnf
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|h
range|:
name|headCnfs
control|)
block|{
for|for
control|(
name|RexNode
name|t
range|:
name|tailCnfs
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|or
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|h
argument_list|,
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|and
argument_list|(
name|list
argument_list|)
return|;
case|case
name|NOT
case|:
specifier|final
name|RexNode
name|arg
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|arg
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|NOT
case|:
return|return
name|toCnf2
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|arg
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|OR
case|:
name|operands
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|arg
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
return|return
name|toCnf2
argument_list|(
name|and
argument_list|(
name|Lists
operator|.
name|transform
argument_list|(
name|flattenOr
argument_list|(
name|operands
argument_list|)
argument_list|,
name|RexUtil
operator|::
name|addNot
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|AND
case|:
name|operands
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|arg
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
return|return
name|toCnf2
argument_list|(
name|or
argument_list|(
name|Lists
operator|.
name|transform
argument_list|(
name|flattenAnd
argument_list|(
name|operands
argument_list|)
argument_list|,
name|RexUtil
operator|::
name|addNot
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|incrementAndCheck
argument_list|()
expr_stmt|;
return|return
name|rex
return|;
block|}
default|default:
name|incrementAndCheck
argument_list|()
expr_stmt|;
return|return
name|rex
return|;
block|}
block|}
specifier|private
name|void
name|incrementAndCheck
parameter_list|()
block|{
if|if
condition|(
name|maxNodeCount
operator|>=
literal|0
operator|&&
operator|++
name|currentCount
operator|>
name|maxNodeCount
condition|)
block|{
throw|throw
name|OverflowError
operator|.
name|INSTANCE
throw|;
block|}
block|}
comment|/** Exception to catch when we pass the limit. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|private
specifier|static
class|class
name|OverflowError
extends|extends
name|ControlFlowException
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ThrowableInstanceNeverThrown"
argument_list|)
specifier|protected
specifier|static
specifier|final
name|OverflowError
name|INSTANCE
init|=
operator|new
name|OverflowError
argument_list|()
decl_stmt|;
specifier|private
name|OverflowError
parameter_list|()
block|{
block|}
block|}
specifier|private
name|RexNode
name|pull
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
decl_stmt|;
switch|switch
condition|(
name|rex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
name|operands
operator|=
name|flattenAnd
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|and
argument_list|(
name|pullList
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
case|case
name|OR
case|:
name|operands
operator|=
name|flattenOr
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|factors
init|=
name|commonFactors
argument_list|(
name|operands
argument_list|)
decl_stmt|;
if|if
condition|(
name|factors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|or
argument_list|(
name|operands
argument_list|)
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|operands
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|removeFactor
argument_list|(
name|factors
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|and
argument_list|(
name|Iterables
operator|.
name|concat
argument_list|(
name|factors
operator|.
name|values
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|or
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|rex
return|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|pullList
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
name|RexNode
name|pulled
init|=
name|pull
argument_list|(
name|node
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|pulled
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
name|list
operator|.
name|addAll
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|pulled
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|list
operator|.
name|add
argument_list|(
name|pulled
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
specifier|private
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|commonFactors
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|i
operator|++
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|RexNode
name|conjunction
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|node
argument_list|)
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|conjunction
argument_list|,
name|conjunction
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|retainAll
argument_list|(
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
return|;
block|}
specifier|private
name|RexNode
name|removeFactor
parameter_list|(
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|factors
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|node
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|factors
operator|.
name|containsKey
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|and
argument_list|(
name|list
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|and
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|or
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|)
return|;
block|}
block|}
comment|/** Transforms a list of expressions to the list of digests. */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|strings
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
name|list
argument_list|,
name|Object
operator|::
name|toString
argument_list|)
return|;
block|}
comment|/** Helps {@link org.apache.calcite.rex.RexUtil#toDnf}. */
specifier|private
specifier|static
class|class
name|DnfHelper
block|{
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|private
name|DnfHelper
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
block|}
specifier|public
name|RexNode
name|toDnf
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
decl_stmt|;
switch|switch
condition|(
name|rex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
name|operands
operator|=
name|flattenAnd
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|head
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|headDnf
init|=
name|toDnf
argument_list|(
name|head
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|headDnfs
init|=
name|RelOptUtil
operator|.
name|disjunctions
argument_list|(
name|headDnf
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|tail
init|=
name|and
argument_list|(
name|Util
operator|.
name|skip
argument_list|(
name|operands
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|tailDnf
init|=
name|toDnf
argument_list|(
name|tail
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|tailDnfs
init|=
name|RelOptUtil
operator|.
name|disjunctions
argument_list|(
name|tailDnf
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|h
range|:
name|headDnfs
control|)
block|{
for|for
control|(
name|RexNode
name|t
range|:
name|tailDnfs
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|and
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|h
argument_list|,
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|or
argument_list|(
name|list
argument_list|)
return|;
case|case
name|OR
case|:
name|operands
operator|=
name|flattenOr
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|or
argument_list|(
name|toDnfs
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
case|case
name|NOT
case|:
specifier|final
name|RexNode
name|arg
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|arg
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|NOT
case|:
return|return
name|toDnf
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|arg
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|OR
case|:
name|operands
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|arg
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
return|return
name|toDnf
argument_list|(
name|and
argument_list|(
name|Lists
operator|.
name|transform
argument_list|(
name|flattenOr
argument_list|(
name|operands
argument_list|)
argument_list|,
name|RexUtil
operator|::
name|addNot
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|AND
case|:
name|operands
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|arg
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
return|return
name|toDnf
argument_list|(
name|or
argument_list|(
name|Lists
operator|.
name|transform
argument_list|(
name|flattenAnd
argument_list|(
name|operands
argument_list|)
argument_list|,
name|RexUtil
operator|::
name|addNot
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|rex
return|;
block|}
default|default:
return|return
name|rex
return|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|toDnfs
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
name|RexNode
name|dnf
init|=
name|toDnf
argument_list|(
name|node
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|dnf
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|OR
case|:
name|list
operator|.
name|addAll
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|dnf
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|list
operator|.
name|add
argument_list|(
name|dnf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
specifier|private
name|RexNode
name|and
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|or
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|)
return|;
block|}
block|}
comment|/** Shuttle that adds {@code offset} to each {@link RexInputRef} in an    * expression. */
specifier|private
specifier|static
class|class
name|RexShiftShuttle
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|int
name|offset
decl_stmt|;
name|RexShiftShuttle
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|input
parameter_list|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|input
operator|.
name|getIndex
argument_list|()
operator|+
name|offset
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Visitor that throws {@link org.apache.calcite.util.Util.FoundOne} if    * applied to an expression that contains a {@link RexCorrelVariable}. */
specifier|private
specifier|static
class|class
name|CorrelationFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|static
specifier|final
name|CorrelationFinder
name|INSTANCE
init|=
operator|new
name|CorrelationFinder
argument_list|()
decl_stmt|;
specifier|private
name|CorrelationFinder
parameter_list|()
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|var
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
block|}
comment|/** Shuttle that fixes up an expression to match changes in nullability of    * input fields. */
specifier|public
specifier|static
class|class
name|FixNullabilityShuttle
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
decl_stmt|;
specifier|private
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|public
name|FixNullabilityShuttle
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
parameter_list|)
block|{
name|this
operator|.
name|typeList
operator|=
name|typeList
expr_stmt|;
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|ref
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rightType
init|=
name|typeList
operator|.
name|get
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|refType
init|=
name|ref
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|refType
operator|.
name|equals
argument_list|(
name|rightType
argument_list|)
condition|)
block|{
return|return
name|ref
return|;
block|}
specifier|final
name|RelDataType
name|refType2
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|refType
argument_list|,
name|rightType
operator|.
name|isNullable
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|refType2
operator|.
name|equals
argument_list|(
name|rightType
argument_list|)
condition|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|,
name|refType2
argument_list|)
return|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"mismatched type "
operator|+
name|ref
operator|+
literal|" "
operator|+
name|rightType
argument_list|)
throw|;
block|}
block|}
comment|/** Visitor that throws {@link org.apache.calcite.util.Util.FoundOne} if    * applied to an expression that contains a {@link RexSubQuery}. */
specifier|public
specifier|static
class|class
name|SubQueryFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|SubQueryFinder
name|INSTANCE
init|=
operator|new
name|SubQueryFinder
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"Guava"
argument_list|)
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
specifier|final
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
argument_list|<
name|Project
argument_list|>
name|PROJECT_PREDICATE
init|=
name|SubQueryFinder
operator|::
name|containsSubQuery
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"Guava"
argument_list|)
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Filter
argument_list|>
name|FILTER_PREDICATE
init|=
name|SubQueryFinder
operator|::
name|containsSubQuery
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"Guava"
argument_list|)
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
specifier|final
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
argument_list|<
name|Join
argument_list|>
name|JOIN_PREDICATE
init|=
name|SubQueryFinder
operator|::
name|containsSubQuery
decl_stmt|;
specifier|private
name|SubQueryFinder
parameter_list|()
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Returns whether a {@link Project} contains a sub-query. */
specifier|public
specifier|static
name|boolean
name|containsSubQuery
parameter_list|(
name|Project
name|project
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|node
range|:
name|project
operator|.
name|getProjects
argument_list|()
control|)
block|{
try|try
block|{
name|node
operator|.
name|accept
argument_list|(
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Returns whether a {@link Filter} contains a sub-query. */
specifier|public
specifier|static
name|boolean
name|containsSubQuery
parameter_list|(
name|Filter
name|filter
parameter_list|)
block|{
try|try
block|{
name|filter
operator|.
name|getCondition
argument_list|()
operator|.
name|accept
argument_list|(
name|INSTANCE
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/** Returns whether a {@link Join} contains a sub-query. */
specifier|public
specifier|static
name|boolean
name|containsSubQuery
parameter_list|(
name|Join
name|join
parameter_list|)
block|{
try|try
block|{
name|join
operator|.
name|getCondition
argument_list|()
operator|.
name|accept
argument_list|(
name|INSTANCE
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitSubQuery
parameter_list|(
name|RexSubQuery
name|subQuery
parameter_list|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|subQuery
argument_list|)
throw|;
block|}
specifier|public
specifier|static
name|RexSubQuery
name|find
parameter_list|(
name|Iterable
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
try|try
block|{
name|node
operator|.
name|accept
argument_list|(
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
operator|(
name|RexSubQuery
operator|)
name|e
operator|.
name|getNode
argument_list|()
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
specifier|static
name|RexSubQuery
name|find
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
try|try
block|{
name|node
operator|.
name|accept
argument_list|(
name|INSTANCE
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
operator|(
name|RexSubQuery
operator|)
name|e
operator|.
name|getNode
argument_list|()
return|;
block|}
block|}
block|}
comment|/** Deep expressions simplifier.    *    *<p>This class is broken because it does not change the value of    * {@link RexUnknownAs} as it recurses into an expression. Do not use. */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
class|class
name|ExprSimplifier
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|RexSimplify
name|simplify
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexUnknownAs
argument_list|>
name|unknownAsMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|RexUnknownAs
name|unknownAs
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|matchNullability
decl_stmt|;
specifier|public
name|ExprSimplifier
parameter_list|(
name|RexSimplify
name|simplify
parameter_list|)
block|{
name|this
argument_list|(
name|simplify
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ExprSimplifier
parameter_list|(
name|RexSimplify
name|simplify
parameter_list|,
name|boolean
name|matchNullability
parameter_list|)
block|{
name|this
argument_list|(
name|simplify
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|,
name|matchNullability
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ExprSimplifier
parameter_list|(
name|RexSimplify
name|simplify
parameter_list|,
name|RexUnknownAs
name|unknownAs
parameter_list|,
name|boolean
name|matchNullability
parameter_list|)
block|{
name|this
operator|.
name|simplify
operator|=
name|simplify
expr_stmt|;
name|this
operator|.
name|unknownAs
operator|=
name|unknownAs
expr_stmt|;
name|this
operator|.
name|matchNullability
operator|=
name|matchNullability
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|RexUnknownAs
name|unknownAs
init|=
name|this
operator|.
name|unknownAs
decl_stmt|;
switch|switch
condition|(
name|unknownAs
condition|)
block|{
case|case
name|FALSE
case|:
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
case|case
name|CASE
case|:
comment|// Default value is used for top operator
name|unknownAs
operator|=
name|unknownAsMap
operator|.
name|getOrDefault
argument_list|(
name|call
argument_list|,
name|RexUnknownAs
operator|.
name|FALSE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unknownAs
operator|=
name|RexUnknownAs
operator|.
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|operands
control|)
block|{
name|this
operator|.
name|unknownAsMap
operator|.
name|put
argument_list|(
name|operand
argument_list|,
name|unknownAs
argument_list|)
expr_stmt|;
block|}
block|}
name|RexNode
name|node
init|=
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|RexNode
name|simplifiedNode
init|=
name|simplify
operator|.
name|simplify
argument_list|(
name|node
argument_list|,
name|unknownAs
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|simplifiedNode
condition|)
block|{
return|return
name|node
return|;
block|}
if|if
condition|(
name|simplifiedNode
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|simplifiedNode
return|;
block|}
return|return
name|simplify
operator|.
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|simplifiedNode
argument_list|,
name|matchNullability
argument_list|)
return|;
block|}
block|}
comment|/** Visitor that tells whether a node matching a particular description exists    * in a tree. */
specifier|public
specifier|abstract
specifier|static
class|class
name|RexFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
name|RexFinder
parameter_list|()
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Returns whether a {@link Project} contains the kind of expression we      * seek. */
specifier|public
name|boolean
name|inProject
parameter_list|(
name|Project
name|project
parameter_list|)
block|{
return|return
name|anyContain
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|)
return|;
block|}
comment|/** Returns whether a {@link Filter} contains the kind of expression we      * seek. */
specifier|public
name|boolean
name|inFilter
parameter_list|(
name|Filter
name|filter
parameter_list|)
block|{
return|return
name|contains
argument_list|(
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|)
return|;
block|}
comment|/** Returns whether a {@link Join} contains kind of expression we seek. */
specifier|public
name|boolean
name|inJoin
parameter_list|(
name|Join
name|join
parameter_list|)
block|{
return|return
name|contains
argument_list|(
name|join
operator|.
name|getCondition
argument_list|()
argument_list|)
return|;
block|}
comment|/** Returns whether the given expression contains what this RexFinder      * seeks. */
specifier|public
name|boolean
name|contains
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
try|try
block|{
name|node
operator|.
name|accept
argument_list|(
name|RexFinder
operator|.
name|this
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/** Returns whether any of the given expressions contain what this RexFinder      * seeks. */
specifier|public
name|boolean
name|anyContain
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
try|try
block|{
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
name|node
operator|.
name|accept
argument_list|(
name|RexFinder
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
end_class

end_unit

