begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|DataContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|java
operator|.
name|JavaTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|DateTimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnitRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|BinaryExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|BlockBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|BlockStatement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ConstantExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ExpressionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Expressions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|MemberExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|MethodCallExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|NewExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|OptimizeShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ParameterExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Primitive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactoryImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexPatternFieldRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|SqlFunctions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|FunctionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|ImplementableAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|ImplementableFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|AggregateFunctionImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBinaryOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlJsonConstructorNullClause
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlJsonEmptyOrError
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlJsonValueEmptyOrErrorBehavior
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlMatchFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlTypeConstructorFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWindowTableFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlJsonArrayAggAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlJsonObjectAggAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlTrimFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlUserDefinedAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlUserDefinedFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlUserDefinedTableFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlUserDefinedTableMacro
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|BuiltInMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|RoundingMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumUtils
operator|.
name|generateCollatorExpression
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ExpressionType
operator|.
name|Add
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ExpressionType
operator|.
name|Divide
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ExpressionType
operator|.
name|Equal
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ExpressionType
operator|.
name|GreaterThan
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ExpressionType
operator|.
name|GreaterThanOrEqual
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ExpressionType
operator|.
name|LessThan
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ExpressionType
operator|.
name|LessThanOrEqual
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ExpressionType
operator|.
name|Multiply
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ExpressionType
operator|.
name|Negate
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ExpressionType
operator|.
name|NotEqual
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ExpressionType
operator|.
name|Subtract
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ExpressionType
operator|.
name|UnaryPlus
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlInternalOperators
operator|.
name|THROW_UNLESS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|ARRAY_AGG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|ARRAY_CONCAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|ARRAY_CONCAT_AGG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|ARRAY_LENGTH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|ARRAY_REVERSE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|BOOL_AND
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|BOOL_OR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|CHAR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|CHR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|COMPRESS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|CONCAT2
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|CONCAT_FUNCTION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|COSH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|DATE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|DATE_FROM_UNIX_DATE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|DAYNAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|DIFFERENCE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|EXISTS_NODE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|EXTRACT_VALUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|EXTRACT_XML
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|FROM_BASE64
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|ILIKE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|JSON_DEPTH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|JSON_KEYS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|JSON_LENGTH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|JSON_PRETTY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|JSON_REMOVE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|JSON_STORAGE_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|JSON_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|LEFT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|LOGICAL_AND
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|LOGICAL_OR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|MD5
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|MONTHNAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|REGEXP_REPLACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|REPEAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|REVERSE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|RIGHT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|RLIKE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|SHA1
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|SINH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|SOUNDEX
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|SPACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|STRCMP
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|TANH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|TIMESTAMP_MICROS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|TIMESTAMP_MILLIS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|TIMESTAMP_SECONDS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|TO_BASE64
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|TRANSLATE3
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|UNIX_DATE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|UNIX_MICROS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|UNIX_MILLIS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|UNIX_SECONDS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
operator|.
name|XML_TRANSFORM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|ABS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|ACOS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|AND
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|ANY_VALUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|ARRAY_VALUE_CONSTRUCTOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|ASCII
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|ASIN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|ATAN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|ATAN2
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|BIT_AND
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|BIT_OR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|BIT_XOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CARDINALITY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CAST
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CBRT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CEIL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CHARACTER_LENGTH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CHAR_LENGTH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CLASSIFIER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|COALESCE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|COLLECT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CONCAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|COS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|COT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|COUNT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CURRENT_CATALOG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CURRENT_DATE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CURRENT_PATH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CURRENT_ROLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CURRENT_TIME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CURRENT_TIMESTAMP
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CURRENT_USER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|CURRENT_VALUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|DATETIME_PLUS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|DEGREES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|DENSE_RANK
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|DIVIDE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|DIVIDE_INTEGER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|ELEMENT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|EQUALS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|EVERY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|EXP
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|EXTRACT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|FIRST_VALUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|FLOOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|FUSION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|GROUPING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|GROUPING_ID
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|HOP
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|INITCAP
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|INTERSECTION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_A_SET
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_EMPTY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_FALSE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_JSON_ARRAY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_JSON_OBJECT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_JSON_SCALAR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_JSON_VALUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_NOT_A_SET
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_NOT_EMPTY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_NOT_FALSE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_NOT_JSON_ARRAY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_NOT_JSON_OBJECT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_NOT_JSON_SCALAR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_NOT_JSON_VALUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_NOT_TRUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_NULL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|ITEM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|JSON_ARRAY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|JSON_ARRAYAGG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|JSON_EXISTS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|JSON_OBJECT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|JSON_OBJECTAGG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|JSON_QUERY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|JSON_TYPE_OPERATOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|JSON_VALUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|JSON_VALUE_EXPRESSION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LAG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LAST
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LAST_DAY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LAST_VALUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LEAD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LIKE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LISTAGG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LOCALTIME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LOCALTIMESTAMP
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LOG10
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|LOWER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MAP_VALUE_CONSTRUCTOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MAX
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MEMBER_OF
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MIN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MINUS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MINUS_DATE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MOD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MODE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MULTISET_EXCEPT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MULTISET_EXCEPT_DISTINCT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MULTISET_INTERSECT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MULTISET_INTERSECT_DISTINCT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MULTISET_UNION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|MULTISET_UNION_DISTINCT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|NEXT_VALUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|NOT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|NOT_SUBMULTISET_OF
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|NTH_VALUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|NTILE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|OCTET_LENGTH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|OR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|OVERLAY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|PI
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|PLUS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|POSITION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|POWER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|RADIANS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|RAND
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|RAND_INTEGER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|RANK
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|REGR_COUNT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|REINTERPRET
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|REPLACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|ROUND
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|ROW
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|ROW_NUMBER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|SESSION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|SESSION_USER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|SIGN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|SIMILAR_TO
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|SIN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|SINGLE_VALUE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|SLICE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|SOME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|STRUCT_ACCESS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|SUBMULTISET_OF
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|SUBSTRING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|SUM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|SUM0
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|SYSTEM_USER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|TAN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|TRIM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|TRUNCATE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|TUMBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|UNARY_MINUS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|UNARY_PLUS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|UPPER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
operator|.
name|USER
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * Contains implementations of Rex operators as Java code.  */
end_comment

begin_class
specifier|public
class|class
name|RexImpTable
block|{
specifier|public
specifier|static
specifier|final
name|RexImpTable
name|INSTANCE
init|=
operator|new
name|RexImpTable
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|ConstantExpression
name|NULL_EXPR
init|=
name|Expressions
operator|.
name|constant
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|ConstantExpression
name|FALSE_EXPR
init|=
name|Expressions
operator|.
name|constant
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|ConstantExpression
name|TRUE_EXPR
init|=
name|Expressions
operator|.
name|constant
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|ConstantExpression
name|COMMA_EXPR
init|=
name|Expressions
operator|.
name|constant
argument_list|(
literal|","
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MemberExpression
name|BOXED_FALSE_EXPR
init|=
name|Expressions
operator|.
name|field
argument_list|(
literal|null
argument_list|,
name|Boolean
operator|.
name|class
argument_list|,
literal|"FALSE"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MemberExpression
name|BOXED_TRUE_EXPR
init|=
name|Expressions
operator|.
name|field
argument_list|(
literal|null
argument_list|,
name|Boolean
operator|.
name|class
argument_list|,
literal|"TRUE"
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlOperator
argument_list|,
name|RexCallImplementor
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlAggFunction
argument_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|AggImplementor
argument_list|>
argument_list|>
name|aggMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlAggFunction
argument_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|WinAggImplementor
argument_list|>
argument_list|>
name|winAggMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlMatchFunction
argument_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|MatchImplementor
argument_list|>
argument_list|>
name|matchMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlOperator
argument_list|,
name|Supplier
argument_list|<
name|?
extends|extends
name|TableFunctionCallImplementor
argument_list|>
argument_list|>
name|tvfImplementorMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"method.invocation.invalid"
argument_list|)
name|RexImpTable
parameter_list|()
block|{
name|defineMethod
argument_list|(
name|THROW_UNLESS
argument_list|,
name|BuiltInMethod
operator|.
name|THROW_UNLESS
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|ROW
argument_list|,
name|BuiltInMethod
operator|.
name|ARRAY
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ALL
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|UPPER
argument_list|,
name|BuiltInMethod
operator|.
name|UPPER
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|LOWER
argument_list|,
name|BuiltInMethod
operator|.
name|LOWER
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|INITCAP
argument_list|,
name|BuiltInMethod
operator|.
name|INITCAP
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|TO_BASE64
argument_list|,
name|BuiltInMethod
operator|.
name|TO_BASE64
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|FROM_BASE64
argument_list|,
name|BuiltInMethod
operator|.
name|FROM_BASE64
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|MD5
argument_list|,
name|BuiltInMethod
operator|.
name|MD5
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|SHA1
argument_list|,
name|BuiltInMethod
operator|.
name|SHA1
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|SUBSTRING
argument_list|,
name|BuiltInMethod
operator|.
name|SUBSTRING
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|LEFT
argument_list|,
name|BuiltInMethod
operator|.
name|LEFT
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ANY
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|RIGHT
argument_list|,
name|BuiltInMethod
operator|.
name|RIGHT
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ANY
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|REPLACE
argument_list|,
name|BuiltInMethod
operator|.
name|REPLACE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|TRANSLATE3
argument_list|,
name|BuiltInMethod
operator|.
name|TRANSLATE3
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|CHR
argument_list|,
name|BuiltInMethod
operator|.
name|CHAR_FROM_UTF8
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|CHARACTER_LENGTH
argument_list|,
name|BuiltInMethod
operator|.
name|CHAR_LENGTH
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|CHAR_LENGTH
argument_list|,
name|BuiltInMethod
operator|.
name|CHAR_LENGTH
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|OCTET_LENGTH
argument_list|,
name|BuiltInMethod
operator|.
name|OCTET_LENGTH
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|CONCAT
argument_list|,
operator|new
name|ConcatImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|CONCAT_FUNCTION
argument_list|,
name|BuiltInMethod
operator|.
name|MULTI_STRING_CONCAT
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|CONCAT2
argument_list|,
name|BuiltInMethod
operator|.
name|STRING_CONCAT
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|OVERLAY
argument_list|,
name|BuiltInMethod
operator|.
name|OVERLAY
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|POSITION
argument_list|,
name|BuiltInMethod
operator|.
name|POSITION
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|ASCII
argument_list|,
name|BuiltInMethod
operator|.
name|ASCII
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|CHAR
argument_list|,
name|BuiltInMethod
operator|.
name|CHAR_FROM_ASCII
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|SEMI_STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|REPEAT
argument_list|,
name|BuiltInMethod
operator|.
name|REPEAT
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|SPACE
argument_list|,
name|BuiltInMethod
operator|.
name|SPACE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|STRCMP
argument_list|,
name|BuiltInMethod
operator|.
name|STRCMP
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|SOUNDEX
argument_list|,
name|BuiltInMethod
operator|.
name|SOUNDEX
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|DIFFERENCE
argument_list|,
name|BuiltInMethod
operator|.
name|DIFFERENCE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|REVERSE
argument_list|,
name|BuiltInMethod
operator|.
name|REVERSE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|TRIM
argument_list|,
operator|new
name|TrimImplementor
argument_list|()
argument_list|)
expr_stmt|;
comment|// logical
name|map
operator|.
name|put
argument_list|(
name|AND
argument_list|,
operator|new
name|LogicalAndImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|OR
argument_list|,
operator|new
name|LogicalOrImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|NOT
argument_list|,
operator|new
name|LogicalNotImplementor
argument_list|()
argument_list|)
expr_stmt|;
comment|// comparisons
name|defineBinary
argument_list|(
name|LESS_THAN
argument_list|,
name|LessThan
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|"lt"
argument_list|)
expr_stmt|;
name|defineBinary
argument_list|(
name|LESS_THAN_OR_EQUAL
argument_list|,
name|LessThanOrEqual
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|"le"
argument_list|)
expr_stmt|;
name|defineBinary
argument_list|(
name|GREATER_THAN
argument_list|,
name|GreaterThan
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|"gt"
argument_list|)
expr_stmt|;
name|defineBinary
argument_list|(
name|GREATER_THAN_OR_EQUAL
argument_list|,
name|GreaterThanOrEqual
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|"ge"
argument_list|)
expr_stmt|;
name|defineBinary
argument_list|(
name|EQUALS
argument_list|,
name|Equal
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|"eq"
argument_list|)
expr_stmt|;
name|defineBinary
argument_list|(
name|NOT_EQUALS
argument_list|,
name|NotEqual
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|"ne"
argument_list|)
expr_stmt|;
comment|// arithmetic
name|defineBinary
argument_list|(
name|PLUS
argument_list|,
name|Add
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|"plus"
argument_list|)
expr_stmt|;
name|defineBinary
argument_list|(
name|MINUS
argument_list|,
name|Subtract
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|"minus"
argument_list|)
expr_stmt|;
name|defineBinary
argument_list|(
name|MULTIPLY
argument_list|,
name|Multiply
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|"multiply"
argument_list|)
expr_stmt|;
name|defineBinary
argument_list|(
name|DIVIDE
argument_list|,
name|Divide
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|"divide"
argument_list|)
expr_stmt|;
name|defineBinary
argument_list|(
name|DIVIDE_INTEGER
argument_list|,
name|Divide
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|"divide"
argument_list|)
expr_stmt|;
name|defineUnary
argument_list|(
name|UNARY_MINUS
argument_list|,
name|Negate
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
name|BuiltInMethod
operator|.
name|BIG_DECIMAL_NEGATE
operator|.
name|getMethodName
argument_list|()
argument_list|)
expr_stmt|;
name|defineUnary
argument_list|(
name|UNARY_PLUS
argument_list|,
name|UnaryPlus
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|MOD
argument_list|,
literal|"mod"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|EXP
argument_list|,
literal|"exp"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|POWER
argument_list|,
literal|"power"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|LN
argument_list|,
literal|"ln"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|LOG10
argument_list|,
literal|"log10"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|ABS
argument_list|,
literal|"abs"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|RAND
argument_list|,
operator|new
name|RandImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|RAND_INTEGER
argument_list|,
operator|new
name|RandIntegerImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|ACOS
argument_list|,
literal|"acos"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|ASIN
argument_list|,
literal|"asin"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|ATAN
argument_list|,
literal|"atan"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|ATAN2
argument_list|,
literal|"atan2"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|CBRT
argument_list|,
literal|"cbrt"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|COS
argument_list|,
literal|"cos"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|COSH
argument_list|,
literal|"cosh"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|COT
argument_list|,
literal|"cot"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|DEGREES
argument_list|,
literal|"degrees"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|RADIANS
argument_list|,
literal|"radians"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|ROUND
argument_list|,
literal|"sround"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|SIGN
argument_list|,
literal|"sign"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|SIN
argument_list|,
literal|"sin"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|SINH
argument_list|,
literal|"sinh"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|TAN
argument_list|,
literal|"tan"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|TANH
argument_list|,
literal|"tanh"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|TRUNCATE
argument_list|,
literal|"struncate"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|PI
argument_list|,
operator|new
name|PiImplementor
argument_list|()
argument_list|)
expr_stmt|;
comment|// datetime
name|map
operator|.
name|put
argument_list|(
name|DATETIME_PLUS
argument_list|,
operator|new
name|DatetimeArithmeticImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|MINUS_DATE
argument_list|,
operator|new
name|DatetimeArithmeticImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|EXTRACT
argument_list|,
operator|new
name|ExtractImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|FLOOR
argument_list|,
operator|new
name|FloorImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|FLOOR
operator|.
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|BuiltInMethod
operator|.
name|UNIX_TIMESTAMP_FLOOR
operator|.
name|method
argument_list|,
name|BuiltInMethod
operator|.
name|UNIX_DATE_FLOOR
operator|.
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|CEIL
argument_list|,
operator|new
name|FloorImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|CEIL
operator|.
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|BuiltInMethod
operator|.
name|UNIX_TIMESTAMP_CEIL
operator|.
name|method
argument_list|,
name|BuiltInMethod
operator|.
name|UNIX_DATE_CEIL
operator|.
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|LAST_DAY
argument_list|,
literal|"lastDay"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|DAYNAME
argument_list|,
operator|new
name|PeriodNameImplementor
argument_list|(
literal|"dayName"
argument_list|,
name|BuiltInMethod
operator|.
name|DAYNAME_WITH_TIMESTAMP
argument_list|,
name|BuiltInMethod
operator|.
name|DAYNAME_WITH_DATE
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|MONTHNAME
argument_list|,
operator|new
name|PeriodNameImplementor
argument_list|(
literal|"monthName"
argument_list|,
name|BuiltInMethod
operator|.
name|MONTHNAME_WITH_TIMESTAMP
argument_list|,
name|BuiltInMethod
operator|.
name|MONTHNAME_WITH_DATE
argument_list|)
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|TIMESTAMP_SECONDS
argument_list|,
literal|"timestampSeconds"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|TIMESTAMP_MILLIS
argument_list|,
literal|"timestampMillis"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|TIMESTAMP_MICROS
argument_list|,
literal|"timestampMicros"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|UNIX_SECONDS
argument_list|,
literal|"unixSeconds"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|UNIX_MILLIS
argument_list|,
literal|"unixMillis"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|UNIX_MICROS
argument_list|,
literal|"unixMicros"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|DATE_FROM_UNIX_DATE
argument_list|,
literal|"dateFromUnixDate"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|UNIX_DATE
argument_list|,
literal|"unixDate"
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_NULL
argument_list|,
operator|new
name|IsNullImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_NOT_NULL
argument_list|,
operator|new
name|IsNotNullImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_TRUE
argument_list|,
operator|new
name|IsTrueImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_NOT_TRUE
argument_list|,
operator|new
name|IsNotTrueImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_FALSE
argument_list|,
operator|new
name|IsFalseImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_NOT_FALSE
argument_list|,
operator|new
name|IsNotFalseImplementor
argument_list|()
argument_list|)
expr_stmt|;
comment|// LIKE, ILIKE and SIMILAR
name|map
operator|.
name|put
argument_list|(
name|LIKE
argument_list|,
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|LIKE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ILIKE
argument_list|,
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|ILIKE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|RLIKE
argument_list|,
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|RLIKE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SIMILAR_TO
argument_list|,
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|SIMILAR
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// POSIX REGEX
specifier|final
name|MethodImplementor
name|posixRegexImplementorCaseSensitive
init|=
operator|new
name|PosixRegexMethodImplementor
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|MethodImplementor
name|posixRegexImplementorCaseInsensitive
init|=
operator|new
name|PosixRegexMethodImplementor
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|POSIX_REGEX_CASE_INSENSITIVE
argument_list|,
name|posixRegexImplementorCaseInsensitive
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|POSIX_REGEX_CASE_SENSITIVE
argument_list|,
name|posixRegexImplementorCaseSensitive
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NEGATED_POSIX_REGEX_CASE_INSENSITIVE
argument_list|,
name|NotImplementor
operator|.
name|of
argument_list|(
name|posixRegexImplementorCaseInsensitive
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NEGATED_POSIX_REGEX_CASE_SENSITIVE
argument_list|,
name|NotImplementor
operator|.
name|of
argument_list|(
name|posixRegexImplementorCaseSensitive
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|REGEXP_REPLACE
argument_list|,
operator|new
name|RegexpReplaceImplementor
argument_list|()
argument_list|)
expr_stmt|;
comment|// Multisets& arrays
name|defineMethod
argument_list|(
name|CARDINALITY
argument_list|,
name|BuiltInMethod
operator|.
name|COLLECTION_SIZE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|ARRAY_LENGTH
argument_list|,
name|BuiltInMethod
operator|.
name|COLLECTION_SIZE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|SLICE
argument_list|,
name|BuiltInMethod
operator|.
name|SLICE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|ELEMENT
argument_list|,
name|BuiltInMethod
operator|.
name|ELEMENT
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|STRUCT_ACCESS
argument_list|,
name|BuiltInMethod
operator|.
name|STRUCT_ACCESS
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ANY
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|MEMBER_OF
argument_list|,
name|BuiltInMethod
operator|.
name|MEMBER_OF
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|ARRAY_REVERSE
argument_list|,
name|BuiltInMethod
operator|.
name|ARRAY_REVERSE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ARRAY_CONCAT
argument_list|,
operator|new
name|ArrayConcatImplementor
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|MethodImplementor
name|isEmptyImplementor
init|=
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|IS_EMPTY
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_EMPTY
argument_list|,
name|isEmptyImplementor
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_NOT_EMPTY
argument_list|,
name|NotImplementor
operator|.
name|of
argument_list|(
name|isEmptyImplementor
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|MethodImplementor
name|isASetImplementor
init|=
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|IS_A_SET
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_A_SET
argument_list|,
name|isASetImplementor
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_NOT_A_SET
argument_list|,
name|NotImplementor
operator|.
name|of
argument_list|(
name|isASetImplementor
argument_list|)
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|MULTISET_INTERSECT_DISTINCT
argument_list|,
name|BuiltInMethod
operator|.
name|MULTISET_INTERSECT_DISTINCT
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|MULTISET_INTERSECT
argument_list|,
name|BuiltInMethod
operator|.
name|MULTISET_INTERSECT_ALL
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|MULTISET_EXCEPT_DISTINCT
argument_list|,
name|BuiltInMethod
operator|.
name|MULTISET_EXCEPT_DISTINCT
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|MULTISET_EXCEPT
argument_list|,
name|BuiltInMethod
operator|.
name|MULTISET_EXCEPT_ALL
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|MULTISET_UNION_DISTINCT
argument_list|,
name|BuiltInMethod
operator|.
name|MULTISET_UNION_DISTINCT
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|MULTISET_UNION
argument_list|,
name|BuiltInMethod
operator|.
name|MULTISET_UNION_ALL
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|)
expr_stmt|;
specifier|final
name|MethodImplementor
name|subMultisetImplementor
init|=
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|SUBMULTISET_OF
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SUBMULTISET_OF
argument_list|,
name|subMultisetImplementor
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|NOT_SUBMULTISET_OF
argument_list|,
name|NotImplementor
operator|.
name|of
argument_list|(
name|subMultisetImplementor
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|COALESCE
argument_list|,
operator|new
name|CoalesceImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|CAST
argument_list|,
operator|new
name|CastImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|DATE
argument_list|,
operator|new
name|CastImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|REINTERPRET
argument_list|,
operator|new
name|ReinterpretImplementor
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|RexCallImplementor
name|value
init|=
operator|new
name|ValueConstructorImplementor
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|MAP_VALUE_CONSTRUCTOR
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ARRAY_VALUE_CONSTRUCTOR
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ITEM
argument_list|,
operator|new
name|ItemImplementor
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|DEFAULT
argument_list|,
operator|new
name|DefaultImplementor
argument_list|()
argument_list|)
expr_stmt|;
comment|// Sequences
name|defineMethod
argument_list|(
name|CURRENT_VALUE
argument_list|,
name|BuiltInMethod
operator|.
name|SEQUENCE_CURRENT_VALUE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|NEXT_VALUE
argument_list|,
name|BuiltInMethod
operator|.
name|SEQUENCE_NEXT_VALUE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
comment|// Compression Operators
name|defineMethod
argument_list|(
name|COMPRESS
argument_list|,
name|BuiltInMethod
operator|.
name|COMPRESS
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
comment|// Xml Operators
name|defineMethod
argument_list|(
name|EXTRACT_VALUE
argument_list|,
name|BuiltInMethod
operator|.
name|EXTRACT_VALUE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|XML_TRANSFORM
argument_list|,
name|BuiltInMethod
operator|.
name|XML_TRANSFORM
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|EXTRACT_XML
argument_list|,
name|BuiltInMethod
operator|.
name|EXTRACT_XML
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|EXISTS_NODE
argument_list|,
name|BuiltInMethod
operator|.
name|EXISTS_NODE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
comment|// Json Operators
name|defineMethod
argument_list|(
name|JSON_VALUE_EXPRESSION
argument_list|,
name|BuiltInMethod
operator|.
name|JSON_VALUE_EXPRESSION
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|JSON_TYPE_OPERATOR
argument_list|,
name|BuiltInMethod
operator|.
name|JSON_VALUE_EXPRESSION
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|JSON_EXISTS
argument_list|,
name|BuiltInMethod
operator|.
name|JSON_EXISTS
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|JSON_VALUE
argument_list|,
operator|new
name|JsonValueImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|JSON_VALUE
operator|.
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|JSON_QUERY
argument_list|,
name|BuiltInMethod
operator|.
name|JSON_QUERY
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|JSON_TYPE
argument_list|,
name|BuiltInMethod
operator|.
name|JSON_TYPE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|JSON_DEPTH
argument_list|,
name|BuiltInMethod
operator|.
name|JSON_DEPTH
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|JSON_KEYS
argument_list|,
name|BuiltInMethod
operator|.
name|JSON_KEYS
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|JSON_PRETTY
argument_list|,
name|BuiltInMethod
operator|.
name|JSON_PRETTY
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|JSON_LENGTH
argument_list|,
name|BuiltInMethod
operator|.
name|JSON_LENGTH
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|JSON_REMOVE
argument_list|,
name|BuiltInMethod
operator|.
name|JSON_REMOVE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|JSON_STORAGE_SIZE
argument_list|,
name|BuiltInMethod
operator|.
name|JSON_STORAGE_SIZE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|JSON_OBJECT
argument_list|,
name|BuiltInMethod
operator|.
name|JSON_OBJECT
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|defineMethod
argument_list|(
name|JSON_ARRAY
argument_list|,
name|BuiltInMethod
operator|.
name|JSON_ARRAY
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|JSON_OBJECTAGG
operator|.
name|with
argument_list|(
name|SqlJsonConstructorNullClause
operator|.
name|ABSENT_ON_NULL
argument_list|)
argument_list|,
name|JsonObjectAggImplementor
operator|.
name|supplierFor
argument_list|(
name|BuiltInMethod
operator|.
name|JSON_OBJECTAGG_ADD
operator|.
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|JSON_OBJECTAGG
operator|.
name|with
argument_list|(
name|SqlJsonConstructorNullClause
operator|.
name|NULL_ON_NULL
argument_list|)
argument_list|,
name|JsonObjectAggImplementor
operator|.
name|supplierFor
argument_list|(
name|BuiltInMethod
operator|.
name|JSON_OBJECTAGG_ADD
operator|.
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|JSON_ARRAYAGG
operator|.
name|with
argument_list|(
name|SqlJsonConstructorNullClause
operator|.
name|ABSENT_ON_NULL
argument_list|)
argument_list|,
name|JsonArrayAggImplementor
operator|.
name|supplierFor
argument_list|(
name|BuiltInMethod
operator|.
name|JSON_ARRAYAGG_ADD
operator|.
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|JSON_ARRAYAGG
operator|.
name|with
argument_list|(
name|SqlJsonConstructorNullClause
operator|.
name|NULL_ON_NULL
argument_list|)
argument_list|,
name|JsonArrayAggImplementor
operator|.
name|supplierFor
argument_list|(
name|BuiltInMethod
operator|.
name|JSON_ARRAYAGG_ADD
operator|.
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_JSON_VALUE
argument_list|,
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|IS_JSON_VALUE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_JSON_OBJECT
argument_list|,
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|IS_JSON_OBJECT
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_JSON_ARRAY
argument_list|,
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|IS_JSON_ARRAY
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_JSON_SCALAR
argument_list|,
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|IS_JSON_SCALAR
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_NOT_JSON_VALUE
argument_list|,
name|NotImplementor
operator|.
name|of
argument_list|(
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|IS_JSON_VALUE
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_NOT_JSON_OBJECT
argument_list|,
name|NotImplementor
operator|.
name|of
argument_list|(
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|IS_JSON_OBJECT
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_NOT_JSON_ARRAY
argument_list|,
name|NotImplementor
operator|.
name|of
argument_list|(
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|IS_JSON_ARRAY
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|IS_NOT_JSON_SCALAR
argument_list|,
name|NotImplementor
operator|.
name|of
argument_list|(
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|IS_JSON_SCALAR
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// System functions
specifier|final
name|SystemFunctionImplementor
name|systemFunctionImplementor
init|=
operator|new
name|SystemFunctionImplementor
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|USER
argument_list|,
name|systemFunctionImplementor
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|CURRENT_USER
argument_list|,
name|systemFunctionImplementor
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SESSION_USER
argument_list|,
name|systemFunctionImplementor
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SYSTEM_USER
argument_list|,
name|systemFunctionImplementor
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|CURRENT_PATH
argument_list|,
name|systemFunctionImplementor
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|CURRENT_ROLE
argument_list|,
name|systemFunctionImplementor
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|CURRENT_CATALOG
argument_list|,
name|systemFunctionImplementor
argument_list|)
expr_stmt|;
comment|// Current time functions
name|map
operator|.
name|put
argument_list|(
name|CURRENT_TIME
argument_list|,
name|systemFunctionImplementor
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|CURRENT_TIMESTAMP
argument_list|,
name|systemFunctionImplementor
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|CURRENT_DATE
argument_list|,
name|systemFunctionImplementor
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|LOCALTIME
argument_list|,
name|systemFunctionImplementor
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|LOCALTIMESTAMP
argument_list|,
name|systemFunctionImplementor
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|COUNT
argument_list|,
name|constructorSupplier
argument_list|(
name|CountImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|REGR_COUNT
argument_list|,
name|constructorSupplier
argument_list|(
name|CountImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|SUM0
argument_list|,
name|constructorSupplier
argument_list|(
name|SumImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|SUM
argument_list|,
name|constructorSupplier
argument_list|(
name|SumImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|Supplier
argument_list|<
name|MinMaxImplementor
argument_list|>
name|minMax
init|=
name|constructorSupplier
argument_list|(
name|MinMaxImplementor
operator|.
name|class
argument_list|)
decl_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|MIN
argument_list|,
name|minMax
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|MAX
argument_list|,
name|minMax
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|ANY_VALUE
argument_list|,
name|minMax
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|SOME
argument_list|,
name|minMax
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|EVERY
argument_list|,
name|minMax
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|BOOL_AND
argument_list|,
name|minMax
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|BOOL_OR
argument_list|,
name|minMax
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|LOGICAL_AND
argument_list|,
name|minMax
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|LOGICAL_OR
argument_list|,
name|minMax
argument_list|)
expr_stmt|;
specifier|final
name|Supplier
argument_list|<
name|BitOpImplementor
argument_list|>
name|bitop
init|=
name|constructorSupplier
argument_list|(
name|BitOpImplementor
operator|.
name|class
argument_list|)
decl_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|BIT_AND
argument_list|,
name|bitop
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|BIT_OR
argument_list|,
name|bitop
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|BIT_XOR
argument_list|,
name|bitop
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|SINGLE_VALUE
argument_list|,
name|constructorSupplier
argument_list|(
name|SingleValueImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|COLLECT
argument_list|,
name|constructorSupplier
argument_list|(
name|CollectImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|ARRAY_AGG
argument_list|,
name|constructorSupplier
argument_list|(
name|CollectImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|LISTAGG
argument_list|,
name|constructorSupplier
argument_list|(
name|ListaggImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|FUSION
argument_list|,
name|constructorSupplier
argument_list|(
name|FusionImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|MODE
argument_list|,
name|constructorSupplier
argument_list|(
name|ModeImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|ARRAY_CONCAT_AGG
argument_list|,
name|constructorSupplier
argument_list|(
name|FusionImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|INTERSECTION
argument_list|,
name|constructorSupplier
argument_list|(
name|IntersectionImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Supplier
argument_list|<
name|GroupingImplementor
argument_list|>
name|grouping
init|=
name|constructorSupplier
argument_list|(
name|GroupingImplementor
operator|.
name|class
argument_list|)
decl_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|GROUPING
argument_list|,
name|grouping
argument_list|)
expr_stmt|;
name|aggMap
operator|.
name|put
argument_list|(
name|GROUPING_ID
argument_list|,
name|grouping
argument_list|)
expr_stmt|;
name|winAggMap
operator|.
name|put
argument_list|(
name|RANK
argument_list|,
name|constructorSupplier
argument_list|(
name|RankImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|winAggMap
operator|.
name|put
argument_list|(
name|DENSE_RANK
argument_list|,
name|constructorSupplier
argument_list|(
name|DenseRankImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|winAggMap
operator|.
name|put
argument_list|(
name|ROW_NUMBER
argument_list|,
name|constructorSupplier
argument_list|(
name|RowNumberImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|winAggMap
operator|.
name|put
argument_list|(
name|FIRST_VALUE
argument_list|,
name|constructorSupplier
argument_list|(
name|FirstValueImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|winAggMap
operator|.
name|put
argument_list|(
name|NTH_VALUE
argument_list|,
name|constructorSupplier
argument_list|(
name|NthValueImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|winAggMap
operator|.
name|put
argument_list|(
name|LAST_VALUE
argument_list|,
name|constructorSupplier
argument_list|(
name|LastValueImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|winAggMap
operator|.
name|put
argument_list|(
name|LEAD
argument_list|,
name|constructorSupplier
argument_list|(
name|LeadImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|winAggMap
operator|.
name|put
argument_list|(
name|LAG
argument_list|,
name|constructorSupplier
argument_list|(
name|LagImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|winAggMap
operator|.
name|put
argument_list|(
name|NTILE
argument_list|,
name|constructorSupplier
argument_list|(
name|NtileImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|winAggMap
operator|.
name|put
argument_list|(
name|COUNT
argument_list|,
name|constructorSupplier
argument_list|(
name|CountWinImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|winAggMap
operator|.
name|put
argument_list|(
name|REGR_COUNT
argument_list|,
name|constructorSupplier
argument_list|(
name|CountWinImplementor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
comment|// Functions for MATCH_RECOGNIZE
name|matchMap
operator|.
name|put
argument_list|(
name|CLASSIFIER
argument_list|,
name|ClassifierImplementor
operator|::
operator|new
argument_list|)
expr_stmt|;
name|matchMap
operator|.
name|put
argument_list|(
name|LAST
argument_list|,
name|LastImplementor
operator|::
operator|new
argument_list|)
expr_stmt|;
name|tvfImplementorMap
operator|.
name|put
argument_list|(
name|TUMBLE
argument_list|,
name|TumbleImplementor
operator|::
operator|new
argument_list|)
expr_stmt|;
name|tvfImplementorMap
operator|.
name|put
argument_list|(
name|HOP
argument_list|,
name|HopImplementor
operator|::
operator|new
argument_list|)
expr_stmt|;
name|tvfImplementorMap
operator|.
name|put
argument_list|(
name|SESSION
argument_list|,
name|SessionImplementor
operator|::
operator|new
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Supplier
argument_list|<
name|T
argument_list|>
name|constructorSupplier
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|klass
parameter_list|)
block|{
specifier|final
name|Constructor
argument_list|<
name|T
argument_list|>
name|constructor
decl_stmt|;
try|try
block|{
name|constructor
operator|=
name|klass
operator|.
name|getDeclaredConstructor
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|klass
operator|+
literal|" should implement zero arguments constructor"
argument_list|)
throw|;
block|}
return|return
parameter_list|()
lambda|->
block|{
try|try
block|{
return|return
name|constructor
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
decl||
name|IllegalAccessException
decl||
name|InvocationTargetException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error while creating aggregate implementor "
operator|+
name|constructor
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|;
block|}
specifier|public
specifier|static
name|CallImplementor
name|createImplementor
parameter_list|(
specifier|final
name|NotNullImplementor
name|implementor
parameter_list|,
specifier|final
name|NullPolicy
name|nullPolicy
parameter_list|,
specifier|final
name|boolean
name|harmonize
parameter_list|)
block|{
return|return
parameter_list|(
name|translator
parameter_list|,
name|call
parameter_list|,
name|nullAs
parameter_list|)
lambda|->
block|{
specifier|final
name|RexCallImplementor
name|rexCallImplementor
init|=
name|createRexCallImplementor
argument_list|(
name|implementor
argument_list|,
name|nullPolicy
argument_list|,
name|harmonize
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexToLixTranslator
operator|.
name|Result
argument_list|>
name|arguments
init|=
name|translator
operator|.
name|getCallOperandResult
argument_list|(
name|call
argument_list|)
decl_stmt|;
assert|assert
name|arguments
operator|!=
literal|null
assert|;
specifier|final
name|RexToLixTranslator
operator|.
name|Result
name|result
init|=
name|rexCallImplementor
operator|.
name|implement
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|arguments
argument_list|)
decl_stmt|;
return|return
name|nullAs
operator|.
name|handle
argument_list|(
name|result
operator|.
name|valueVariable
argument_list|)
return|;
block|}
return|;
block|}
specifier|private
name|void
name|defineMethod
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|String
name|functionName
parameter_list|,
name|NullPolicy
name|nullPolicy
parameter_list|)
block|{
name|map
operator|.
name|put
argument_list|(
name|operator
argument_list|,
operator|new
name|MethodNameImplementor
argument_list|(
name|functionName
argument_list|,
name|nullPolicy
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|defineMethod
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|Method
name|method
parameter_list|,
name|NullPolicy
name|nullPolicy
parameter_list|)
block|{
name|map
operator|.
name|put
argument_list|(
name|operator
argument_list|,
operator|new
name|MethodImplementor
argument_list|(
name|method
argument_list|,
name|nullPolicy
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|defineUnary
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|ExpressionType
name|expressionType
parameter_list|,
name|NullPolicy
name|nullPolicy
parameter_list|,
annotation|@
name|Nullable
name|String
name|backupMethodName
parameter_list|)
block|{
name|map
operator|.
name|put
argument_list|(
name|operator
argument_list|,
operator|new
name|UnaryImplementor
argument_list|(
name|expressionType
argument_list|,
name|nullPolicy
argument_list|,
name|backupMethodName
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|defineBinary
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|ExpressionType
name|expressionType
parameter_list|,
name|NullPolicy
name|nullPolicy
parameter_list|,
name|String
name|backupMethodName
parameter_list|)
block|{
name|map
operator|.
name|put
argument_list|(
name|operator
argument_list|,
operator|new
name|BinaryImplementor
argument_list|(
name|nullPolicy
argument_list|,
literal|true
argument_list|,
name|expressionType
argument_list|,
name|backupMethodName
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|RexCallImplementor
name|createRexCallImplementor
parameter_list|(
specifier|final
name|NotNullImplementor
name|implementor
parameter_list|,
specifier|final
name|NullPolicy
name|nullPolicy
parameter_list|,
specifier|final
name|boolean
name|harmonize
parameter_list|)
block|{
return|return
operator|new
name|AbstractRexCallImplementor
argument_list|(
name|nullPolicy
argument_list|,
name|harmonize
argument_list|)
block|{
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"not_null_udf"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|implementor
operator|.
name|implement
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
block|}
return|;
block|}
specifier|private
specifier|static
name|RexCallImplementor
name|wrapAsRexCallImplementor
parameter_list|(
specifier|final
name|CallImplementor
name|implementor
parameter_list|)
block|{
return|return
operator|new
name|AbstractRexCallImplementor
argument_list|(
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
block|{
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"udf"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|implementor
operator|.
name|implement
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|RexImpTable
operator|.
name|NullAs
operator|.
name|NULL
argument_list|)
return|;
block|}
block|}
return|;
block|}
specifier|public
annotation|@
name|Nullable
name|RexCallImplementor
name|get
parameter_list|(
specifier|final
name|SqlOperator
name|operator
parameter_list|)
block|{
if|if
condition|(
name|operator
operator|instanceof
name|SqlUserDefinedFunction
condition|)
block|{
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Function
name|udf
init|=
operator|(
operator|(
name|SqlUserDefinedFunction
operator|)
name|operator
operator|)
operator|.
name|getFunction
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|udf
operator|instanceof
name|ImplementableFunction
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"User defined function "
operator|+
name|operator
operator|+
literal|" must implement ImplementableFunction"
argument_list|)
throw|;
block|}
name|CallImplementor
name|implementor
init|=
operator|(
operator|(
name|ImplementableFunction
operator|)
name|udf
operator|)
operator|.
name|getImplementor
argument_list|()
decl_stmt|;
return|return
name|wrapAsRexCallImplementor
argument_list|(
name|implementor
argument_list|)
return|;
block|}
if|else if
condition|(
name|operator
operator|instanceof
name|SqlTypeConstructorFunction
condition|)
block|{
return|return
name|map
operator|.
name|get
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ROW
argument_list|)
return|;
block|}
return|return
name|map
operator|.
name|get
argument_list|(
name|operator
argument_list|)
return|;
block|}
specifier|public
annotation|@
name|Nullable
name|AggImplementor
name|get
parameter_list|(
specifier|final
name|SqlAggFunction
name|aggregation
parameter_list|,
name|boolean
name|forWindowAggregate
parameter_list|)
block|{
if|if
condition|(
name|aggregation
operator|instanceof
name|SqlUserDefinedAggFunction
condition|)
block|{
specifier|final
name|SqlUserDefinedAggFunction
name|udaf
init|=
operator|(
name|SqlUserDefinedAggFunction
operator|)
name|aggregation
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|udaf
operator|.
name|function
operator|instanceof
name|ImplementableAggFunction
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"User defined aggregation "
operator|+
name|aggregation
operator|+
literal|" must implement ImplementableAggFunction"
argument_list|)
throw|;
block|}
return|return
operator|(
operator|(
name|ImplementableAggFunction
operator|)
name|udaf
operator|.
name|function
operator|)
operator|.
name|getImplementor
argument_list|(
name|forWindowAggregate
argument_list|)
return|;
block|}
if|if
condition|(
name|forWindowAggregate
condition|)
block|{
name|Supplier
argument_list|<
name|?
extends|extends
name|WinAggImplementor
argument_list|>
name|winAgg
init|=
name|winAggMap
operator|.
name|get
argument_list|(
name|aggregation
argument_list|)
decl_stmt|;
if|if
condition|(
name|winAgg
operator|!=
literal|null
condition|)
block|{
return|return
name|winAgg
operator|.
name|get
argument_list|()
return|;
block|}
comment|// Regular aggregates can be used in window context as well
block|}
name|Supplier
argument_list|<
name|?
extends|extends
name|AggImplementor
argument_list|>
name|aggSupplier
init|=
name|aggMap
operator|.
name|get
argument_list|(
name|aggregation
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggSupplier
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|aggSupplier
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|MatchImplementor
name|get
parameter_list|(
specifier|final
name|SqlMatchFunction
name|function
parameter_list|)
block|{
specifier|final
name|Supplier
argument_list|<
name|?
extends|extends
name|MatchImplementor
argument_list|>
name|supplier
init|=
name|matchMap
operator|.
name|get
argument_list|(
name|function
argument_list|)
decl_stmt|;
if|if
condition|(
name|supplier
operator|!=
literal|null
condition|)
block|{
return|return
name|supplier
operator|.
name|get
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Supplier should not be null"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|TableFunctionCallImplementor
name|get
parameter_list|(
specifier|final
name|SqlWindowTableFunction
name|operator
parameter_list|)
block|{
specifier|final
name|Supplier
argument_list|<
name|?
extends|extends
name|TableFunctionCallImplementor
argument_list|>
name|supplier
init|=
name|tvfImplementorMap
operator|.
name|get
argument_list|(
name|operator
argument_list|)
decl_stmt|;
if|if
condition|(
name|supplier
operator|!=
literal|null
condition|)
block|{
return|return
name|supplier
operator|.
name|get
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Supplier should not be null"
argument_list|)
throw|;
block|}
block|}
specifier|static
name|Expression
name|optimize
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|expression
operator|.
name|accept
argument_list|(
operator|new
name|OptimizeShuttle
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|Expression
name|optimize2
parameter_list|(
name|Expression
name|operand
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
if|if
condition|(
name|Primitive
operator|.
name|is
argument_list|(
name|operand
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
comment|// Primitive values cannot be null
return|return
name|optimize
argument_list|(
name|expression
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|optimize
argument_list|(
name|Expressions
operator|.
name|condition
argument_list|(
name|Expressions
operator|.
name|equal
argument_list|(
name|operand
argument_list|,
name|NULL_EXPR
argument_list|)
argument_list|,
name|NULL_EXPR
argument_list|,
name|expression
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|RelDataType
name|toSql
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|RelDataTypeFactoryImpl
operator|.
name|JavaType
condition|)
block|{
specifier|final
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|!=
literal|null
operator|&&
name|typeName
operator|!=
name|SqlTypeName
operator|.
name|OTHER
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|)
argument_list|,
name|type
operator|.
name|isNullable
argument_list|()
argument_list|)
return|;
block|}
block|}
return|return
name|type
return|;
block|}
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|allSame
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
name|E
name|prev
init|=
literal|null
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|list
control|)
block|{
if|if
condition|(
name|prev
operator|!=
literal|null
operator|&&
operator|!
name|prev
operator|.
name|equals
argument_list|(
name|e
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|prev
operator|=
name|e
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Strategy what an operator should return if one of its    * arguments is null. */
specifier|public
enum|enum
name|NullAs
block|{
comment|/** The most common policy among the SQL built-in operators. If      * one of the arguments is null, returns null. */
name|NULL
block|,
comment|/** If one of the arguments is null, the function returns      * false. Example: {@code IS NOT NULL}. */
name|FALSE
block|,
comment|/** If one of the arguments is null, the function returns      * true. Example: {@code IS NULL}. */
name|TRUE
block|,
comment|/** It is not possible for any of the arguments to be null.  If      * the argument type is nullable, the enclosing code will already      * have performed a not-null check. This may allow the operator      * implementor to generate a more efficient implementation, for      * example, by avoiding boxing or unboxing. */
name|NOT_POSSIBLE
block|,
comment|/** Return false if result is not null, true if result is null. */
name|IS_NULL
block|,
comment|/** Return true if result is not null, false if result is null. */
name|IS_NOT_NULL
block|;
specifier|public
specifier|static
name|NullAs
name|of
parameter_list|(
name|boolean
name|nullable
parameter_list|)
block|{
return|return
name|nullable
condition|?
name|NULL
else|:
name|NOT_POSSIBLE
return|;
block|}
comment|/** Adapts an expression with "normal" result to one that adheres to      * this particular policy. */
specifier|public
name|Expression
name|handle
parameter_list|(
name|Expression
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|Primitive
operator|.
name|flavor
argument_list|(
name|x
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|PRIMITIVE
case|:
comment|// Expression cannot be null. We can skip any runtime checks.
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|NULL
case|:
case|case
name|NOT_POSSIBLE
case|:
case|case
name|FALSE
case|:
case|case
name|TRUE
case|:
return|return
name|x
return|;
case|case
name|IS_NULL
case|:
return|return
name|FALSE_EXPR
return|;
case|case
name|IS_NOT_NULL
case|:
return|return
name|TRUE_EXPR
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
case|case
name|BOX
case|:
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|NOT_POSSIBLE
case|:
return|return
name|EnumUtils
operator|.
name|convert
argument_list|(
name|x
argument_list|,
name|Primitive
operator|.
name|unbox
argument_list|(
name|x
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|NULL
case|:
case|case
name|NOT_POSSIBLE
case|:
return|return
name|x
return|;
case|case
name|FALSE
case|:
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|IS_TRUE
operator|.
name|method
argument_list|,
name|x
argument_list|)
return|;
case|case
name|TRUE
case|:
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|IS_NOT_FALSE
operator|.
name|method
argument_list|,
name|x
argument_list|)
return|;
case|case
name|IS_NULL
case|:
return|return
name|Expressions
operator|.
name|equal
argument_list|(
name|x
argument_list|,
name|NULL_EXPR
argument_list|)
return|;
case|case
name|IS_NOT_NULL
case|:
return|return
name|Expressions
operator|.
name|notEqual
argument_list|(
name|x
argument_list|,
name|NULL_EXPR
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
block|}
specifier|static
name|Expression
name|getDefaultValue
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
name|Primitive
name|p
init|=
name|Primitive
operator|.
name|of
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
return|return
name|Expressions
operator|.
name|constant
argument_list|(
name|p
operator|.
name|defaultValue
argument_list|,
name|type
argument_list|)
return|;
block|}
return|return
name|Expressions
operator|.
name|constant
argument_list|(
literal|null
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/** Multiplies an expression by a constant and divides by another constant,    * optimizing appropriately.    *    *<p>For example, {@code multiplyDivide(e, 10, 1000)} returns    * {@code e / 100}. */
specifier|public
specifier|static
name|Expression
name|multiplyDivide
parameter_list|(
name|Expression
name|e
parameter_list|,
name|BigDecimal
name|multiplier
parameter_list|,
name|BigDecimal
name|divider
parameter_list|)
block|{
if|if
condition|(
name|multiplier
operator|.
name|equals
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
condition|)
block|{
if|if
condition|(
name|divider
operator|.
name|equals
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
condition|)
block|{
return|return
name|e
return|;
block|}
return|return
name|Expressions
operator|.
name|divide
argument_list|(
name|e
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|divider
operator|.
name|intValueExact
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|final
name|BigDecimal
name|x
init|=
name|multiplier
operator|.
name|divide
argument_list|(
name|divider
argument_list|,
name|RoundingMode
operator|.
name|UNNECESSARY
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|x
operator|.
name|compareTo
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
name|e
return|;
case|case
literal|1
case|:
return|return
name|Expressions
operator|.
name|multiply
argument_list|(
name|e
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|x
operator|.
name|intValueExact
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
operator|-
literal|1
case|:
return|return
name|multiplyDivide
argument_list|(
name|e
argument_list|,
name|BigDecimal
operator|.
name|ONE
argument_list|,
name|x
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
comment|/** Implementor for the {@code COUNT} aggregate function. */
specifier|static
class|class
name|CountImplementor
extends|extends
name|StrictAggImplementor
block|{
annotation|@
name|Override
specifier|public
name|void
name|implementNotNullAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|postIncrementAssign
argument_list|(
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Implementor for the {@code COUNT} windowed aggregate function. */
specifier|static
class|class
name|CountWinImplementor
extends|extends
name|StrictWinAggImplementor
block|{
name|boolean
name|justFrameRowCount
decl_stmt|;
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Type
argument_list|>
name|getNotNullState
parameter_list|(
name|WinAggContext
name|info
parameter_list|)
block|{
name|boolean
name|hasNullable
init|=
literal|false
decl_stmt|;
for|for
control|(
name|RelDataType
name|type
range|:
name|info
operator|.
name|parameterRelTypes
argument_list|()
control|)
block|{
if|if
condition|(
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|hasNullable
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|hasNullable
condition|)
block|{
name|justFrameRowCount
operator|=
literal|true
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
return|return
name|super
operator|.
name|getNotNullState
argument_list|(
name|info
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementNotNullAdd
parameter_list|(
name|WinAggContext
name|info
parameter_list|,
name|WinAggAddContext
name|add
parameter_list|)
block|{
if|if
condition|(
name|justFrameRowCount
condition|)
block|{
return|return;
block|}
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|postIncrementAssign
argument_list|(
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|Expression
name|implementNotNullResult
parameter_list|(
name|WinAggContext
name|info
parameter_list|,
name|WinAggResultContext
name|result
parameter_list|)
block|{
if|if
condition|(
name|justFrameRowCount
condition|)
block|{
return|return
name|result
operator|.
name|getFrameRowCount
argument_list|()
return|;
block|}
return|return
name|super
operator|.
name|implementNotNullResult
argument_list|(
name|info
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code SUM} windowed aggregate function. */
specifier|static
class|class
name|SumImplementor
extends|extends
name|StrictAggImplementor
block|{
annotation|@
name|Override
specifier|protected
name|void
name|implementNotNullReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
name|Expression
name|start
init|=
name|info
operator|.
name|returnType
argument_list|()
operator|==
name|BigDecimal
operator|.
name|class
condition|?
name|Expressions
operator|.
name|constant
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|)
else|:
name|Expressions
operator|.
name|constant
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|reset
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementNotNullAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
name|Expression
name|acc
init|=
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Expression
name|next
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|returnType
argument_list|()
operator|==
name|BigDecimal
operator|.
name|class
condition|)
block|{
name|next
operator|=
name|Expressions
operator|.
name|call
argument_list|(
name|acc
argument_list|,
literal|"add"
argument_list|,
name|add
operator|.
name|arguments
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|Expressions
operator|.
name|add
argument_list|(
name|acc
argument_list|,
name|EnumUtils
operator|.
name|convert
argument_list|(
name|add
operator|.
name|arguments
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|acc
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|accAdvance
argument_list|(
name|add
argument_list|,
name|acc
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Expression
name|implementNotNullResult
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResultContext
name|result
parameter_list|)
block|{
return|return
name|super
operator|.
name|implementNotNullResult
argument_list|(
name|info
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code MIN} and {@code MAX} aggregate functions. */
specifier|static
class|class
name|MinMaxImplementor
extends|extends
name|StrictAggImplementor
block|{
annotation|@
name|Override
specifier|protected
name|void
name|implementNotNullReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
name|Expression
name|acc
init|=
name|reset
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Primitive
name|p
init|=
name|Primitive
operator|.
name|of
argument_list|(
name|acc
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isMin
init|=
name|info
operator|.
name|aggregation
argument_list|()
operator|.
name|kind
operator|==
name|SqlKind
operator|.
name|MIN
decl_stmt|;
name|Object
name|inf
init|=
name|p
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|isMin
condition|?
name|p
operator|.
name|max
else|:
name|p
operator|.
name|min
operator|)
decl_stmt|;
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|acc
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|inf
argument_list|,
name|acc
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementNotNullAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
name|Expression
name|acc
init|=
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Expression
name|arg
init|=
name|add
operator|.
name|arguments
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isMin
init|=
name|info
operator|.
name|aggregation
argument_list|()
operator|.
name|kind
operator|==
name|SqlKind
operator|.
name|MIN
decl_stmt|;
specifier|final
name|Method
name|method
init|=
operator|(
name|isMin
condition|?
name|BuiltInMethod
operator|.
name|LESSER
else|:
name|BuiltInMethod
operator|.
name|GREATER
operator|)
operator|.
name|method
decl_stmt|;
name|Expression
name|next
init|=
name|Expressions
operator|.
name|call
argument_list|(
name|method
operator|.
name|getDeclaringClass
argument_list|()
argument_list|,
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|acc
argument_list|,
name|Expressions
operator|.
name|unbox
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|accAdvance
argument_list|(
name|add
argument_list|,
name|acc
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Implementor for the {@code SINGLE_VALUE} aggregate function. */
specifier|static
class|class
name|SingleValueImplementor
implements|implements
name|AggImplementor
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Type
argument_list|>
name|getStateType
parameter_list|(
name|AggContext
name|info
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
name|info
operator|.
name|returnType
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
name|List
argument_list|<
name|Expression
argument_list|>
name|acc
init|=
name|reset
operator|.
name|accumulator
argument_list|()
decl_stmt|;
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|acc
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|false
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|acc
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|getDefaultValue
argument_list|(
name|acc
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
name|List
argument_list|<
name|Expression
argument_list|>
name|acc
init|=
name|add
operator|.
name|accumulator
argument_list|()
decl_stmt|;
name|Expression
name|flag
init|=
name|acc
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|ifThen
argument_list|(
name|flag
argument_list|,
name|Expressions
operator|.
name|throw_
argument_list|(
name|Expressions
operator|.
name|new_
argument_list|(
name|IllegalStateException
operator|.
name|class
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|"more than one value in agg "
operator|+
name|info
operator|.
name|aggregation
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|flag
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|true
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|acc
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|add
operator|.
name|arguments
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Expression
name|implementResult
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResultContext
name|result
parameter_list|)
block|{
return|return
name|EnumUtils
operator|.
name|convert
argument_list|(
name|result
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|info
operator|.
name|returnType
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code COLLECT} and {@code ARRAY_AGG}    * aggregate functions. */
specifier|static
class|class
name|CollectImplementor
extends|extends
name|StrictAggImplementor
block|{
annotation|@
name|Override
specifier|protected
name|void
name|implementNotNullReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
comment|// acc[0] = new ArrayList();
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|reset
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Expressions
operator|.
name|new_
argument_list|(
name|ArrayList
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementNotNullAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
comment|// acc[0].add(arg);
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|BuiltInMethod
operator|.
name|COLLECTION_ADD
operator|.
name|method
argument_list|,
name|add
operator|.
name|arguments
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Implementor for the {@code LISTAGG} aggregate function. */
specifier|static
class|class
name|ListaggImplementor
extends|extends
name|StrictAggImplementor
block|{
annotation|@
name|Override
specifier|protected
name|void
name|implementNotNullReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|reset
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|NULL_EXPR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementNotNullAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
specifier|final
name|Expression
name|accValue
init|=
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|arg0
init|=
name|add
operator|.
name|arguments
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|arg1
init|=
name|add
operator|.
name|arguments
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|?
name|add
operator|.
name|arguments
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
else|:
name|COMMA_EXPR
decl_stmt|;
specifier|final
name|Expression
name|result
init|=
name|Expressions
operator|.
name|condition
argument_list|(
name|Expressions
operator|.
name|equal
argument_list|(
name|NULL_EXPR
argument_list|,
name|accValue
argument_list|)
argument_list|,
name|arg0
argument_list|,
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|STRING_CONCAT
operator|.
name|method
argument_list|,
name|accValue
argument_list|,
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|STRING_CONCAT
operator|.
name|method
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|accValue
argument_list|,
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Implementor for the {@code INTERSECTION} aggregate function. */
specifier|static
class|class
name|IntersectionImplementor
extends|extends
name|StrictAggImplementor
block|{
annotation|@
name|Override
specifier|protected
name|void
name|implementNotNullReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|reset
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|null
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementNotNullAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
name|BlockBuilder
name|accumulatorIsNull
init|=
operator|new
name|BlockBuilder
argument_list|()
decl_stmt|;
name|accumulatorIsNull
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Expressions
operator|.
name|new_
argument_list|(
name|ArrayList
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|accumulatorIsNull
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|BuiltInMethod
operator|.
name|COLLECTION_ADDALL
operator|.
name|method
argument_list|,
name|add
operator|.
name|arguments
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|BlockBuilder
name|accumulatorNotNull
init|=
operator|new
name|BlockBuilder
argument_list|()
decl_stmt|;
name|accumulatorNotNull
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|BuiltInMethod
operator|.
name|COLLECTION_RETAIN_ALL
operator|.
name|method
argument_list|,
name|add
operator|.
name|arguments
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|ifThenElse
argument_list|(
name|Expressions
operator|.
name|equal
argument_list|(
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|null
argument_list|)
argument_list|)
argument_list|,
name|accumulatorIsNull
operator|.
name|toBlock
argument_list|()
argument_list|,
name|accumulatorNotNull
operator|.
name|toBlock
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Implementor for the {@code MODE} aggregate function. */
specifier|static
class|class
name|ModeImplementor
extends|extends
name|StrictAggImplementor
block|{
annotation|@
name|Override
specifier|protected
name|void
name|implementNotNullReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
comment|// acc[0] = null;
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|reset
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|null
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// acc[1] = new HashMap<>();
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|reset
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|Expressions
operator|.
name|new_
argument_list|(
name|HashMap
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// acc[2] = Long.valueOf(0);
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|reset
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|0
argument_list|,
name|Long
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|implementNotNullAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
name|Expression
name|currentArg
init|=
name|add
operator|.
name|arguments
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Expression
name|currentResult
init|=
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Expression
name|accMap
init|=
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|Expression
name|currentMaxNumber
init|=
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|// the default number of occurrences is 0
name|Expression
name|getOrDefaultExpression
init|=
name|Expressions
operator|.
name|call
argument_list|(
name|accMap
argument_list|,
name|BuiltInMethod
operator|.
name|MAP_GET_OR_DEFAULT
operator|.
name|method
argument_list|,
name|currentArg
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|0
argument_list|,
name|Long
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
comment|// declare and assign the occurrences number about current value
name|ParameterExpression
name|currentNumber
init|=
name|Expressions
operator|.
name|parameter
argument_list|(
name|Long
operator|.
name|class
argument_list|,
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|newName
argument_list|(
literal|"currentNumber"
argument_list|)
argument_list|)
decl_stmt|;
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|declare
argument_list|(
literal|0
argument_list|,
name|currentNumber
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|currentNumber
argument_list|,
name|Expressions
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|convert_
argument_list|(
name|getOrDefaultExpression
argument_list|,
name|Long
operator|.
name|class
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|1
argument_list|,
name|Long
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// update the occurrences number about current value
name|Expression
name|methodCallExpression2
init|=
name|Expressions
operator|.
name|call
argument_list|(
name|accMap
argument_list|,
name|BuiltInMethod
operator|.
name|MAP_PUT
operator|.
name|method
argument_list|,
name|currentArg
argument_list|,
name|currentNumber
argument_list|)
decl_stmt|;
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|methodCallExpression2
argument_list|)
argument_list|)
expr_stmt|;
comment|// update the most frequent value
name|BlockBuilder
name|thenBlock
init|=
operator|new
name|BlockBuilder
argument_list|(
literal|true
argument_list|,
name|add
operator|.
name|currentBlock
argument_list|()
argument_list|)
decl_stmt|;
name|thenBlock
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|currentMaxNumber
argument_list|,
name|Expressions
operator|.
name|convert_
argument_list|(
name|currentNumber
argument_list|,
name|Long
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|thenBlock
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|currentResult
argument_list|,
name|currentArg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// if the maximum number of occurrences less than current value's occurrences number
comment|// than update
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|ifThen
argument_list|(
name|Expressions
operator|.
name|lessThan
argument_list|(
name|currentMaxNumber
argument_list|,
name|currentNumber
argument_list|)
argument_list|,
name|thenBlock
operator|.
name|toBlock
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|Expression
name|implementNotNullResult
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResultContext
name|result
parameter_list|)
block|{
return|return
name|result
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Type
argument_list|>
name|getNotNullState
parameter_list|(
name|AggContext
name|info
parameter_list|)
block|{
name|List
argument_list|<
name|Type
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// the most frequent value
name|types
operator|.
name|add
argument_list|(
name|Object
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// hashmap's key: value, hashmap's value: number of occurrences
name|types
operator|.
name|add
argument_list|(
name|HashMap
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// maximum number of occurrences about frequent value
name|types
operator|.
name|add
argument_list|(
name|Long
operator|.
name|class
argument_list|)
expr_stmt|;
return|return
name|types
return|;
block|}
block|}
comment|/** Implementor for the {@code FUSION} and {@code ARRAY_CONCAT_AGG}    * aggregate functions. */
specifier|static
class|class
name|FusionImplementor
extends|extends
name|StrictAggImplementor
block|{
annotation|@
name|Override
specifier|protected
name|void
name|implementNotNullReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
comment|// acc[0] = new ArrayList();
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|reset
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Expressions
operator|.
name|new_
argument_list|(
name|ArrayList
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementNotNullAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
comment|// acc[0].add(arg);
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|BuiltInMethod
operator|.
name|COLLECTION_ADDALL
operator|.
name|method
argument_list|,
name|add
operator|.
name|arguments
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Implementor for the {@code BIT_AND}, {@code BIT_OR} and {@code BIT_XOR} aggregate function. */
specifier|static
class|class
name|BitOpImplementor
extends|extends
name|StrictAggImplementor
block|{
annotation|@
name|Override
specifier|protected
name|void
name|implementNotNullReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
name|Expression
name|start
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isBinary
argument_list|(
name|info
operator|.
name|returnRelType
argument_list|()
argument_list|)
condition|)
block|{
name|start
operator|=
name|Expressions
operator|.
name|field
argument_list|(
literal|null
argument_list|,
name|ByteString
operator|.
name|class
argument_list|,
literal|"EMPTY"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Object
name|initValue
init|=
name|info
operator|.
name|aggregation
argument_list|()
operator|==
name|BIT_AND
condition|?
operator|-
literal|1L
else|:
literal|0
decl_stmt|;
name|start
operator|=
name|Expressions
operator|.
name|constant
argument_list|(
name|initValue
argument_list|,
name|info
operator|.
name|returnType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|reset
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementNotNullAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
name|Expression
name|acc
init|=
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Expression
name|arg
init|=
name|add
operator|.
name|arguments
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|SqlAggFunction
name|aggregation
init|=
name|info
operator|.
name|aggregation
argument_list|()
decl_stmt|;
specifier|final
name|BuiltInMethod
name|builtInMethod
decl_stmt|;
switch|switch
condition|(
name|aggregation
operator|.
name|kind
condition|)
block|{
case|case
name|BIT_AND
case|:
name|builtInMethod
operator|=
name|BuiltInMethod
operator|.
name|BIT_AND
expr_stmt|;
break|break;
case|case
name|BIT_OR
case|:
name|builtInMethod
operator|=
name|BuiltInMethod
operator|.
name|BIT_OR
expr_stmt|;
break|break;
case|case
name|BIT_XOR
case|:
name|builtInMethod
operator|=
name|BuiltInMethod
operator|.
name|BIT_XOR
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown "
operator|+
name|aggregation
operator|.
name|getName
argument_list|()
operator|+
literal|". Only support bit_and, bit_or and bit_xor for bit aggregation function"
argument_list|)
throw|;
block|}
specifier|final
name|Method
name|method
init|=
name|builtInMethod
operator|.
name|method
decl_stmt|;
name|Expression
name|next
init|=
name|Expressions
operator|.
name|call
argument_list|(
name|method
operator|.
name|getDeclaringClass
argument_list|()
argument_list|,
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|acc
argument_list|,
name|Expressions
operator|.
name|unbox
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|accAdvance
argument_list|(
name|add
argument_list|,
name|acc
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Implementor for the {@code GROUPING} aggregate function. */
specifier|static
class|class
name|GroupingImplementor
implements|implements
name|AggImplementor
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Type
argument_list|>
name|getStateType
parameter_list|(
name|AggContext
name|info
parameter_list|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
block|}
annotation|@
name|Override
specifier|public
name|Expression
name|implementResult
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResultContext
name|result
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|keys
decl_stmt|;
switch|switch
condition|(
name|info
operator|.
name|aggregation
argument_list|()
operator|.
name|kind
condition|)
block|{
case|case
name|GROUPING
case|:
comment|// "GROUPING(e, ...)", also "GROUPING_ID(e, ...)"
name|keys
operator|=
name|result
operator|.
name|call
argument_list|()
operator|.
name|getArgList
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
name|Expression
name|e
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|groupSets
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|keyOrdinals
init|=
name|info
operator|.
name|keyOrdinals
argument_list|()
decl_stmt|;
name|long
name|x
init|=
literal|1L
operator|<<
operator|(
name|keys
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
for|for
control|(
name|int
name|k
range|:
name|keys
control|)
block|{
specifier|final
name|int
name|i
init|=
name|keyOrdinals
operator|.
name|indexOf
argument_list|(
name|k
argument_list|)
decl_stmt|;
assert|assert
name|i
operator|>=
literal|0
assert|;
specifier|final
name|Expression
name|e2
init|=
name|Expressions
operator|.
name|condition
argument_list|(
name|result
operator|.
name|keyField
argument_list|(
name|keyOrdinals
operator|.
name|size
argument_list|()
operator|+
name|i
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|x
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|0L
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
name|e
operator|=
name|e2
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|Expressions
operator|.
name|add
argument_list|(
name|e
argument_list|,
name|e2
argument_list|)
expr_stmt|;
block|}
name|x
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|e
operator|!=
literal|null
condition|?
name|e
else|:
name|Expressions
operator|.
name|constant
argument_list|(
literal|0
argument_list|,
name|info
operator|.
name|returnType
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for user-defined aggregate functions. */
specifier|public
specifier|static
class|class
name|UserDefinedAggReflectiveImplementor
extends|extends
name|StrictAggImplementor
block|{
specifier|private
specifier|final
name|AggregateFunctionImpl
name|afi
decl_stmt|;
specifier|public
name|UserDefinedAggReflectiveImplementor
parameter_list|(
name|AggregateFunctionImpl
name|afi
parameter_list|)
block|{
name|this
operator|.
name|afi
operator|=
name|afi
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Type
argument_list|>
name|getNotNullState
parameter_list|(
name|AggContext
name|info
parameter_list|)
block|{
if|if
condition|(
name|afi
operator|.
name|isStatic
condition|)
block|{
return|return
name|Collections
operator|.
name|singletonList
argument_list|(
name|afi
operator|.
name|accumulatorType
argument_list|)
return|;
block|}
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|afi
operator|.
name|accumulatorType
argument_list|,
name|afi
operator|.
name|declaringClass
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|implementNotNullReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
name|List
argument_list|<
name|Expression
argument_list|>
name|acc
init|=
name|reset
operator|.
name|accumulator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|afi
operator|.
name|isStatic
condition|)
block|{
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|acc
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|makeNew
argument_list|(
name|afi
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|acc
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Expressions
operator|.
name|call
argument_list|(
name|afi
operator|.
name|isStatic
condition|?
literal|null
else|:
name|acc
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|afi
operator|.
name|initMethod
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|NewExpression
name|makeNew
parameter_list|(
name|AggregateFunctionImpl
name|afi
parameter_list|)
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
argument_list|>
name|constructor
init|=
name|afi
operator|.
name|declaringClass
operator|.
name|getConstructor
argument_list|()
decl_stmt|;
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|constructor
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
name|Expressions
operator|.
name|new_
argument_list|(
name|afi
operator|.
name|declaringClass
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
comment|// ignore, and try next constructor
block|}
try|try
block|{
name|Constructor
argument_list|<
name|?
argument_list|>
name|constructor
init|=
name|afi
operator|.
name|declaringClass
operator|.
name|getConstructor
argument_list|(
name|FunctionContext
operator|.
name|class
argument_list|)
decl_stmt|;
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|constructor
argument_list|,
literal|"constructor"
argument_list|)
expr_stmt|;
return|return
name|Expressions
operator|.
name|new_
argument_list|(
name|afi
operator|.
name|declaringClass
argument_list|,
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|FUNCTION_CONTEXTS_OF
operator|.
name|method
argument_list|,
name|DataContext
operator|.
name|ROOT
argument_list|,
comment|// TODO: pass in the values of arguments that are literals
name|Expressions
operator|.
name|newArrayBounds
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|afi
operator|.
name|getParameters
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
comment|// This should never happen: validator should have made sure that the
comment|// class had an appropriate constructor.
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"no valid constructor for "
operator|+
name|afi
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|implementNotNullAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
name|List
argument_list|<
name|Expression
argument_list|>
name|acc
init|=
name|add
operator|.
name|accumulator
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Expression
argument_list|>
name|aggArgs
init|=
name|add
operator|.
name|arguments
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Expression
argument_list|>
name|args
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|aggArgs
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|args
operator|.
name|add
argument_list|(
name|acc
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|addAll
argument_list|(
name|aggArgs
argument_list|)
expr_stmt|;
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|acc
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Expressions
operator|.
name|call
argument_list|(
name|afi
operator|.
name|isStatic
condition|?
literal|null
else|:
name|acc
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|afi
operator|.
name|addMethod
argument_list|,
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|Expression
name|implementNotNullResult
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResultContext
name|result
parameter_list|)
block|{
name|List
argument_list|<
name|Expression
argument_list|>
name|acc
init|=
name|result
operator|.
name|accumulator
argument_list|()
decl_stmt|;
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|afi
operator|.
name|isStatic
condition|?
literal|null
else|:
name|acc
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|requireNonNull
argument_list|(
name|afi
operator|.
name|resultMethod
argument_list|,
parameter_list|()
lambda|->
literal|"resultMethod is null. Does "
operator|+
name|afi
operator|.
name|declaringClass
operator|+
literal|" declare result method?"
argument_list|)
argument_list|,
name|acc
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code RANK} windowed aggregate function. */
specifier|static
class|class
name|RankImplementor
extends|extends
name|StrictWinAggImplementor
block|{
annotation|@
name|Override
specifier|protected
name|void
name|implementNotNullAdd
parameter_list|(
name|WinAggContext
name|info
parameter_list|,
name|WinAggAddContext
name|add
parameter_list|)
block|{
name|Expression
name|acc
init|=
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// This is an example of the generated code
if|if
condition|(
literal|false
condition|)
block|{
operator|new
name|Object
argument_list|()
block|{
name|int
name|curentPosition
decl_stmt|;
comment|// position in for-win-agg-loop
name|int
name|startIndex
decl_stmt|;
comment|// index of start of window
name|Comparable
annotation|@
name|Nullable
type|[]
name|rows
decl_stmt|;
comment|// accessed via WinAggAddContext.compareRows
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nullness"
argument_list|)
name|void
name|sample
parameter_list|()
block|{
if|if
condition|(
name|curentPosition
operator|>
name|startIndex
condition|)
block|{
if|if
condition|(
name|rows
index|[
name|curentPosition
operator|-
literal|1
index|]
operator|.
name|compareTo
argument_list|(
name|rows
index|[
name|curentPosition
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|// update rank
block|}
block|}
block|}
block|}
expr_stmt|;
block|}
name|BlockBuilder
name|builder
init|=
name|add
operator|.
name|nestBlock
argument_list|()
decl_stmt|;
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|ifThen
argument_list|(
name|Expressions
operator|.
name|lessThan
argument_list|(
name|add
operator|.
name|compareRows
argument_list|(
name|Expressions
operator|.
name|subtract
argument_list|(
name|add
operator|.
name|currentPosition
argument_list|()
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|add
operator|.
name|currentPosition
argument_list|()
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|acc
argument_list|,
name|computeNewRank
argument_list|(
name|acc
argument_list|,
name|add
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add
operator|.
name|exitBlock
argument_list|()
expr_stmt|;
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|ifThen
argument_list|(
name|Expressions
operator|.
name|greaterThan
argument_list|(
name|add
operator|.
name|currentPosition
argument_list|()
argument_list|,
name|add
operator|.
name|startIndex
argument_list|()
argument_list|)
argument_list|,
name|builder
operator|.
name|toBlock
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|Expression
name|computeNewRank
parameter_list|(
name|Expression
name|acc
parameter_list|,
name|WinAggAddContext
name|add
parameter_list|)
block|{
name|Expression
name|pos
init|=
name|add
operator|.
name|currentPosition
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|add
operator|.
name|startIndex
argument_list|()
operator|.
name|equals
argument_list|(
name|Expressions
operator|.
name|constant
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|// In general, currentPosition-startIndex should be used
comment|// However, rank/dense_rank does not allow preceding/following clause
comment|// so we always result in startIndex==0.
name|pos
operator|=
name|Expressions
operator|.
name|subtract
argument_list|(
name|pos
argument_list|,
name|add
operator|.
name|startIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Expression
name|implementNotNullResult
parameter_list|(
name|WinAggContext
name|info
parameter_list|,
name|WinAggResultContext
name|result
parameter_list|)
block|{
comment|// Rank is 1-based
return|return
name|Expressions
operator|.
name|add
argument_list|(
name|super
operator|.
name|implementNotNullResult
argument_list|(
name|info
argument_list|,
name|result
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code DENSE_RANK} windowed aggregate function. */
specifier|static
class|class
name|DenseRankImplementor
extends|extends
name|RankImplementor
block|{
annotation|@
name|Override
specifier|protected
name|Expression
name|computeNewRank
parameter_list|(
name|Expression
name|acc
parameter_list|,
name|WinAggAddContext
name|add
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|add
argument_list|(
name|acc
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code FIRST_VALUE} and {@code LAST_VALUE}    * windowed aggregate functions. */
specifier|static
class|class
name|FirstLastValueImplementor
implements|implements
name|WinAggImplementor
block|{
specifier|private
specifier|final
name|SeekType
name|seekType
decl_stmt|;
specifier|protected
name|FirstLastValueImplementor
parameter_list|(
name|SeekType
name|seekType
parameter_list|)
block|{
name|this
operator|.
name|seekType
operator|=
name|seekType
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Type
argument_list|>
name|getStateType
parameter_list|(
name|AggContext
name|info
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
comment|// no op
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
comment|// no op
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|needCacheWhenFrameIntact
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|Expression
name|implementResult
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResultContext
name|result
parameter_list|)
block|{
name|WinAggResultContext
name|winResult
init|=
operator|(
name|WinAggResultContext
operator|)
name|result
decl_stmt|;
return|return
name|Expressions
operator|.
name|condition
argument_list|(
name|winResult
operator|.
name|hasRows
argument_list|()
argument_list|,
name|winResult
operator|.
name|rowTranslator
argument_list|(
name|winResult
operator|.
name|computeIndex
argument_list|(
name|Expressions
operator|.
name|constant
argument_list|(
literal|0
argument_list|)
argument_list|,
name|seekType
argument_list|)
argument_list|)
operator|.
name|translate
argument_list|(
name|winResult
operator|.
name|rexArguments
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|info
operator|.
name|returnType
argument_list|()
argument_list|)
argument_list|,
name|getDefaultValue
argument_list|(
name|info
operator|.
name|returnType
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code FIRST_VALUE} windowed aggregate function. */
specifier|static
class|class
name|FirstValueImplementor
extends|extends
name|FirstLastValueImplementor
block|{
specifier|protected
name|FirstValueImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|SeekType
operator|.
name|START
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Implementor for the {@code LAST_VALUE} windowed aggregate function. */
specifier|static
class|class
name|LastValueImplementor
extends|extends
name|FirstLastValueImplementor
block|{
specifier|protected
name|LastValueImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|SeekType
operator|.
name|END
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Implementor for the {@code NTH_VALUE}    * windowed aggregate function. */
specifier|static
class|class
name|NthValueImplementor
implements|implements
name|WinAggImplementor
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Type
argument_list|>
name|getStateType
parameter_list|(
name|AggContext
name|info
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
comment|// no op
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
comment|// no op
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|needCacheWhenFrameIntact
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|Expression
name|implementResult
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResultContext
name|result
parameter_list|)
block|{
name|WinAggResultContext
name|winResult
init|=
operator|(
name|WinAggResultContext
operator|)
name|result
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexArgs
init|=
name|winResult
operator|.
name|rexArguments
argument_list|()
decl_stmt|;
name|ParameterExpression
name|res
init|=
name|Expressions
operator|.
name|parameter
argument_list|(
literal|0
argument_list|,
name|info
operator|.
name|returnType
argument_list|()
argument_list|,
name|result
operator|.
name|currentBlock
argument_list|()
operator|.
name|newName
argument_list|(
literal|"nth"
argument_list|)
argument_list|)
decl_stmt|;
name|RexToLixTranslator
name|currentRowTranslator
init|=
name|winResult
operator|.
name|rowTranslator
argument_list|(
name|winResult
operator|.
name|computeIndex
argument_list|(
name|Expressions
operator|.
name|constant
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SeekType
operator|.
name|START
argument_list|)
argument_list|)
decl_stmt|;
name|Expression
name|dstIndex
init|=
name|winResult
operator|.
name|computeIndex
argument_list|(
name|Expressions
operator|.
name|subtract
argument_list|(
name|currentRowTranslator
operator|.
name|translate
argument_list|(
name|rexArgs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|int
operator|.
name|class
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|SeekType
operator|.
name|START
argument_list|)
decl_stmt|;
name|Expression
name|rowInRange
init|=
name|winResult
operator|.
name|rowInPartition
argument_list|(
name|dstIndex
argument_list|)
decl_stmt|;
name|BlockBuilder
name|thenBlock
init|=
name|result
operator|.
name|nestBlock
argument_list|()
decl_stmt|;
name|Expression
name|nthValue
init|=
name|winResult
operator|.
name|rowTranslator
argument_list|(
name|dstIndex
argument_list|)
operator|.
name|translate
argument_list|(
name|rexArgs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|res
operator|.
name|type
argument_list|)
decl_stmt|;
name|thenBlock
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|res
argument_list|,
name|nthValue
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|exitBlock
argument_list|()
expr_stmt|;
name|BlockStatement
name|thenBranch
init|=
name|thenBlock
operator|.
name|toBlock
argument_list|()
decl_stmt|;
name|Expression
name|defaultValue
init|=
name|getDefaultValue
argument_list|(
name|res
operator|.
name|type
argument_list|)
decl_stmt|;
name|result
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|declare
argument_list|(
literal|0
argument_list|,
name|res
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|ifThenElse
argument_list|(
name|rowInRange
argument_list|,
name|thenBranch
argument_list|,
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|res
argument_list|,
name|defaultValue
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
comment|/** Implementor for the {@code LEAD} and {@code LAG} windowed    * aggregate functions. */
specifier|static
class|class
name|LeadLagImplementor
implements|implements
name|WinAggImplementor
block|{
specifier|private
specifier|final
name|boolean
name|isLead
decl_stmt|;
specifier|protected
name|LeadLagImplementor
parameter_list|(
name|boolean
name|isLead
parameter_list|)
block|{
name|this
operator|.
name|isLead
operator|=
name|isLead
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Type
argument_list|>
name|getStateType
parameter_list|(
name|AggContext
name|info
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
comment|// no op
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
comment|// no op
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|needCacheWhenFrameIntact
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Expression
name|implementResult
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResultContext
name|result
parameter_list|)
block|{
name|WinAggResultContext
name|winResult
init|=
operator|(
name|WinAggResultContext
operator|)
name|result
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexArgs
init|=
name|winResult
operator|.
name|rexArguments
argument_list|()
decl_stmt|;
name|ParameterExpression
name|res
init|=
name|Expressions
operator|.
name|parameter
argument_list|(
literal|0
argument_list|,
name|info
operator|.
name|returnType
argument_list|()
argument_list|,
name|result
operator|.
name|currentBlock
argument_list|()
operator|.
name|newName
argument_list|(
name|isLead
condition|?
literal|"lead"
else|:
literal|"lag"
argument_list|)
argument_list|)
decl_stmt|;
name|Expression
name|offset
decl_stmt|;
name|RexToLixTranslator
name|currentRowTranslator
init|=
name|winResult
operator|.
name|rowTranslator
argument_list|(
name|winResult
operator|.
name|computeIndex
argument_list|(
name|Expressions
operator|.
name|constant
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SeekType
operator|.
name|SET
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rexArgs
operator|.
name|size
argument_list|()
operator|>=
literal|2
condition|)
block|{
comment|// lead(x, offset) or lead(x, offset, default)
name|offset
operator|=
name|currentRowTranslator
operator|.
name|translate
argument_list|(
name|rexArgs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|int
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|Expressions
operator|.
name|constant
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isLead
condition|)
block|{
name|offset
operator|=
name|Expressions
operator|.
name|negate
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
name|Expression
name|dstIndex
init|=
name|winResult
operator|.
name|computeIndex
argument_list|(
name|offset
argument_list|,
name|SeekType
operator|.
name|SET
argument_list|)
decl_stmt|;
name|Expression
name|rowInRange
init|=
name|winResult
operator|.
name|rowInPartition
argument_list|(
name|dstIndex
argument_list|)
decl_stmt|;
name|BlockBuilder
name|thenBlock
init|=
name|result
operator|.
name|nestBlock
argument_list|()
decl_stmt|;
name|Expression
name|lagResult
init|=
name|winResult
operator|.
name|rowTranslator
argument_list|(
name|dstIndex
argument_list|)
operator|.
name|translate
argument_list|(
name|rexArgs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|res
operator|.
name|type
argument_list|)
decl_stmt|;
name|thenBlock
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|res
argument_list|,
name|lagResult
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|exitBlock
argument_list|()
expr_stmt|;
name|BlockStatement
name|thenBranch
init|=
name|thenBlock
operator|.
name|toBlock
argument_list|()
decl_stmt|;
name|Expression
name|defaultValue
init|=
name|rexArgs
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|?
name|currentRowTranslator
operator|.
name|translate
argument_list|(
name|rexArgs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|,
name|res
operator|.
name|type
argument_list|)
else|:
name|getDefaultValue
argument_list|(
name|res
operator|.
name|type
argument_list|)
decl_stmt|;
name|result
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|declare
argument_list|(
literal|0
argument_list|,
name|res
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|ifThenElse
argument_list|(
name|rowInRange
argument_list|,
name|thenBranch
argument_list|,
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|res
argument_list|,
name|defaultValue
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
comment|/** Implementor for the {@code LEAD} windowed aggregate function. */
specifier|public
specifier|static
class|class
name|LeadImplementor
extends|extends
name|LeadLagImplementor
block|{
specifier|protected
name|LeadImplementor
parameter_list|()
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Implementor for the {@code LAG} windowed aggregate function. */
specifier|public
specifier|static
class|class
name|LagImplementor
extends|extends
name|LeadLagImplementor
block|{
specifier|protected
name|LagImplementor
parameter_list|()
block|{
name|super
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Implementor for the {@code NTILE} windowed aggregate function. */
specifier|static
class|class
name|NtileImplementor
implements|implements
name|WinAggImplementor
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Type
argument_list|>
name|getStateType
parameter_list|(
name|AggContext
name|info
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
comment|// no op
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
comment|// no op
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|needCacheWhenFrameIntact
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Expression
name|implementResult
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResultContext
name|result
parameter_list|)
block|{
name|WinAggResultContext
name|winResult
init|=
operator|(
name|WinAggResultContext
operator|)
name|result
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexArgs
init|=
name|winResult
operator|.
name|rexArguments
argument_list|()
decl_stmt|;
name|Expression
name|tiles
init|=
name|winResult
operator|.
name|rowTranslator
argument_list|(
name|winResult
operator|.
name|index
argument_list|()
argument_list|)
operator|.
name|translate
argument_list|(
name|rexArgs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
name|Expression
name|ntile
init|=
name|Expressions
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|constant
argument_list|(
literal|1
argument_list|)
argument_list|,
name|Expressions
operator|.
name|divide
argument_list|(
name|Expressions
operator|.
name|multiply
argument_list|(
name|tiles
argument_list|,
name|Expressions
operator|.
name|subtract
argument_list|(
name|winResult
operator|.
name|index
argument_list|()
argument_list|,
name|winResult
operator|.
name|startIndex
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|winResult
operator|.
name|getPartitionRowCount
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|ntile
return|;
block|}
block|}
comment|/** Implementor for the {@code ROW_NUMBER} windowed aggregate function. */
specifier|static
class|class
name|RowNumberImplementor
extends|extends
name|StrictWinAggImplementor
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Type
argument_list|>
name|getNotNullState
parameter_list|(
name|WinAggContext
name|info
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|implementNotNullAdd
parameter_list|(
name|WinAggContext
name|info
parameter_list|,
name|WinAggAddContext
name|add
parameter_list|)
block|{
comment|// no op
block|}
annotation|@
name|Override
specifier|protected
name|Expression
name|implementNotNullResult
parameter_list|(
name|WinAggContext
name|info
parameter_list|,
name|WinAggResultContext
name|result
parameter_list|)
block|{
comment|// Window cannot be empty since ROWS/RANGE is not possible for ROW_NUMBER
return|return
name|Expressions
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|subtract
argument_list|(
name|result
operator|.
name|index
argument_list|()
argument_list|,
name|result
operator|.
name|startIndex
argument_list|()
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code JSON_OBJECTAGG} aggregate function. */
specifier|static
class|class
name|JsonObjectAggImplementor
implements|implements
name|AggImplementor
block|{
specifier|private
specifier|final
name|Method
name|m
decl_stmt|;
name|JsonObjectAggImplementor
parameter_list|(
name|Method
name|m
parameter_list|)
block|{
name|this
operator|.
name|m
operator|=
name|m
expr_stmt|;
block|}
specifier|static
name|Supplier
argument_list|<
name|JsonObjectAggImplementor
argument_list|>
name|supplierFor
parameter_list|(
name|Method
name|m
parameter_list|)
block|{
return|return
parameter_list|()
lambda|->
operator|new
name|JsonObjectAggImplementor
argument_list|(
name|m
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Type
argument_list|>
name|getStateType
parameter_list|(
name|AggContext
name|info
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|singletonList
argument_list|(
name|Map
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|reset
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Expressions
operator|.
name|new_
argument_list|(
name|HashMap
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
specifier|final
name|SqlJsonObjectAggAggFunction
name|function
init|=
operator|(
name|SqlJsonObjectAggAggFunction
operator|)
name|info
operator|.
name|aggregation
argument_list|()
decl_stmt|;
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|m
argument_list|,
name|Iterables
operator|.
name|concat
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|add
operator|.
name|arguments
argument_list|()
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|Expressions
operator|.
name|constant
argument_list|(
name|function
operator|.
name|getNullClause
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Expression
name|implementResult
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResultContext
name|result
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|JSONIZE
operator|.
name|method
argument_list|,
name|result
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code JSON_ARRAYAGG} aggregate function. */
specifier|static
class|class
name|JsonArrayAggImplementor
implements|implements
name|AggImplementor
block|{
specifier|private
specifier|final
name|Method
name|m
decl_stmt|;
name|JsonArrayAggImplementor
parameter_list|(
name|Method
name|m
parameter_list|)
block|{
name|this
operator|.
name|m
operator|=
name|m
expr_stmt|;
block|}
specifier|static
name|Supplier
argument_list|<
name|JsonArrayAggImplementor
argument_list|>
name|supplierFor
parameter_list|(
name|Method
name|m
parameter_list|)
block|{
return|return
parameter_list|()
lambda|->
operator|new
name|JsonArrayAggImplementor
argument_list|(
name|m
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Type
argument_list|>
name|getStateType
parameter_list|(
name|AggContext
name|info
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|singletonList
argument_list|(
name|List
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementReset
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResetContext
name|reset
parameter_list|)
block|{
name|reset
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|assign
argument_list|(
name|reset
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Expressions
operator|.
name|new_
argument_list|(
name|ArrayList
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|implementAdd
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggAddContext
name|add
parameter_list|)
block|{
specifier|final
name|SqlJsonArrayAggAggFunction
name|function
init|=
operator|(
name|SqlJsonArrayAggAggFunction
operator|)
name|info
operator|.
name|aggregation
argument_list|()
decl_stmt|;
name|add
operator|.
name|currentBlock
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|m
argument_list|,
name|Iterables
operator|.
name|concat
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|add
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|add
operator|.
name|arguments
argument_list|()
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|Expressions
operator|.
name|constant
argument_list|(
name|function
operator|.
name|getNullClause
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Expression
name|implementResult
parameter_list|(
name|AggContext
name|info
parameter_list|,
name|AggResultContext
name|result
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|JSONIZE
operator|.
name|method
argument_list|,
name|result
operator|.
name|accumulator
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code TRIM} function. */
specifier|private
specifier|static
class|class
name|TrimImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|TrimImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"trim"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
specifier|final
name|boolean
name|strict
init|=
operator|!
name|translator
operator|.
name|conformance
operator|.
name|allowExtendedTrim
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|value
init|=
name|translator
operator|.
name|getLiteralValue
argument_list|(
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|SqlTrimFunction
operator|.
name|Flag
name|flag
init|=
operator|(
name|SqlTrimFunction
operator|.
name|Flag
operator|)
name|value
decl_stmt|;
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|TRIM
operator|.
name|method
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|flag
operator|==
name|SqlTrimFunction
operator|.
name|Flag
operator|.
name|BOTH
operator|||
name|flag
operator|==
name|SqlTrimFunction
operator|.
name|Flag
operator|.
name|LEADING
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|flag
operator|==
name|SqlTrimFunction
operator|.
name|Flag
operator|.
name|BOTH
operator|||
name|flag
operator|==
name|SqlTrimFunction
operator|.
name|Flag
operator|.
name|TRAILING
argument_list|)
argument_list|,
name|argValueList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|argValueList
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|strict
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code MONTHNAME} and {@code DAYNAME} functions.    * Each takes a {@link java.util.Locale} argument. */
specifier|private
specifier|static
class|class
name|PeriodNameImplementor
extends|extends
name|MethodNameImplementor
block|{
specifier|private
specifier|final
name|BuiltInMethod
name|timestampMethod
decl_stmt|;
specifier|private
specifier|final
name|BuiltInMethod
name|dateMethod
decl_stmt|;
name|PeriodNameImplementor
parameter_list|(
name|String
name|methodName
parameter_list|,
name|BuiltInMethod
name|timestampMethod
parameter_list|,
name|BuiltInMethod
name|dateMethod
parameter_list|)
block|{
name|super
argument_list|(
name|methodName
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|timestampMethod
operator|=
name|timestampMethod
expr_stmt|;
name|this
operator|.
name|dateMethod
operator|=
name|dateMethod
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"periodName"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
name|Expression
name|operand
init|=
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|TIMESTAMP
case|:
return|return
name|getExpression
argument_list|(
name|translator
argument_list|,
name|operand
argument_list|,
name|timestampMethod
argument_list|)
return|;
case|case
name|DATE
case|:
return|return
name|getExpression
argument_list|(
name|translator
argument_list|,
name|operand
argument_list|,
name|dateMethod
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unknown type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|Expression
name|getExpression
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|Expression
name|operand
parameter_list|,
name|BuiltInMethod
name|builtInMethod
parameter_list|)
block|{
specifier|final
name|MethodCallExpression
name|locale
init|=
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|LOCALE
operator|.
name|method
argument_list|,
name|translator
operator|.
name|getRoot
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|builtInMethod
operator|.
name|method
operator|.
name|getDeclaringClass
argument_list|()
argument_list|,
name|builtInMethod
operator|.
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|operand
argument_list|,
name|locale
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code FLOOR} and {@code CEIL} functions. */
specifier|private
specifier|static
class|class
name|FloorImplementor
extends|extends
name|MethodNameImplementor
block|{
specifier|final
name|Method
name|timestampMethod
decl_stmt|;
specifier|final
name|Method
name|dateMethod
decl_stmt|;
name|FloorImplementor
parameter_list|(
name|String
name|methodName
parameter_list|,
name|Method
name|timestampMethod
parameter_list|,
name|Method
name|dateMethod
parameter_list|)
block|{
name|super
argument_list|(
name|methodName
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|timestampMethod
operator|=
name|timestampMethod
expr_stmt|;
name|this
operator|.
name|dateMethod
operator|=
name|dateMethod
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"floor"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
switch|switch
condition|(
name|call
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|BIGINT
case|:
case|case
name|INTEGER
case|:
case|case
name|SMALLINT
case|:
case|case
name|TINYINT
case|:
return|return
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
default|default:
return|return
name|super
operator|.
name|implementSafe
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
case|case
literal|2
case|:
specifier|final
name|Type
name|type
decl_stmt|;
specifier|final
name|Method
name|floorMethod
decl_stmt|;
specifier|final
name|boolean
name|preFloor
decl_stmt|;
name|Expression
name|operand
init|=
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|call
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
case|:
name|operand
operator|=
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP
operator|.
name|method
argument_list|,
name|operand
argument_list|,
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|TIME_ZONE
operator|.
name|method
argument_list|,
name|translator
operator|.
name|getRoot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// fall through
case|case
name|TIMESTAMP
case|:
name|type
operator|=
name|long
operator|.
name|class
expr_stmt|;
name|floorMethod
operator|=
name|timestampMethod
expr_stmt|;
name|preFloor
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|int
operator|.
name|class
expr_stmt|;
name|floorMethod
operator|=
name|dateMethod
expr_stmt|;
name|preFloor
operator|=
literal|false
expr_stmt|;
block|}
specifier|final
name|TimeUnitRange
name|timeUnitRange
init|=
operator|(
name|TimeUnitRange
operator|)
name|requireNonNull
argument_list|(
name|translator
operator|.
name|getLiteralValue
argument_list|(
name|argValueList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|"timeUnitRange"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|timeUnitRange
condition|)
block|{
case|case
name|YEAR
case|:
case|case
name|QUARTER
case|:
case|case
name|MONTH
case|:
case|case
name|WEEK
case|:
case|case
name|DAY
case|:
specifier|final
name|Expression
name|operand1
init|=
name|preFloor
condition|?
name|call
argument_list|(
name|operand
argument_list|,
name|type
argument_list|,
name|TimeUnit
operator|.
name|DAY
argument_list|)
else|:
name|operand
decl_stmt|;
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|floorMethod
argument_list|,
name|translator
operator|.
name|getLiteral
argument_list|(
name|argValueList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|operand1
argument_list|)
return|;
case|case
name|NANOSECOND
case|:
default|default:
return|return
name|call
argument_list|(
name|operand
argument_list|,
name|type
argument_list|,
name|timeUnitRange
operator|.
name|startUnit
argument_list|)
return|;
block|}
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
specifier|private
name|Expression
name|call
parameter_list|(
name|Expression
name|operand
parameter_list|,
name|Type
name|type
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|SqlFunctions
operator|.
name|class
argument_list|,
name|methodName
argument_list|,
name|EnumUtils
operator|.
name|convert
argument_list|(
name|operand
argument_list|,
name|type
argument_list|)
argument_list|,
name|EnumUtils
operator|.
name|convert
argument_list|(
name|Expressions
operator|.
name|constant
argument_list|(
name|timeUnit
operator|.
name|multiplier
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for a function that generates calls to a given method. */
specifier|private
specifier|static
class|class
name|MethodImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
specifier|protected
specifier|final
name|Method
name|method
decl_stmt|;
name|MethodImplementor
parameter_list|(
name|Method
name|method
parameter_list|,
annotation|@
name|Nullable
name|NullPolicy
name|nullPolicy
parameter_list|,
name|boolean
name|harmonize
parameter_list|)
block|{
name|super
argument_list|(
name|nullPolicy
argument_list|,
name|harmonize
argument_list|)
expr_stmt|;
name|this
operator|.
name|method
operator|=
name|method
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"method_call"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
if|if
condition|(
name|Modifier
operator|.
name|isStatic
argument_list|(
name|method
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|call
argument_list|(
name|method
argument_list|,
literal|null
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|call
argument_list|(
name|method
argument_list|,
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Util
operator|.
name|skip
argument_list|(
name|argValueList
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|static
name|Expression
name|call
parameter_list|(
name|Method
name|method
parameter_list|,
annotation|@
name|Nullable
name|Expression
name|target
parameter_list|,
name|List
argument_list|<
name|Expression
argument_list|>
name|args
parameter_list|)
block|{
if|if
condition|(
name|method
operator|.
name|isVarArgs
argument_list|()
condition|)
block|{
specifier|final
name|int
name|last
init|=
name|method
operator|.
name|getParameterCount
argument_list|()
operator|-
literal|1
decl_stmt|;
name|ImmutableList
argument_list|<
name|Expression
argument_list|>
name|vargs
init|=
name|ImmutableList
operator|.
expr|<
name|Expression
operator|>
name|builder
argument_list|()
operator|.
name|addAll
argument_list|(
name|args
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|last
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|newArrayInit
argument_list|(
name|method
operator|.
name|getParameterTypes
argument_list|()
index|[
name|last
index|]
argument_list|,
name|args
operator|.
name|subList
argument_list|(
name|last
argument_list|,
name|args
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|toArray
argument_list|(
operator|new
name|Expression
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|target
argument_list|,
name|method
argument_list|,
name|vargs
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|method
operator|.
name|getDeclaringClass
argument_list|()
decl_stmt|;
return|return
name|EnumUtils
operator|.
name|call
argument_list|(
name|target
argument_list|,
name|clazz
argument_list|,
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|args
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Implementor for {@link org.apache.calcite.sql.fun.SqlPosixRegexOperator}s. */
specifier|private
specifier|static
class|class
name|PosixRegexMethodImplementor
extends|extends
name|MethodImplementor
block|{
specifier|protected
specifier|final
name|boolean
name|caseSensitive
decl_stmt|;
name|PosixRegexMethodImplementor
parameter_list|(
name|boolean
name|caseSensitive
parameter_list|)
block|{
name|super
argument_list|(
name|BuiltInMethod
operator|.
name|POSIX_REGEX
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|caseSensitive
operator|=
name|caseSensitive
expr_stmt|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
assert|assert
name|argValueList
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
comment|// Add extra parameter (caseSensitive boolean flag), required by SqlFunctions#posixRegex.
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|newOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|argValueList
argument_list|)
decl_stmt|;
name|newOperands
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|constant
argument_list|(
name|caseSensitive
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|implementSafe
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|newOperands
argument_list|)
return|;
block|}
block|}
comment|/**    * Implementor for JSON_VALUE function, convert to solid format    * "JSON_VALUE(json_doc, path, empty_behavior, empty_default, error_behavior, error default)"    * in order to simplify the runtime implementation.    *    *<p>We should avoid this when we support    * variable arguments function.    */
specifier|private
specifier|static
class|class
name|JsonValueImplementor
extends|extends
name|MethodImplementor
block|{
name|JsonValueImplementor
parameter_list|(
name|Method
name|method
parameter_list|)
block|{
name|super
argument_list|(
name|method
argument_list|,
name|NullPolicy
operator|.
name|ARG0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
specifier|final
name|Expression
name|expression
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|newOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|newOperands
operator|.
name|add
argument_list|(
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|newOperands
operator|.
name|add
argument_list|(
name|argValueList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Expression
argument_list|>
name|leftExprs
init|=
name|Util
operator|.
name|skip
argument_list|(
name|argValueList
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|// Default value for JSON_VALUE behaviors.
name|Expression
name|emptyBehavior
init|=
name|Expressions
operator|.
name|constant
argument_list|(
name|SqlJsonValueEmptyOrErrorBehavior
operator|.
name|NULL
argument_list|)
decl_stmt|;
name|Expression
name|defaultValueOnEmpty
init|=
name|Expressions
operator|.
name|constant
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Expression
name|errorBehavior
init|=
name|Expressions
operator|.
name|constant
argument_list|(
name|SqlJsonValueEmptyOrErrorBehavior
operator|.
name|NULL
argument_list|)
decl_stmt|;
name|Expression
name|defaultValueOnError
init|=
name|Expressions
operator|.
name|constant
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|// Patched up with user defines.
if|if
condition|(
name|leftExprs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Expression
name|expr
init|=
name|leftExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|exprVal
init|=
name|translator
operator|.
name|getLiteralValue
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprVal
operator|!=
literal|null
condition|)
block|{
name|int
name|defaultSymbolIdx
init|=
name|i
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|exprVal
operator|==
name|SqlJsonEmptyOrError
operator|.
name|EMPTY
condition|)
block|{
if|if
condition|(
name|defaultSymbolIdx
operator|>=
literal|0
operator|&&
name|translator
operator|.
name|getLiteralValue
argument_list|(
name|leftExprs
operator|.
name|get
argument_list|(
name|defaultSymbolIdx
argument_list|)
argument_list|)
operator|==
name|SqlJsonValueEmptyOrErrorBehavior
operator|.
name|DEFAULT
condition|)
block|{
name|defaultValueOnEmpty
operator|=
name|leftExprs
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|emptyBehavior
operator|=
name|leftExprs
operator|.
name|get
argument_list|(
name|defaultSymbolIdx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emptyBehavior
operator|=
name|leftExprs
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|exprVal
operator|==
name|SqlJsonEmptyOrError
operator|.
name|ERROR
condition|)
block|{
if|if
condition|(
name|defaultSymbolIdx
operator|>=
literal|0
operator|&&
name|translator
operator|.
name|getLiteralValue
argument_list|(
name|leftExprs
operator|.
name|get
argument_list|(
name|defaultSymbolIdx
argument_list|)
argument_list|)
operator|==
name|SqlJsonValueEmptyOrErrorBehavior
operator|.
name|DEFAULT
condition|)
block|{
name|defaultValueOnError
operator|=
name|leftExprs
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|errorBehavior
operator|=
name|leftExprs
operator|.
name|get
argument_list|(
name|defaultSymbolIdx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errorBehavior
operator|=
name|leftExprs
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|newOperands
operator|.
name|add
argument_list|(
name|emptyBehavior
argument_list|)
expr_stmt|;
name|newOperands
operator|.
name|add
argument_list|(
name|defaultValueOnEmpty
argument_list|)
expr_stmt|;
name|newOperands
operator|.
name|add
argument_list|(
name|errorBehavior
argument_list|)
expr_stmt|;
name|newOperands
operator|.
name|add
argument_list|(
name|defaultValueOnError
argument_list|)
expr_stmt|;
name|Class
name|clazz
init|=
name|method
operator|.
name|getDeclaringClass
argument_list|()
decl_stmt|;
name|expression
operator|=
name|EnumUtils
operator|.
name|call
argument_list|(
literal|null
argument_list|,
name|clazz
argument_list|,
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|newOperands
argument_list|)
expr_stmt|;
specifier|final
name|Type
name|returnType
init|=
name|translator
operator|.
name|typeFactory
operator|.
name|getJavaClass
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|EnumUtils
operator|.
name|convert
argument_list|(
name|expression
argument_list|,
name|returnType
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for SQL functions that generates calls to a given method name.    *    *<p>Use this, as opposed to {@link MethodImplementor}, if the SQL function    * is overloaded; then you can use one implementor for several overloads. */
specifier|private
specifier|static
class|class
name|MethodNameImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
specifier|protected
specifier|final
name|String
name|methodName
decl_stmt|;
name|MethodNameImplementor
parameter_list|(
name|String
name|methodName
parameter_list|,
name|NullPolicy
name|nullPolicy
parameter_list|,
name|boolean
name|harmonize
parameter_list|)
block|{
name|super
argument_list|(
name|nullPolicy
argument_list|,
name|harmonize
argument_list|)
expr_stmt|;
name|this
operator|.
name|methodName
operator|=
name|methodName
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"method_name_call"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|EnumUtils
operator|.
name|call
argument_list|(
literal|null
argument_list|,
name|SqlFunctions
operator|.
name|class
argument_list|,
name|methodName
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for binary operators. */
specifier|private
specifier|static
class|class
name|BinaryImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
comment|/** Types that can be arguments to comparison operators such as      * {@code<}. */
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|Primitive
argument_list|>
name|COMP_OP_TYPES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|Primitive
operator|.
name|BYTE
argument_list|,
name|Primitive
operator|.
name|CHAR
argument_list|,
name|Primitive
operator|.
name|SHORT
argument_list|,
name|Primitive
operator|.
name|INT
argument_list|,
name|Primitive
operator|.
name|LONG
argument_list|,
name|Primitive
operator|.
name|FLOAT
argument_list|,
name|Primitive
operator|.
name|DOUBLE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|SqlBinaryOperator
argument_list|>
name|COMPARISON_OPERATORS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
argument_list|,
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|SqlBinaryOperator
argument_list|>
name|EQUALS_OPERATORS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|METHOD_POSTFIX_FOR_ANY_TYPE
init|=
literal|"Any"
decl_stmt|;
specifier|private
specifier|final
name|ExpressionType
name|expressionType
decl_stmt|;
specifier|private
specifier|final
name|String
name|backupMethodName
decl_stmt|;
name|BinaryImplementor
parameter_list|(
name|NullPolicy
name|nullPolicy
parameter_list|,
name|boolean
name|harmonize
parameter_list|,
name|ExpressionType
name|expressionType
parameter_list|,
name|String
name|backupMethodName
parameter_list|)
block|{
name|super
argument_list|(
name|nullPolicy
argument_list|,
name|harmonize
argument_list|)
expr_stmt|;
name|this
operator|.
name|expressionType
operator|=
name|expressionType
expr_stmt|;
name|this
operator|.
name|backupMethodName
operator|=
name|backupMethodName
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"binary_call"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
comment|// neither nullable:
comment|//   return x OP y
comment|// x nullable
comment|//   null_returns_null
comment|//     return x == null ? null : x OP y
comment|//   ignore_null
comment|//     return x == null ? null : y
comment|// x, y both nullable
comment|//   null_returns_null
comment|//     return x == null || y == null ? null : x OP y
comment|//   ignore_null
comment|//     return x == null ? y : y == null ? x : x OP y
if|if
condition|(
name|backupMethodName
operator|!=
literal|null
condition|)
block|{
comment|// If one or both operands have ANY type, use the late-binding backup
comment|// method.
if|if
condition|(
name|anyAnyOperands
argument_list|(
name|call
argument_list|)
condition|)
block|{
return|return
name|callBackupMethodAnyType
argument_list|(
name|argValueList
argument_list|)
return|;
block|}
specifier|final
name|Type
name|type0
init|=
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|Type
name|type1
init|=
name|argValueList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|SqlBinaryOperator
name|op
init|=
operator|(
name|SqlBinaryOperator
operator|)
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|relDataType0
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|Expression
name|fieldComparator
init|=
name|generateCollatorExpression
argument_list|(
name|relDataType0
operator|.
name|getCollation
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldComparator
operator|!=
literal|null
condition|)
block|{
name|argValueList
operator|.
name|add
argument_list|(
name|fieldComparator
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Primitive
name|primitive
init|=
name|Primitive
operator|.
name|ofBoxOr
argument_list|(
name|type0
argument_list|)
decl_stmt|;
if|if
condition|(
name|primitive
operator|==
literal|null
operator|||
name|type1
operator|==
name|BigDecimal
operator|.
name|class
operator|||
name|COMPARISON_OPERATORS
operator|.
name|contains
argument_list|(
name|op
argument_list|)
operator|&&
operator|!
name|COMP_OP_TYPES
operator|.
name|contains
argument_list|(
name|primitive
argument_list|)
condition|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|SqlFunctions
operator|.
name|class
argument_list|,
name|backupMethodName
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
comment|// When checking equals or not equals on two primitive boxing classes
comment|// (i.e. Long x, Long y), we should fall back to call `SqlFunctions.eq(x, y)`
comment|// or `SqlFunctions.ne(x, y)`, rather than `x == y`
specifier|final
name|Primitive
name|boxPrimitive0
init|=
name|Primitive
operator|.
name|ofBox
argument_list|(
name|type0
argument_list|)
decl_stmt|;
specifier|final
name|Primitive
name|boxPrimitive1
init|=
name|Primitive
operator|.
name|ofBox
argument_list|(
name|type1
argument_list|)
decl_stmt|;
if|if
condition|(
name|EQUALS_OPERATORS
operator|.
name|contains
argument_list|(
name|op
argument_list|)
operator|&&
name|boxPrimitive0
operator|!=
literal|null
operator|&&
name|boxPrimitive1
operator|!=
literal|null
condition|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|SqlFunctions
operator|.
name|class
argument_list|,
name|backupMethodName
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
block|}
return|return
name|Expressions
operator|.
name|makeBinary
argument_list|(
name|expressionType
argument_list|,
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|argValueList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns whether any of a call's operands have ANY type. */
specifier|private
specifier|static
name|boolean
name|anyAnyOperands
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|operands
control|)
block|{
if|if
condition|(
name|operand
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|Expression
name|callBackupMethodAnyType
parameter_list|(
name|List
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
specifier|final
name|String
name|backupMethodNameForAnyType
init|=
name|backupMethodName
operator|+
name|METHOD_POSTFIX_FOR_ANY_TYPE
decl_stmt|;
comment|// one or both of parameter(s) is(are) ANY type
specifier|final
name|Expression
name|expression0
init|=
name|maybeBox
argument_list|(
name|expressions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|expression1
init|=
name|maybeBox
argument_list|(
name|expressions
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|SqlFunctions
operator|.
name|class
argument_list|,
name|backupMethodNameForAnyType
argument_list|,
name|expression0
argument_list|,
name|expression1
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Expression
name|maybeBox
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
specifier|final
name|Primitive
name|primitive
init|=
name|Primitive
operator|.
name|of
argument_list|(
name|expression
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|primitive
operator|!=
literal|null
condition|)
block|{
name|expression
operator|=
name|Expressions
operator|.
name|box
argument_list|(
name|expression
argument_list|,
name|primitive
argument_list|)
expr_stmt|;
block|}
return|return
name|expression
return|;
block|}
block|}
comment|/** Implementor for unary operators. */
specifier|private
specifier|static
class|class
name|UnaryImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
specifier|private
specifier|final
name|ExpressionType
name|expressionType
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|String
name|backupMethodName
decl_stmt|;
name|UnaryImplementor
parameter_list|(
name|ExpressionType
name|expressionType
parameter_list|,
name|NullPolicy
name|nullPolicy
parameter_list|,
annotation|@
name|Nullable
name|String
name|backupMethodName
parameter_list|)
block|{
name|super
argument_list|(
name|nullPolicy
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|expressionType
operator|=
name|expressionType
expr_stmt|;
name|this
operator|.
name|backupMethodName
operator|=
name|backupMethodName
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"unary_call"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
specifier|final
name|Expression
name|argValue
init|=
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|e
decl_stmt|;
comment|//Special case for implementing unary minus with BigDecimal type
comment|//for other data type(except BigDecimal) '-' operator is OK, but for
comment|//BigDecimal, we should call negate method of BigDecimal
if|if
condition|(
name|expressionType
operator|==
name|ExpressionType
operator|.
name|Negate
operator|&&
name|argValue
operator|.
name|type
operator|==
name|BigDecimal
operator|.
name|class
operator|&&
literal|null
operator|!=
name|backupMethodName
condition|)
block|{
name|e
operator|=
name|Expressions
operator|.
name|call
argument_list|(
name|argValue
argument_list|,
name|backupMethodName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|Expressions
operator|.
name|makeUnary
argument_list|(
name|expressionType
argument_list|,
name|argValue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|.
name|type
operator|.
name|equals
argument_list|(
name|argValue
operator|.
name|type
argument_list|)
condition|)
block|{
return|return
name|e
return|;
block|}
comment|// Certain unary operators do not preserve type. For example, the "-"
comment|// operator applied to a "byte" expression returns an "int".
return|return
name|Expressions
operator|.
name|convert_
argument_list|(
name|e
argument_list|,
name|argValue
operator|.
name|type
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code EXTRACT(unit FROM datetime)} function. */
specifier|private
specifier|static
class|class
name|ExtractImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|ExtractImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"extract"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
specifier|final
name|TimeUnitRange
name|timeUnitRange
init|=
operator|(
name|TimeUnitRange
operator|)
name|translator
operator|.
name|getLiteralValue
argument_list|(
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|TimeUnit
name|unit
init|=
name|requireNonNull
argument_list|(
name|timeUnitRange
argument_list|,
literal|"timeUnitRange"
argument_list|)
operator|.
name|startUnit
decl_stmt|;
name|Expression
name|operand
init|=
name|argValueList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|SqlTypeName
name|sqlTypeName
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|MILLENNIUM
case|:
case|case
name|CENTURY
case|:
case|case
name|YEAR
case|:
case|case
name|QUARTER
case|:
case|case
name|MONTH
case|:
case|case
name|DAY
case|:
case|case
name|DOW
case|:
case|case
name|DECADE
case|:
case|case
name|DOY
case|:
case|case
name|ISODOW
case|:
case|case
name|ISOYEAR
case|:
case|case
name|WEEK
case|:
switch|switch
condition|(
name|sqlTypeName
condition|)
block|{
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
break|break;
case|case
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
case|:
name|operand
operator|=
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP
operator|.
name|method
argument_list|,
name|operand
argument_list|,
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|TIME_ZONE
operator|.
name|method
argument_list|,
name|translator
operator|.
name|getRoot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// fall through
case|case
name|TIMESTAMP
case|:
name|operand
operator|=
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|FLOOR_DIV
operator|.
name|method
argument_list|,
name|operand
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|TimeUnit
operator|.
name|DAY
operator|.
name|multiplier
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// fall through
case|case
name|DATE
case|:
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|UNIX_DATE_EXTRACT
operator|.
name|method
argument_list|,
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected "
operator|+
name|sqlTypeName
argument_list|)
throw|;
block|}
break|break;
case|case
name|MILLISECOND
case|:
case|case
name|MICROSECOND
case|:
case|case
name|NANOSECOND
case|:
if|if
condition|(
name|sqlTypeName
operator|==
name|SqlTypeName
operator|.
name|DATE
condition|)
block|{
return|return
name|Expressions
operator|.
name|constant
argument_list|(
literal|0L
argument_list|)
return|;
block|}
name|operand
operator|=
name|mod
argument_list|(
name|operand
argument_list|,
name|TimeUnit
operator|.
name|MINUTE
operator|.
name|multiplier
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Expressions
operator|.
name|multiply
argument_list|(
name|operand
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
operator|(
name|long
operator|)
operator|(
literal|1
operator|/
name|unit
operator|.
name|multiplier
operator|.
name|doubleValue
argument_list|()
operator|)
argument_list|)
argument_list|)
return|;
case|case
name|EPOCH
case|:
switch|switch
condition|(
name|sqlTypeName
condition|)
block|{
case|case
name|DATE
case|:
comment|// convert to milliseconds
name|operand
operator|=
name|Expressions
operator|.
name|multiply
argument_list|(
name|operand
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|TimeUnit
operator|.
name|DAY
operator|.
name|multiplier
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// fall through
case|case
name|TIMESTAMP
case|:
comment|// convert to seconds
return|return
name|Expressions
operator|.
name|divide
argument_list|(
name|operand
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|TimeUnit
operator|.
name|SECOND
operator|.
name|multiplier
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
case|:
name|operand
operator|=
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP
operator|.
name|method
argument_list|,
name|operand
argument_list|,
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|TIME_ZONE
operator|.
name|method
argument_list|,
name|translator
operator|.
name|getRoot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Expressions
operator|.
name|divide
argument_list|(
name|operand
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|TimeUnit
operator|.
name|SECOND
operator|.
name|multiplier
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
comment|// no convertlet conversion, pass it as extract
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected "
operator|+
name|sqlTypeName
argument_list|)
throw|;
default|default:
break|break;
block|}
break|break;
case|case
name|HOUR
case|:
case|case
name|MINUTE
case|:
case|case
name|SECOND
case|:
switch|switch
condition|(
name|sqlTypeName
condition|)
block|{
case|case
name|DATE
case|:
return|return
name|Expressions
operator|.
name|multiply
argument_list|(
name|operand
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|0L
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
break|break;
block|}
name|operand
operator|=
name|mod
argument_list|(
name|operand
argument_list|,
name|getFactor
argument_list|(
name|unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|TimeUnit
operator|.
name|QUARTER
condition|)
block|{
name|operand
operator|=
name|Expressions
operator|.
name|subtract
argument_list|(
name|operand
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|1L
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|operand
operator|=
name|Expressions
operator|.
name|divide
argument_list|(
name|operand
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|unit
operator|.
name|multiplier
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|TimeUnit
operator|.
name|QUARTER
condition|)
block|{
name|operand
operator|=
name|Expressions
operator|.
name|add
argument_list|(
name|operand
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|1L
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|operand
return|;
block|}
block|}
specifier|private
specifier|static
name|Expression
name|mod
parameter_list|(
name|Expression
name|operand
parameter_list|,
name|long
name|factor
parameter_list|)
block|{
if|if
condition|(
name|factor
operator|==
literal|1L
condition|)
block|{
return|return
name|operand
return|;
block|}
else|else
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|FLOOR_MOD
operator|.
name|method
argument_list|,
name|operand
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|factor
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|long
name|getFactor
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
block|{
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|DAY
case|:
return|return
literal|1L
return|;
case|case
name|HOUR
case|:
return|return
name|TimeUnit
operator|.
name|DAY
operator|.
name|multiplier
operator|.
name|longValue
argument_list|()
return|;
case|case
name|MINUTE
case|:
return|return
name|TimeUnit
operator|.
name|HOUR
operator|.
name|multiplier
operator|.
name|longValue
argument_list|()
return|;
case|case
name|SECOND
case|:
return|return
name|TimeUnit
operator|.
name|MINUTE
operator|.
name|multiplier
operator|.
name|longValue
argument_list|()
return|;
case|case
name|MILLISECOND
case|:
return|return
name|TimeUnit
operator|.
name|SECOND
operator|.
name|multiplier
operator|.
name|longValue
argument_list|()
return|;
case|case
name|MONTH
case|:
return|return
name|TimeUnit
operator|.
name|YEAR
operator|.
name|multiplier
operator|.
name|longValue
argument_list|()
return|;
case|case
name|QUARTER
case|:
return|return
name|TimeUnit
operator|.
name|YEAR
operator|.
name|multiplier
operator|.
name|longValue
argument_list|()
return|;
case|case
name|YEAR
case|:
case|case
name|DECADE
case|:
case|case
name|CENTURY
case|:
case|case
name|MILLENNIUM
case|:
return|return
literal|1L
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|unit
argument_list|)
throw|;
block|}
block|}
comment|/** Implementor for the SQL {@code COALESCE} operator. */
specifier|private
specifier|static
class|class
name|CoalesceImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|CoalesceImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"coalesce"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|implementRecurse
argument_list|(
name|translator
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Expression
name|implementRecurse
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
if|if
condition|(
name|argValueList
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Expressions
operator|.
name|condition
argument_list|(
name|translator
operator|.
name|checkNotNull
argument_list|(
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|implementRecurse
argument_list|(
name|translator
argument_list|,
name|Util
operator|.
name|skip
argument_list|(
name|argValueList
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Implementor for the SQL {@code CAST} operator. */
specifier|private
specifier|static
class|class
name|CastImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|CastImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"cast"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|RelDataType
name|sourceType
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
comment|// Short-circuit if no cast is required
name|RexNode
name|arg
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|sourceType
argument_list|)
condition|)
block|{
comment|// No cast required, omit cast
return|return
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|SqlTypeUtil
operator|.
name|equalSansNullability
argument_list|(
name|translator
operator|.
name|typeFactory
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|arg
operator|.
name|getType
argument_list|()
argument_list|)
operator|&&
name|translator
operator|.
name|deref
argument_list|(
name|arg
argument_list|)
operator|instanceof
name|RexLiteral
condition|)
block|{
return|return
name|RexToLixTranslator
operator|.
name|translateLiteral
argument_list|(
operator|(
name|RexLiteral
operator|)
name|translator
operator|.
name|deref
argument_list|(
name|arg
argument_list|)
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|translator
operator|.
name|typeFactory
argument_list|,
name|NullAs
operator|.
name|NULL
argument_list|)
return|;
block|}
specifier|final
name|RelDataType
name|targetType
init|=
name|nullifyType
argument_list|(
name|translator
operator|.
name|typeFactory
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|translator
operator|.
name|translateCast
argument_list|(
name|sourceType
argument_list|,
name|targetType
argument_list|,
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RelDataType
name|nullifyType
parameter_list|(
name|JavaTypeFactory
name|typeFactory
parameter_list|,
specifier|final
name|RelDataType
name|type
parameter_list|,
specifier|final
name|boolean
name|nullable
parameter_list|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|RelDataTypeFactoryImpl
operator|.
name|JavaType
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|javaClass
init|=
operator|(
operator|(
name|RelDataTypeFactoryImpl
operator|.
name|JavaType
operator|)
name|type
operator|)
operator|.
name|getJavaClass
argument_list|()
decl_stmt|;
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|primitive
init|=
name|Primitive
operator|.
name|unbox
argument_list|(
name|javaClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|primitive
operator|!=
name|javaClass
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createJavaType
argument_list|(
name|primitive
argument_list|)
return|;
block|}
block|}
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|nullable
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code REINTERPRET} internal SQL operator. */
specifier|private
specifier|static
class|class
name|ReinterpretImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|ReinterpretImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"reInterpret"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
return|return
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for a array concat. */
specifier|private
specifier|static
class|class
name|ArrayConcatImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|ArrayConcatImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"array_concat"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
specifier|final
name|BlockBuilder
name|blockBuilder
init|=
name|translator
operator|.
name|getBlockBuilder
argument_list|()
decl_stmt|;
specifier|final
name|Expression
name|list
init|=
name|blockBuilder
operator|.
name|append
argument_list|(
literal|"list"
argument_list|,
name|Expressions
operator|.
name|new_
argument_list|(
name|ArrayList
operator|.
name|class
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|nullValue
init|=
name|Expressions
operator|.
name|constant
argument_list|(
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|Expression
name|expression
range|:
name|argValueList
control|)
block|{
name|blockBuilder
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|ifThenElse
argument_list|(
name|Expressions
operator|.
name|or
argument_list|(
name|Expressions
operator|.
name|equal
argument_list|(
name|nullValue
argument_list|,
name|list
argument_list|)
argument_list|,
name|Expressions
operator|.
name|equal
argument_list|(
name|nullValue
argument_list|,
name|expression
argument_list|)
argument_list|)
argument_list|,
name|Expressions
operator|.
name|assign
argument_list|(
name|list
argument_list|,
name|nullValue
argument_list|)
argument_list|,
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|list
argument_list|,
name|BuiltInMethod
operator|.
name|COLLECTION_ADDALL
operator|.
name|method
argument_list|,
name|expression
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
block|}
comment|/** Implementor for a array or string concat. */
specifier|private
specifier|static
class|class
name|ConcatImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
specifier|private
name|ArrayConcatImplementor
name|arrayConcatImplementor
init|=
operator|new
name|ArrayConcatImplementor
argument_list|()
decl_stmt|;
specifier|private
name|MethodImplementor
name|stringConcatImplementor
init|=
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|STRING_CONCAT
operator|.
name|method
argument_list|,
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|ConcatImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"concat"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ARRAY
condition|)
block|{
return|return
name|arrayConcatImplementor
operator|.
name|implementSafe
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
return|return
name|stringConcatImplementor
operator|.
name|implementSafe
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for a value-constructor. */
specifier|private
specifier|static
class|class
name|ValueConstructorImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|ValueConstructorImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"value_constructor"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
name|SqlKind
name|kind
init|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
decl_stmt|;
specifier|final
name|BlockBuilder
name|blockBuilder
init|=
name|translator
operator|.
name|getBlockBuilder
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|MAP_VALUE_CONSTRUCTOR
case|:
name|Expression
name|map
init|=
name|blockBuilder
operator|.
name|append
argument_list|(
literal|"map"
argument_list|,
name|Expressions
operator|.
name|new_
argument_list|(
name|LinkedHashMap
operator|.
name|class
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argValueList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Expression
name|key
init|=
name|argValueList
operator|.
name|get
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
name|Expression
name|value
init|=
name|argValueList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|blockBuilder
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|map
argument_list|,
name|BuiltInMethod
operator|.
name|MAP_PUT
operator|.
name|method
argument_list|,
name|Expressions
operator|.
name|box
argument_list|(
name|key
argument_list|)
argument_list|,
name|Expressions
operator|.
name|box
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
case|case
name|ARRAY_VALUE_CONSTRUCTOR
case|:
name|Expression
name|lyst
init|=
name|blockBuilder
operator|.
name|append
argument_list|(
literal|"list"
argument_list|,
name|Expressions
operator|.
name|new_
argument_list|(
name|ArrayList
operator|.
name|class
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Expression
name|value
range|:
name|argValueList
control|)
block|{
name|blockBuilder
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|statement
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|lyst
argument_list|,
name|BuiltInMethod
operator|.
name|COLLECTION_ADD
operator|.
name|method
argument_list|,
name|Expressions
operator|.
name|box
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|lyst
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected: "
operator|+
name|kind
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Implementor for the {@code ITEM} SQL operator. */
specifier|private
specifier|static
class|class
name|ItemImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|ItemImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"item"
return|;
block|}
comment|// Since we follow PostgreSQL's semantics that an out-of-bound reference
comment|// returns NULL, x[y] can return null even if x and y are both NOT NULL.
comment|// (In SQL standard semantics, an out-of-bound reference to an array
comment|// throws an exception.)
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
specifier|final
name|MethodImplementor
name|implementor
init|=
name|getImplementor
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|implementor
operator|.
name|implementSafe
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
specifier|private
name|MethodImplementor
name|getImplementor
parameter_list|(
name|SqlTypeName
name|sqlTypeName
parameter_list|)
block|{
switch|switch
condition|(
name|sqlTypeName
condition|)
block|{
case|case
name|ARRAY
case|:
return|return
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|ARRAY_ITEM
operator|.
name|method
argument_list|,
name|nullPolicy
argument_list|,
literal|false
argument_list|)
return|;
case|case
name|MAP
case|:
return|return
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|MAP_ITEM
operator|.
name|method
argument_list|,
name|nullPolicy
argument_list|,
literal|false
argument_list|)
return|;
default|default:
return|return
operator|new
name|MethodImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|ANY_ITEM
operator|.
name|method
argument_list|,
name|nullPolicy
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Implementor for SQL system functions.    *    *<p>Several of these are represented internally as constant values, set    * per execution. */
specifier|private
specifier|static
class|class
name|SystemFunctionImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|SystemFunctionImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"system_func"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
specifier|final
name|Expression
name|root
init|=
name|translator
operator|.
name|getRoot
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|CURRENT_USER
operator|||
name|op
operator|==
name|SESSION_USER
operator|||
name|op
operator|==
name|USER
condition|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|USER
operator|.
name|method
argument_list|,
name|root
argument_list|)
return|;
block|}
if|else if
condition|(
name|op
operator|==
name|SYSTEM_USER
condition|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|SYSTEM_USER
operator|.
name|method
argument_list|,
name|root
argument_list|)
return|;
block|}
if|else if
condition|(
name|op
operator|==
name|CURRENT_PATH
operator|||
name|op
operator|==
name|CURRENT_ROLE
operator|||
name|op
operator|==
name|CURRENT_CATALOG
condition|)
block|{
comment|// By default, the CURRENT_ROLE and CURRENT_CATALOG functions return the
comment|// empty string because a role or a catalog has to be set explicitly.
return|return
name|Expressions
operator|.
name|constant
argument_list|(
literal|""
argument_list|)
return|;
block|}
if|else if
condition|(
name|op
operator|==
name|CURRENT_TIMESTAMP
condition|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|CURRENT_TIMESTAMP
operator|.
name|method
argument_list|,
name|root
argument_list|)
return|;
block|}
if|else if
condition|(
name|op
operator|==
name|CURRENT_TIME
condition|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|CURRENT_TIME
operator|.
name|method
argument_list|,
name|root
argument_list|)
return|;
block|}
if|else if
condition|(
name|op
operator|==
name|CURRENT_DATE
condition|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|CURRENT_DATE
operator|.
name|method
argument_list|,
name|root
argument_list|)
return|;
block|}
if|else if
condition|(
name|op
operator|==
name|LOCALTIMESTAMP
condition|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|LOCAL_TIMESTAMP
operator|.
name|method
argument_list|,
name|root
argument_list|)
return|;
block|}
if|else if
condition|(
name|op
operator|==
name|LOCALTIME
condition|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|LOCAL_TIME
operator|.
name|method
argument_list|,
name|root
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unknown function "
operator|+
name|op
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Implementor for the {@code NOT} operator. */
specifier|private
specifier|static
class|class
name|NotImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
specifier|private
name|AbstractRexCallImplementor
name|implementor
decl_stmt|;
specifier|private
name|NotImplementor
parameter_list|(
name|AbstractRexCallImplementor
name|implementor
parameter_list|)
block|{
name|super
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|implementor
operator|=
name|implementor
expr_stmt|;
block|}
specifier|static
name|AbstractRexCallImplementor
name|of
parameter_list|(
name|AbstractRexCallImplementor
name|implementor
parameter_list|)
block|{
return|return
operator|new
name|NotImplementor
argument_list|(
name|implementor
argument_list|)
return|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"not"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
specifier|final
name|Expression
name|expression
init|=
name|implementor
operator|.
name|implementSafe
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|argValueList
argument_list|)
decl_stmt|;
return|return
name|Expressions
operator|.
name|not
argument_list|(
name|expression
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for various datetime arithmetic. */
specifier|private
specifier|static
class|class
name|DatetimeArithmeticImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|DatetimeArithmeticImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"dateTime_arithmetic"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
specifier|final
name|RexNode
name|operand0
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Expression
name|trop0
init|=
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlTypeName
name|typeName1
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
name|Expression
name|trop1
init|=
name|argValueList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|SqlTypeName
name|typeName
init|=
name|call
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|operand0
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|DATE
case|:
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TIMESTAMP
case|:
name|trop0
operator|=
name|Expressions
operator|.
name|convert_
argument_list|(
name|Expressions
operator|.
name|multiply
argument_list|(
name|trop0
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
argument_list|)
argument_list|)
argument_list|,
name|long
operator|.
name|class
argument_list|)
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|typeName1
condition|)
block|{
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
name|trop1
operator|=
name|Expressions
operator|.
name|convert_
argument_list|(
name|Expressions
operator|.
name|divide
argument_list|(
name|trop1
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
argument_list|)
argument_list|)
argument_list|,
name|int
operator|.
name|class
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
case|case
name|TIME
case|:
name|trop1
operator|=
name|Expressions
operator|.
name|convert_
argument_list|(
name|trop1
argument_list|,
name|int
operator|.
name|class
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|typeName1
condition|)
block|{
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|MINUS
case|:
name|trop1
operator|=
name|Expressions
operator|.
name|negate
argument_list|(
name|trop1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TIME
case|:
return|return
name|Expressions
operator|.
name|convert_
argument_list|(
name|trop0
argument_list|,
name|long
operator|.
name|class
argument_list|)
return|;
default|default:
specifier|final
name|BuiltInMethod
name|method
init|=
name|operand0
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|TIMESTAMP
condition|?
name|BuiltInMethod
operator|.
name|ADD_MONTHS
else|:
name|BuiltInMethod
operator|.
name|ADD_MONTHS_INT
decl_stmt|;
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|method
operator|.
name|method
argument_list|,
name|trop0
argument_list|,
name|trop1
argument_list|)
return|;
block|}
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|MINUS
case|:
return|return
name|normalize
argument_list|(
name|typeName
argument_list|,
name|Expressions
operator|.
name|subtract
argument_list|(
name|trop0
argument_list|,
name|trop1
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|normalize
argument_list|(
name|typeName
argument_list|,
name|Expressions
operator|.
name|add
argument_list|(
name|trop0
argument_list|,
name|trop1
argument_list|)
argument_list|)
return|;
block|}
default|default:
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|MINUS
case|:
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|SUBTRACT_MONTHS
operator|.
name|method
argument_list|,
name|trop0
argument_list|,
name|trop1
argument_list|)
return|;
default|default:
break|break;
block|}
name|TimeUnit
name|fromUnit
init|=
name|typeName1
operator|==
name|SqlTypeName
operator|.
name|DATE
condition|?
name|TimeUnit
operator|.
name|DAY
else|:
name|TimeUnit
operator|.
name|MILLISECOND
decl_stmt|;
name|TimeUnit
name|toUnit
init|=
name|TimeUnit
operator|.
name|MILLISECOND
decl_stmt|;
return|return
name|multiplyDivide
argument_list|(
name|Expressions
operator|.
name|convert_
argument_list|(
name|Expressions
operator|.
name|subtract
argument_list|(
name|trop0
argument_list|,
name|trop1
argument_list|)
argument_list|,
operator|(
name|Class
operator|)
name|long
operator|.
name|class
argument_list|)
argument_list|,
name|fromUnit
operator|.
name|multiplier
argument_list|,
name|toUnit
operator|.
name|multiplier
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|call
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Normalizes a TIME value into 00:00:00..23:59:39. */
specifier|private
specifier|static
name|Expression
name|normalize
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|,
name|Expression
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TIME
case|:
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|FLOOR_MOD
operator|.
name|method
argument_list|,
name|e
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|e
return|;
block|}
block|}
block|}
comment|/** Implements CLASSIFIER match-recognize function. */
specifier|private
specifier|static
class|class
name|ClassifierImplementor
implements|implements
name|MatchImplementor
block|{
annotation|@
name|Override
specifier|public
name|Expression
name|implement
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|ParameterExpression
name|row
parameter_list|,
name|ParameterExpression
name|rows
parameter_list|,
name|ParameterExpression
name|symbols
parameter_list|,
name|ParameterExpression
name|i
parameter_list|)
block|{
return|return
name|EnumUtils
operator|.
name|convert
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|symbols
argument_list|,
name|BuiltInMethod
operator|.
name|LIST_GET
operator|.
name|method
argument_list|,
name|i
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
block|}
block|}
comment|/** Implements the LAST match-recognize function. */
specifier|private
specifier|static
class|class
name|LastImplementor
implements|implements
name|MatchImplementor
block|{
annotation|@
name|Override
specifier|public
name|Expression
name|implement
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|ParameterExpression
name|row
parameter_list|,
name|ParameterExpression
name|rows
parameter_list|,
name|ParameterExpression
name|symbols
parameter_list|,
name|ParameterExpression
name|i
parameter_list|)
block|{
specifier|final
name|RexNode
name|node
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|String
name|alpha
init|=
operator|(
operator|(
name|RexPatternFieldRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getAlpha
argument_list|()
decl_stmt|;
comment|// TODO: verify if the variable is needed
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|final
name|BinaryExpression
name|lastIndex
init|=
name|Expressions
operator|.
name|subtract
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|rows
argument_list|,
name|BuiltInMethod
operator|.
name|COLLECTION_SIZE
operator|.
name|method
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// Just take the last one, if exists
if|if
condition|(
literal|"*"
operator|.
name|equals
argument_list|(
name|alpha
argument_list|)
condition|)
block|{
name|setInputGetterIndex
argument_list|(
name|translator
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|// Important, unbox the node / expression to avoid NullAs.NOT_POSSIBLE
specifier|final
name|RexPatternFieldRef
name|ref
init|=
operator|(
name|RexPatternFieldRef
operator|)
name|node
decl_stmt|;
specifier|final
name|RexPatternFieldRef
name|newRef
init|=
operator|new
name|RexPatternFieldRef
argument_list|(
name|ref
operator|.
name|getAlpha
argument_list|()
argument_list|,
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|,
name|translator
operator|.
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|ref
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|expression
init|=
name|translator
operator|.
name|translate
argument_list|(
name|newRef
argument_list|,
name|NullAs
operator|.
name|NULL
argument_list|)
decl_stmt|;
name|setInputGetterIndex
argument_list|(
name|translator
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|expression
return|;
block|}
else|else
block|{
comment|// Alpha != "*" so we have to search for a specific one to find and use that, if found
name|setInputGetterIndex
argument_list|(
name|translator
argument_list|,
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|MATCH_UTILS_LAST_WITH_SYMBOL
operator|.
name|method
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
name|alpha
argument_list|)
argument_list|,
name|rows
argument_list|,
name|symbols
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// Important, unbox the node / expression to avoid NullAs.NOT_POSSIBLE
specifier|final
name|RexPatternFieldRef
name|ref
init|=
operator|(
name|RexPatternFieldRef
operator|)
name|node
decl_stmt|;
specifier|final
name|RexPatternFieldRef
name|newRef
init|=
operator|new
name|RexPatternFieldRef
argument_list|(
name|ref
operator|.
name|getAlpha
argument_list|()
argument_list|,
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|,
name|translator
operator|.
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|ref
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|expression
init|=
name|translator
operator|.
name|translate
argument_list|(
name|newRef
argument_list|,
name|NullAs
operator|.
name|NULL
argument_list|)
decl_stmt|;
name|setInputGetterIndex
argument_list|(
name|translator
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|expression
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|setInputGetterIndex
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
annotation|@
name|Nullable
name|Expression
name|o
parameter_list|)
block|{
name|requireNonNull
argument_list|(
operator|(
name|EnumerableMatch
operator|.
name|PassedRowsInputGetter
operator|)
name|translator
operator|.
name|inputGetter
argument_list|,
literal|"inputGetter"
argument_list|)
operator|.
name|setIndex
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Null-safe implementor of {@code RexCall}s. */
specifier|public
interface|interface
name|RexCallImplementor
block|{
name|RexToLixTranslator
operator|.
name|Result
name|implement
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|RexToLixTranslator
operator|.
name|Result
argument_list|>
name|arguments
parameter_list|)
function_decl|;
block|}
comment|/**    * Abstract implementation of the {@link RexCallImplementor} interface.    *    *<p>It is not always safe to execute the {@link RexCall} directly due to    * the special null arguments. Therefore, the generated code logic is    * conditional correspondingly.    *    *<p>For example, {@code a + b} will generate two declaration statements:    *    *<blockquote>    *<code>    * final Integer xxx_value = (a_isNull || b_isNull) ? null : plus(a, b);<br>    * final boolean xxx_isNull = xxx_value == null;    *</code>    *</blockquote>    */
specifier|private
specifier|abstract
specifier|static
class|class
name|AbstractRexCallImplementor
implements|implements
name|RexCallImplementor
block|{
specifier|final
annotation|@
name|Nullable
name|NullPolicy
name|nullPolicy
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|harmonize
decl_stmt|;
name|AbstractRexCallImplementor
parameter_list|(
annotation|@
name|Nullable
name|NullPolicy
name|nullPolicy
parameter_list|,
name|boolean
name|harmonize
parameter_list|)
block|{
name|this
operator|.
name|nullPolicy
operator|=
name|nullPolicy
expr_stmt|;
name|this
operator|.
name|harmonize
operator|=
name|harmonize
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexToLixTranslator
operator|.
name|Result
name|implement
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexToLixTranslator
operator|.
name|Result
argument_list|>
name|arguments
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argIsNullList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexToLixTranslator
operator|.
name|Result
name|result
range|:
name|arguments
control|)
block|{
name|argIsNullList
operator|.
name|add
argument_list|(
name|result
operator|.
name|isNullVariable
argument_list|)
expr_stmt|;
name|argValueList
operator|.
name|add
argument_list|(
name|result
operator|.
name|valueVariable
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Expression
name|condition
init|=
name|getCondition
argument_list|(
name|argIsNullList
argument_list|)
decl_stmt|;
specifier|final
name|ParameterExpression
name|valueVariable
init|=
name|genValueStatement
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|argValueList
argument_list|,
name|condition
argument_list|)
decl_stmt|;
specifier|final
name|ParameterExpression
name|isNullVariable
init|=
name|genIsNullStatement
argument_list|(
name|translator
argument_list|,
name|valueVariable
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexToLixTranslator
operator|.
name|Result
argument_list|(
name|isNullVariable
argument_list|,
name|valueVariable
argument_list|)
return|;
block|}
comment|// Variable name facilitates reasoning about issues when necessary
specifier|abstract
name|String
name|getVariableName
parameter_list|()
function_decl|;
comment|/** Figures out conditional expression according to NullPolicy. */
name|Expression
name|getCondition
parameter_list|(
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argIsNullList
parameter_list|)
block|{
if|if
condition|(
name|argIsNullList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|nullPolicy
operator|==
literal|null
operator|||
name|nullPolicy
operator|==
name|NullPolicy
operator|.
name|NONE
condition|)
block|{
return|return
name|FALSE_EXPR
return|;
block|}
if|if
condition|(
name|nullPolicy
operator|==
name|NullPolicy
operator|.
name|ARG0
condition|)
block|{
return|return
name|argIsNullList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|nullPolicy
operator|==
name|NullPolicy
operator|.
name|ALL
condition|)
block|{
comment|// Condition for NullPolicy.ALL: v0 == null&& v1 == null
return|return
name|Expressions
operator|.
name|foldAnd
argument_list|(
name|argIsNullList
argument_list|)
return|;
block|}
comment|// Condition for regular cases: v0 == null || v1 == null
return|return
name|Expressions
operator|.
name|foldOr
argument_list|(
name|argIsNullList
argument_list|)
return|;
block|}
comment|// E.g., "final Integer xxx_value = (a_isNull || b_isNull) ? null : plus(a, b)"
specifier|private
name|ParameterExpression
name|genValueStatement
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|,
specifier|final
name|Expression
name|condition
parameter_list|)
block|{
name|List
argument_list|<
name|Expression
argument_list|>
name|optimizedArgValueList
init|=
name|argValueList
decl_stmt|;
if|if
condition|(
name|harmonize
condition|)
block|{
name|optimizedArgValueList
operator|=
name|harmonize
argument_list|(
name|optimizedArgValueList
argument_list|,
name|translator
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
name|optimizedArgValueList
operator|=
name|unboxIfNecessary
argument_list|(
name|optimizedArgValueList
argument_list|)
expr_stmt|;
specifier|final
name|Expression
name|callValue
init|=
name|implementSafe
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|optimizedArgValueList
argument_list|)
decl_stmt|;
comment|// In general, RexCall's type is correct for code generation
comment|// and thus we should ensure the consistency.
comment|// However, for some special cases (e.g., TableFunction),
comment|// the implementation's type is correct, we can't convert it.
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
specifier|final
name|Type
name|returnType
init|=
name|translator
operator|.
name|typeFactory
operator|.
name|getJavaClass
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|noConvert
init|=
operator|(
name|returnType
operator|==
literal|null
operator|)
operator|||
operator|(
name|returnType
operator|==
name|callValue
operator|.
name|getType
argument_list|()
operator|)
operator|||
operator|(
name|op
operator|instanceof
name|SqlUserDefinedTableMacro
operator|)
operator|||
operator|(
name|op
operator|instanceof
name|SqlUserDefinedTableFunction
operator|)
decl_stmt|;
specifier|final
name|Expression
name|convertedCallValue
init|=
name|noConvert
condition|?
name|callValue
else|:
name|EnumUtils
operator|.
name|convert
argument_list|(
name|callValue
argument_list|,
name|returnType
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|valueExpression
init|=
name|Expressions
operator|.
name|condition
argument_list|(
name|condition
argument_list|,
name|getIfTrue
argument_list|(
name|convertedCallValue
operator|.
name|getType
argument_list|()
argument_list|,
name|argValueList
argument_list|)
argument_list|,
name|convertedCallValue
argument_list|)
decl_stmt|;
specifier|final
name|ParameterExpression
name|value
init|=
name|Expressions
operator|.
name|parameter
argument_list|(
name|convertedCallValue
operator|.
name|getType
argument_list|()
argument_list|,
name|translator
operator|.
name|getBlockBuilder
argument_list|()
operator|.
name|newName
argument_list|(
name|getVariableName
argument_list|()
operator|+
literal|"_value"
argument_list|)
argument_list|)
decl_stmt|;
name|translator
operator|.
name|getBlockBuilder
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|declare
argument_list|(
name|Modifier
operator|.
name|FINAL
argument_list|,
name|value
argument_list|,
name|valueExpression
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
name|Expression
name|getIfTrue
parameter_list|(
name|Type
name|type
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|getDefaultValue
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|// E.g., "final boolean xxx_isNull = xxx_value == null"
specifier|private
name|ParameterExpression
name|genIsNullStatement
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|ParameterExpression
name|value
parameter_list|)
block|{
specifier|final
name|ParameterExpression
name|isNullVariable
init|=
name|Expressions
operator|.
name|parameter
argument_list|(
name|Boolean
operator|.
name|TYPE
argument_list|,
name|translator
operator|.
name|getBlockBuilder
argument_list|()
operator|.
name|newName
argument_list|(
name|getVariableName
argument_list|()
operator|+
literal|"_isNull"
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|isNullExpression
init|=
name|translator
operator|.
name|checkNull
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|translator
operator|.
name|getBlockBuilder
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|declare
argument_list|(
name|Modifier
operator|.
name|FINAL
argument_list|,
name|isNullVariable
argument_list|,
name|isNullExpression
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|isNullVariable
return|;
block|}
comment|/** Ensures that operands have identical type. */
specifier|private
specifier|static
name|List
argument_list|<
name|Expression
argument_list|>
name|harmonize
parameter_list|(
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|,
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|)
block|{
name|int
name|nullCount
init|=
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|translator
operator|.
name|builder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|RelDataType
name|type
init|=
name|operand
operator|.
name|getType
argument_list|()
decl_stmt|;
name|type
operator|=
name|toSql
argument_list|(
name|typeFactory
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|translator
operator|.
name|isNullable
argument_list|(
name|operand
argument_list|)
condition|)
block|{
operator|++
name|nullCount
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|types
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allSame
argument_list|(
name|types
argument_list|)
condition|)
block|{
comment|// Operands have the same nullability and type. Return them
comment|// unchanged.
return|return
name|argValueList
return|;
block|}
specifier|final
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|leastRestrictive
argument_list|(
name|types
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
comment|// There is no common type. Presumably this is a binary operator with
comment|// asymmetric arguments (e.g. interval / integer) which is not intended
comment|// to be harmonized.
return|return
name|argValueList
return|;
block|}
assert|assert
operator|(
name|nullCount
operator|>
literal|0
operator|)
operator|==
name|type
operator|.
name|isNullable
argument_list|()
assert|;
specifier|final
name|Type
name|javaClass
init|=
name|translator
operator|.
name|typeFactory
operator|.
name|getJavaClass
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|harmonizedArgValues
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Expression
name|argValue
range|:
name|argValueList
control|)
block|{
name|harmonizedArgValues
operator|.
name|add
argument_list|(
name|EnumUtils
operator|.
name|convert
argument_list|(
name|argValue
argument_list|,
name|javaClass
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|harmonizedArgValues
return|;
block|}
comment|/** Under null check, it is safe to unbox the operands before entering the      * implementor. */
specifier|private
name|List
argument_list|<
name|Expression
argument_list|>
name|unboxIfNecessary
parameter_list|(
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
name|List
argument_list|<
name|Expression
argument_list|>
name|unboxValueList
init|=
name|argValueList
decl_stmt|;
if|if
condition|(
name|nullPolicy
operator|==
name|NullPolicy
operator|.
name|STRICT
operator|||
name|nullPolicy
operator|==
name|NullPolicy
operator|.
name|ANY
operator|||
name|nullPolicy
operator|==
name|NullPolicy
operator|.
name|SEMI_STRICT
condition|)
block|{
name|unboxValueList
operator|=
name|argValueList
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|AbstractRexCallImplementor
operator|::
name|unboxExpression
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nullPolicy
operator|==
name|NullPolicy
operator|.
name|ARG0
operator|&&
name|argValueList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|Expression
name|unboxArg0
init|=
name|unboxExpression
argument_list|(
name|unboxValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|unboxValueList
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|unboxArg0
argument_list|)
expr_stmt|;
block|}
return|return
name|unboxValueList
return|;
block|}
specifier|private
specifier|static
name|Expression
name|unboxExpression
parameter_list|(
specifier|final
name|Expression
name|argValue
parameter_list|)
block|{
name|Primitive
name|fromBox
init|=
name|Primitive
operator|.
name|ofBox
argument_list|(
name|argValue
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|fromBox
operator|==
literal|null
operator|||
name|fromBox
operator|==
name|Primitive
operator|.
name|VOID
condition|)
block|{
return|return
name|argValue
return|;
block|}
comment|// Optimization: for "long x";
comment|// "Long.valueOf(x)" generates "x"
if|if
condition|(
name|argValue
operator|instanceof
name|MethodCallExpression
condition|)
block|{
name|MethodCallExpression
name|mce
init|=
operator|(
name|MethodCallExpression
operator|)
name|argValue
decl_stmt|;
if|if
condition|(
name|mce
operator|.
name|method
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"valueOf"
argument_list|)
operator|&&
name|mce
operator|.
name|expressions
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|Expression
name|originArg
init|=
name|mce
operator|.
name|expressions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|Primitive
operator|.
name|of
argument_list|(
name|originArg
operator|.
name|type
argument_list|)
operator|==
name|fromBox
condition|)
block|{
return|return
name|originArg
return|;
block|}
block|}
block|}
return|return
name|NullAs
operator|.
name|NOT_POSSIBLE
operator|.
name|handle
argument_list|(
name|argValue
argument_list|)
return|;
block|}
specifier|abstract
name|Expression
name|implementSafe
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
function_decl|;
block|}
comment|/**    * Implementor for the {@code AND} operator.    *    *<p>If any of the arguments are false, result is false;    * else if any arguments are null, result is null;    * else true.    */
specifier|private
specifier|static
class|class
name|LogicalAndImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|LogicalAndImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"logical_and"
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexToLixTranslator
operator|.
name|Result
name|implement
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexToLixTranslator
operator|.
name|Result
argument_list|>
name|arguments
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argIsNullList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexToLixTranslator
operator|.
name|Result
name|result
range|:
name|arguments
control|)
block|{
name|argIsNullList
operator|.
name|add
argument_list|(
name|result
operator|.
name|isNullVariable
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|nullAsTrue
init|=
name|arguments
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|result
lambda|->
name|Expressions
operator|.
name|condition
argument_list|(
name|result
operator|.
name|isNullVariable
argument_list|,
name|TRUE_EXPR
argument_list|,
name|result
operator|.
name|valueVariable
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|hasFalse
init|=
name|Expressions
operator|.
name|not
argument_list|(
name|Expressions
operator|.
name|foldAnd
argument_list|(
name|nullAsTrue
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|hasNull
init|=
name|Expressions
operator|.
name|foldOr
argument_list|(
name|argIsNullList
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|callExpression
init|=
name|Expressions
operator|.
name|condition
argument_list|(
name|hasFalse
argument_list|,
name|BOXED_FALSE_EXPR
argument_list|,
name|Expressions
operator|.
name|condition
argument_list|(
name|hasNull
argument_list|,
name|NULL_EXPR
argument_list|,
name|BOXED_TRUE_EXPR
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexImpTable
operator|.
name|NullAs
name|nullAs
init|=
name|translator
operator|.
name|isNullable
argument_list|(
name|call
argument_list|)
condition|?
name|RexImpTable
operator|.
name|NullAs
operator|.
name|NULL
else|:
name|RexImpTable
operator|.
name|NullAs
operator|.
name|NOT_POSSIBLE
decl_stmt|;
specifier|final
name|Expression
name|valueExpression
init|=
name|nullAs
operator|.
name|handle
argument_list|(
name|callExpression
argument_list|)
decl_stmt|;
specifier|final
name|ParameterExpression
name|valueVariable
init|=
name|Expressions
operator|.
name|parameter
argument_list|(
name|valueExpression
operator|.
name|getType
argument_list|()
argument_list|,
name|translator
operator|.
name|getBlockBuilder
argument_list|()
operator|.
name|newName
argument_list|(
name|getVariableName
argument_list|()
operator|+
literal|"_value"
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|isNullExpression
init|=
name|translator
operator|.
name|checkNull
argument_list|(
name|valueVariable
argument_list|)
decl_stmt|;
specifier|final
name|ParameterExpression
name|isNullVariable
init|=
name|Expressions
operator|.
name|parameter
argument_list|(
name|Boolean
operator|.
name|TYPE
argument_list|,
name|translator
operator|.
name|getBlockBuilder
argument_list|()
operator|.
name|newName
argument_list|(
name|getVariableName
argument_list|()
operator|+
literal|"_isNull"
argument_list|)
argument_list|)
decl_stmt|;
name|translator
operator|.
name|getBlockBuilder
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|declare
argument_list|(
name|Modifier
operator|.
name|FINAL
argument_list|,
name|valueVariable
argument_list|,
name|valueExpression
argument_list|)
argument_list|)
expr_stmt|;
name|translator
operator|.
name|getBlockBuilder
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|declare
argument_list|(
name|Modifier
operator|.
name|FINAL
argument_list|,
name|isNullVariable
argument_list|,
name|isNullExpression
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|RexToLixTranslator
operator|.
name|Result
argument_list|(
name|isNullVariable
argument_list|,
name|valueVariable
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"This implementSafe should not be called,"
operator|+
literal|" please call implement(...)"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Implementor for the {@code OR} operator.    *    *<p>If any of the arguments are true, result is true;    * else if any arguments are null, result is null;    * else false.    */
specifier|private
specifier|static
class|class
name|LogicalOrImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|LogicalOrImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"logical_or"
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexToLixTranslator
operator|.
name|Result
name|implement
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexToLixTranslator
operator|.
name|Result
argument_list|>
name|arguments
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argIsNullList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexToLixTranslator
operator|.
name|Result
name|result
range|:
name|arguments
control|)
block|{
name|argIsNullList
operator|.
name|add
argument_list|(
name|result
operator|.
name|isNullVariable
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|nullAsFalse
init|=
name|arguments
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|result
lambda|->
name|Expressions
operator|.
name|condition
argument_list|(
name|result
operator|.
name|isNullVariable
argument_list|,
name|FALSE_EXPR
argument_list|,
name|result
operator|.
name|valueVariable
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|hasTrue
init|=
name|Expressions
operator|.
name|foldOr
argument_list|(
name|nullAsFalse
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|hasNull
init|=
name|Expressions
operator|.
name|foldOr
argument_list|(
name|argIsNullList
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|callExpression
init|=
name|Expressions
operator|.
name|condition
argument_list|(
name|hasTrue
argument_list|,
name|BOXED_TRUE_EXPR
argument_list|,
name|Expressions
operator|.
name|condition
argument_list|(
name|hasNull
argument_list|,
name|NULL_EXPR
argument_list|,
name|BOXED_FALSE_EXPR
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexImpTable
operator|.
name|NullAs
name|nullAs
init|=
name|translator
operator|.
name|isNullable
argument_list|(
name|call
argument_list|)
condition|?
name|RexImpTable
operator|.
name|NullAs
operator|.
name|NULL
else|:
name|RexImpTable
operator|.
name|NullAs
operator|.
name|NOT_POSSIBLE
decl_stmt|;
specifier|final
name|Expression
name|valueExpression
init|=
name|nullAs
operator|.
name|handle
argument_list|(
name|callExpression
argument_list|)
decl_stmt|;
specifier|final
name|ParameterExpression
name|valueVariable
init|=
name|Expressions
operator|.
name|parameter
argument_list|(
name|valueExpression
operator|.
name|getType
argument_list|()
argument_list|,
name|translator
operator|.
name|getBlockBuilder
argument_list|()
operator|.
name|newName
argument_list|(
name|getVariableName
argument_list|()
operator|+
literal|"_value"
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|isNullExpression
init|=
name|translator
operator|.
name|checkNull
argument_list|(
name|valueExpression
argument_list|)
decl_stmt|;
specifier|final
name|ParameterExpression
name|isNullVariable
init|=
name|Expressions
operator|.
name|parameter
argument_list|(
name|Boolean
operator|.
name|TYPE
argument_list|,
name|translator
operator|.
name|getBlockBuilder
argument_list|()
operator|.
name|newName
argument_list|(
name|getVariableName
argument_list|()
operator|+
literal|"_isNull"
argument_list|)
argument_list|)
decl_stmt|;
name|translator
operator|.
name|getBlockBuilder
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|declare
argument_list|(
name|Modifier
operator|.
name|FINAL
argument_list|,
name|valueVariable
argument_list|,
name|valueExpression
argument_list|)
argument_list|)
expr_stmt|;
name|translator
operator|.
name|getBlockBuilder
argument_list|()
operator|.
name|add
argument_list|(
name|Expressions
operator|.
name|declare
argument_list|(
name|Modifier
operator|.
name|FINAL
argument_list|,
name|isNullVariable
argument_list|,
name|isNullExpression
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|RexToLixTranslator
operator|.
name|Result
argument_list|(
name|isNullVariable
argument_list|,
name|valueVariable
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"This implementSafe should not be called,"
operator|+
literal|" please call implement(...)"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Implementor for the {@code NOT} operator.    *    *<p>If any of the arguments are false, result is true;    * else if any arguments are null, result is null;    * else false.    */
specifier|private
specifier|static
class|class
name|LogicalNotImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|LogicalNotImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"logical_not"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|NOT
operator|.
name|method
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
block|}
comment|/**    * Implementation that calls a given {@link java.lang.reflect.Method}.    *    *<p>When method is not static, a new instance of the required class is    * created.    */
specifier|private
specifier|static
class|class
name|ReflectiveImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
specifier|protected
specifier|final
name|Method
name|method
decl_stmt|;
name|ReflectiveImplementor
parameter_list|(
name|Method
name|method
parameter_list|,
annotation|@
name|Nullable
name|NullPolicy
name|nullPolicy
parameter_list|)
block|{
name|super
argument_list|(
name|nullPolicy
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|method
operator|=
name|method
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"reflective_"
operator|+
name|method
operator|.
name|getName
argument_list|()
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList0
init|=
name|EnumUtils
operator|.
name|fromInternal
argument_list|(
name|method
operator|.
name|getParameterTypes
argument_list|()
argument_list|,
name|argValueList
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|method
operator|.
name|getModifiers
argument_list|()
operator|&
name|Modifier
operator|.
name|STATIC
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|method
argument_list|,
name|argValueList0
argument_list|)
return|;
block|}
else|else
block|{
comment|// The UDF class must have a public zero-args constructor.
comment|// Assume that the validator checked already.
specifier|final
name|Expression
name|target
init|=
name|Expressions
operator|.
name|new_
argument_list|(
name|method
operator|.
name|getDeclaringClass
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|target
argument_list|,
name|method
argument_list|,
name|argValueList0
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Implementor for the {@code RAND} function. */
specifier|private
specifier|static
class|class
name|RandImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
specifier|private
specifier|final
name|AbstractRexCallImplementor
index|[]
name|implementors
init|=
block|{
operator|new
name|ReflectiveImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|RAND
operator|.
name|method
argument_list|,
name|nullPolicy
argument_list|)
block|,
operator|new
name|ReflectiveImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|RAND_SEED
operator|.
name|method
argument_list|,
name|nullPolicy
argument_list|)
block|}
decl_stmt|;
name|RandImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"rand"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|implementors
index|[
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
index|]
operator|.
name|implementSafe
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code RAND_INTEGER} function. */
specifier|private
specifier|static
class|class
name|RandIntegerImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
specifier|private
specifier|final
name|AbstractRexCallImplementor
index|[]
name|implementors
init|=
block|{
operator|new
name|ReflectiveImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|RAND_INTEGER
operator|.
name|method
argument_list|,
name|nullPolicy
argument_list|)
block|,
operator|new
name|ReflectiveImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|RAND_INTEGER_SEED
operator|.
name|method
argument_list|,
name|nullPolicy
argument_list|)
block|}
decl_stmt|;
name|RandIntegerImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"rand_integer"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|implementors
index|[
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
operator|.
name|implementSafe
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code PI} operator. */
specifier|private
specifier|static
class|class
name|PiImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|PiImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"pi"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|constant
argument_list|(
name|Math
operator|.
name|PI
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code IS FALSE} SQL operator. */
specifier|private
specifier|static
class|class
name|IsFalseImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|IsFalseImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"is_false"
return|;
block|}
annotation|@
name|Override
name|Expression
name|getIfTrue
parameter_list|(
name|Type
name|type
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|constant
argument_list|(
literal|false
argument_list|,
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|equal
argument_list|(
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|FALSE_EXPR
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code IS NOT FALSE} SQL operator. */
specifier|private
specifier|static
class|class
name|IsNotFalseImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|IsNotFalseImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"is_not_false"
return|;
block|}
annotation|@
name|Override
name|Expression
name|getIfTrue
parameter_list|(
name|Type
name|type
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|constant
argument_list|(
literal|true
argument_list|,
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|notEqual
argument_list|(
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|FALSE_EXPR
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code IS NOT NULL} SQL operator. */
specifier|private
specifier|static
class|class
name|IsNotNullImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|IsNotNullImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"is_not_null"
return|;
block|}
annotation|@
name|Override
name|Expression
name|getIfTrue
parameter_list|(
name|Type
name|type
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|constant
argument_list|(
literal|false
argument_list|,
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|notEqual
argument_list|(
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|NULL_EXPR
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code IS NOT TRUE} SQL operator. */
specifier|private
specifier|static
class|class
name|IsNotTrueImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|IsNotTrueImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"is_not_true"
return|;
block|}
annotation|@
name|Override
name|Expression
name|getIfTrue
parameter_list|(
name|Type
name|type
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|constant
argument_list|(
literal|true
argument_list|,
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|notEqual
argument_list|(
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TRUE_EXPR
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code IS NULL} SQL operator. */
specifier|private
specifier|static
class|class
name|IsNullImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|IsNullImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"is_null"
return|;
block|}
annotation|@
name|Override
name|Expression
name|getIfTrue
parameter_list|(
name|Type
name|type
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|constant
argument_list|(
literal|true
argument_list|,
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|equal
argument_list|(
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|NULL_EXPR
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code IS TRUE} SQL operator. */
specifier|private
specifier|static
class|class
name|IsTrueImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|IsTrueImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"is_true"
return|;
block|}
annotation|@
name|Override
name|Expression
name|getIfTrue
parameter_list|(
name|Type
name|type
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|constant
argument_list|(
literal|false
argument_list|,
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|equal
argument_list|(
name|argValueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TRUE_EXPR
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code REGEXP_REPLACE} function. */
specifier|private
specifier|static
class|class
name|RegexpReplaceImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
specifier|private
specifier|final
name|AbstractRexCallImplementor
index|[]
name|implementors
init|=
block|{
operator|new
name|ReflectiveImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|REGEXP_REPLACE3
operator|.
name|method
argument_list|,
name|nullPolicy
argument_list|)
block|,
operator|new
name|ReflectiveImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|REGEXP_REPLACE4
operator|.
name|method
argument_list|,
name|nullPolicy
argument_list|)
block|,
operator|new
name|ReflectiveImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|REGEXP_REPLACE5
operator|.
name|method
argument_list|,
name|nullPolicy
argument_list|)
block|,
operator|new
name|ReflectiveImplementor
argument_list|(
name|BuiltInMethod
operator|.
name|REGEXP_REPLACE6
operator|.
name|method
argument_list|,
name|nullPolicy
argument_list|)
block|,     }
decl_stmt|;
name|RegexpReplaceImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|STRICT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"regexp_replace"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|implementors
index|[
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|3
index|]
operator|.
name|implementSafe
argument_list|(
name|translator
argument_list|,
name|call
argument_list|,
name|argValueList
argument_list|)
return|;
block|}
block|}
comment|/** Implementor for the {@code DEFAULT} function. */
specifier|private
specifier|static
class|class
name|DefaultImplementor
extends|extends
name|AbstractRexCallImplementor
block|{
name|DefaultImplementor
parameter_list|()
block|{
name|super
argument_list|(
name|NullPolicy
operator|.
name|NONE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|String
name|getVariableName
parameter_list|()
block|{
return|return
literal|"default"
return|;
block|}
annotation|@
name|Override
name|Expression
name|implementSafe
parameter_list|(
specifier|final
name|RexToLixTranslator
name|translator
parameter_list|,
specifier|final
name|RexCall
name|call
parameter_list|,
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|argValueList
parameter_list|)
block|{
return|return
name|Expressions
operator|.
name|constant
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
comment|/** Implements the {@code TUMBLE} table function. */
specifier|private
specifier|static
class|class
name|TumbleImplementor
implements|implements
name|TableFunctionCallImplementor
block|{
annotation|@
name|Override
specifier|public
name|Expression
name|implement
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|Expression
name|inputEnumerable
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|PhysType
name|inputPhysType
parameter_list|,
name|PhysType
name|outputPhysType
parameter_list|)
block|{
comment|// The table operand is removed from the RexCall because it
comment|// represents the input, see StandardConvertletTable#convertWindowFunction.
name|Expression
name|intervalExpression
init|=
name|translator
operator|.
name|translate
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|RexCall
name|descriptor
init|=
operator|(
name|RexCall
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|ParameterExpression
name|parameter
init|=
name|Expressions
operator|.
name|parameter
argument_list|(
name|Primitive
operator|.
name|box
argument_list|(
name|inputPhysType
operator|.
name|getJavaRowType
argument_list|()
argument_list|)
argument_list|,
literal|"_input"
argument_list|)
decl_stmt|;
name|Expression
name|wmColExpr
init|=
name|inputPhysType
operator|.
name|fieldReference
argument_list|(
name|parameter
argument_list|,
operator|(
operator|(
name|RexInputRef
operator|)
name|descriptor
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|,
name|outputPhysType
operator|.
name|getJavaFieldType
argument_list|(
name|inputPhysType
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// handle the optional offset parameter. Use 0 for the default value when offset
comment|// parameter is not set.
specifier|final
name|Expression
name|offsetExpr
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|?
name|translator
operator|.
name|translate
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
else|:
name|Expressions
operator|.
name|constant
argument_list|(
literal|0
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|TUMBLING
operator|.
name|method
argument_list|,
name|inputEnumerable
argument_list|,
name|EnumUtils
operator|.
name|tumblingWindowSelector
argument_list|(
name|inputPhysType
argument_list|,
name|outputPhysType
argument_list|,
name|wmColExpr
argument_list|,
name|intervalExpression
argument_list|,
name|offsetExpr
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Implements the {@code HOP} table function. */
specifier|private
specifier|static
class|class
name|HopImplementor
implements|implements
name|TableFunctionCallImplementor
block|{
annotation|@
name|Override
specifier|public
name|Expression
name|implement
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|Expression
name|inputEnumerable
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|PhysType
name|inputPhysType
parameter_list|,
name|PhysType
name|outputPhysType
parameter_list|)
block|{
name|Expression
name|slidingInterval
init|=
name|translator
operator|.
name|translate
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|Expression
name|windowSize
init|=
name|translator
operator|.
name|translate
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|RexCall
name|descriptor
init|=
operator|(
name|RexCall
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Expression
name|wmColIndexExpr
init|=
name|Expressions
operator|.
name|constant
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|descriptor
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
comment|// handle the optional offset parameter. Use 0 for the default value when offset
comment|// parameter is not set.
specifier|final
name|Expression
name|offsetExpr
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|3
condition|?
name|translator
operator|.
name|translate
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|3
argument_list|)
argument_list|)
else|:
name|Expressions
operator|.
name|constant
argument_list|(
literal|0
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|HOPPING
operator|.
name|method
argument_list|,
name|Expressions
operator|.
name|list
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|inputEnumerable
argument_list|,
name|BuiltInMethod
operator|.
name|ENUMERABLE_ENUMERATOR
operator|.
name|method
argument_list|)
argument_list|,
name|wmColIndexExpr
argument_list|,
name|slidingInterval
argument_list|,
name|windowSize
argument_list|,
name|offsetExpr
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Implements the {@code SESSION} table function. */
specifier|private
specifier|static
class|class
name|SessionImplementor
implements|implements
name|TableFunctionCallImplementor
block|{
annotation|@
name|Override
specifier|public
name|Expression
name|implement
parameter_list|(
name|RexToLixTranslator
name|translator
parameter_list|,
name|Expression
name|inputEnumerable
parameter_list|,
name|RexCall
name|call
parameter_list|,
name|PhysType
name|inputPhysType
parameter_list|,
name|PhysType
name|outputPhysType
parameter_list|)
block|{
name|RexCall
name|timestampDescriptor
init|=
operator|(
name|RexCall
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexCall
name|keyDescriptor
init|=
operator|(
name|RexCall
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|Expression
name|gapInterval
init|=
name|translator
operator|.
name|translate
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|Expression
name|wmColIndexExpr
init|=
name|Expressions
operator|.
name|constant
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|timestampDescriptor
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|Expression
name|keyColIndexExpr
init|=
name|Expressions
operator|.
name|constant
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|keyDescriptor
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|Expressions
operator|.
name|call
argument_list|(
name|BuiltInMethod
operator|.
name|SESSIONIZATION
operator|.
name|method
argument_list|,
name|Expressions
operator|.
name|list
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|inputEnumerable
argument_list|,
name|BuiltInMethod
operator|.
name|ENUMERABLE_ENUMERATOR
operator|.
name|method
argument_list|)
argument_list|,
name|wmColIndexExpr
argument_list|,
name|keyColIndexExpr
argument_list|,
name|gapInterval
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

