begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|clone
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|DataContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|java
operator|.
name|AbstractQueryableTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|AbstractEnumerable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Enumerable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Enumerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|QueryProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Queryable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Primitive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelProtoDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|ScannableTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Statistic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Statistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|AbstractTableQueryable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Implementation of table that reads rows from column stores, one per column.  * Column store formats are chosen based on the type and distribution of the  * values in the column; see {@link Representation} and  * {@link RepresentationType}.  */
end_comment

begin_class
class|class
name|ArrayTable
extends|extends
name|AbstractQueryableTable
implements|implements
name|ScannableTable
block|{
specifier|private
specifier|final
name|RelProtoDataType
name|protoRowType
decl_stmt|;
specifier|private
specifier|final
name|Supplier
argument_list|<
name|Content
argument_list|>
name|supplier
decl_stmt|;
comment|/** Creates an ArrayTable. */
name|ArrayTable
parameter_list|(
name|Type
name|elementType
parameter_list|,
name|RelProtoDataType
name|protoRowType
parameter_list|,
name|Supplier
argument_list|<
name|Content
argument_list|>
name|supplier
parameter_list|)
block|{
name|super
argument_list|(
name|elementType
argument_list|)
expr_stmt|;
name|this
operator|.
name|protoRowType
operator|=
name|protoRowType
expr_stmt|;
name|this
operator|.
name|supplier
operator|=
name|supplier
expr_stmt|;
block|}
specifier|public
name|RelDataType
name|getRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|protoRowType
operator|.
name|apply
argument_list|(
name|typeFactory
argument_list|)
return|;
block|}
specifier|public
name|Statistic
name|getStatistic
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Content
name|content
init|=
name|supplier
operator|.
name|get
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|Column
argument_list|>
name|ord
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|content
operator|.
name|columns
argument_list|)
control|)
block|{
if|if
condition|(
name|ord
operator|.
name|e
operator|.
name|cardinality
operator|==
name|content
operator|.
name|size
condition|)
block|{
name|keys
operator|.
name|add
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|ord
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Statistics
operator|.
name|of
argument_list|(
name|content
operator|.
name|size
argument_list|,
name|keys
argument_list|,
name|content
operator|.
name|collations
argument_list|)
return|;
block|}
specifier|public
name|Enumerable
argument_list|<
name|Object
index|[]
argument_list|>
name|scan
parameter_list|(
name|DataContext
name|root
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|Object
index|[]
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|Object
index|[]
argument_list|>
name|enumerator
parameter_list|()
block|{
specifier|final
name|Content
name|content
init|=
name|supplier
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|content
operator|.
name|arrayEnumerator
argument_list|()
return|;
block|}
block|}
return|;
block|}
specifier|public
parameter_list|<
name|T
parameter_list|>
name|Queryable
argument_list|<
name|T
argument_list|>
name|asQueryable
parameter_list|(
specifier|final
name|QueryProvider
name|queryProvider
parameter_list|,
name|SchemaPlus
name|schema
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
return|return
operator|new
name|AbstractTableQueryable
argument_list|<
name|T
argument_list|>
argument_list|(
name|queryProvider
argument_list|,
name|schema
argument_list|,
name|this
argument_list|,
name|tableName
argument_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Enumerator
argument_list|<
name|T
argument_list|>
name|enumerator
parameter_list|()
block|{
specifier|final
name|Content
name|content
init|=
name|supplier
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|content
operator|.
name|enumerator
argument_list|()
return|;
block|}
block|}
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Pair
argument_list|<
name|Object
argument_list|,
name|T
argument_list|>
name|toPair
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
return|return
operator|(
name|Pair
argument_list|<
name|Object
argument_list|,
name|T
argument_list|>
operator|)
name|dataSet
return|;
block|}
comment|/** How a column's values are represented. */
enum|enum
name|RepresentationType
block|{
comment|/** Constant. Contains only one value.      *      *<p>We can't store 0-bit values in      * an array: we'd have no way of knowing how many there were.</p>      *      * @see Constant      */
name|CONSTANT
block|,
comment|/** Object array. Null values are represented by null. Values may or may      * not be canonized; if canonized, = and != can be implemented using      * pointer.      *      * @see ObjectArray      */
name|OBJECT_ARRAY
block|,
comment|/**      * Array of primitives. Null values not possible. Only for primitive      * types (and not optimal for boolean).      *      * @see PrimitiveArray      */
name|PRIMITIVE_ARRAY
block|,
comment|/** Bit-sliced primitive array. Values are {@code bitCount} bits each,      * and interpreted as signed. Stored as an array of long values.      *      *<p>If gcd(bitCount, 64) != 0, some values will cross boundaries.      * bits each. But for all of those values except 4, there is a primitive      * type (8 byte, 16 short, 32 int) which is more efficient.      *      * @see BitSlicedPrimitiveArray      */
name|BIT_SLICED_PRIMITIVE_ARRAY
block|,
comment|/**      * Dictionary of primitives. Use one of the previous methods to store      * unsigned offsets into the dictionary. Dictionary is canonized and      * sorted, so v1&lt; v2 if and only if code(v1)&lt; code(v2). The      * dictionary may or may not contain a null value.      *      *<p>The dictionary is not beneficial unless the codes are      * significantly shorter than the values. A column of {@code long}      * values with many duplicates is a win; a column of mostly distinct      * {@code short} values is likely a loss. The other win is if there are      * null values; otherwise the best option would be an      * {@link #OBJECT_ARRAY}.</p>      *      * @see PrimitiveDictionary      */
name|PRIMITIVE_DICTIONARY
block|,
comment|/**      * Dictionary of objects. Use one of the previous methods to store      * unsigned offsets into the dictionary.      *      * @see ObjectDictionary      */
name|OBJECT_DICTIONARY
block|,
comment|/**      * Compressed string table. Block of char data. Strings represented      * using an unsigned offset into the table (stored using one of the      * previous methods).      *      *<p>First 2 bytes are unsigned length; subsequent bytes are string      * contents. The null value, strings longer than 64k and strings that      * occur very commonly are held in an 'exceptions' array and are      * recognized by their high offsets. Other strings are created on demand      * (this reduces the number of objects that need to be created during      * deserialization from cache.</p>      *      * @see StringDictionary      */
name|STRING_DICTIONARY
block|,
comment|/**      * Compressed byte array table. Similar to compressed string table.      *      * @see ByteStringDictionary      */
name|BYTE_STRING_DICTIONARY
block|,   }
comment|/** Column definition and value set. */
specifier|public
specifier|static
class|class
name|Column
block|{
specifier|final
name|Representation
name|representation
decl_stmt|;
specifier|final
name|Object
name|dataSet
decl_stmt|;
specifier|final
name|int
name|cardinality
decl_stmt|;
name|Column
parameter_list|(
name|Representation
name|representation
parameter_list|,
name|Object
name|data
parameter_list|,
name|int
name|cardinality
parameter_list|)
block|{
name|this
operator|.
name|representation
operator|=
name|representation
expr_stmt|;
name|this
operator|.
name|dataSet
operator|=
name|data
expr_stmt|;
name|this
operator|.
name|cardinality
operator|=
name|cardinality
expr_stmt|;
block|}
specifier|public
name|Column
name|permute
parameter_list|(
name|int
index|[]
name|sources
parameter_list|)
block|{
return|return
operator|new
name|Column
argument_list|(
name|representation
argument_list|,
name|representation
operator|.
name|permute
argument_list|(
name|dataSet
argument_list|,
name|sources
argument_list|)
argument_list|,
name|cardinality
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Column(representation="
operator|+
name|representation
operator|+
literal|", value="
operator|+
name|representation
operator|.
name|toString
argument_list|(
name|dataSet
argument_list|)
operator|+
literal|")"
return|;
block|}
comment|/** Returns a list view onto a data set. */
specifier|public
specifier|static
name|List
name|asList
parameter_list|(
specifier|final
name|Representation
name|representation
parameter_list|,
specifier|final
name|Object
name|dataSet
parameter_list|)
block|{
comment|// Cache size. It might be expensive to compute.
specifier|final
name|int
name|size
init|=
name|representation
operator|.
name|size
argument_list|(
name|dataSet
argument_list|)
decl_stmt|;
return|return
operator|new
name|AbstractList
argument_list|()
block|{
specifier|public
name|Object
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|representation
operator|.
name|getObject
argument_list|(
name|dataSet
argument_list|,
name|index
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
block|}
return|;
block|}
block|}
comment|/** Representation of the values of a column. */
specifier|public
interface|interface
name|Representation
block|{
comment|/** Returns the representation type. */
name|RepresentationType
name|getType
parameter_list|()
function_decl|;
comment|/** Converts a value set into a compact representation. If      * {@code sources} is not null, permutes. */
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
function_decl|;
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
function_decl|;
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
function_decl|;
comment|/** Creates a data set that is the same as a given data set      * but re-ordered. */
name|Object
name|permute
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
function_decl|;
comment|/** Returns the number of elements in a data set. (Some representations      * return the capacity, which may be slightly larger than the actual      * size.) */
name|int
name|size
parameter_list|(
name|Object
name|dataSet
parameter_list|)
function_decl|;
comment|/** Converts a data set to a string. */
name|String
name|toString
parameter_list|(
name|Object
name|dataSet
parameter_list|)
function_decl|;
block|}
comment|/** Representation that stores the column values in an array. */
specifier|public
specifier|static
class|class
name|ObjectArray
implements|implements
name|Representation
block|{
specifier|final
name|int
name|ordinal
decl_stmt|;
name|ObjectArray
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ObjectArray(ordinal="
operator|+
name|ordinal
operator|+
literal|")"
return|;
block|}
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|OBJECT_ARRAY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
comment|// We assume the values have been canonized.
specifier|final
name|List
argument_list|<
name|Comparable
argument_list|>
name|list
init|=
name|permuteList
argument_list|(
name|valueSet
operator|.
name|values
argument_list|,
name|sources
argument_list|)
decl_stmt|;
return|return
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|Comparable
index|[
literal|0
index|]
argument_list|)
return|;
block|}
specifier|public
name|Object
name|permute
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
name|Comparable
index|[]
name|list
init|=
operator|(
name|Comparable
index|[]
operator|)
name|dataSet
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|list
operator|.
name|length
decl_stmt|;
specifier|final
name|Comparable
index|[]
name|comparables
init|=
operator|new
name|Comparable
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|comparables
index|[
name|i
index|]
operator|=
name|list
index|[
name|sources
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
return|return
name|comparables
return|;
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Comparable
index|[]
operator|)
name|dataSet
operator|)
index|[
name|ordinal
index|]
return|;
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|getObject
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
specifier|public
name|int
name|size
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Comparable
index|[]
operator|)
name|dataSet
operator|)
operator|.
name|length
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|toString
argument_list|(
operator|(
name|Comparable
index|[]
operator|)
name|dataSet
argument_list|)
return|;
block|}
block|}
comment|/** Representation that stores the values of a column in an array of    * primitive values. */
specifier|public
specifier|static
class|class
name|PrimitiveArray
implements|implements
name|Representation
block|{
specifier|final
name|int
name|ordinal
decl_stmt|;
specifier|private
specifier|final
name|Primitive
name|primitive
decl_stmt|;
specifier|private
specifier|final
name|Primitive
name|p
decl_stmt|;
name|PrimitiveArray
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|Primitive
name|primitive
parameter_list|,
name|Primitive
name|p
parameter_list|)
block|{
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|this
operator|.
name|primitive
operator|=
name|primitive
expr_stmt|;
name|this
operator|.
name|p
operator|=
name|p
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"PrimitiveArray(ordinal="
operator|+
name|ordinal
operator|+
literal|", primitive="
operator|+
name|primitive
operator|+
literal|", p="
operator|+
name|p
operator|+
literal|")"
return|;
block|}
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|PRIMITIVE_ARRAY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
name|primitive
operator|.
name|toArray2
argument_list|(
name|permuteList
argument_list|(
operator|(
name|List
operator|)
name|valueSet
operator|.
name|values
argument_list|,
name|sources
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|Object
name|permute
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
return|return
name|primitive
operator|.
name|permute
argument_list|(
name|dataSet
argument_list|,
name|sources
argument_list|)
return|;
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
return|return
name|p
operator|.
name|arrayItem
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
return|;
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
return|return
name|Array
operator|.
name|getInt
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
return|return
name|Array
operator|.
name|getLength
argument_list|(
name|dataSet
argument_list|)
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
return|return
name|p
operator|.
name|arrayToString
argument_list|(
name|dataSet
argument_list|)
return|;
block|}
block|}
comment|/** Representation that stores column values in a dictionary of    * primitive values, then uses a short code for each row. */
specifier|public
specifier|static
class|class
name|PrimitiveDictionary
implements|implements
name|Representation
block|{
name|PrimitiveDictionary
parameter_list|()
block|{
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"PrimitiveDictionary()"
return|;
block|}
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|PRIMITIVE_DICTIONARY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|Object
name|permute
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|int
name|size
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|String
name|toString
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
block|}
comment|/** Representation that stores the values of a column as a    * dictionary of objects. */
specifier|public
specifier|static
class|class
name|ObjectDictionary
implements|implements
name|Representation
block|{
specifier|final
name|int
name|ordinal
decl_stmt|;
specifier|final
name|Representation
name|representation
decl_stmt|;
name|ObjectDictionary
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|Representation
name|representation
parameter_list|)
block|{
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|this
operator|.
name|representation
operator|=
name|representation
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ObjectDictionary(ordinal="
operator|+
name|ordinal
operator|+
literal|", representation="
operator|+
name|representation
operator|+
literal|")"
return|;
block|}
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|OBJECT_DICTIONARY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
specifier|final
name|int
name|n
init|=
name|valueSet
operator|.
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|extra
init|=
name|valueSet
operator|.
name|containsNull
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|Comparable
index|[]
name|codeValues
init|=
name|valueSet
operator|.
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|Comparable
index|[
name|n
operator|+
name|extra
index|]
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|codeValues
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ColumnLoader
operator|.
name|ValueSet
name|codeValueSet
init|=
operator|new
name|ColumnLoader
operator|.
name|ValueSet
argument_list|(
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Comparable
argument_list|>
name|list
init|=
name|permuteList
argument_list|(
name|valueSet
operator|.
name|values
argument_list|,
name|sources
argument_list|)
decl_stmt|;
for|for
control|(
name|Comparable
name|value
range|:
name|list
control|)
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|code
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|codeValues
argument_list|,
name|value
argument_list|)
expr_stmt|;
assert|assert
name|code
operator|>=
literal|0
operator|:
name|code
operator|+
literal|", "
operator|+
name|value
assert|;
block|}
name|codeValueSet
operator|.
name|add
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
name|Object
name|codes
init|=
name|representation
operator|.
name|freeze
argument_list|(
name|codeValueSet
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|codes
argument_list|,
name|codeValues
argument_list|)
return|;
block|}
specifier|public
name|Object
name|permute
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
specifier|final
name|Pair
argument_list|<
name|Object
argument_list|,
name|Comparable
index|[]
argument_list|>
name|pair
init|=
name|toPair
argument_list|(
name|dataSet
argument_list|)
decl_stmt|;
name|Object
name|codes
init|=
name|pair
operator|.
name|left
decl_stmt|;
name|Comparable
index|[]
name|codeValues
init|=
name|pair
operator|.
name|right
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|representation
operator|.
name|permute
argument_list|(
name|codes
argument_list|,
name|sources
argument_list|)
argument_list|,
name|codeValues
argument_list|)
return|;
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
specifier|final
name|Pair
argument_list|<
name|Object
argument_list|,
name|Comparable
index|[]
argument_list|>
name|pair
init|=
name|toPair
argument_list|(
name|dataSet
argument_list|)
decl_stmt|;
name|int
name|code
init|=
name|representation
operator|.
name|getInt
argument_list|(
name|pair
operator|.
name|left
argument_list|,
name|ordinal
argument_list|)
decl_stmt|;
return|return
name|pair
operator|.
name|right
index|[
name|code
index|]
return|;
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|getObject
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
specifier|public
name|int
name|size
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
specifier|final
name|Pair
argument_list|<
name|Object
argument_list|,
name|Comparable
index|[]
argument_list|>
name|pair
init|=
name|toPair
argument_list|(
name|dataSet
argument_list|)
decl_stmt|;
return|return
name|representation
operator|.
name|size
argument_list|(
name|pair
operator|.
name|left
argument_list|)
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
return|return
name|Column
operator|.
name|asList
argument_list|(
name|this
argument_list|,
name|dataSet
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Representation that stores string column values. */
specifier|public
specifier|static
class|class
name|StringDictionary
implements|implements
name|Representation
block|{
name|StringDictionary
parameter_list|()
block|{
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"StringDictionary()"
return|;
block|}
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|STRING_DICTIONARY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|Object
name|permute
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|int
name|size
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|String
name|toString
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
return|return
name|Column
operator|.
name|asList
argument_list|(
name|this
argument_list|,
name|dataSet
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Representation that stores byte-string column values. */
specifier|public
specifier|static
class|class
name|ByteStringDictionary
implements|implements
name|Representation
block|{
name|ByteStringDictionary
parameter_list|()
block|{
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ByteStringDictionary()"
return|;
block|}
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|BYTE_STRING_DICTIONARY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|Object
name|permute
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|int
name|size
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|String
name|toString
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
return|return
name|Column
operator|.
name|asList
argument_list|(
name|this
argument_list|,
name|dataSet
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Representation of a column that has the same value for every row. */
specifier|public
specifier|static
class|class
name|Constant
implements|implements
name|Representation
block|{
specifier|final
name|int
name|ordinal
decl_stmt|;
name|Constant
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Constant(ordinal="
operator|+
name|ordinal
operator|+
literal|")"
return|;
block|}
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|CONSTANT
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|valueSet
operator|.
name|values
operator|.
name|size
argument_list|()
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|size
operator|==
literal|0
condition|?
literal|null
else|:
name|valueSet
operator|.
name|values
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
return|;
block|}
specifier|public
name|Object
name|permute
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
return|return
name|dataSet
return|;
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
name|Pair
argument_list|<
name|Object
argument_list|,
name|Integer
argument_list|>
name|pair
init|=
name|toPair
argument_list|(
name|dataSet
argument_list|)
decl_stmt|;
return|return
name|pair
operator|.
name|left
return|;
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
name|Pair
argument_list|<
name|Object
argument_list|,
name|Integer
argument_list|>
name|pair
init|=
name|toPair
argument_list|(
name|dataSet
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|Number
operator|)
name|pair
operator|.
name|left
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
specifier|public
name|int
name|size
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
name|Pair
argument_list|<
name|Object
argument_list|,
name|Integer
argument_list|>
name|pair
init|=
name|toPair
argument_list|(
name|dataSet
argument_list|)
decl_stmt|;
return|return
name|pair
operator|.
name|right
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
name|Pair
argument_list|<
name|Object
argument_list|,
name|Integer
argument_list|>
name|pair
init|=
name|toPair
argument_list|(
name|dataSet
argument_list|)
decl_stmt|;
return|return
name|Collections
operator|.
name|nCopies
argument_list|(
name|pair
operator|.
name|right
argument_list|,
name|pair
operator|.
name|left
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Representation that stores numeric values in a bit-sliced    * array. Each value does not necessarily occupy 8, 16, 32 or 64    * bits (the number of bits used by the built-in types). This    * representation is often used to store the value codes for a    * dictionary-based representation. */
specifier|public
specifier|static
class|class
name|BitSlicedPrimitiveArray
implements|implements
name|Representation
block|{
specifier|final
name|int
name|ordinal
decl_stmt|;
specifier|final
name|int
name|bitCount
decl_stmt|;
specifier|final
name|Primitive
name|primitive
decl_stmt|;
specifier|final
name|boolean
name|signed
decl_stmt|;
name|BitSlicedPrimitiveArray
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|int
name|bitCount
parameter_list|,
name|Primitive
name|primitive
parameter_list|,
name|boolean
name|signed
parameter_list|)
block|{
assert|assert
name|bitCount
operator|>
literal|0
assert|;
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|this
operator|.
name|bitCount
operator|=
name|bitCount
expr_stmt|;
name|this
operator|.
name|primitive
operator|=
name|primitive
expr_stmt|;
name|this
operator|.
name|signed
operator|=
name|signed
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"BitSlicedPrimitiveArray(ordinal="
operator|+
name|ordinal
operator|+
literal|", bitCount="
operator|+
name|bitCount
operator|+
literal|", primitive="
operator|+
name|primitive
operator|+
literal|", signed="
operator|+
name|signed
operator|+
literal|")"
return|;
block|}
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|BIT_SLICED_PRIMITIVE_ARRAY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
specifier|final
name|int
name|chunksPerWord
init|=
literal|64
operator|/
name|bitCount
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Comparable
argument_list|>
name|valueList
init|=
name|permuteList
argument_list|(
name|valueSet
operator|.
name|values
argument_list|,
name|sources
argument_list|)
decl_stmt|;
specifier|final
name|int
name|valueCount
init|=
name|valueList
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|wordCount
init|=
operator|(
name|valueCount
operator|+
operator|(
name|chunksPerWord
operator|-
literal|1
operator|)
operator|)
operator|/
name|chunksPerWord
decl_stmt|;
specifier|final
name|int
name|remainingChunkCount
init|=
name|valueCount
operator|%
name|chunksPerWord
decl_stmt|;
specifier|final
name|long
index|[]
name|longs
init|=
operator|new
name|long
index|[
name|wordCount
index|]
decl_stmt|;
specifier|final
name|int
name|n
init|=
name|valueCount
operator|/
name|chunksPerWord
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|valueCount
operator|>
literal|0
operator|&&
name|valueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|Boolean
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|Boolean
argument_list|>
name|booleans
init|=
operator|(
name|List
operator|)
name|valueList
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|long
name|v
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|chunksPerWord
condition|;
name|j
operator|++
control|)
block|{
name|v
operator||=
name|booleans
operator|.
name|get
argument_list|(
name|k
operator|++
argument_list|)
condition|?
operator|(
literal|1
operator|<<
operator|(
name|bitCount
operator|*
name|j
operator|)
operator|)
else|:
literal|0
expr_stmt|;
block|}
name|longs
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
block|}
if|if
condition|(
name|remainingChunkCount
operator|>
literal|0
condition|)
block|{
name|long
name|v
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|remainingChunkCount
condition|;
name|j
operator|++
control|)
block|{
name|v
operator||=
name|booleans
operator|.
name|get
argument_list|(
name|k
operator|++
argument_list|)
condition|?
operator|(
literal|1
operator|<<
operator|(
name|bitCount
operator|*
name|j
operator|)
operator|)
else|:
literal|0
expr_stmt|;
block|}
name|longs
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
block|}
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|Number
argument_list|>
name|numbers
init|=
operator|(
name|List
operator|)
name|valueList
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|long
name|v
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|chunksPerWord
condition|;
name|j
operator|++
control|)
block|{
name|v
operator||=
name|numbers
operator|.
name|get
argument_list|(
name|k
operator|++
argument_list|)
operator|.
name|longValue
argument_list|()
operator|<<
operator|(
name|bitCount
operator|*
name|j
operator|)
expr_stmt|;
block|}
name|longs
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
block|}
if|if
condition|(
name|remainingChunkCount
operator|>
literal|0
condition|)
block|{
name|long
name|v
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|remainingChunkCount
condition|;
name|j
operator|++
control|)
block|{
name|v
operator||=
name|numbers
operator|.
name|get
argument_list|(
name|k
operator|++
argument_list|)
operator|.
name|longValue
argument_list|()
operator|<<
operator|(
name|bitCount
operator|*
name|j
operator|)
expr_stmt|;
block|}
name|longs
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
block|}
block|}
return|return
name|longs
return|;
block|}
specifier|public
name|Object
name|permute
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
index|[]
name|sources
parameter_list|)
block|{
specifier|final
name|long
index|[]
name|longs0
init|=
operator|(
name|long
index|[]
operator|)
name|dataSet
decl_stmt|;
name|int
name|n
init|=
name|sources
operator|.
name|length
decl_stmt|;
specifier|final
name|long
index|[]
name|longs
init|=
operator|new
name|long
index|[
name|longs0
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|orLong
argument_list|(
name|bitCount
argument_list|,
name|longs
argument_list|,
name|i
argument_list|,
name|getLong
argument_list|(
name|bitCount
argument_list|,
name|longs0
argument_list|,
name|sources
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|longs
return|;
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
specifier|final
name|long
index|[]
name|longs
init|=
operator|(
name|long
index|[]
operator|)
name|dataSet
decl_stmt|;
specifier|final
name|int
name|chunksPerWord
init|=
literal|64
operator|/
name|bitCount
decl_stmt|;
specifier|final
name|int
name|word
init|=
name|ordinal
operator|/
name|chunksPerWord
decl_stmt|;
specifier|final
name|long
name|v
init|=
name|longs
index|[
name|word
index|]
decl_stmt|;
specifier|final
name|int
name|chunk
init|=
name|ordinal
operator|%
name|chunksPerWord
decl_stmt|;
specifier|final
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
name|bitCount
operator|)
operator|-
literal|1
decl_stmt|;
specifier|final
name|int
name|signMask
init|=
literal|1
operator|<<
operator|(
name|bitCount
operator|-
literal|1
operator|)
decl_stmt|;
specifier|final
name|int
name|shift
init|=
name|chunk
operator|*
name|bitCount
decl_stmt|;
specifier|final
name|long
name|w
init|=
name|v
operator|>>
name|shift
decl_stmt|;
name|long
name|x
init|=
name|w
operator|&
name|mask
decl_stmt|;
if|if
condition|(
name|signed
operator|&&
operator|(
name|x
operator|&
name|signMask
operator|)
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
switch|switch
condition|(
name|primitive
condition|)
block|{
case|case
name|BOOLEAN
case|:
return|return
name|x
operator|!=
literal|0
return|;
case|case
name|BYTE
case|:
return|return
operator|(
name|byte
operator|)
name|x
return|;
case|case
name|CHAR
case|:
return|return
operator|(
name|char
operator|)
name|x
return|;
case|case
name|SHORT
case|:
return|return
operator|(
name|short
operator|)
name|x
return|;
case|case
name|INT
case|:
return|return
operator|(
name|int
operator|)
name|x
return|;
case|case
name|LONG
case|:
return|return
name|x
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|primitive
operator|+
literal|" unexpected"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
specifier|final
name|long
index|[]
name|longs
init|=
operator|(
name|long
index|[]
operator|)
name|dataSet
decl_stmt|;
specifier|final
name|int
name|chunksPerWord
init|=
literal|64
operator|/
name|bitCount
decl_stmt|;
specifier|final
name|int
name|word
init|=
name|ordinal
operator|/
name|chunksPerWord
decl_stmt|;
specifier|final
name|long
name|v
init|=
name|longs
index|[
name|word
index|]
decl_stmt|;
specifier|final
name|int
name|chunk
init|=
name|ordinal
operator|%
name|chunksPerWord
decl_stmt|;
specifier|final
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
name|bitCount
operator|)
operator|-
literal|1
decl_stmt|;
specifier|final
name|int
name|signMask
init|=
literal|1
operator|<<
operator|(
name|bitCount
operator|-
literal|1
operator|)
decl_stmt|;
specifier|final
name|int
name|shift
init|=
name|chunk
operator|*
name|bitCount
decl_stmt|;
specifier|final
name|long
name|w
init|=
name|v
operator|>>
name|shift
decl_stmt|;
name|long
name|x
init|=
name|w
operator|&
name|mask
decl_stmt|;
if|if
condition|(
name|signed
operator|&&
operator|(
name|x
operator|&
name|signMask
operator|)
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|x
return|;
block|}
specifier|public
specifier|static
name|long
name|getLong
parameter_list|(
name|int
name|bitCount
parameter_list|,
name|long
index|[]
name|values
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
return|return
name|getLong
argument_list|(
name|bitCount
argument_list|,
literal|64
operator|/
name|bitCount
argument_list|,
operator|(
literal|1L
operator|<<
name|bitCount
operator|)
operator|-
literal|1L
argument_list|,
name|values
argument_list|,
name|ordinal
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|long
name|getLong
parameter_list|(
name|int
name|bitCount
parameter_list|,
name|int
name|chunksPerWord
parameter_list|,
name|long
name|mask
parameter_list|,
name|long
index|[]
name|values
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
specifier|final
name|int
name|word
init|=
name|ordinal
operator|/
name|chunksPerWord
decl_stmt|;
specifier|final
name|int
name|chunk
init|=
name|ordinal
operator|%
name|chunksPerWord
decl_stmt|;
specifier|final
name|long
name|value
init|=
name|values
index|[
name|word
index|]
decl_stmt|;
specifier|final
name|int
name|shift
init|=
name|chunk
operator|*
name|bitCount
decl_stmt|;
return|return
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
name|mask
return|;
block|}
specifier|public
specifier|static
name|void
name|orLong
parameter_list|(
name|int
name|bitCount
parameter_list|,
name|long
index|[]
name|values
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|long
name|value
parameter_list|)
block|{
name|orLong
argument_list|(
name|bitCount
argument_list|,
literal|64
operator|/
name|bitCount
argument_list|,
name|values
argument_list|,
name|ordinal
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|orLong
parameter_list|(
name|int
name|bitCount
parameter_list|,
name|int
name|chunksPerWord
parameter_list|,
name|long
index|[]
name|values
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|long
name|value
parameter_list|)
block|{
specifier|final
name|int
name|word
init|=
name|ordinal
operator|/
name|chunksPerWord
decl_stmt|;
specifier|final
name|int
name|chunk
init|=
name|ordinal
operator|%
name|chunksPerWord
decl_stmt|;
specifier|final
name|int
name|shift
init|=
name|chunk
operator|*
name|bitCount
decl_stmt|;
name|values
index|[
name|word
index|]
operator||=
name|value
operator|<<
name|shift
expr_stmt|;
block|}
specifier|public
name|int
name|size
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
specifier|final
name|long
index|[]
name|longs
init|=
operator|(
name|long
index|[]
operator|)
name|dataSet
decl_stmt|;
specifier|final
name|int
name|chunksPerWord
init|=
literal|64
operator|/
name|bitCount
decl_stmt|;
return|return
name|longs
operator|.
name|length
operator|*
name|chunksPerWord
return|;
comment|// may be slightly too high
block|}
specifier|public
name|String
name|toString
parameter_list|(
name|Object
name|dataSet
parameter_list|)
block|{
return|return
name|Column
operator|.
name|asList
argument_list|(
name|this
argument_list|,
name|dataSet
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|permuteList
parameter_list|(
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
specifier|final
name|int
index|[]
name|sources
parameter_list|)
block|{
if|if
condition|(
name|sources
operator|==
literal|null
condition|)
block|{
return|return
name|list
return|;
block|}
return|return
operator|new
name|AbstractList
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|sources
index|[
name|index
index|]
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|list
operator|.
name|size
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/** Contents of a table. */
specifier|public
specifier|static
class|class
name|Content
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|Column
argument_list|>
name|columns
decl_stmt|;
specifier|private
specifier|final
name|int
name|size
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|RelCollation
argument_list|>
name|collations
decl_stmt|;
name|Content
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Column
argument_list|>
name|columns
parameter_list|,
name|int
name|size
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RelCollation
argument_list|>
name|collations
parameter_list|)
block|{
name|this
operator|.
name|columns
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|columns
argument_list|)
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|collations
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|collations
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
name|Content
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Column
argument_list|>
name|columns
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|sortField
parameter_list|)
block|{
name|this
argument_list|(
name|columns
argument_list|,
name|size
argument_list|,
name|sortField
operator|>=
literal|0
condition|?
name|RelCollations
operator|.
name|createSingleton
argument_list|(
name|sortField
argument_list|)
else|:
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|Enumerator
argument_list|<
name|T
argument_list|>
name|enumerator
parameter_list|()
block|{
if|if
condition|(
name|columns
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
operator|(
name|Enumerator
argument_list|<
name|T
argument_list|>
operator|)
operator|new
name|ObjectEnumerator
argument_list|(
name|size
argument_list|,
name|columns
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|Enumerator
argument_list|<
name|T
argument_list|>
operator|)
operator|new
name|ArrayEnumerator
argument_list|(
name|size
argument_list|,
name|columns
argument_list|)
return|;
block|}
block|}
specifier|public
name|Enumerator
argument_list|<
name|Object
index|[]
argument_list|>
name|arrayEnumerator
parameter_list|()
block|{
return|return
operator|new
name|ArrayEnumerator
argument_list|(
name|size
argument_list|,
name|columns
argument_list|)
return|;
block|}
comment|/** Enumerator over a table with a single column; each element      * returned is an object. */
specifier|private
specifier|static
class|class
name|ObjectEnumerator
implements|implements
name|Enumerator
argument_list|<
name|Object
argument_list|>
block|{
specifier|final
name|int
name|rowCount
decl_stmt|;
specifier|final
name|Object
name|dataSet
decl_stmt|;
specifier|final
name|Representation
name|representation
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|ObjectEnumerator
parameter_list|(
name|int
name|rowCount
parameter_list|,
name|Column
name|column
parameter_list|)
block|{
name|this
operator|.
name|rowCount
operator|=
name|rowCount
expr_stmt|;
name|this
operator|.
name|dataSet
operator|=
name|column
operator|.
name|dataSet
expr_stmt|;
name|this
operator|.
name|representation
operator|=
name|column
operator|.
name|representation
expr_stmt|;
block|}
specifier|public
name|Object
name|current
parameter_list|()
block|{
return|return
name|representation
operator|.
name|getObject
argument_list|(
name|dataSet
argument_list|,
name|i
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
return|return
operator|++
name|i
operator|<
name|rowCount
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
block|}
block|}
comment|/** Enumerator over a table with more than one column; each element      * returned is an array. */
specifier|private
specifier|static
class|class
name|ArrayEnumerator
implements|implements
name|Enumerator
argument_list|<
name|Object
index|[]
argument_list|>
block|{
specifier|final
name|int
name|rowCount
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Column
argument_list|>
name|columns
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|ArrayEnumerator
parameter_list|(
name|int
name|rowCount
parameter_list|,
name|List
argument_list|<
name|Column
argument_list|>
name|columns
parameter_list|)
block|{
name|this
operator|.
name|rowCount
operator|=
name|rowCount
expr_stmt|;
name|this
operator|.
name|columns
operator|=
name|columns
expr_stmt|;
block|}
specifier|public
name|Object
index|[]
name|current
parameter_list|()
block|{
name|Object
index|[]
name|objects
init|=
operator|new
name|Object
index|[
name|columns
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|objects
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|Column
name|pair
init|=
name|columns
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|objects
index|[
name|j
index|]
operator|=
name|pair
operator|.
name|representation
operator|.
name|getObject
argument_list|(
name|pair
operator|.
name|dataSet
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|objects
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
return|return
operator|++
name|i
operator|<
name|rowCount
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|// End ArrayTable.java
end_comment

end_unit

