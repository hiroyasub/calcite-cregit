begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|Spaces
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptSamplingParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|ViewExpanders
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|prepare
operator|.
name|Prepare
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|prepare
operator|.
name|RelOptTableImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollationTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelRoot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelShuttleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|SingleRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Collect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sample
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|hint
operator|.
name|HintStrategyTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|hint
operator|.
name|Hintable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|hint
operator|.
name|RelHint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalCorrelate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalIntersect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalMatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalMinus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalTableFunctionScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalTableModify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalTableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalUnion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelColumnMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|stream
operator|.
name|Delta
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|stream
operator|.
name|LogicalDelta
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCorrelVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexPatternFieldRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexRangeRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSubQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexWindowBound
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexWindowBounds
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|ColumnStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|ModifiableTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|ModifiableView
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|TranslatableTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Wrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|JoinConditionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|JoinType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBasicCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCallBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDataTypeSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDelete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlInsert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIntervalQualifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlMatchRecognize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlMerge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNumericLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOrderBy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlPivot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSampleSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelectKeyword
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSetOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSnapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUnnestOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUnpivot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUpdate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlValuesOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWindow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWithItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlInOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlQuantifyOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlRowOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlReturnTypeInference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|TableFunctionReturnTypeInference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlBasicVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|AggregatingSelectScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|CollectNamespace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|DelegatingScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|ListScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|MatchRecognizeScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|ParameterScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SelectScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlMonotonicity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlNameMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlQualified
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlUserDefinedTableFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlUserDefinedTableMacro
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorNamespace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableIntList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NlsString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NumberUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|trace
operator|.
name|CalciteTrace
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|immutables
operator|.
name|value
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiFunction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|UnaryOperator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Nullness
operator|.
name|castNonNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
operator|.
name|stripAs
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * Converts a SQL parse tree (consisting of  * {@link org.apache.calcite.sql.SqlNode} objects) into a relational algebra  * expression (consisting of {@link org.apache.calcite.rel.RelNode} objects).  *  *<p>The public entry points are: {@link #convertQuery},  * {@link #convertExpression(SqlNode)}.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"UnstableApiUsage"
argument_list|)
annotation|@
name|Value
operator|.
name|Enclosing
specifier|public
class|class
name|SqlToRelConverter
block|{
comment|//~ Static fields/initializers ---------------------------------------------
comment|/** Default configuration. */
specifier|private
specifier|static
specifier|final
name|Config
name|CONFIG
init|=
name|ImmutableSqlToRelConverter
operator|.
name|Config
operator|.
name|builder
argument_list|()
operator|.
name|withRelBuilderFactory
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
operator|.
name|withRelBuilderConfigTransform
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withPushJoinCondition
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|withHintStrategyTable
argument_list|(
name|HintStrategyTable
operator|.
name|EMPTY
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|Logger
name|SQL2REL_LOGGER
init|=
name|CalciteTrace
operator|.
name|getSqlToRelTracer
argument_list|()
decl_stmt|;
comment|/** Size of the smallest IN list that will be converted to a semijoin to a    * static table. */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_IN_SUB_QUERY_THRESHOLD
init|=
literal|20
decl_stmt|;
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_IN_SUBQUERY_THRESHOLD
init|=
name|DEFAULT_IN_SUB_QUERY_THRESHOLD
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|protected
specifier|final
annotation|@
name|Nullable
name|SqlValidator
name|validator
decl_stmt|;
specifier|protected
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|protected
specifier|final
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
decl_stmt|;
specifier|protected
specifier|final
name|RelOptCluster
name|cluster
decl_stmt|;
specifier|private
name|SubQueryConverter
name|subQueryConverter
decl_stmt|;
specifier|protected
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
name|leaves
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
annotation|@
name|Nullable
name|SqlDynamicParam
argument_list|>
name|dynamicParamSqlNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|SqlOperatorTable
name|opTab
decl_stmt|;
specifier|protected
specifier|final
name|RelDataTypeFactory
name|typeFactory
decl_stmt|;
specifier|private
specifier|final
name|SqlNodeToRexConverter
name|exprConverter
decl_stmt|;
specifier|private
specifier|final
name|HintStrategyTable
name|hintStrategies
decl_stmt|;
specifier|private
name|int
name|explainParamCount
decl_stmt|;
specifier|public
specifier|final
name|SqlToRelConverter
operator|.
name|Config
name|config
decl_stmt|;
specifier|private
specifier|final
name|RelBuilder
name|relBuilder
decl_stmt|;
comment|/**    * Fields used in name resolution for correlated sub-queries.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|CorrelationId
argument_list|,
name|DeferredLookup
argument_list|>
name|mapCorrelToDeferred
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Stack of names of datasets requested by the<code>    * TABLE(SAMPLE(&lt;datasetName&gt;,&lt;query&gt;))</code> construct.    */
specifier|private
specifier|final
name|Deque
argument_list|<
name|String
argument_list|>
name|datasetStack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Mapping of non-correlated sub-queries that have been converted to their    * equivalent constants. Used to avoid re-evaluating the sub-query if it's    * already been evaluated.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|RexNode
argument_list|>
name|mapConvertedNonCorrSubqs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
specifier|final
name|RelOptTable
operator|.
name|ViewExpander
name|viewExpander
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a converter.    *    * @param viewExpander    Preparing statement    * @param validator       Validator    * @param catalogReader   Schema    * @param planner         Planner    * @param rexBuilder      Rex builder    * @param convertletTable Expression converter    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|SqlToRelConverter
parameter_list|(
name|RelOptTable
operator|.
name|ViewExpander
name|viewExpander
parameter_list|,
name|SqlValidator
name|validator
parameter_list|,
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
parameter_list|,
name|RelOptPlanner
name|planner
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|SqlRexConvertletTable
name|convertletTable
parameter_list|)
block|{
name|this
argument_list|(
name|viewExpander
argument_list|,
name|validator
argument_list|,
name|catalogReader
argument_list|,
name|RelOptCluster
operator|.
name|create
argument_list|(
name|planner
argument_list|,
name|rexBuilder
argument_list|)
argument_list|,
name|convertletTable
argument_list|,
name|SqlToRelConverter
operator|.
name|config
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|SqlToRelConverter
parameter_list|(
name|RelOptTable
operator|.
name|ViewExpander
name|viewExpander
parameter_list|,
name|SqlValidator
name|validator
parameter_list|,
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
parameter_list|,
name|RelOptCluster
name|cluster
parameter_list|,
name|SqlRexConvertletTable
name|convertletTable
parameter_list|)
block|{
name|this
argument_list|(
name|viewExpander
argument_list|,
name|validator
argument_list|,
name|catalogReader
argument_list|,
name|cluster
argument_list|,
name|convertletTable
argument_list|,
name|SqlToRelConverter
operator|.
name|config
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Creates a converter. */
specifier|public
name|SqlToRelConverter
parameter_list|(
name|RelOptTable
operator|.
name|ViewExpander
name|viewExpander
parameter_list|,
annotation|@
name|Nullable
name|SqlValidator
name|validator
parameter_list|,
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
parameter_list|,
name|RelOptCluster
name|cluster
parameter_list|,
name|SqlRexConvertletTable
name|convertletTable
parameter_list|,
name|Config
name|config
parameter_list|)
block|{
name|this
operator|.
name|viewExpander
operator|=
name|viewExpander
expr_stmt|;
name|this
operator|.
name|opTab
operator|=
operator|(
name|validator
operator|==
literal|null
operator|)
condition|?
name|SqlStdOperatorTable
operator|.
name|instance
argument_list|()
else|:
name|validator
operator|.
name|getOperatorTable
argument_list|()
expr_stmt|;
name|this
operator|.
name|validator
operator|=
name|validator
expr_stmt|;
name|this
operator|.
name|catalogReader
operator|=
name|catalogReader
expr_stmt|;
name|this
operator|.
name|subQueryConverter
operator|=
operator|new
name|NoOpSubQueryConverter
argument_list|()
expr_stmt|;
name|this
operator|.
name|rexBuilder
operator|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
expr_stmt|;
name|this
operator|.
name|typeFactory
operator|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
expr_stmt|;
name|this
operator|.
name|exprConverter
operator|=
operator|new
name|SqlNodeToRexConverterImpl
argument_list|(
name|convertletTable
argument_list|)
expr_stmt|;
name|this
operator|.
name|explainParamCount
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|requireNonNull
argument_list|(
name|config
argument_list|,
literal|"config"
argument_list|)
expr_stmt|;
name|this
operator|.
name|relBuilder
operator|=
name|config
operator|.
name|getRelBuilderFactory
argument_list|()
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
literal|null
argument_list|)
operator|.
name|transform
argument_list|(
name|config
operator|.
name|getRelBuilderConfigTransform
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|hintStrategies
operator|=
name|config
operator|.
name|getHintStrategyTable
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|setHintStrategies
argument_list|(
name|this
operator|.
name|hintStrategies
argument_list|)
expr_stmt|;
name|this
operator|.
name|cluster
operator|=
name|requireNonNull
argument_list|(
name|cluster
argument_list|,
literal|"cluster"
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|private
name|SqlValidator
name|validator
parameter_list|()
block|{
return|return
name|requireNonNull
argument_list|(
name|validator
argument_list|,
literal|"validator"
argument_list|)
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|SqlValidatorNamespace
parameter_list|>
name|T
name|getNamespace
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|T
operator|)
name|requireNonNull
argument_list|(
name|getNamespaceOrNull
argument_list|(
name|node
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"Namespace is not found for "
operator|+
name|node
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
parameter_list|<
name|T
extends|extends
name|SqlValidatorNamespace
parameter_list|>
annotation|@
name|Nullable
name|T
name|getNamespaceOrNull
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
return|return
operator|(
expr|@
name|Nullable
name|T
operator|)
name|validator
argument_list|()
operator|.
name|getNamespace
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/** Returns the RelOptCluster in use. */
specifier|public
name|RelOptCluster
name|getCluster
parameter_list|()
block|{
return|return
name|cluster
return|;
block|}
comment|/**    * Returns the row-expression builder.    */
specifier|public
name|RexBuilder
name|getRexBuilder
parameter_list|()
block|{
return|return
name|rexBuilder
return|;
block|}
comment|/**    * Returns the number of dynamic parameters encountered during translation;    * this must only be called after {@link #convertQuery}.    *    * @return number of dynamic parameters    */
specifier|public
name|int
name|getDynamicParamCount
parameter_list|()
block|{
return|return
name|dynamicParamSqlNodes
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Returns the type inferred for a dynamic parameter.    *    * @param index 0-based index of dynamic parameter    * @return inferred type, never null    */
specifier|public
name|RelDataType
name|getDynamicParamType
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|SqlNode
name|sqlNode
init|=
name|dynamicParamSqlNodes
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|sqlNode
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|"dynamic param type inference"
argument_list|)
throw|;
block|}
return|return
name|validator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|sqlNode
argument_list|)
return|;
block|}
comment|/**    * Returns the current count of the number of dynamic parameters in an    * EXPLAIN PLAN statement.    *    * @param increment if true, increment the count    * @return the current count before the optional increment    */
specifier|public
name|int
name|getDynamicParamCountInExplain
parameter_list|(
name|boolean
name|increment
parameter_list|)
block|{
name|int
name|retVal
init|=
name|explainParamCount
decl_stmt|;
if|if
condition|(
name|increment
condition|)
block|{
operator|++
name|explainParamCount
expr_stmt|;
block|}
return|return
name|retVal
return|;
block|}
comment|/** Returns the mapping of non-correlated sub-queries that have been converted    * to the constants that they evaluate to. */
specifier|public
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|RexNode
argument_list|>
name|getMapConvertedNonCorrSubqs
parameter_list|()
block|{
return|return
name|mapConvertedNonCorrSubqs
return|;
block|}
comment|/**    * Adds to the current map of non-correlated converted sub-queries the    * elements from another map that contains non-correlated sub-queries that    * have been converted by another SqlToRelConverter.    *    * @param alreadyConvertedNonCorrSubqs the other map    */
specifier|public
name|void
name|addConvertedNonCorrSubqs
parameter_list|(
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|RexNode
argument_list|>
name|alreadyConvertedNonCorrSubqs
parameter_list|)
block|{
name|mapConvertedNonCorrSubqs
operator|.
name|putAll
argument_list|(
name|alreadyConvertedNonCorrSubqs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets a new SubQueryConverter. To have any effect, this must be called    * before any convert method.    *    * @param converter new SubQueryConverter    */
specifier|public
name|void
name|setSubQueryConverter
parameter_list|(
name|SubQueryConverter
name|converter
parameter_list|)
block|{
name|subQueryConverter
operator|=
name|converter
expr_stmt|;
block|}
comment|/**    * Sets the number of dynamic parameters in the current EXPLAIN PLAN    * statement.    *    * @param explainParamCount number of dynamic parameters in the statement    */
specifier|public
name|void
name|setDynamicParamCountInExplain
parameter_list|(
name|int
name|explainParamCount
parameter_list|)
block|{
assert|assert
name|config
operator|.
name|isExplain
argument_list|()
assert|;
name|this
operator|.
name|explainParamCount
operator|=
name|explainParamCount
expr_stmt|;
block|}
specifier|private
name|void
name|checkConvertedType
parameter_list|(
name|SqlNode
name|query
parameter_list|,
name|RelNode
name|result
parameter_list|)
block|{
if|if
condition|(
name|query
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|DML
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Verify that conversion from SQL to relational algebra did
comment|// not perturb any type information.  (We can't do this if the
comment|// SQL statement is something like an INSERT which has no
comment|// validator type information associated with its result,
comment|// hence the namespace check above.)
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|validatedFields
init|=
name|validator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|query
argument_list|)
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|validatedRowType
init|=
name|validator
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createStructType
argument_list|(
name|Pair
operator|.
name|right
argument_list|(
name|validatedFields
argument_list|)
argument_list|,
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|validatedFields
argument_list|)
argument_list|,
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|convertedFields
init|=
name|result
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|validatedFields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|convertedRowType
init|=
name|validator
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createStructType
argument_list|(
name|convertedFields
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|RelOptUtil
operator|.
name|equal
argument_list|(
literal|"validated row type"
argument_list|,
name|validatedRowType
argument_list|,
literal|"converted row type"
argument_list|,
name|convertedRowType
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Conversion to relational algebra failed to "
operator|+
literal|"preserve datatypes:\n"
operator|+
literal|"validated type:\n"
operator|+
name|validatedRowType
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\nconverted type:\n"
operator|+
name|convertedRowType
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\nrel:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|result
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|public
name|RelNode
name|flattenTypes
parameter_list|(
name|RelNode
name|rootRel
parameter_list|,
name|boolean
name|restructure
parameter_list|)
block|{
name|RelStructuredTypeFlattener
name|typeFlattener
init|=
operator|new
name|RelStructuredTypeFlattener
argument_list|(
name|relBuilder
argument_list|,
name|rexBuilder
argument_list|,
name|createToRelContext
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
argument_list|,
name|restructure
argument_list|)
decl_stmt|;
return|return
name|typeFlattener
operator|.
name|rewrite
argument_list|(
name|rootRel
argument_list|)
return|;
block|}
comment|/**    * If sub-query is correlated and decorrelation is enabled, performs    * decorrelation.    *    * @param query   Query    * @param rootRel Root relational expression    * @return New root relational expression after decorrelation    */
specifier|public
name|RelNode
name|decorrelate
parameter_list|(
name|SqlNode
name|query
parameter_list|,
name|RelNode
name|rootRel
parameter_list|)
block|{
if|if
condition|(
operator|!
name|config
operator|.
name|isDecorrelationEnabled
argument_list|()
condition|)
block|{
return|return
name|rootRel
return|;
block|}
specifier|final
name|RelNode
name|result
init|=
name|decorrelateQuery
argument_list|(
name|rootRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|rootRel
condition|)
block|{
name|checkConvertedType
argument_list|(
name|query
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Walks over a tree of relational expressions, replacing each    * {@link RelNode} with a 'slimmed down' relational expression that projects    * only the fields required by its consumer.    *    *<p>This may make things easier for the optimizer, by removing crud that    * would expand the search space, but is difficult for the optimizer itself    * to do it, because optimizer rules must preserve the number and type of    * fields. Hence, this transform that operates on the entire tree, similar    * to the {@link RelStructuredTypeFlattener type-flattening transform}.    *    *<p>Currently this functionality is disabled in farrago/luciddb; the    * default implementation of this method does nothing.    *    * @param ordered Whether the relational expression must produce results in    * a particular order (typically because it has an ORDER BY at top level)    * @param rootRel Relational expression that is at the root of the tree    * @return Trimmed relational expression    */
specifier|public
name|RelNode
name|trimUnusedFields
parameter_list|(
name|boolean
name|ordered
parameter_list|,
name|RelNode
name|rootRel
parameter_list|)
block|{
comment|// Trim fields that are not used by their consumer.
if|if
condition|(
name|isTrimUnusedFields
argument_list|()
condition|)
block|{
specifier|final
name|RelFieldTrimmer
name|trimmer
init|=
name|newFieldTrimmer
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelCollation
argument_list|>
name|collations
init|=
name|rootRel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTraits
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|rootRel
operator|=
name|trimmer
operator|.
name|trim
argument_list|(
name|rootRel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ordered
operator|&&
name|collations
operator|!=
literal|null
operator|&&
operator|!
name|collations
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|collations
operator|.
name|equals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|RelCollations
operator|.
name|EMPTY
argument_list|)
argument_list|)
condition|)
block|{
specifier|final
name|RelTraitSet
name|traitSet
init|=
name|rootRel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|,
name|collations
argument_list|)
decl_stmt|;
name|rootRel
operator|=
name|rootRel
operator|.
name|copy
argument_list|(
name|traitSet
argument_list|,
name|rootRel
operator|.
name|getInputs
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SQL2REL_LOGGER
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|SQL2REL_LOGGER
operator|.
name|debug
argument_list|(
name|RelOptUtil
operator|.
name|dumpPlan
argument_list|(
literal|"Plan after trimming unused fields"
argument_list|,
name|rootRel
argument_list|,
name|SqlExplainFormat
operator|.
name|TEXT
argument_list|,
name|SqlExplainLevel
operator|.
name|EXPPLAN_ATTRIBUTES
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rootRel
return|;
block|}
comment|/**    * Creates a RelFieldTrimmer.    *    * @return Field trimmer    */
specifier|protected
name|RelFieldTrimmer
name|newFieldTrimmer
parameter_list|()
block|{
return|return
operator|new
name|RelFieldTrimmer
argument_list|(
name|validator
argument_list|,
name|relBuilder
argument_list|)
return|;
block|}
comment|/**    * Converts an unvalidated query's parse tree into a relational expression.    *    * @param query           Query to convert    * @param needsValidation Whether to validate the query before converting;    *<code>false</code> if the query has already been    *                        validated.    * @param top             Whether the query is top-level, say if its result    *                        will become a JDBC result set;<code>false</code> if    *                        the query will be part of a view.    */
specifier|public
name|RelRoot
name|convertQuery
parameter_list|(
name|SqlNode
name|query
parameter_list|,
specifier|final
name|boolean
name|needsValidation
parameter_list|,
specifier|final
name|boolean
name|top
parameter_list|)
block|{
if|if
condition|(
name|needsValidation
condition|)
block|{
name|query
operator|=
name|validator
argument_list|()
operator|.
name|validate
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|result
init|=
name|convertQueryRecursive
argument_list|(
name|query
argument_list|,
name|top
argument_list|,
literal|null
argument_list|)
operator|.
name|rel
decl_stmt|;
if|if
condition|(
name|top
condition|)
block|{
if|if
condition|(
name|isStream
argument_list|(
name|query
argument_list|)
condition|)
block|{
name|result
operator|=
operator|new
name|LogicalDelta
argument_list|(
name|cluster
argument_list|,
name|result
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
name|RelCollation
name|collation
init|=
name|RelCollations
operator|.
name|EMPTY
decl_stmt|;
if|if
condition|(
operator|!
name|query
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|DML
argument_list|)
condition|)
block|{
if|if
condition|(
name|isOrdered
argument_list|(
name|query
argument_list|)
condition|)
block|{
name|collation
operator|=
name|requiredCollation
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
name|checkConvertedType
argument_list|(
name|query
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQL2REL_LOGGER
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|SQL2REL_LOGGER
operator|.
name|debug
argument_list|(
name|RelOptUtil
operator|.
name|dumpPlan
argument_list|(
literal|"Plan after converting SqlNode to RelNode"
argument_list|,
name|result
argument_list|,
name|SqlExplainFormat
operator|.
name|TEXT
argument_list|,
name|SqlExplainLevel
operator|.
name|EXPPLAN_ATTRIBUTES
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataType
name|validatedRowType
init|=
name|validator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelHint
argument_list|>
name|hints
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|query
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|SELECT
condition|)
block|{
specifier|final
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|query
decl_stmt|;
if|if
condition|(
name|select
operator|.
name|hasHints
argument_list|()
condition|)
block|{
name|hints
operator|=
name|SqlUtil
operator|.
name|getRelHint
argument_list|(
name|hintStrategies
argument_list|,
name|select
operator|.
name|getHints
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// propagate the hints.
name|result
operator|=
name|RelOptUtil
operator|.
name|propagateRelHints
argument_list|(
name|result
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|RelRoot
operator|.
name|of
argument_list|(
name|result
argument_list|,
name|validatedRowType
argument_list|,
name|query
operator|.
name|getKind
argument_list|()
argument_list|)
operator|.
name|withCollation
argument_list|(
name|collation
argument_list|)
operator|.
name|withHints
argument_list|(
name|hints
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isStream
parameter_list|(
name|SqlNode
name|query
parameter_list|)
block|{
return|return
name|query
operator|instanceof
name|SqlSelect
operator|&&
operator|(
operator|(
name|SqlSelect
operator|)
name|query
operator|)
operator|.
name|isKeywordPresent
argument_list|(
name|SqlSelectKeyword
operator|.
name|STREAM
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isOrdered
parameter_list|(
name|SqlNode
name|query
parameter_list|)
block|{
switch|switch
condition|(
name|query
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|SELECT
case|:
name|SqlNodeList
name|orderList
init|=
operator|(
operator|(
name|SqlSelect
operator|)
name|query
operator|)
operator|.
name|getOrderList
argument_list|()
decl_stmt|;
return|return
name|orderList
operator|!=
literal|null
operator|&&
name|orderList
operator|.
name|size
argument_list|()
operator|>
literal|0
return|;
case|case
name|WITH
case|:
return|return
name|isOrdered
argument_list|(
operator|(
operator|(
name|SqlWith
operator|)
name|query
operator|)
operator|.
name|body
argument_list|)
return|;
case|case
name|ORDER_BY
case|:
return|return
operator|(
operator|(
name|SqlOrderBy
operator|)
name|query
operator|)
operator|.
name|orderList
operator|.
name|size
argument_list|()
operator|>
literal|0
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
specifier|private
specifier|static
name|RelCollation
name|requiredCollation
parameter_list|(
name|RelNode
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|Sort
condition|)
block|{
return|return
operator|(
operator|(
name|Sort
operator|)
name|r
operator|)
operator|.
name|collation
return|;
block|}
if|if
condition|(
name|r
operator|instanceof
name|Project
condition|)
block|{
return|return
name|requiredCollation
argument_list|(
operator|(
operator|(
name|Project
operator|)
name|r
operator|)
operator|.
name|getInput
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|r
operator|instanceof
name|Delta
condition|)
block|{
return|return
name|requiredCollation
argument_list|(
operator|(
operator|(
name|Delta
operator|)
name|r
operator|)
operator|.
name|getInput
argument_list|()
argument_list|)
return|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
comment|/**    * Converts a SELECT statement's parse tree into a relational expression.    */
specifier|public
name|RelNode
name|convertSelect
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|boolean
name|top
parameter_list|)
block|{
specifier|final
name|SqlValidatorScope
name|selectScope
init|=
name|validator
argument_list|()
operator|.
name|getWhereScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
specifier|final
name|Blackboard
name|bb
init|=
name|createBlackboard
argument_list|(
name|selectScope
argument_list|,
literal|null
argument_list|,
name|top
argument_list|)
decl_stmt|;
name|convertSelectImpl
argument_list|(
name|bb
argument_list|,
name|select
argument_list|)
expr_stmt|;
return|return
name|castNonNull
argument_list|(
name|bb
operator|.
name|root
argument_list|)
return|;
block|}
comment|/**    * Factory method for creating translation workspace.    */
specifier|protected
name|Blackboard
name|createBlackboard
parameter_list|(
annotation|@
name|Nullable
name|SqlValidatorScope
name|scope
parameter_list|,
annotation|@
name|Nullable
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|nameToNodeMap
parameter_list|,
name|boolean
name|top
parameter_list|)
block|{
return|return
operator|new
name|Blackboard
argument_list|(
name|scope
argument_list|,
name|nameToNodeMap
argument_list|,
name|top
argument_list|)
return|;
block|}
comment|/**    * Implementation of {@link #convertSelect(SqlSelect, boolean)};    * derived class may override.    */
specifier|protected
name|void
name|convertSelectImpl
parameter_list|(
specifier|final
name|Blackboard
name|bb
parameter_list|,
name|SqlSelect
name|select
parameter_list|)
block|{
name|convertFrom
argument_list|(
name|bb
argument_list|,
name|select
operator|.
name|getFrom
argument_list|()
argument_list|)
expr_stmt|;
name|convertWhere
argument_list|(
name|bb
argument_list|,
name|select
operator|.
name|getWhere
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderExprList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|collationList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|gatherOrderExprs
argument_list|(
name|bb
argument_list|,
name|select
argument_list|,
name|select
operator|.
name|getOrderList
argument_list|()
argument_list|,
name|orderExprList
argument_list|,
name|collationList
argument_list|)
expr_stmt|;
specifier|final
name|RelCollation
name|collation
init|=
name|cluster
operator|.
name|traitSet
argument_list|()
operator|.
name|canonize
argument_list|(
name|RelCollations
operator|.
name|of
argument_list|(
name|collationList
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|validator
argument_list|()
operator|.
name|isAggregate
argument_list|(
name|select
argument_list|)
condition|)
block|{
name|convertAgg
argument_list|(
name|bb
argument_list|,
name|select
argument_list|,
name|orderExprList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|convertSelectList
argument_list|(
name|bb
argument_list|,
name|select
argument_list|,
name|orderExprList
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|select
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
name|distinctify
argument_list|(
name|bb
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|convertOrder
argument_list|(
name|select
argument_list|,
name|bb
argument_list|,
name|collation
argument_list|,
name|orderExprList
argument_list|,
name|select
operator|.
name|getOffset
argument_list|()
argument_list|,
name|select
operator|.
name|getFetch
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
operator|.
name|hasHints
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|hints
init|=
name|SqlUtil
operator|.
name|getRelHint
argument_list|(
name|hintStrategies
argument_list|,
name|select
operator|.
name|getHints
argument_list|()
argument_list|)
decl_stmt|;
comment|// Attach the hints to the first Hintable node we found from the root node.
name|bb
operator|.
name|setRoot
argument_list|(
name|bb
operator|.
name|root
argument_list|()
operator|.
name|accept
argument_list|(
operator|new
name|RelShuttleImpl
argument_list|()
block|{
name|boolean
name|attached
init|=
literal|false
decl_stmt|;
annotation|@
name|Override
specifier|public
name|RelNode
name|visitChild
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|i
parameter_list|,
name|RelNode
name|child
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|Hintable
operator|&&
operator|!
name|attached
condition|)
block|{
name|attached
operator|=
literal|true
expr_stmt|;
return|return
operator|(
operator|(
name|Hintable
operator|)
name|parent
operator|)
operator|.
name|attachHints
argument_list|(
name|hints
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|visitChild
argument_list|(
name|parent
argument_list|,
name|i
argument_list|,
name|child
argument_list|)
return|;
block|}
block|}
block|}
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bb
operator|.
name|setRoot
argument_list|(
name|bb
operator|.
name|root
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Having translated 'SELECT ... FROM ... [GROUP BY ...] [HAVING ...]', adds    * a relational expression to make the results unique.    *    *<p>If the SELECT clause contains duplicate expressions, adds    * {@link org.apache.calcite.rel.logical.LogicalProject}s so that we are    * grouping on the minimal set of keys. The performance gain isn't huge, but    * it is difficult to detect these duplicate expressions later.    *    * @param bb               Blackboard    * @param checkForDupExprs Check for duplicate expressions    */
specifier|private
name|void
name|distinctify
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|boolean
name|checkForDupExprs
parameter_list|)
block|{
comment|// Look for duplicate expressions in the project.
comment|// Say we have 'select x, y, x, z'.
comment|// Then dups will be {[2, 0]}
comment|// and oldToNew will be {[0, 0], [1, 1], [2, 0], [3, 2]}
name|RelNode
name|rel
init|=
name|bb
operator|.
name|root
decl_stmt|;
if|if
condition|(
name|checkForDupExprs
operator|&&
operator|(
name|rel
operator|instanceof
name|LogicalProject
operator|)
condition|)
block|{
name|LogicalProject
name|project
init|=
operator|(
name|LogicalProject
operator|)
name|rel
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|projectExprs
init|=
name|project
operator|.
name|getProjects
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|origins
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|dupCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projectExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
init|=
name|projectExprs
operator|.
name|indexOf
argument_list|(
name|projectExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|>=
literal|0
operator|&&
name|x
operator|<
name|i
condition|)
block|{
name|origins
operator|.
name|add
argument_list|(
name|x
argument_list|)
expr_stmt|;
operator|++
name|dupCount
expr_stmt|;
block|}
else|else
block|{
name|origins
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dupCount
operator|==
literal|0
condition|)
block|{
name|distinctify
argument_list|(
name|bb
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|squished
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|newProjects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|origins
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
name|i
condition|)
block|{
name|squished
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|newProjects
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|newProjects
operator|.
name|add
argument_list|(
name|RexInputRef
operator|.
name|of2
argument_list|(
name|i
argument_list|,
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|rel
operator|=
name|LogicalProject
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|newProjects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|newProjects
argument_list|)
argument_list|)
expr_stmt|;
name|bb
operator|.
name|root
operator|=
name|rel
expr_stmt|;
name|distinctify
argument_list|(
name|bb
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|rel
operator|=
name|bb
operator|.
name|root
argument_list|()
expr_stmt|;
comment|// Create the expressions to reverse the mapping.
comment|// Project($0, $1, $0, $2).
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|undoProjects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|origin
init|=
name|origins
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|undoProjects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|castNonNull
argument_list|(
name|squished
operator|.
name|get
argument_list|(
name|origin
argument_list|)
argument_list|)
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rel
operator|=
name|LogicalProject
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|undoProjects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|undoProjects
argument_list|)
argument_list|)
expr_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|rel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
assert|assert
name|rel
operator|!=
literal|null
operator|:
literal|"rel must not be null, root = "
operator|+
name|bb
operator|.
name|root
assert|;
comment|// Usual case: all of the expressions in the SELECT clause are
comment|// different.
specifier|final
name|ImmutableBitSet
name|groupSet
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
name|rel
operator|=
name|createAggregate
argument_list|(
name|bb
argument_list|,
name|groupSet
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupSet
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
expr_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|rel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Converts a query's ORDER BY clause, if any.    *    *<p>Ignores the ORDER BY clause if the query is not top-level and FETCH or    * OFFSET are not present.    *    * @param select        Query    * @param bb            Blackboard    * @param collation     Collation list    * @param orderExprList Method populates this list with orderBy expressions    *                      not present in selectList    * @param offset        Expression for number of rows to discard before    *                      returning first row    * @param fetch         Expression for number of rows to fetch    */
specifier|protected
name|void
name|convertOrder
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|Blackboard
name|bb
parameter_list|,
name|RelCollation
name|collation
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderExprList
parameter_list|,
annotation|@
name|Nullable
name|SqlNode
name|offset
parameter_list|,
annotation|@
name|Nullable
name|SqlNode
name|fetch
parameter_list|)
block|{
if|if
condition|(
name|removeSortInSubQuery
argument_list|(
name|bb
operator|.
name|top
argument_list|)
operator|||
name|select
operator|.
name|getOrderList
argument_list|()
operator|==
literal|null
operator|||
name|select
operator|.
name|getOrderList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
assert|assert
name|removeSortInSubQuery
argument_list|(
name|bb
operator|.
name|top
argument_list|)
operator|||
name|collation
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|isEmpty
argument_list|()
assert|;
if|if
condition|(
operator|(
name|offset
operator|==
literal|null
operator|||
operator|(
name|offset
operator|instanceof
name|SqlLiteral
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|SqlLiteral
operator|)
name|offset
operator|)
operator|.
name|bigDecimalValue
argument_list|()
argument_list|,
name|BigDecimal
operator|.
name|ZERO
argument_list|)
operator|)
operator|)
operator|&&
name|fetch
operator|==
literal|null
condition|)
block|{
return|return;
block|}
block|}
comment|// Create a sorter using the previously constructed collations.
name|bb
operator|.
name|setRoot
argument_list|(
name|LogicalSort
operator|.
name|create
argument_list|(
name|bb
operator|.
name|root
argument_list|()
argument_list|,
name|collation
argument_list|,
name|offset
operator|==
literal|null
condition|?
literal|null
else|:
name|convertExpression
argument_list|(
name|offset
argument_list|)
argument_list|,
name|fetch
operator|==
literal|null
condition|?
literal|null
else|:
name|convertExpression
argument_list|(
name|fetch
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// If extra expressions were added to the project list for sorting,
comment|// add another project to remove them. But make the collation empty, because
comment|// we can't represent the real collation.
comment|//
comment|// If it is the top node, use the real collation, but don't trim fields.
if|if
condition|(
name|orderExprList
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|bb
operator|.
name|top
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|bb
operator|.
name|root
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
operator|-
name|orderExprList
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldCount
condition|;
name|i
operator|++
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|bb
operator|.
name|root
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bb
operator|.
name|setRoot
argument_list|(
name|LogicalProject
operator|.
name|create
argument_list|(
name|bb
operator|.
name|root
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|exprs
argument_list|,
name|rowType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|fieldCount
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns whether we should remove the sort for the subsequent query conversion.    *    * @param top Whether the rel to convert is the root of the query    */
specifier|private
name|boolean
name|removeSortInSubQuery
parameter_list|(
name|boolean
name|top
parameter_list|)
block|{
return|return
name|config
operator|.
name|isRemoveSortInSubQuery
argument_list|()
operator|&&
operator|!
name|top
return|;
block|}
comment|/**    * Returns whether a given node contains a {@link SqlInOperator}.    *    * @param node a RexNode tree    */
specifier|private
specifier|static
name|boolean
name|containsInOperator
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
try|try
block|{
name|SqlVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
init|=
operator|new
name|SqlBasicVisitor
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlInOperator
condition|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|call
argument_list|)
throw|;
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|node
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Push down all the NOT logical operators into any IN/NOT IN operators.    *    * @param scope Scope where {@code sqlNode} occurs    * @param sqlNode the root node from which to look for NOT operators    * @return the transformed SqlNode representation with NOT pushed down.    */
specifier|private
specifier|static
name|SqlNode
name|pushDownNotForIn
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNode
name|sqlNode
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|sqlNode
operator|instanceof
name|SqlCall
operator|)
operator|||
operator|!
name|containsInOperator
argument_list|(
name|sqlNode
argument_list|)
condition|)
block|{
return|return
name|sqlNode
return|;
block|}
specifier|final
name|SqlCall
name|sqlCall
init|=
operator|(
name|SqlCall
operator|)
name|sqlNode
decl_stmt|;
switch|switch
condition|(
name|sqlCall
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
case|case
name|OR
case|:
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|sqlCall
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|operands
operator|.
name|add
argument_list|(
name|pushDownNotForIn
argument_list|(
name|scope
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlCall
name|newCall
init|=
name|sqlCall
operator|.
name|getOperator
argument_list|()
operator|.
name|createCall
argument_list|(
name|sqlCall
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|operands
argument_list|)
decl_stmt|;
return|return
name|reg
argument_list|(
name|scope
argument_list|,
name|newCall
argument_list|)
return|;
case|case
name|NOT
case|:
assert|assert
name|sqlCall
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|SqlCall
assert|;
specifier|final
name|SqlCall
name|call
init|=
name|sqlCall
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sqlCall
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CASE
case|:
specifier|final
name|SqlCase
name|caseNode
init|=
operator|(
name|SqlCase
operator|)
name|call
decl_stmt|;
specifier|final
name|SqlNodeList
name|thenOperands
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlNode
name|thenOperand
range|:
name|caseNode
operator|.
name|getThenOperands
argument_list|()
control|)
block|{
specifier|final
name|SqlCall
name|not
init|=
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|thenOperand
argument_list|)
decl_stmt|;
name|thenOperands
operator|.
name|add
argument_list|(
name|pushDownNotForIn
argument_list|(
name|scope
argument_list|,
name|reg
argument_list|(
name|scope
argument_list|,
name|not
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SqlNode
name|elseOperand
init|=
name|requireNonNull
argument_list|(
name|caseNode
operator|.
name|getElseOperand
argument_list|()
argument_list|,
literal|"getElseOperand for "
operator|+
name|caseNode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SqlUtil
operator|.
name|isNull
argument_list|(
name|elseOperand
argument_list|)
condition|)
block|{
comment|// "not(unknown)" is "unknown", so no need to simplify
specifier|final
name|SqlCall
name|not
init|=
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|elseOperand
argument_list|)
decl_stmt|;
name|elseOperand
operator|=
name|pushDownNotForIn
argument_list|(
name|scope
argument_list|,
name|reg
argument_list|(
name|scope
argument_list|,
name|not
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|reg
argument_list|(
name|scope
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CASE
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|caseNode
operator|.
name|getValueOperand
argument_list|()
argument_list|,
name|caseNode
operator|.
name|getWhenOperands
argument_list|()
argument_list|,
name|thenOperands
argument_list|,
name|elseOperand
argument_list|)
argument_list|)
return|;
case|case
name|AND
case|:
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|orOperands
operator|.
name|add
argument_list|(
name|pushDownNotForIn
argument_list|(
name|scope
argument_list|,
name|reg
argument_list|(
name|scope
argument_list|,
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|operand
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|reg
argument_list|(
name|scope
argument_list|,
name|SqlStdOperatorTable
operator|.
name|OR
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|orOperands
argument_list|)
argument_list|)
return|;
case|case
name|OR
case|:
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|andOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|andOperands
operator|.
name|add
argument_list|(
name|pushDownNotForIn
argument_list|(
name|scope
argument_list|,
name|reg
argument_list|(
name|scope
argument_list|,
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|operand
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|reg
argument_list|(
name|scope
argument_list|,
name|SqlStdOperatorTable
operator|.
name|AND
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|andOperands
argument_list|)
argument_list|)
return|;
case|case
name|NOT
case|:
assert|assert
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|1
assert|;
return|return
name|pushDownNotForIn
argument_list|(
name|scope
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|NOT_IN
case|:
return|return
name|reg
argument_list|(
name|scope
argument_list|,
name|SqlStdOperatorTable
operator|.
name|IN
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|IN
case|:
return|return
name|reg
argument_list|(
name|scope
argument_list|,
name|SqlStdOperatorTable
operator|.
name|NOT_IN
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|sqlNode
return|;
block|}
comment|/** Registers with the validator a {@link SqlNode} that has been created    * during the Sql-to-Rel process. */
specifier|private
specifier|static
name|SqlNode
name|reg
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNode
name|e
parameter_list|)
block|{
name|scope
operator|.
name|getValidator
argument_list|()
operator|.
name|deriveType
argument_list|(
name|scope
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
comment|/**    * Converts a WHERE clause.    *    * @param bb    Blackboard    * @param where WHERE clause, may be null    */
specifier|private
name|void
name|convertWhere
parameter_list|(
specifier|final
name|Blackboard
name|bb
parameter_list|,
specifier|final
annotation|@
name|Nullable
name|SqlNode
name|where
parameter_list|)
block|{
if|if
condition|(
name|where
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|SqlNode
name|newWhere
init|=
name|pushDownNotForIn
argument_list|(
name|bb
operator|.
name|scope
argument_list|()
argument_list|,
name|where
argument_list|)
decl_stmt|;
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|newWhere
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|UNKNOWN_AS_FALSE
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|convertedWhere
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|newWhere
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|convertedWhere2
init|=
name|RexUtil
operator|.
name|removeNullabilityCast
argument_list|(
name|typeFactory
argument_list|,
name|convertedWhere
argument_list|)
decl_stmt|;
comment|// only allocate filter if the condition is not TRUE
if|if
condition|(
name|convertedWhere2
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return;
block|}
specifier|final
name|RelFactories
operator|.
name|FilterFactory
name|filterFactory
init|=
name|RelFactories
operator|.
name|DEFAULT_FILTER_FACTORY
decl_stmt|;
specifier|final
name|RelNode
name|filter
init|=
name|filterFactory
operator|.
name|createFilter
argument_list|(
name|bb
operator|.
name|root
argument_list|()
argument_list|,
name|convertedWhere2
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|r
decl_stmt|;
specifier|final
name|CorrelationUse
name|p
init|=
name|getCorrelationUse
argument_list|(
name|bb
argument_list|,
name|filter
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
assert|assert
name|p
operator|.
name|r
operator|instanceof
name|Filter
assert|;
name|Filter
name|f
init|=
operator|(
name|Filter
operator|)
name|p
operator|.
name|r
decl_stmt|;
name|r
operator|=
name|LogicalFilter
operator|.
name|create
argument_list|(
name|f
operator|.
name|getInput
argument_list|()
argument_list|,
name|f
operator|.
name|getCondition
argument_list|()
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|p
operator|.
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|filter
expr_stmt|;
block|}
name|bb
operator|.
name|setRoot
argument_list|(
name|r
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|replaceSubQueries
parameter_list|(
specifier|final
name|Blackboard
name|bb
parameter_list|,
specifier|final
name|SqlNode
name|expr
parameter_list|,
name|RelOptUtil
operator|.
name|Logic
name|logic
parameter_list|)
block|{
name|findSubQueries
argument_list|(
name|bb
argument_list|,
name|expr
argument_list|,
name|logic
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|SubQuery
name|node
range|:
name|bb
operator|.
name|subQueryList
control|)
block|{
name|substituteSubQuery
argument_list|(
name|bb
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|substituteSubQuery
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SubQuery
name|subQuery
parameter_list|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|subQuery
operator|.
name|expr
decl_stmt|;
if|if
condition|(
name|expr
operator|!=
literal|null
condition|)
block|{
comment|// Already done.
return|return;
block|}
specifier|final
name|SqlBasicCall
name|call
decl_stmt|;
specifier|final
name|RelNode
name|rel
decl_stmt|;
specifier|final
name|SqlNode
name|query
decl_stmt|;
specifier|final
name|RelOptUtil
operator|.
name|Exists
name|converted
decl_stmt|;
switch|switch
condition|(
name|subQuery
operator|.
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CURSOR
case|:
name|convertCursor
argument_list|(
name|bb
argument_list|,
name|subQuery
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_QUERY_CONSTRUCTOR
case|:
case|case
name|MAP_QUERY_CONSTRUCTOR
case|:
case|case
name|MULTISET_QUERY_CONSTRUCTOR
case|:
if|if
condition|(
operator|!
name|config
operator|.
name|isExpand
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// fall through
case|case
name|MULTISET_VALUE_CONSTRUCTOR
case|:
name|rel
operator|=
name|convertMultisets
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|subQuery
operator|.
name|node
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|subQuery
operator|.
name|expr
operator|=
name|bb
operator|.
name|register
argument_list|(
name|rel
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|)
expr_stmt|;
return|return;
case|case
name|IN
case|:
case|case
name|NOT_IN
case|:
case|case
name|SOME
case|:
case|case
name|ALL
case|:
name|call
operator|=
operator|(
name|SqlBasicCall
operator|)
name|subQuery
operator|.
name|node
expr_stmt|;
name|query
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
operator|.
name|isExpand
argument_list|()
operator|&&
operator|!
operator|(
name|query
operator|instanceof
name|SqlNodeList
operator|)
condition|)
block|{
return|return;
block|}
specifier|final
name|SqlNode
name|leftKeyNode
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftKeys
decl_stmt|;
switch|switch
condition|(
name|leftKeyNode
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|ROW
case|:
name|leftKeys
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|SqlNode
name|sqlExpr
range|:
operator|(
operator|(
name|SqlBasicCall
operator|)
name|leftKeyNode
operator|)
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|leftKeys
operator|.
name|add
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|sqlExpr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|leftKeys
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|leftKeyNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|query
operator|instanceof
name|SqlNodeList
condition|)
block|{
name|SqlNodeList
name|valueList
init|=
operator|(
name|SqlNodeList
operator|)
name|query
decl_stmt|;
comment|// When the list size under the threshold or the list references columns, we convert to OR.
if|if
condition|(
name|valueList
operator|.
name|size
argument_list|()
operator|<
name|config
operator|.
name|getInSubQueryThreshold
argument_list|()
operator|||
name|valueList
operator|.
name|accept
argument_list|(
operator|new
name|SqlIdentifierFinder
argument_list|()
argument_list|)
condition|)
block|{
name|subQuery
operator|.
name|expr
operator|=
name|convertInToOr
argument_list|(
name|bb
argument_list|,
name|leftKeys
argument_list|,
name|valueList
argument_list|,
operator|(
name|SqlInOperator
operator|)
name|call
operator|.
name|getOperator
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Otherwise, let convertExists translate
comment|// values list into an inline table for the
comment|// reference to Q below.
block|}
comment|// Project out the search columns from the left side
comment|// Q1:
comment|// "select from emp where emp.deptno in (select col1 from T)"
comment|//
comment|// is converted to
comment|//
comment|// "select from
comment|//   emp inner join (select distinct col1 from T)) q
comment|//   on emp.deptno = q.col1
comment|//
comment|// Q2:
comment|// "select from emp where emp.deptno not in (Q)"
comment|//
comment|// is converted to
comment|//
comment|// "select from
comment|//   emp left outer join (select distinct col1, TRUE from T) q
comment|//   on emp.deptno = q.col1
comment|//   where emp.deptno<> null
comment|//         and q.indicator<> TRUE"
comment|//
comment|// Note: Sub-query can be used as SqlUpdate#condition like below:
comment|//
comment|//   UPDATE emp
comment|//   SET empno = 1 WHERE emp.empno IN (
comment|//     SELECT emp.empno FROM emp WHERE emp.empno = 2)
comment|//
comment|// In such case, when converting SqlUpdate#condition, bb.root is null
comment|// and it makes no sense to do the sub-query substitution.
if|if
condition|(
name|bb
operator|.
name|root
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|RelDataType
name|targetRowType
init|=
name|SqlTypeUtil
operator|.
name|promoteToRowType
argument_list|(
name|typeFactory
argument_list|,
name|validator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|leftKeyNode
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|notIn
init|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|kind
operator|==
name|SqlKind
operator|.
name|NOT_IN
decl_stmt|;
name|converted
operator|=
name|convertExists
argument_list|(
name|query
argument_list|,
name|RelOptUtil
operator|.
name|SubQueryType
operator|.
name|IN
argument_list|,
name|subQuery
operator|.
name|logic
argument_list|,
name|notIn
argument_list|,
name|targetRowType
argument_list|)
expr_stmt|;
if|if
condition|(
name|converted
operator|.
name|indicator
condition|)
block|{
comment|// Generate
comment|//    emp CROSS JOIN (SELECT COUNT(*) AS c,
comment|//                       COUNT(deptno) AS ck FROM dept)
specifier|final
name|RelDataType
name|longType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|seek
init|=
name|converted
operator|.
name|r
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// fragile
specifier|final
name|int
name|keyCount
init|=
name|leftKeys
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|args
init|=
name|ImmutableIntList
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|keyCount
argument_list|)
decl_stmt|;
name|LogicalAggregate
name|aggregate
init|=
name|LogicalAggregate
operator|.
name|create
argument_list|(
name|seek
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|()
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|AggregateCall
operator|.
name|create
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|RelCollations
operator|.
name|EMPTY
argument_list|,
name|longType
argument_list|,
literal|null
argument_list|)
argument_list|,
name|AggregateCall
operator|.
name|create
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|args
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|RelCollations
operator|.
name|EMPTY
argument_list|,
name|longType
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|LogicalJoin
name|join
init|=
name|LogicalJoin
operator|.
name|create
argument_list|(
name|bb
operator|.
name|root
argument_list|()
argument_list|,
name|aggregate
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|join
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RexNode
name|rex
init|=
name|bb
operator|.
name|register
argument_list|(
name|converted
operator|.
name|r
argument_list|,
name|converted
operator|.
name|outerJoin
condition|?
name|JoinRelType
operator|.
name|LEFT
else|:
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|leftKeys
argument_list|)
decl_stmt|;
name|RelOptUtil
operator|.
name|Logic
name|logic
init|=
name|subQuery
operator|.
name|logic
decl_stmt|;
switch|switch
condition|(
name|logic
condition|)
block|{
case|case
name|TRUE_FALSE_UNKNOWN
case|:
case|case
name|UNKNOWN_AS_TRUE
case|:
if|if
condition|(
operator|!
name|converted
operator|.
name|indicator
condition|)
block|{
name|logic
operator|=
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|subQuery
operator|.
name|expr
operator|=
name|translateIn
argument_list|(
name|logic
argument_list|,
name|bb
operator|.
name|root
argument_list|,
name|rex
argument_list|)
expr_stmt|;
if|if
condition|(
name|notIn
condition|)
block|{
name|subQuery
operator|.
name|expr
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|subQuery
operator|.
name|expr
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|EXISTS
case|:
comment|// "select from emp where exists (select a from T)"
comment|//
comment|// is converted to the following if the sub-query is correlated:
comment|//
comment|// "select from emp left outer join (select AGG_TRUE() as indicator
comment|// from T group by corr_var) q where q.indicator is true"
comment|//
comment|// If there is no correlation, the expression is replaced with a
comment|// boolean indicating whether the sub-query returned 0 or>= 1 row.
if|if
condition|(
operator|!
name|config
operator|.
name|isExpand
argument_list|()
condition|)
block|{
return|return;
block|}
name|call
operator|=
operator|(
name|SqlBasicCall
operator|)
name|subQuery
operator|.
name|node
expr_stmt|;
name|query
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
specifier|final
name|SqlValidatorScope
name|seekScope
init|=
operator|(
name|query
operator|instanceof
name|SqlSelect
operator|)
condition|?
name|validator
argument_list|()
operator|.
name|getSelectScope
argument_list|(
operator|(
name|SqlSelect
operator|)
name|query
argument_list|)
else|:
literal|null
decl_stmt|;
specifier|final
name|Blackboard
name|seekBb
init|=
name|createBlackboard
argument_list|(
name|seekScope
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|seekRel
init|=
name|convertQueryOrInList
argument_list|(
name|seekBb
argument_list|,
name|query
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|requireNonNull
argument_list|(
name|seekRel
argument_list|,
parameter_list|()
lambda|->
literal|"seekRel is null for query "
operator|+
name|query
argument_list|)
expr_stmt|;
comment|// An EXIST sub-query whose inner child has at least 1 tuple
comment|// (e.g. an Aggregate with no grouping columns or non-empty Values
comment|// node) should be simplified to a Boolean constant expression.
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|seekRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|Double
name|minRowCount
init|=
name|mq
operator|.
name|getMinRowCount
argument_list|(
name|seekRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|minRowCount
operator|!=
literal|null
operator|&&
name|minRowCount
operator|>=
literal|1D
condition|)
block|{
name|subQuery
operator|.
name|expr
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|converted
operator|=
name|RelOptUtil
operator|.
name|createExistsPlan
argument_list|(
name|seekRel
argument_list|,
name|RelOptUtil
operator|.
name|SubQueryType
operator|.
name|EXISTS
argument_list|,
name|subQuery
operator|.
name|logic
argument_list|,
literal|true
argument_list|,
name|relBuilder
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|converted
operator|.
name|indicator
assert|;
if|if
condition|(
name|convertNonCorrelatedSubQuery
argument_list|(
name|subQuery
argument_list|,
name|bb
argument_list|,
name|converted
operator|.
name|r
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return;
block|}
name|subQuery
operator|.
name|expr
operator|=
name|bb
operator|.
name|register
argument_list|(
name|converted
operator|.
name|r
argument_list|,
name|JoinRelType
operator|.
name|LEFT
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNIQUE
case|:
return|return;
case|case
name|SCALAR_QUERY
case|:
comment|// Convert the sub-query.  If it's non-correlated, convert it
comment|// to a constant expression.
if|if
condition|(
operator|!
name|config
operator|.
name|isExpand
argument_list|()
condition|)
block|{
return|return;
block|}
name|call
operator|=
operator|(
name|SqlBasicCall
operator|)
name|subQuery
operator|.
name|node
expr_stmt|;
name|query
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|converted
operator|=
name|convertExists
argument_list|(
name|query
argument_list|,
name|RelOptUtil
operator|.
name|SubQueryType
operator|.
name|SCALAR
argument_list|,
name|subQuery
operator|.
name|logic
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|converted
operator|.
name|indicator
assert|;
if|if
condition|(
name|convertNonCorrelatedSubQuery
argument_list|(
name|subQuery
argument_list|,
name|bb
argument_list|,
name|converted
operator|.
name|r
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|rel
operator|=
name|convertToSingleValueSubq
argument_list|(
name|query
argument_list|,
name|converted
operator|.
name|r
argument_list|)
expr_stmt|;
name|subQuery
operator|.
name|expr
operator|=
name|bb
operator|.
name|register
argument_list|(
name|rel
argument_list|,
name|JoinRelType
operator|.
name|LEFT
argument_list|)
expr_stmt|;
return|return;
case|case
name|SELECT
case|:
comment|// This is used when converting multiset queries:
comment|//
comment|// select * from unnest(select multiset[deptno] from emps);
comment|//
name|converted
operator|=
name|convertExists
argument_list|(
name|subQuery
operator|.
name|node
argument_list|,
name|RelOptUtil
operator|.
name|SubQueryType
operator|.
name|SCALAR
argument_list|,
name|subQuery
operator|.
name|logic
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|converted
operator|.
name|indicator
assert|;
name|subQuery
operator|.
name|expr
operator|=
name|bb
operator|.
name|register
argument_list|(
name|converted
operator|.
name|r
argument_list|,
name|JoinRelType
operator|.
name|LEFT
argument_list|)
expr_stmt|;
comment|// This is used when converting window table functions:
comment|//
comment|// select * from table(tumble(table emps, descriptor(deptno), interval '3' DAY))
comment|//
name|bb
operator|.
name|cursors
operator|.
name|add
argument_list|(
name|converted
operator|.
name|r
argument_list|)
expr_stmt|;
return|return;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected kind of sub-query: "
operator|+
name|subQuery
operator|.
name|node
argument_list|)
throw|;
block|}
block|}
specifier|private
name|RexNode
name|translateIn
parameter_list|(
name|RelOptUtil
operator|.
name|Logic
name|logic
parameter_list|,
annotation|@
name|Nullable
name|RelNode
name|root
parameter_list|,
specifier|final
name|RexNode
name|rex
parameter_list|)
block|{
switch|switch
condition|(
name|logic
condition|)
block|{
case|case
name|TRUE
case|:
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
case|case
name|TRUE_FALSE
case|:
case|case
name|UNKNOWN_AS_FALSE
case|:
assert|assert
name|rex
operator|instanceof
name|RexRangeRef
assert|;
specifier|final
name|int
name|fieldCount
init|=
name|rex
operator|.
name|getType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|RexNode
name|rexNode
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|rex
argument_list|,
name|fieldCount
operator|-
literal|1
argument_list|)
decl_stmt|;
name|rexNode
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
argument_list|,
name|rexNode
argument_list|)
expr_stmt|;
comment|// Then append the IS NOT NULL(leftKeysForIn).
comment|//
comment|// RexRangeRef contains the following fields:
comment|//   leftKeysForIn,
comment|//   rightKeysForIn (the original sub-query select list),
comment|//   nullIndicator
comment|//
comment|// The first two lists contain the same number of fields.
specifier|final
name|int
name|k
init|=
operator|(
name|fieldCount
operator|-
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
name|rexNode
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|rexNode
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|rex
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rexNode
return|;
case|case
name|TRUE_FALSE_UNKNOWN
case|:
case|case
name|UNKNOWN_AS_TRUE
case|:
comment|// select e.deptno,
comment|//   case
comment|//   when ct.c = 0 then false
comment|//   when dt.i is not null then true
comment|//   when e.deptno is null then null
comment|//   when ct.ck< ct.c then null
comment|//   else false
comment|//   end
comment|// from e
comment|// cross join (select count(*) as c, count(deptno) as ck from v) as ct
comment|// left join (select distinct deptno, true as i from v) as dt
comment|//   on e.deptno = dt.deptno
specifier|final
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|requireNonNull
argument_list|(
name|root
argument_list|,
literal|"root"
argument_list|)
decl_stmt|;
specifier|final
name|Project
name|left
init|=
operator|(
name|Project
operator|)
name|join
operator|.
name|getLeft
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|leftLeft
init|=
operator|(
operator|(
name|Join
operator|)
name|left
operator|.
name|getInput
argument_list|()
operator|)
operator|.
name|getLeft
argument_list|()
decl_stmt|;
specifier|final
name|int
name|leftLeftCount
init|=
name|leftLeft
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|longType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cRef
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|root
argument_list|,
name|leftLeftCount
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|ckRef
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|root
argument_list|,
name|leftLeftCount
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|iRef
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|root
argument_list|,
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|zero
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|,
name|longType
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|trueLiteral
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|falseLiteral
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|unknownLiteral
init|=
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|trueLiteral
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|args
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|args
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|cRef
argument_list|,
name|zero
argument_list|)
argument_list|,
name|falseLiteral
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|iRef
argument_list|)
argument_list|,
name|trueLiteral
argument_list|)
expr_stmt|;
specifier|final
name|JoinInfo
name|joinInfo
init|=
name|join
operator|.
name|analyzeCondition
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|leftKey
range|:
name|joinInfo
operator|.
name|leftKeys
control|)
block|{
specifier|final
name|RexNode
name|kRef
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|root
argument_list|,
name|leftKey
argument_list|)
decl_stmt|;
name|args
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|kRef
argument_list|)
argument_list|,
name|unknownLiteral
argument_list|)
expr_stmt|;
block|}
name|args
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|ckRef
argument_list|,
name|cRef
argument_list|)
argument_list|,
name|unknownLiteral
argument_list|,
name|falseLiteral
argument_list|)
expr_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|args
operator|.
name|build
argument_list|()
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|logic
argument_list|)
throw|;
block|}
block|}
comment|/**    * Determines if a sub-query is non-correlated and if so, converts it to a    * constant.    *    * @param subQuery  the call that references the sub-query    * @param bb        blackboard used to convert the sub-query    * @param converted RelNode tree corresponding to the sub-query    * @param isExists  true if the sub-query is part of an EXISTS expression    * @return Whether the sub-query can be converted to a constant    */
specifier|private
name|boolean
name|convertNonCorrelatedSubQuery
parameter_list|(
name|SubQuery
name|subQuery
parameter_list|,
name|Blackboard
name|bb
parameter_list|,
name|RelNode
name|converted
parameter_list|,
name|boolean
name|isExists
parameter_list|)
block|{
name|SqlCall
name|call
init|=
operator|(
name|SqlBasicCall
operator|)
name|subQuery
operator|.
name|node
decl_stmt|;
if|if
condition|(
name|subQueryConverter
operator|.
name|canConvertSubQuery
argument_list|()
operator|&&
name|isSubQueryNonCorrelated
argument_list|(
name|converted
argument_list|,
name|bb
argument_list|)
condition|)
block|{
comment|// First check if the sub-query has already been converted
comment|// because it's a nested sub-query.  If so, don't re-evaluate
comment|// it again.
name|RexNode
name|constExpr
init|=
name|mapConvertedNonCorrSubqs
operator|.
name|get
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|constExpr
operator|==
literal|null
condition|)
block|{
name|constExpr
operator|=
name|subQueryConverter
operator|.
name|convertSubQuery
argument_list|(
name|call
argument_list|,
name|this
argument_list|,
name|isExists
argument_list|,
name|config
operator|.
name|isExplain
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constExpr
operator|!=
literal|null
condition|)
block|{
name|subQuery
operator|.
name|expr
operator|=
name|constExpr
expr_stmt|;
name|mapConvertedNonCorrSubqs
operator|.
name|put
argument_list|(
name|call
argument_list|,
name|constExpr
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Converts the RelNode tree for a select statement to a select that    * produces a single value.    *    * @param query the query    * @param plan   the original RelNode tree corresponding to the statement    * @return the converted RelNode tree    */
specifier|public
name|RelNode
name|convertToSingleValueSubq
parameter_list|(
name|SqlNode
name|query
parameter_list|,
name|RelNode
name|plan
parameter_list|)
block|{
comment|// Check whether query is guaranteed to produce a single value.
if|if
condition|(
name|query
operator|instanceof
name|SqlSelect
condition|)
block|{
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|query
decl_stmt|;
name|SqlNodeList
name|selectList
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
name|SqlNodeList
name|groupList
init|=
name|select
operator|.
name|getGroup
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|selectList
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|groupList
operator|==
literal|null
operator|)
operator|||
operator|(
name|groupList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|SqlNode
name|selectExpr
init|=
name|selectList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectExpr
operator|instanceof
name|SqlCall
condition|)
block|{
name|SqlCall
name|selectExprCall
init|=
operator|(
name|SqlCall
operator|)
name|selectExpr
decl_stmt|;
if|if
condition|(
name|Util
operator|.
name|isSingleValue
argument_list|(
name|selectExprCall
argument_list|)
condition|)
block|{
return|return
name|plan
return|;
block|}
block|}
comment|// If there is a limit with 0 or 1,
comment|// it is ensured to produce a single value
name|SqlNode
name|fetch
init|=
name|select
operator|.
name|getFetch
argument_list|()
decl_stmt|;
if|if
condition|(
name|fetch
operator|instanceof
name|SqlNumericLiteral
condition|)
block|{
name|long
name|value
init|=
operator|(
operator|(
name|SqlNumericLiteral
operator|)
name|fetch
operator|)
operator|.
name|getValueAs
argument_list|(
name|Long
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|2
condition|)
block|{
return|return
name|plan
return|;
block|}
block|}
block|}
block|}
if|else if
condition|(
name|query
operator|instanceof
name|SqlCall
condition|)
block|{
comment|// If the query is (values ...),
comment|// it is necessary to look into the operands to determine
comment|// whether SingleValueAgg is necessary
name|SqlCall
name|exprCall
init|=
operator|(
name|SqlCall
operator|)
name|query
decl_stmt|;
if|if
condition|(
name|exprCall
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlValuesOperator
operator|&&
name|Util
operator|.
name|isSingleValue
argument_list|(
name|exprCall
argument_list|)
condition|)
block|{
return|return
name|plan
return|;
block|}
block|}
comment|// If not, project SingleValueAgg
return|return
name|RelOptUtil
operator|.
name|createSingleValueAggRel
argument_list|(
name|cluster
argument_list|,
name|plan
argument_list|)
return|;
block|}
comment|/**    * Converts "x IN (1, 2, ...)" to "x=1 OR x=2 OR ...".    *    * @param leftKeys   LHS    * @param valuesList RHS    * @param op         The operator (IN, NOT IN,&gt; SOME, ...)    * @return converted expression    */
specifier|private
annotation|@
name|Nullable
name|RexNode
name|convertInToOr
parameter_list|(
specifier|final
name|Blackboard
name|bb
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftKeys
parameter_list|,
name|SqlNodeList
name|valuesList
parameter_list|,
name|SqlInOperator
name|op
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|comparisons
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|rightVals
range|:
name|valuesList
control|)
block|{
name|RexNode
name|rexComparison
decl_stmt|;
specifier|final
name|SqlOperator
name|comparisonOp
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|SqlQuantifyOperator
condition|)
block|{
name|comparisonOp
operator|=
name|RelOptUtil
operator|.
name|op
argument_list|(
operator|(
operator|(
name|SqlQuantifyOperator
operator|)
name|op
operator|)
operator|.
name|comparisonKind
argument_list|,
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|comparisonOp
operator|=
name|SqlStdOperatorTable
operator|.
name|EQUALS
expr_stmt|;
block|}
if|if
condition|(
name|leftKeys
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|rexComparison
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|comparisonOp
argument_list|,
name|leftKeys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|ensureSqlType
argument_list|(
name|leftKeys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|bb
operator|.
name|convertExpression
argument_list|(
name|rightVals
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|rightVals
operator|instanceof
name|SqlCall
assert|;
specifier|final
name|SqlBasicCall
name|call
init|=
operator|(
name|SqlBasicCall
operator|)
name|rightVals
decl_stmt|;
assert|assert
operator|(
name|call
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlRowOperator
operator|)
operator|&&
name|call
operator|.
name|operandCount
argument_list|()
operator|==
name|leftKeys
operator|.
name|size
argument_list|()
assert|;
name|rexComparison
operator|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|Util
operator|.
name|transform
argument_list|(
name|Pair
operator|.
name|zip
argument_list|(
name|leftKeys
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
argument_list|,
name|pair
lambda|->
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|comparisonOp
argument_list|,
name|pair
operator|.
name|left
argument_list|,
comment|// TODO: remove requireNonNull when checkerframework issue resolved
name|ensureSqlType
argument_list|(
name|requireNonNull
argument_list|(
name|pair
operator|.
name|left
argument_list|,
literal|"pair.left"
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|bb
operator|.
name|convertExpression
argument_list|(
name|pair
operator|.
name|right
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|comparisons
operator|.
name|add
argument_list|(
name|rexComparison
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|op
operator|.
name|kind
condition|)
block|{
case|case
name|ALL
case|:
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|comparisons
argument_list|,
literal|true
argument_list|)
return|;
case|case
name|NOT_IN
case|:
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|RexUtil
operator|.
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|comparisons
argument_list|)
argument_list|)
return|;
case|case
name|IN
case|:
case|case
name|SOME
case|:
return|return
name|RexUtil
operator|.
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|comparisons
argument_list|,
literal|true
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
comment|/** Ensures that an expression has a given {@link SqlTypeName}, applying a    * cast if necessary. If the expression already has the right type family,    * returns the expression unchanged. */
specifier|private
name|RexNode
name|ensureSqlType
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|node
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|||
operator|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|VARCHAR
operator|&&
name|node
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|CHAR
operator|)
condition|)
block|{
return|return
name|node
return|;
block|}
return|return
name|rexBuilder
operator|.
name|ensureType
argument_list|(
name|type
argument_list|,
name|node
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Gets the list size threshold under which {@link #convertInToOr} is used.    * Lists of this size or greater will instead be converted to use a join    * against an inline table    * ({@link org.apache.calcite.rel.logical.LogicalValues}) rather than a    * predicate. A threshold of 0 forces usage of an inline table in all cases; a    * threshold of Integer.MAX_VALUE forces usage of OR in all cases    *    * @return threshold, default {@link #DEFAULT_IN_SUB_QUERY_THRESHOLD}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|protected
name|int
name|getInSubqueryThreshold
parameter_list|()
block|{
return|return
name|config
operator|.
name|getInSubQueryThreshold
argument_list|()
return|;
block|}
comment|/**    * Converts an EXISTS or IN predicate into a join. For EXISTS, the sub-query    * produces an indicator variable, and the result is a relational expression    * which outer joins that indicator to the original query. After performing    * the outer join, the condition will be TRUE if the EXISTS condition holds,    * NULL otherwise.    *    * @param seek           A query, for example 'select * from emp' or    *                       'values (1,2,3)' or '('Foo', 34)'.    * @param subQueryType   Whether sub-query is IN, EXISTS or scalar    * @param logic Whether the answer needs to be in full 3-valued logic (TRUE,    *     FALSE, UNKNOWN) will be required, or whether we can accept an    *     approximation (say representing UNKNOWN as FALSE)    * @param notIn Whether the operation is NOT IN    * @return join expression    */
specifier|private
name|RelOptUtil
operator|.
name|Exists
name|convertExists
parameter_list|(
name|SqlNode
name|seek
parameter_list|,
name|RelOptUtil
operator|.
name|SubQueryType
name|subQueryType
parameter_list|,
name|RelOptUtil
operator|.
name|Logic
name|logic
parameter_list|,
name|boolean
name|notIn
parameter_list|,
annotation|@
name|Nullable
name|RelDataType
name|targetDataType
parameter_list|)
block|{
specifier|final
name|SqlValidatorScope
name|seekScope
init|=
operator|(
name|seek
operator|instanceof
name|SqlSelect
operator|)
condition|?
name|validator
argument_list|()
operator|.
name|getSelectScope
argument_list|(
operator|(
name|SqlSelect
operator|)
name|seek
argument_list|)
else|:
literal|null
decl_stmt|;
specifier|final
name|Blackboard
name|seekBb
init|=
name|createBlackboard
argument_list|(
name|seekScope
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|RelNode
name|seekRel
init|=
name|convertQueryOrInList
argument_list|(
name|seekBb
argument_list|,
name|seek
argument_list|,
name|targetDataType
argument_list|)
decl_stmt|;
name|requireNonNull
argument_list|(
name|seekRel
argument_list|,
parameter_list|()
lambda|->
literal|"seekRel is null for query "
operator|+
name|seek
argument_list|)
expr_stmt|;
return|return
name|RelOptUtil
operator|.
name|createExistsPlan
argument_list|(
name|seekRel
argument_list|,
name|subQueryType
argument_list|,
name|logic
argument_list|,
name|notIn
argument_list|,
name|relBuilder
argument_list|)
return|;
block|}
specifier|private
annotation|@
name|Nullable
name|RelNode
name|convertQueryOrInList
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlNode
name|seek
parameter_list|,
annotation|@
name|Nullable
name|RelDataType
name|targetRowType
parameter_list|)
block|{
comment|// NOTE: Once we start accepting single-row queries as row constructors,
comment|// there will be an ambiguity here for a case like X IN ((SELECT Y FROM
comment|// Z)).  The SQL standard resolves the ambiguity by saying that a lone
comment|// select should be interpreted as a table expression, not a row
comment|// expression.  The semantic difference is that a table expression can
comment|// return multiple rows.
if|if
condition|(
name|seek
operator|instanceof
name|SqlNodeList
condition|)
block|{
return|return
name|convertRowValues
argument_list|(
name|bb
argument_list|,
name|seek
argument_list|,
operator|(
name|SqlNodeList
operator|)
name|seek
argument_list|,
literal|false
argument_list|,
name|targetRowType
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|convertQueryRecursive
argument_list|(
name|seek
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
operator|.
name|project
argument_list|()
return|;
block|}
block|}
specifier|private
annotation|@
name|Nullable
name|RelNode
name|convertRowValues
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlNode
name|rowList
parameter_list|,
name|Collection
argument_list|<
name|SqlNode
argument_list|>
name|rows
parameter_list|,
name|boolean
name|allowLiteralsOnly
parameter_list|,
annotation|@
name|Nullable
name|RelDataType
name|targetRowType
parameter_list|)
block|{
comment|// NOTE jvs 30-Apr-2006: We combine all rows consisting entirely of
comment|// literals into a single LogicalValues; this gives the optimizer a smaller
comment|// input tree.  For everything else (computed expressions, row
comment|// sub-queries), we union each row in as a projection on top of a
comment|// LogicalOneRow.
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|listType
init|=
name|validator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|rowList
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
decl_stmt|;
if|if
condition|(
name|targetRowType
operator|!=
literal|null
condition|)
block|{
name|rowType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|targetRowType
argument_list|,
name|SqlTypeUtil
operator|.
name|containsNullable
argument_list|(
name|listType
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rowType
operator|=
name|SqlTypeUtil
operator|.
name|promoteToRowType
argument_list|(
name|typeFactory
argument_list|,
name|listType
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|unionInputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|rows
control|)
block|{
name|SqlBasicCall
name|call
decl_stmt|;
if|if
condition|(
name|isRowConstructor
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|call
operator|=
operator|(
name|SqlBasicCall
operator|)
name|node
expr_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexLiteral
argument_list|>
name|tuple
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|SqlNode
argument_list|>
name|operand
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
control|)
block|{
name|RexLiteral
name|rexLiteral
init|=
name|convertLiteralInValuesList
argument_list|(
name|operand
operator|.
name|e
argument_list|,
name|bb
argument_list|,
name|rowType
argument_list|,
name|operand
operator|.
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|rexLiteral
operator|==
literal|null
operator|)
operator|&&
name|allowLiteralsOnly
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|(
name|rexLiteral
operator|==
literal|null
operator|)
operator|||
operator|!
name|config
operator|.
name|isCreateValuesRel
argument_list|()
condition|)
block|{
comment|// fallback to convertRowConstructor
name|tuple
operator|=
literal|null
expr_stmt|;
break|break;
block|}
name|tuple
operator|.
name|add
argument_list|(
name|rexLiteral
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tuple
operator|!=
literal|null
condition|)
block|{
name|tupleList
operator|.
name|add
argument_list|(
name|tuple
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|RexLiteral
name|rexLiteral
init|=
name|convertLiteralInValuesList
argument_list|(
name|node
argument_list|,
name|bb
argument_list|,
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|rexLiteral
operator|!=
literal|null
operator|)
operator|&&
name|config
operator|.
name|isCreateValuesRel
argument_list|()
condition|)
block|{
name|tupleList
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|rexLiteral
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rexLiteral
operator|==
literal|null
operator|)
operator|&&
name|allowLiteralsOnly
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// convert "1" to "row(1)"
name|call
operator|=
operator|(
name|SqlBasicCall
operator|)
name|SqlStdOperatorTable
operator|.
name|ROW
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|unionInputs
operator|.
name|add
argument_list|(
name|convertRowConstructor
argument_list|(
name|bb
argument_list|,
name|call
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LogicalValues
name|values
init|=
name|LogicalValues
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|rowType
argument_list|,
name|tupleList
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|resultRel
decl_stmt|;
if|if
condition|(
name|unionInputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|resultRel
operator|=
name|values
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|values
operator|.
name|getTuples
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|unionInputs
operator|.
name|add
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
name|resultRel
operator|=
name|LogicalUnion
operator|.
name|create
argument_list|(
name|unionInputs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|leaves
operator|.
name|put
argument_list|(
name|resultRel
argument_list|,
name|resultRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|resultRel
return|;
block|}
specifier|private
annotation|@
name|Nullable
name|RexLiteral
name|convertLiteralInValuesList
parameter_list|(
annotation|@
name|Nullable
name|SqlNode
name|sqlNode
parameter_list|,
name|Blackboard
name|bb
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|int
name|iField
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|sqlNode
operator|instanceof
name|SqlLiteral
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|RelDataTypeField
name|field
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|iField
argument_list|)
decl_stmt|;
name|RelDataType
name|type
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
comment|// null literals for weird stuff like UDT's need
comment|// special handling during type flattening, so
comment|// don't use LogicalValues for those
return|return
literal|null
return|;
block|}
return|return
name|convertLiteral
argument_list|(
operator|(
name|SqlLiteral
operator|)
name|sqlNode
argument_list|,
name|bb
argument_list|,
name|type
argument_list|)
return|;
block|}
specifier|private
name|RexLiteral
name|convertLiteral
parameter_list|(
name|SqlLiteral
name|sqlLiteral
parameter_list|,
name|Blackboard
name|bb
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
name|RexNode
name|literalExpr
init|=
name|exprConverter
operator|.
name|convertLiteral
argument_list|(
name|bb
argument_list|,
name|sqlLiteral
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|literalExpr
operator|instanceof
name|RexLiteral
operator|)
condition|)
block|{
assert|assert
name|literalExpr
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
assert|;
name|RexNode
name|child
init|=
operator|(
operator|(
name|RexCall
operator|)
name|literalExpr
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|RexLiteral
operator|.
name|isNullLiteral
argument_list|(
name|child
argument_list|)
assert|;
comment|// NOTE jvs 22-Nov-2006:  we preserve type info
comment|// in LogicalValues digest, so it's OK to lose it here
return|return
operator|(
name|RexLiteral
operator|)
name|child
return|;
block|}
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|literalExpr
decl_stmt|;
name|Comparable
name|value
init|=
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|hasScale
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|BigDecimal
name|roundedValue
init|=
name|NumberUtil
operator|.
name|rescaleBigDecimal
argument_list|(
operator|(
name|BigDecimal
operator|)
name|value
argument_list|,
name|type
operator|.
name|getScale
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|roundedValue
argument_list|,
name|type
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|value
operator|instanceof
name|NlsString
operator|)
operator|&&
operator|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|CHAR
operator|)
condition|)
block|{
comment|// pad fixed character type
name|NlsString
name|unpadded
init|=
operator|(
name|NlsString
operator|)
name|value
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCharLiteral
argument_list|(
operator|new
name|NlsString
argument_list|(
name|Spaces
operator|.
name|padRight
argument_list|(
name|unpadded
operator|.
name|getValue
argument_list|()
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
argument_list|,
name|unpadded
operator|.
name|getCharsetName
argument_list|()
argument_list|,
name|unpadded
operator|.
name|getCollation
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
return|return
name|literal
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isRowConstructor
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ROW
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
return|return
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"row"
argument_list|)
return|;
block|}
comment|/**    * Builds a list of all<code>IN</code> or<code>EXISTS</code> operators    * inside SQL parse tree. Does not traverse inside queries.    *    * @param bb                           blackboard    * @param node                         the SQL parse tree    * @param logic Whether the answer needs to be in full 3-valued logic (TRUE,    *              FALSE, UNKNOWN) will be required, or whether we can accept    *              an approximation (say representing UNKNOWN as FALSE)    * @param registerOnlyScalarSubQueries if set to true and the parse tree    *                                     corresponds to a variation of a select    *                                     node, only register it if it's a scalar    *                                     sub-query    */
specifier|private
name|void
name|findSubQueries
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|RelOptUtil
operator|.
name|Logic
name|logic
parameter_list|,
name|boolean
name|registerOnlyScalarSubQueries
parameter_list|)
block|{
specifier|final
name|SqlKind
name|kind
init|=
name|node
operator|.
name|getKind
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|EXISTS
case|:
case|case
name|UNIQUE
case|:
case|case
name|SELECT
case|:
case|case
name|MULTISET_QUERY_CONSTRUCTOR
case|:
case|case
name|MULTISET_VALUE_CONSTRUCTOR
case|:
case|case
name|ARRAY_QUERY_CONSTRUCTOR
case|:
case|case
name|MAP_QUERY_CONSTRUCTOR
case|:
case|case
name|CURSOR
case|:
case|case
name|SCALAR_QUERY
case|:
if|if
condition|(
operator|!
name|registerOnlyScalarSubQueries
operator|||
operator|(
name|kind
operator|==
name|SqlKind
operator|.
name|SCALAR_QUERY
operator|)
condition|)
block|{
name|bb
operator|.
name|registerSubQuery
argument_list|(
name|node
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|IN
case|:
break|break;
case|case
name|NOT_IN
case|:
case|case
name|NOT
case|:
name|logic
operator|=
name|logic
operator|.
name|negate
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|node
operator|instanceof
name|SqlCall
condition|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
comment|// Do no change logic for AND, IN and NOT IN expressions;
comment|// but do change logic for OR, NOT and others;
comment|// EXISTS was handled already.
case|case
name|AND
case|:
case|case
name|IN
case|:
case|case
name|NOT_IN
case|:
break|break;
default|default:
name|logic
operator|=
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
expr_stmt|;
break|break;
block|}
for|for
control|(
name|SqlNode
name|operand
range|:
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
control|)
block|{
if|if
condition|(
name|operand
operator|!=
literal|null
condition|)
block|{
comment|// In the case of an IN expression, locate scalar
comment|// sub-queries so we can convert them to constants
name|findSubQueries
argument_list|(
name|bb
argument_list|,
name|operand
argument_list|,
name|logic
argument_list|,
name|kind
operator|==
name|SqlKind
operator|.
name|IN
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|NOT_IN
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|SOME
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|ALL
operator|||
name|registerOnlyScalarSubQueries
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlNodeList
condition|)
block|{
for|for
control|(
name|SqlNode
name|child
range|:
operator|(
name|SqlNodeList
operator|)
name|node
control|)
block|{
name|findSubQueries
argument_list|(
name|bb
argument_list|,
name|child
argument_list|,
name|logic
argument_list|,
name|kind
operator|==
name|SqlKind
operator|.
name|IN
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|NOT_IN
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|SOME
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|ALL
operator|||
name|registerOnlyScalarSubQueries
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Now that we've located any scalar sub-queries inside the IN
comment|// expression, register the IN expression itself.  We need to
comment|// register the scalar sub-queries first so they can be converted
comment|// before the IN expression is converted.
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|IN
case|:
case|case
name|NOT_IN
case|:
case|case
name|SOME
case|:
case|case
name|ALL
case|:
switch|switch
condition|(
name|logic
condition|)
block|{
case|case
name|TRUE_FALSE_UNKNOWN
case|:
name|RelDataType
name|type
init|=
name|validator
argument_list|()
operator|.
name|getValidatedNodeTypeIfKnown
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
comment|// The node might not be validated if we still don't know type of the node.
comment|// Therefore return directly.
return|return;
block|}
else|else
block|{
break|break;
block|}
case|case
name|UNKNOWN_AS_FALSE
case|:
name|logic
operator|=
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|bb
operator|.
name|registerSubQuery
argument_list|(
name|node
argument_list|,
name|logic
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/**    * Converts an expression from {@link SqlNode} to {@link RexNode} format.    *    * @param node Expression to translate    * @return Converted expression    */
specifier|public
name|RexNode
name|convertExpression
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|nameToTypeMap
init|=
name|Collections
operator|.
name|emptyMap
argument_list|()
decl_stmt|;
specifier|final
name|ParameterScope
name|scope
init|=
operator|new
name|ParameterScope
argument_list|(
operator|(
name|SqlValidatorImpl
operator|)
name|validator
argument_list|()
argument_list|,
name|nameToTypeMap
argument_list|)
decl_stmt|;
specifier|final
name|Blackboard
name|bb
init|=
name|createBlackboard
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|node
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
argument_list|)
expr_stmt|;
return|return
name|bb
operator|.
name|convertExpression
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/**    * Converts an expression from {@link SqlNode} to {@link RexNode} format,    * mapping identifier references to predefined expressions.    *    * @param node          Expression to translate    * @param nameToNodeMap map from String to {@link RexNode}; when an    *                      {@link SqlIdentifier} is encountered, it is used as a    *                      key and translated to the corresponding value from    *                      this map    * @return Converted expression    */
specifier|public
name|RexNode
name|convertExpression
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|nameToNodeMap
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|nameToTypeMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|entry
range|:
name|nameToNodeMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|nameToTypeMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ParameterScope
name|scope
init|=
operator|new
name|ParameterScope
argument_list|(
operator|(
name|SqlValidatorImpl
operator|)
name|validator
argument_list|()
argument_list|,
name|nameToTypeMap
argument_list|)
decl_stmt|;
specifier|final
name|Blackboard
name|bb
init|=
name|createBlackboard
argument_list|(
name|scope
argument_list|,
name|nameToNodeMap
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|node
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
argument_list|)
expr_stmt|;
return|return
name|bb
operator|.
name|convertExpression
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/**    * Converts a non-standard expression.    *    *<p>This method is an extension-point that derived classes can override. If    * this method returns a null result, the normal expression translation    * process will proceed. The default implementation always returns null.    *    * @param node Expression    * @param bb   Blackboard    * @return null to proceed with the usual expression translation process    */
specifier|protected
annotation|@
name|Nullable
name|RexNode
name|convertExtendedExpression
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Blackboard
name|bb
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
specifier|private
name|RexNode
name|convertOver
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlNode
name|node
parameter_list|)
block|{
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
name|SqlCall
name|aggCall
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|boolean
name|ignoreNulls
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|aggCall
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|IGNORE_NULLS
case|:
name|ignoreNulls
operator|=
literal|true
expr_stmt|;
comment|// fall through
case|case
name|RESPECT_NULLS
case|:
name|aggCall
operator|=
name|aggCall
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|SqlNode
name|windowOrRef
init|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|SqlWindow
name|window
init|=
name|validator
argument_list|()
operator|.
name|resolveWindow
argument_list|(
name|windowOrRef
argument_list|,
name|bb
operator|.
name|scope
argument_list|()
argument_list|)
decl_stmt|;
name|SqlNode
name|sqlLowerBound
init|=
name|window
operator|.
name|getLowerBound
argument_list|()
decl_stmt|;
name|SqlNode
name|sqlUpperBound
init|=
name|window
operator|.
name|getUpperBound
argument_list|()
decl_stmt|;
name|boolean
name|rows
init|=
name|window
operator|.
name|isRows
argument_list|()
decl_stmt|;
name|SqlNodeList
name|orderList
init|=
name|window
operator|.
name|getOrderList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|aggCall
operator|.
name|getOperator
argument_list|()
operator|.
name|allowsFraming
argument_list|()
condition|)
block|{
comment|// If the operator does not allow framing, bracketing is implicitly
comment|// everything up to the current row.
name|sqlLowerBound
operator|=
name|SqlWindow
operator|.
name|createUnboundedPreceding
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|sqlUpperBound
operator|=
name|SqlWindow
operator|.
name|createCurrentRow
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|aggCall
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ROW_NUMBER
condition|)
block|{
comment|// ROW_NUMBER() expects specific kind of framing.
name|rows
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|orderList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Without ORDER BY, there must be no bracketing.
name|sqlLowerBound
operator|=
name|SqlWindow
operator|.
name|createUnboundedPreceding
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|sqlUpperBound
operator|=
name|SqlWindow
operator|.
name|createUnboundedFollowing
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|sqlLowerBound
operator|==
literal|null
operator|&&
name|sqlUpperBound
operator|==
literal|null
condition|)
block|{
name|sqlLowerBound
operator|=
name|SqlWindow
operator|.
name|createUnboundedPreceding
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|sqlUpperBound
operator|=
name|SqlWindow
operator|.
name|createCurrentRow
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|sqlUpperBound
operator|==
literal|null
condition|)
block|{
name|sqlUpperBound
operator|=
name|SqlWindow
operator|.
name|createCurrentRow
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|sqlLowerBound
operator|==
literal|null
condition|)
block|{
name|sqlLowerBound
operator|=
name|SqlWindow
operator|.
name|createCurrentRow
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlNodeList
name|partitionList
init|=
name|window
operator|.
name|getPartitionList
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|partitionKeys
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|partition
range|:
name|partitionList
control|)
block|{
name|validator
argument_list|()
operator|.
name|deriveType
argument_list|(
name|bb
operator|.
name|scope
argument_list|()
argument_list|,
name|partition
argument_list|)
expr_stmt|;
name|partitionKeys
operator|.
name|add
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|partition
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RexNode
name|lowerBound
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|requireNonNull
argument_list|(
name|sqlLowerBound
argument_list|,
literal|"sqlLowerBound"
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|upperBound
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|requireNonNull
argument_list|(
name|sqlUpperBound
argument_list|,
literal|"sqlUpperBound"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|orderList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|rows
condition|)
block|{
comment|// A logical range requires an ORDER BY clause. Use the implicit
comment|// ordering of this relation. There must be one, otherwise it would
comment|// have failed validation.
name|orderList
operator|=
name|bb
operator|.
name|scope
argument_list|()
operator|.
name|getOrderList
argument_list|()
expr_stmt|;
if|if
condition|(
name|orderList
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Relation should have sort key for implicit ORDER BY"
argument_list|)
throw|;
block|}
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|orderKeys
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|order
range|:
name|orderList
control|)
block|{
name|orderKeys
operator|.
name|add
argument_list|(
name|bb
operator|.
name|convertSortExpression
argument_list|(
name|order
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|ASCENDING
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
argument_list|,
name|bb
operator|::
name|sortToRex
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|bb
operator|.
name|window
operator|==
literal|null
argument_list|,
literal|"already in window agg mode"
argument_list|)
expr_stmt|;
name|bb
operator|.
name|window
operator|=
name|window
expr_stmt|;
name|RexNode
name|rexAgg
init|=
name|exprConverter
operator|.
name|convertCall
argument_list|(
name|bb
argument_list|,
name|aggCall
argument_list|)
decl_stmt|;
name|rexAgg
operator|=
name|rexBuilder
operator|.
name|ensureType
argument_list|(
name|validator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
argument_list|,
name|rexAgg
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Walk over the tree and apply 'over' to all agg functions. This is
comment|// necessary because the returned expression is not necessarily a call
comment|// to an agg function. For example, AVG(x) becomes SUM(x) / COUNT(x).
specifier|final
name|SqlLiteral
name|q
init|=
name|aggCall
operator|.
name|getFunctionQuantifier
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isDistinct
init|=
name|q
operator|!=
literal|null
operator|&&
name|q
operator|.
name|getValue
argument_list|()
operator|==
name|SqlSelectKeyword
operator|.
name|DISTINCT
decl_stmt|;
specifier|final
name|RexShuttle
name|visitor
init|=
operator|new
name|HistogramShuttle
argument_list|(
name|partitionKeys
operator|.
name|build
argument_list|()
argument_list|,
name|orderKeys
operator|.
name|build
argument_list|()
argument_list|,
name|rows
argument_list|,
name|RexWindowBounds
operator|.
name|create
argument_list|(
name|sqlLowerBound
argument_list|,
name|lowerBound
argument_list|)
argument_list|,
name|RexWindowBounds
operator|.
name|create
argument_list|(
name|sqlUpperBound
argument_list|,
name|upperBound
argument_list|)
argument_list|,
name|window
operator|.
name|isAllowPartial
argument_list|()
argument_list|,
name|isDistinct
argument_list|,
name|ignoreNulls
argument_list|)
decl_stmt|;
return|return
name|rexAgg
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
return|;
block|}
finally|finally
block|{
name|bb
operator|.
name|window
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|convertFrom
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
annotation|@
name|Nullable
name|SqlNode
name|from
parameter_list|)
block|{
name|convertFrom
argument_list|(
name|bb
argument_list|,
name|from
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Converts a FROM clause into a relational expression.    *    * @param bb   Scope within which to resolve identifiers    * @param from FROM clause of a query. Examples include:    *    *<ul>    *<li>a single table ("SALES.EMP"),    *<li>an aliased table ("EMP AS E"),    *<li>a list of tables ("EMP, DEPT"),    *<li>an ANSI Join expression ("EMP JOIN DEPT ON EMP.DEPTNO =    *             DEPT.DEPTNO"),    *<li>a VALUES clause ("VALUES ('Fred', 20)"),    *<li>a query ("(SELECT * FROM EMP WHERE GENDER = 'F')"),    *<li>or any combination of the above.    *</ul>    * @param fieldNames Field aliases, usually come from AS clause, or null    */
specifier|protected
name|void
name|convertFrom
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
annotation|@
name|Nullable
name|SqlNode
name|from
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
if|if
condition|(
name|from
operator|==
literal|null
condition|)
block|{
name|bb
operator|.
name|setRoot
argument_list|(
name|LogicalValues
operator|.
name|createOneRow
argument_list|(
name|cluster
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|SqlCall
name|call
decl_stmt|;
switch|switch
condition|(
name|from
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|from
expr_stmt|;
name|SqlNode
name|firstOperand
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
init|=
name|call
operator|.
name|operandCount
argument_list|()
operator|>
literal|2
condition|?
name|SqlIdentifier
operator|.
name|simpleNames
argument_list|(
name|Util
operator|.
name|skip
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|,
literal|2
argument_list|)
argument_list|)
else|:
literal|null
decl_stmt|;
name|convertFrom
argument_list|(
name|bb
argument_list|,
name|firstOperand
argument_list|,
name|fieldNameList
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_RECOGNIZE
case|:
name|convertMatchRecognize
argument_list|(
name|bb
argument_list|,
operator|(
name|SqlMatchRecognize
operator|)
name|from
argument_list|)
expr_stmt|;
return|return;
case|case
name|PIVOT
case|:
name|convertPivot
argument_list|(
name|bb
argument_list|,
operator|(
name|SqlPivot
operator|)
name|from
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNPIVOT
case|:
name|convertUnpivot
argument_list|(
name|bb
argument_list|,
operator|(
name|SqlUnpivot
operator|)
name|from
argument_list|)
expr_stmt|;
return|return;
case|case
name|WITH_ITEM
case|:
name|convertFrom
argument_list|(
name|bb
argument_list|,
operator|(
operator|(
name|SqlWithItem
operator|)
name|from
operator|)
operator|.
name|query
argument_list|)
expr_stmt|;
return|return;
case|case
name|WITH
case|:
name|convertFrom
argument_list|(
name|bb
argument_list|,
operator|(
operator|(
name|SqlWith
operator|)
name|from
operator|)
operator|.
name|body
argument_list|)
expr_stmt|;
return|return;
case|case
name|TABLESAMPLE
case|:
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|from
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
name|SqlSampleSpec
name|sampleSpec
init|=
name|SqlLiteral
operator|.
name|sampleValue
argument_list|(
name|requireNonNull
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"operand[1] of "
operator|+
name|from
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sampleSpec
operator|instanceof
name|SqlSampleSpec
operator|.
name|SqlSubstitutionSampleSpec
condition|)
block|{
name|String
name|sampleName
init|=
operator|(
operator|(
name|SqlSampleSpec
operator|.
name|SqlSubstitutionSampleSpec
operator|)
name|sampleSpec
operator|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|datasetStack
operator|.
name|push
argument_list|(
name|sampleName
argument_list|)
expr_stmt|;
name|convertFrom
argument_list|(
name|bb
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|datasetStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|sampleSpec
operator|instanceof
name|SqlSampleSpec
operator|.
name|SqlTableSampleSpec
condition|)
block|{
name|SqlSampleSpec
operator|.
name|SqlTableSampleSpec
name|tableSampleSpec
init|=
operator|(
name|SqlSampleSpec
operator|.
name|SqlTableSampleSpec
operator|)
name|sampleSpec
decl_stmt|;
name|convertFrom
argument_list|(
name|bb
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RelOptSamplingParameters
name|params
init|=
operator|new
name|RelOptSamplingParameters
argument_list|(
name|tableSampleSpec
operator|.
name|isBernoulli
argument_list|()
argument_list|,
name|tableSampleSpec
operator|.
name|getSamplePercentage
argument_list|()
argument_list|,
name|tableSampleSpec
operator|.
name|isRepeatable
argument_list|()
argument_list|,
name|tableSampleSpec
operator|.
name|getRepeatableSeed
argument_list|()
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
operator|new
name|Sample
argument_list|(
name|cluster
argument_list|,
name|bb
operator|.
name|root
argument_list|()
argument_list|,
name|params
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unknown TABLESAMPLE type: "
operator|+
name|sampleSpec
argument_list|)
throw|;
block|}
return|return;
case|case
name|TABLE_REF
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|from
expr_stmt|;
name|convertIdentifier
argument_list|(
name|bb
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|null
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|IDENTIFIER
case|:
name|convertIdentifier
argument_list|(
name|bb
argument_list|,
operator|(
name|SqlIdentifier
operator|)
name|from
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return;
case|case
name|EXTEND
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|from
expr_stmt|;
specifier|final
name|SqlNode
name|operand0
init|=
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlIdentifier
name|id
init|=
name|operand0
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|TABLE_REF
condition|?
operator|(
operator|(
name|SqlCall
operator|)
name|operand0
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
else|:
operator|(
name|SqlIdentifier
operator|)
name|operand0
decl_stmt|;
name|SqlNodeList
name|extendedColumns
init|=
operator|(
name|SqlNodeList
operator|)
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|convertIdentifier
argument_list|(
name|bb
argument_list|,
name|id
argument_list|,
name|extendedColumns
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return;
case|case
name|SNAPSHOT
case|:
name|convertTemporalTable
argument_list|(
name|bb
argument_list|,
operator|(
name|SqlCall
operator|)
name|from
argument_list|)
expr_stmt|;
return|return;
case|case
name|JOIN
case|:
name|convertJoin
argument_list|(
name|bb
argument_list|,
operator|(
name|SqlJoin
operator|)
name|from
argument_list|)
expr_stmt|;
return|return;
case|case
name|SELECT
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
case|case
name|UNION
case|:
specifier|final
name|RelNode
name|rel
init|=
name|convertQueryRecursive
argument_list|(
name|from
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|rel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
case|case
name|VALUES
case|:
name|convertValuesImpl
argument_list|(
name|bb
argument_list|,
operator|(
name|SqlCall
operator|)
name|from
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldNames
operator|!=
literal|null
condition|)
block|{
name|bb
operator|.
name|setRoot
argument_list|(
name|relBuilder
operator|.
name|push
argument_list|(
name|bb
operator|.
name|root
argument_list|()
argument_list|)
operator|.
name|rename
argument_list|(
name|fieldNames
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|UNNEST
case|:
name|convertUnnest
argument_list|(
name|bb
argument_list|,
operator|(
name|SqlCall
operator|)
name|from
argument_list|,
name|fieldNames
argument_list|)
expr_stmt|;
return|return;
case|case
name|COLLECTION_TABLE
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|from
expr_stmt|;
comment|// Dig out real call; TABLE() wrapper is just syntactic.
assert|assert
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|SqlCall
name|call2
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|convertCollectionTable
argument_list|(
name|bb
argument_list|,
name|call2
argument_list|)
expr_stmt|;
return|return;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"not a join operator "
operator|+
name|from
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|convertUnnest
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlCall
name|call
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodes
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
specifier|final
name|SqlUnnestOperator
name|operator
init|=
operator|(
name|SqlUnnestOperator
operator|)
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|nodes
control|)
block|{
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|node
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|SqlNode
argument_list|>
name|node
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|nodes
argument_list|)
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|alias
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|node
operator|.
name|e
argument_list|)
argument_list|,
name|validator
argument_list|()
operator|.
name|deriveAlias
argument_list|(
name|node
operator|.
name|e
argument_list|,
name|node
operator|.
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|child
init|=
operator|(
literal|null
operator|!=
name|bb
operator|.
name|root
operator|)
condition|?
name|bb
operator|.
name|root
else|:
name|LogicalValues
operator|.
name|createOneRow
argument_list|(
name|cluster
argument_list|)
decl_stmt|;
name|RelNode
name|uncollect
decl_stmt|;
if|if
condition|(
name|validator
argument_list|()
operator|.
name|config
argument_list|()
operator|.
name|sqlConformance
argument_list|()
operator|.
name|allowAliasUnnestItems
argument_list|()
condition|)
block|{
name|uncollect
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|child
argument_list|)
operator|.
name|project
argument_list|(
name|exprs
argument_list|)
operator|.
name|uncollect
argument_list|(
name|requireNonNull
argument_list|(
name|fieldNames
argument_list|,
literal|"fieldNames"
argument_list|)
argument_list|,
name|operator
operator|.
name|withOrdinality
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// REVIEW danny 2020-04-26: should we unify the normal field aliases and
comment|// the item aliases?
name|uncollect
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|child
argument_list|)
operator|.
name|project
argument_list|(
name|exprs
argument_list|)
operator|.
name|uncollect
argument_list|(
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|operator
operator|.
name|withOrdinality
argument_list|)
operator|.
name|let
argument_list|(
name|r
lambda|->
name|fieldNames
operator|==
literal|null
condition|?
name|r
else|:
name|r
operator|.
name|rename
argument_list|(
name|fieldNames
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|bb
operator|.
name|setRoot
argument_list|(
name|uncollect
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|convertMatchRecognize
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlMatchRecognize
name|matchRecognize
parameter_list|)
block|{
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|matchRecognize
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|scope
init|=
name|validator
argument_list|()
operator|.
name|getMatchRecognizeScope
argument_list|(
name|matchRecognize
argument_list|)
decl_stmt|;
specifier|final
name|Blackboard
name|matchBb
init|=
name|createBlackboard
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|ns
operator|.
name|getRowType
argument_list|()
decl_stmt|;
comment|// convert inner query, could be a table name or a derived table
name|SqlNode
name|expr
init|=
name|matchRecognize
operator|.
name|getTableRef
argument_list|()
decl_stmt|;
name|convertFrom
argument_list|(
name|matchBb
argument_list|,
name|expr
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|matchBb
operator|.
name|root
argument_list|()
decl_stmt|;
comment|// PARTITION BY
specifier|final
name|SqlNodeList
name|partitionList
init|=
name|matchRecognize
operator|.
name|getPartitionList
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|partitionKeys
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|partition
range|:
name|partitionList
control|)
block|{
name|RexNode
name|e
init|=
name|matchBb
operator|.
name|convertExpression
argument_list|(
name|partition
argument_list|)
decl_stmt|;
name|partitionKeys
operator|.
name|set
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|e
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// ORDER BY
specifier|final
name|SqlNodeList
name|orderList
init|=
name|matchRecognize
operator|.
name|getOrderList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|orderKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|order
range|:
name|orderList
control|)
block|{
specifier|final
name|RelFieldCollation
operator|.
name|Direction
name|direction
decl_stmt|;
switch|switch
condition|(
name|order
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
name|direction
operator|=
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
expr_stmt|;
name|order
operator|=
operator|(
operator|(
name|SqlCall
operator|)
name|order
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NULLS_FIRST
case|:
case|case
name|NULLS_LAST
case|:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
default|default:
name|direction
operator|=
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|ASCENDING
expr_stmt|;
break|break;
block|}
specifier|final
name|RelFieldCollation
operator|.
name|NullDirection
name|nullDirection
init|=
name|validator
argument_list|()
operator|.
name|config
argument_list|()
operator|.
name|defaultNullCollation
argument_list|()
operator|.
name|last
argument_list|(
name|desc
argument_list|(
name|direction
argument_list|)
argument_list|)
condition|?
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
else|:
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
decl_stmt|;
name|RexNode
name|e
init|=
name|matchBb
operator|.
name|convertExpression
argument_list|(
name|order
argument_list|)
decl_stmt|;
name|orderKeys
operator|.
name|add
argument_list|(
operator|new
name|RelFieldCollation
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|e
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|,
name|direction
argument_list|,
name|nullDirection
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelCollation
name|orders
init|=
name|cluster
operator|.
name|traitSet
argument_list|()
operator|.
name|canonize
argument_list|(
name|RelCollations
operator|.
name|of
argument_list|(
name|orderKeys
argument_list|)
argument_list|)
decl_stmt|;
comment|// convert pattern
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|patternVarsSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|SqlNode
name|pattern
init|=
name|matchRecognize
operator|.
name|getPattern
argument_list|()
decl_stmt|;
specifier|final
name|SqlBasicVisitor
argument_list|<
annotation|@
name|Nullable
name|RexNode
argument_list|>
name|patternVarVisitor
init|=
operator|new
name|SqlBasicVisitor
argument_list|<
annotation|@
name|Nullable
name|RexNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|operands
control|)
block|{
name|RexNode
name|arg
init|=
name|requireNonNull
argument_list|(
name|node
operator|.
name|accept
argument_list|(
name|this
argument_list|)
argument_list|,
name|node
operator|::
name|toString
argument_list|)
decl_stmt|;
name|newOperands
operator|.
name|add
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|validator
argument_list|()
operator|.
name|getUnknownType
argument_list|()
argument_list|,
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|newOperands
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
assert|assert
name|id
operator|.
name|isSimple
argument_list|()
assert|;
name|patternVarsSet
operator|.
name|add
argument_list|(
name|id
operator|.
name|getSimple
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|id
operator|.
name|getSimple
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
if|if
condition|(
name|literal
operator|instanceof
name|SqlNumericLiteral
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|literal
operator|.
name|intValue
argument_list|(
literal|true
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|literal
operator|.
name|booleanValue
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
decl_stmt|;
specifier|final
name|RexNode
name|patternNode
init|=
name|pattern
operator|.
name|accept
argument_list|(
name|patternVarVisitor
argument_list|)
decl_stmt|;
assert|assert
name|patternNode
operator|!=
literal|null
operator|:
literal|"pattern is not found in "
operator|+
name|pattern
assert|;
name|SqlLiteral
name|interval
init|=
name|matchRecognize
operator|.
name|getInterval
argument_list|()
decl_stmt|;
name|RexNode
name|intervalNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|interval
operator|!=
literal|null
condition|)
block|{
name|intervalNode
operator|=
name|matchBb
operator|.
name|convertLiteral
argument_list|(
name|interval
argument_list|)
expr_stmt|;
block|}
comment|// convert subset
specifier|final
name|SqlNodeList
name|subsets
init|=
name|matchRecognize
operator|.
name|getSubsetList
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|subsetMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|subsets
control|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
name|SqlIdentifier
name|left
init|=
operator|(
name|SqlIdentifier
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|patternVarsSet
operator|.
name|add
argument_list|(
name|left
operator|.
name|getSimple
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|SqlNodeList
name|rights
init|=
operator|(
name|SqlNodeList
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|TreeSet
argument_list|<
name|String
argument_list|>
name|list
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|SqlIdentifier
operator|.
name|simpleNames
argument_list|(
name|rights
argument_list|)
argument_list|)
decl_stmt|;
name|subsetMap
operator|.
name|put
argument_list|(
name|left
operator|.
name|getSimple
argument_list|()
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|SqlNode
name|afterMatch
init|=
name|matchRecognize
operator|.
name|getAfter
argument_list|()
decl_stmt|;
if|if
condition|(
name|afterMatch
operator|==
literal|null
condition|)
block|{
name|afterMatch
operator|=
name|SqlMatchRecognize
operator|.
name|AfterOption
operator|.
name|SKIP_TO_NEXT_ROW
operator|.
name|symbol
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RexNode
name|after
decl_stmt|;
if|if
condition|(
name|afterMatch
operator|instanceof
name|SqlCall
condition|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|afterMatch
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
name|SqlOperator
name|operator
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|afterMatch
operator|)
operator|.
name|getOperator
argument_list|()
decl_stmt|;
assert|assert
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|patternVarsSet
operator|.
name|contains
argument_list|(
name|id
operator|.
name|getSimple
argument_list|()
argument_list|)
operator|:
name|id
operator|.
name|getSimple
argument_list|()
operator|+
literal|" not defined in pattern"
assert|;
name|RexNode
name|rex
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|id
operator|.
name|getSimple
argument_list|()
argument_list|)
decl_stmt|;
name|after
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|validator
argument_list|()
operator|.
name|getUnknownType
argument_list|()
argument_list|,
name|operator
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rex
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|after
operator|=
name|matchBb
operator|.
name|convertExpression
argument_list|(
name|afterMatch
argument_list|)
expr_stmt|;
block|}
name|matchBb
operator|.
name|setPatternVarRef
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// convert measures
specifier|final
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|measureNodes
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|measure
range|:
name|matchRecognize
operator|.
name|getMeasureList
argument_list|()
control|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|measure
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
operator|(
operator|(
name|SqlIdentifier
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getSimple
argument_list|()
decl_stmt|;
name|RexNode
name|rex
init|=
name|matchBb
operator|.
name|convertExpression
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|measureNodes
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|rex
argument_list|)
expr_stmt|;
block|}
comment|// convert definitions
specifier|final
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|definitionNodes
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|def
range|:
name|matchRecognize
operator|.
name|getPatternDefList
argument_list|()
control|)
block|{
name|replaceSubQueries
argument_list|(
name|matchBb
argument_list|,
name|def
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|UNKNOWN_AS_FALSE
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|def
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
operator|(
operator|(
name|SqlIdentifier
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getSimple
argument_list|()
decl_stmt|;
name|RexNode
name|rex
init|=
name|matchBb
operator|.
name|convertExpression
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|definitionNodes
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|rex
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlLiteral
name|rowsPerMatch
init|=
name|matchRecognize
operator|.
name|getRowsPerMatch
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|allRows
init|=
name|rowsPerMatch
operator|!=
literal|null
operator|&&
name|rowsPerMatch
operator|.
name|getValue
argument_list|()
operator|==
name|SqlMatchRecognize
operator|.
name|RowsPerMatchOption
operator|.
name|ALL_ROWS
decl_stmt|;
name|matchBb
operator|.
name|setPatternVarRef
argument_list|(
literal|false
argument_list|)
expr_stmt|;
specifier|final
name|RelFactories
operator|.
name|MatchFactory
name|factory
init|=
name|RelFactories
operator|.
name|DEFAULT_MATCH_FACTORY
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|factory
operator|.
name|createMatch
argument_list|(
name|input
argument_list|,
name|patternNode
argument_list|,
name|rowType
argument_list|,
name|matchRecognize
operator|.
name|getStrictStart
argument_list|()
operator|.
name|booleanValue
argument_list|()
argument_list|,
name|matchRecognize
operator|.
name|getStrictEnd
argument_list|()
operator|.
name|booleanValue
argument_list|()
argument_list|,
name|definitionNodes
operator|.
name|build
argument_list|()
argument_list|,
name|measureNodes
operator|.
name|build
argument_list|()
argument_list|,
name|after
argument_list|,
name|subsetMap
argument_list|,
name|allRows
argument_list|,
name|partitionKeys
operator|.
name|build
argument_list|()
argument_list|,
name|orders
argument_list|,
name|intervalNode
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|rel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|convertPivot
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlPivot
name|pivot
parameter_list|)
block|{
specifier|final
name|SqlValidatorScope
name|scope
init|=
name|validator
argument_list|()
operator|.
name|getJoinScope
argument_list|(
name|pivot
argument_list|)
decl_stmt|;
specifier|final
name|Blackboard
name|pivotBb
init|=
name|createBlackboard
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Convert input
name|convertFrom
argument_list|(
name|pivotBb
argument_list|,
name|pivot
operator|.
name|query
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|pivotBb
operator|.
name|root
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|inputRowType
init|=
name|input
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|// Gather fields.
specifier|final
name|AggConverter
name|aggConverter
init|=
operator|new
name|AggConverter
argument_list|(
name|pivotBb
argument_list|,
operator|(
name|AggregatingSelectScope
operator|)
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|usedColumnNames
init|=
name|pivot
operator|.
name|usedColumnNames
argument_list|()
decl_stmt|;
comment|// 1. Gather group keys.
name|inputRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|field
lambda|->
operator|!
name|usedColumnNames
operator|.
name|contains
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
operator|.
name|forEach
argument_list|(
name|field
lambda|->
name|aggConverter
operator|.
name|addGroupExpr
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 2. Gather axes.
name|pivot
operator|.
name|axisList
operator|.
name|forEach
argument_list|(
name|aggConverter
operator|::
name|addGroupExpr
argument_list|)
expr_stmt|;
comment|// 3. Gather columns used as arguments to aggregate functions.
name|pivotBb
operator|.
name|agg
operator|=
name|aggConverter
expr_stmt|;
specifier|final
name|List
argument_list|<
annotation|@
name|Nullable
name|String
argument_list|>
name|aggAliasList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
assert|assert
name|aggConverter
operator|.
name|aggCalls
operator|.
name|size
argument_list|()
operator|==
literal|0
assert|;
name|pivot
operator|.
name|forEachAgg
argument_list|(
parameter_list|(
name|alias
parameter_list|,
name|call
parameter_list|)
lambda|->
block|{
name|call
operator|.
name|accept
argument_list|(
name|aggConverter
argument_list|)
expr_stmt|;
name|aggAliasList
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
assert|assert
name|aggConverter
operator|.
name|aggCalls
operator|.
name|size
argument_list|()
operator|==
name|aggAliasList
operator|.
name|size
argument_list|()
assert|;
block|}
argument_list|)
expr_stmt|;
name|pivotBb
operator|.
name|agg
operator|=
literal|null
expr_stmt|;
comment|// Project the fields that we will need.
name|relBuilder
operator|.
name|project
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|aggConverter
operator|.
name|getPreExprs
argument_list|()
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|aggConverter
operator|.
name|getPreExprs
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Build expressions.
comment|// 1. Build group key
specifier|final
name|RelBuilder
operator|.
name|GroupKey
name|groupKey
init|=
name|relBuilder
operator|.
name|groupKey
argument_list|(
name|inputRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|field
lambda|->
operator|!
name|usedColumnNames
operator|.
name|contains
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
operator|.
name|map
argument_list|(
name|field
lambda|->
name|aggConverter
operator|.
name|addGroupExpr
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|ImmutableBitSet
operator|.
name|toImmutableBitSet
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// 2. Build axes, for example
comment|// FOR (axis1, axis2 ...) IN ...
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|axes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|axis
range|:
name|pivot
operator|.
name|axisList
control|)
block|{
name|axes
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
name|aggConverter
operator|.
name|addGroupExpr
argument_list|(
name|axis
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 3. Build aggregate expressions, for example
comment|// PIVOT (sum(a) AS alias1, min(b) AS alias2, ... FOR ... IN ...)
specifier|final
name|List
argument_list|<
name|RelBuilder
operator|.
name|AggCall
argument_list|>
name|aggCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Pair
operator|.
name|forEach
argument_list|(
name|aggAliasList
argument_list|,
name|aggConverter
operator|.
name|aggCalls
argument_list|,
parameter_list|(
name|alias
parameter_list|,
name|aggregateCall
parameter_list|)
lambda|->
name|aggCalls
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|aggregateCall
argument_list|(
name|aggregateCall
argument_list|)
operator|.
name|as
argument_list|(
name|alias
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 4. Build values, for example
comment|// IN ((v11, v12, ...) AS label1, (v21, v22, ...) AS label2, ...)
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
argument_list|>
name|valueList
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|pivot
operator|.
name|forEachNameValues
argument_list|(
parameter_list|(
name|alias
parameter_list|,
name|nodeList
parameter_list|)
lambda|->
name|valueList
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|alias
argument_list|,
name|nodeList
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|bb
operator|::
name|convertExpression
argument_list|)
operator|.
name|collect
argument_list|(
name|Util
operator|.
name|toImmutableList
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|relBuilder
operator|.
name|pivot
argument_list|(
name|groupKey
argument_list|,
name|aggCalls
argument_list|,
name|axes
argument_list|,
name|valueList
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|rel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|convertUnpivot
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlUnpivot
name|unpivot
parameter_list|)
block|{
specifier|final
name|SqlValidatorScope
name|scope
init|=
name|validator
argument_list|()
operator|.
name|getJoinScope
argument_list|(
name|unpivot
argument_list|)
decl_stmt|;
specifier|final
name|Blackboard
name|unpivotBb
init|=
name|createBlackboard
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Convert input
name|convertFrom
argument_list|(
name|unpivotBb
argument_list|,
name|unpivot
operator|.
name|query
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|unpivotBb
operator|.
name|root
argument_list|()
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|input
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|measureNames
init|=
name|unpivot
operator|.
name|measureList
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|node
lambda|->
operator|(
operator|(
name|SqlIdentifier
operator|)
name|node
operator|)
operator|.
name|getSimple
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Util
operator|.
name|toImmutableList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|axisNames
init|=
name|unpivot
operator|.
name|axisList
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|node
lambda|->
operator|(
operator|(
name|SqlIdentifier
operator|)
name|node
operator|)
operator|.
name|getSimple
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Util
operator|.
name|toImmutableList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Pair
argument_list|<
name|List
argument_list|<
name|RexLiteral
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
argument_list|>
name|axisMap
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|unpivot
operator|.
name|forEachNameValues
argument_list|(
parameter_list|(
name|nodeList
parameter_list|,
name|valueList
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|valueList
operator|==
literal|null
condition|)
block|{
name|valueList
operator|=
operator|new
name|SqlNodeList
argument_list|(
name|Collections
operator|.
name|nCopies
argument_list|(
name|axisNames
operator|.
name|size
argument_list|()
argument_list|,
name|SqlLiteral
operator|.
name|createCharString
argument_list|(
name|SqlUnpivot
operator|.
name|aliasValue
argument_list|(
name|nodeList
argument_list|)
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|literals
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Pair
operator|.
name|forEach
argument_list|(
name|valueList
argument_list|,
name|unpivot
operator|.
name|axisList
argument_list|,
parameter_list|(
name|value
parameter_list|,
name|axis
parameter_list|)
lambda|->
block|{
specifier|final
name|RelDataType
name|type
init|=
name|validator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|axis
argument_list|)
decl_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|convertLiteral
argument_list|(
operator|(
name|SqlLiteral
operator|)
name|value
argument_list|,
name|bb
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|nodeList
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|unpivotBb
operator|::
name|convertExpression
argument_list|)
operator|.
name|collect
argument_list|(
name|Util
operator|.
name|toImmutableList
argument_list|()
argument_list|)
decl_stmt|;
name|axisMap
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|literals
argument_list|,
name|nodes
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|unpivot
argument_list|(
name|unpivot
operator|.
name|includeNulls
argument_list|,
name|measureNames
argument_list|,
name|axisNames
argument_list|,
name|axisMap
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|convert
argument_list|(
name|getNamespace
argument_list|(
name|unpivot
argument_list|)
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|convertIdentifier
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlIdentifier
name|id
parameter_list|,
annotation|@
name|Nullable
name|SqlNodeList
name|extendedColumns
parameter_list|,
annotation|@
name|Nullable
name|SqlNodeList
name|tableHints
parameter_list|)
block|{
specifier|final
name|SqlValidatorNamespace
name|fromNamespace
init|=
name|getNamespace
argument_list|(
name|id
argument_list|)
operator|.
name|resolve
argument_list|()
decl_stmt|;
if|if
condition|(
name|fromNamespace
operator|.
name|getNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|convertFrom
argument_list|(
name|bb
argument_list|,
name|fromNamespace
operator|.
name|getNode
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|String
name|datasetName
init|=
name|datasetStack
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|datasetStack
operator|.
name|peek
argument_list|()
decl_stmt|;
specifier|final
name|boolean
index|[]
name|usedDataset
init|=
block|{
literal|false
block|}
decl_stmt|;
name|RelOptTable
name|table
init|=
name|SqlValidatorUtil
operator|.
name|getRelOptTable
argument_list|(
name|fromNamespace
argument_list|,
name|catalogReader
argument_list|,
name|datasetName
argument_list|,
name|usedDataset
argument_list|)
decl_stmt|;
assert|assert
name|table
operator|!=
literal|null
operator|:
literal|"getRelOptTable returned null for "
operator|+
name|fromNamespace
assert|;
if|if
condition|(
name|extendedColumns
operator|!=
literal|null
operator|&&
name|extendedColumns
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|SqlValidatorTable
name|validatorTable
init|=
name|table
operator|.
name|unwrapOrThrow
argument_list|(
name|SqlValidatorTable
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|extendedFields
init|=
name|SqlValidatorUtil
operator|.
name|getExtendedColumns
argument_list|(
name|validator
argument_list|,
name|validatorTable
argument_list|,
name|extendedColumns
argument_list|)
decl_stmt|;
name|table
operator|=
name|table
operator|.
name|extend
argument_list|(
name|extendedFields
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|tableRel
decl_stmt|;
comment|// Review Danny 2020-01-13: hacky to construct a new table scan
comment|// in order to apply the hint strategies.
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|hints
init|=
name|hintStrategies
operator|.
name|apply
argument_list|(
name|SqlUtil
operator|.
name|getRelHint
argument_list|(
name|hintStrategies
argument_list|,
name|tableHints
argument_list|)
argument_list|,
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|table
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|tableRel
operator|=
name|toRel
argument_list|(
name|table
argument_list|,
name|hints
argument_list|)
expr_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|tableRel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|usedDataset
index|[
literal|0
index|]
condition|)
block|{
name|bb
operator|.
name|setDataset
argument_list|(
name|datasetName
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|convertCollectionTable
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|operator
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|TABLESAMPLE
condition|)
block|{
specifier|final
name|String
name|sampleName
init|=
name|SqlLiteral
operator|.
name|unchain
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|getValueAs
argument_list|(
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
name|datasetStack
operator|.
name|push
argument_list|(
name|sampleName
argument_list|)
expr_stmt|;
name|SqlCall
name|cursorCall
init|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|SqlNode
name|query
init|=
name|cursorCall
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|converted
init|=
name|convertQuery
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
operator|.
name|rel
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|converted
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|datasetStack
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|call
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
argument_list|)
expr_stmt|;
comment|// Expand table macro if possible. It's more efficient than
comment|// LogicalTableFunctionScan.
specifier|final
name|SqlCallBinding
name|callBinding
init|=
operator|new
name|SqlCallBinding
argument_list|(
name|bb
operator|.
name|scope
argument_list|()
operator|.
name|getValidator
argument_list|()
argument_list|,
name|bb
operator|.
name|scope
argument_list|,
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|operator
operator|instanceof
name|SqlUserDefinedTableMacro
condition|)
block|{
specifier|final
name|SqlUserDefinedTableMacro
name|udf
init|=
operator|(
name|SqlUserDefinedTableMacro
operator|)
name|operator
decl_stmt|;
specifier|final
name|TranslatableTable
name|table
init|=
name|udf
operator|.
name|getTable
argument_list|(
name|callBinding
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|table
operator|.
name|getRowType
argument_list|(
name|typeFactory
argument_list|)
decl_stmt|;
name|RelOptTable
name|relOptTable
init|=
name|RelOptTableImpl
operator|.
name|create
argument_list|(
literal|null
argument_list|,
name|rowType
argument_list|,
name|table
argument_list|,
name|udf
operator|.
name|getNameAsId
argument_list|()
operator|.
name|names
argument_list|)
decl_stmt|;
name|RelNode
name|converted
init|=
name|toRel
argument_list|(
name|relOptTable
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|converted
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|Type
name|elementType
decl_stmt|;
if|if
condition|(
name|operator
operator|instanceof
name|SqlUserDefinedTableFunction
condition|)
block|{
name|SqlUserDefinedTableFunction
name|udtf
init|=
operator|(
name|SqlUserDefinedTableFunction
operator|)
name|operator
decl_stmt|;
name|elementType
operator|=
name|udtf
operator|.
name|getElementType
argument_list|(
name|callBinding
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elementType
operator|=
literal|null
expr_stmt|;
block|}
name|RexNode
name|rexCall
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|bb
operator|.
name|retrieveCursors
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|RelColumnMapping
argument_list|>
name|columnMappings
init|=
name|getColumnMappings
argument_list|(
name|operator
argument_list|)
decl_stmt|;
name|LogicalTableFunctionScan
name|callRel
init|=
name|LogicalTableFunctionScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|inputs
argument_list|,
name|rexCall
argument_list|,
name|elementType
argument_list|,
name|validator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
argument_list|,
name|columnMappings
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|selectScope
init|=
operator|(
operator|(
name|DelegatingScope
operator|)
name|bb
operator|.
name|scope
argument_list|()
operator|)
operator|.
name|getParent
argument_list|()
decl_stmt|;
specifier|final
name|Blackboard
name|seekBb
init|=
name|createBlackboard
argument_list|(
name|selectScope
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|CorrelationUse
name|p
init|=
name|getCorrelationUse
argument_list|(
name|seekBb
argument_list|,
name|callRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
assert|assert
name|p
operator|.
name|r
operator|instanceof
name|LogicalTableFunctionScan
assert|;
name|callRel
operator|=
operator|(
name|LogicalTableFunctionScan
operator|)
name|p
operator|.
name|r
expr_stmt|;
block|}
name|bb
operator|.
name|setRoot
argument_list|(
name|callRel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|afterTableFunction
argument_list|(
name|bb
argument_list|,
name|call
argument_list|,
name|callRel
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|afterTableFunction
parameter_list|(
name|SqlToRelConverter
operator|.
name|Blackboard
name|bb
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|LogicalTableFunctionScan
name|callRel
parameter_list|)
block|{
block|}
specifier|private
name|void
name|convertTemporalTable
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlSnapshot
name|snapshot
init|=
operator|(
name|SqlSnapshot
operator|)
name|call
decl_stmt|;
specifier|final
name|RexNode
name|period
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|snapshot
operator|.
name|getPeriod
argument_list|()
argument_list|)
decl_stmt|;
comment|// convert inner query, could be a table name or a derived table
name|SqlNode
name|expr
init|=
name|snapshot
operator|.
name|getTableRef
argument_list|()
decl_stmt|;
name|convertFrom
argument_list|(
name|bb
argument_list|,
name|expr
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|snapshotRel
init|=
name|relBuilder
operator|.
name|push
argument_list|(
name|bb
operator|.
name|root
argument_list|()
argument_list|)
operator|.
name|snapshot
argument_list|(
name|period
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|snapshotRel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
annotation|@
name|Nullable
name|Set
argument_list|<
name|RelColumnMapping
argument_list|>
name|getColumnMappings
parameter_list|(
name|SqlOperator
name|op
parameter_list|)
block|{
name|SqlReturnTypeInference
name|rti
init|=
name|op
operator|.
name|getReturnTypeInference
argument_list|()
decl_stmt|;
if|if
condition|(
name|rti
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|rti
operator|instanceof
name|TableFunctionReturnTypeInference
condition|)
block|{
name|TableFunctionReturnTypeInference
name|tfrti
init|=
operator|(
name|TableFunctionReturnTypeInference
operator|)
name|rti
decl_stmt|;
return|return
name|tfrti
operator|.
name|getColumnMappings
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** Shuttle that replace outer {@link RexInputRef} with    * {@link RexFieldAccess}, and adjust {@code offset} to    * each inner {@link RexInputRef} in the lateral join    * condition. */
specifier|private
specifier|static
class|class
name|RexAccessShuttle
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|RexBuilder
name|builder
decl_stmt|;
specifier|private
specifier|final
name|RexCorrelVariable
name|rexCorrel
decl_stmt|;
specifier|private
specifier|final
name|BitSet
name|varCols
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|RexAccessShuttle
parameter_list|(
name|RexBuilder
name|builder
parameter_list|,
name|RexCorrelVariable
name|rexCorrel
parameter_list|)
block|{
name|this
operator|.
name|builder
operator|=
name|builder
expr_stmt|;
name|this
operator|.
name|rexCorrel
operator|=
name|rexCorrel
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|input
parameter_list|)
block|{
name|int
name|i
init|=
name|input
operator|.
name|getIndex
argument_list|()
operator|-
name|rexCorrel
operator|.
name|getType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|varCols
operator|.
name|set
argument_list|(
name|input
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|makeFieldAccess
argument_list|(
name|rexCorrel
argument_list|,
name|input
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
return|return
name|builder
operator|.
name|makeInputRef
argument_list|(
name|input
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
return|;
block|}
block|}
specifier|protected
name|RelNode
name|createJoin
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|RelNode
name|leftRel
parameter_list|,
name|RelNode
name|rightRel
parameter_list|,
name|RexNode
name|joinCond
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|)
block|{
assert|assert
name|joinCond
operator|!=
literal|null
assert|;
specifier|final
name|CorrelationUse
name|p
init|=
name|getCorrelationUse
argument_list|(
name|bb
argument_list|,
name|rightRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|RelNode
name|innerRel
init|=
name|p
operator|.
name|r
decl_stmt|;
name|ImmutableBitSet
name|requiredCols
init|=
name|p
operator|.
name|requiredColumns
decl_stmt|;
if|if
condition|(
operator|!
name|joinCond
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
specifier|final
name|RelFactories
operator|.
name|FilterFactory
name|factory
init|=
name|RelFactories
operator|.
name|DEFAULT_FILTER_FACTORY
decl_stmt|;
specifier|final
name|RexCorrelVariable
name|rexCorrel
init|=
operator|(
name|RexCorrelVariable
operator|)
name|rexBuilder
operator|.
name|makeCorrel
argument_list|(
name|leftRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|p
operator|.
name|id
argument_list|)
decl_stmt|;
specifier|final
name|RexAccessShuttle
name|shuttle
init|=
operator|new
name|RexAccessShuttle
argument_list|(
name|rexBuilder
argument_list|,
name|rexCorrel
argument_list|)
decl_stmt|;
comment|// Replace outer RexInputRef with RexFieldAccess,
comment|// and push lateral join predicate into inner child
specifier|final
name|RexNode
name|newCond
init|=
name|joinCond
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
name|innerRel
operator|=
name|factory
operator|.
name|createFilter
argument_list|(
name|p
operator|.
name|r
argument_list|,
name|newCond
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
expr_stmt|;
name|requiredCols
operator|=
name|ImmutableBitSet
operator|.
name|fromBitSet
argument_list|(
name|shuttle
operator|.
name|varCols
argument_list|)
operator|.
name|union
argument_list|(
name|p
operator|.
name|requiredColumns
argument_list|)
expr_stmt|;
block|}
return|return
name|LogicalCorrelate
operator|.
name|create
argument_list|(
name|leftRel
argument_list|,
name|innerRel
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|p
operator|.
name|id
argument_list|,
name|requiredCols
argument_list|,
name|joinType
argument_list|)
return|;
block|}
specifier|final
name|RelNode
name|node
init|=
name|relBuilder
operator|.
name|push
argument_list|(
name|leftRel
argument_list|)
operator|.
name|push
argument_list|(
name|rightRel
argument_list|)
operator|.
name|join
argument_list|(
name|joinType
argument_list|,
name|joinCond
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// If join conditions are pushed down, update the leaves.
if|if
condition|(
name|node
operator|instanceof
name|Project
condition|)
block|{
specifier|final
name|Join
name|newJoin
init|=
operator|(
name|Join
operator|)
name|node
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|leaves
operator|.
name|containsKey
argument_list|(
name|leftRel
argument_list|)
condition|)
block|{
name|leaves
operator|.
name|put
argument_list|(
name|newJoin
operator|.
name|getLeft
argument_list|()
argument_list|,
name|leaves
operator|.
name|get
argument_list|(
name|leftRel
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leaves
operator|.
name|containsKey
argument_list|(
name|rightRel
argument_list|)
condition|)
block|{
name|leaves
operator|.
name|put
argument_list|(
name|newJoin
operator|.
name|getRight
argument_list|()
argument_list|,
name|leaves
operator|.
name|get
argument_list|(
name|rightRel
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|node
return|;
block|}
specifier|private
annotation|@
name|Nullable
name|CorrelationUse
name|getCorrelationUse
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
specifier|final
name|RelNode
name|r0
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|correlatedVariables
init|=
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|r0
argument_list|)
decl_stmt|;
if|if
condition|(
name|correlatedVariables
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|requiredColumns
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|CorrelationId
argument_list|>
name|correlNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// All correlations must refer the same namespace since correlation
comment|// produces exactly one correlation source.
comment|// The same source might be referenced by different variables since
comment|// DeferredLookups are not de-duplicated at create time.
name|SqlValidatorNamespace
name|prevNs
init|=
literal|null
decl_stmt|;
for|for
control|(
name|CorrelationId
name|correlName
range|:
name|correlatedVariables
control|)
block|{
name|DeferredLookup
name|lookup
init|=
name|requireNonNull
argument_list|(
name|mapCorrelToDeferred
operator|.
name|get
argument_list|(
name|correlName
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"correlation variable is not found: "
operator|+
name|correlName
argument_list|)
decl_stmt|;
name|RexFieldAccess
name|fieldAccess
init|=
name|lookup
operator|.
name|getFieldAccess
argument_list|(
name|correlName
argument_list|)
decl_stmt|;
name|String
name|originalRelName
init|=
name|lookup
operator|.
name|getOriginalRelName
argument_list|()
decl_stmt|;
name|String
name|originalFieldName
init|=
name|fieldAccess
operator|.
name|getField
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|bb
operator|.
name|getValidator
argument_list|()
operator|.
name|getCatalogReader
argument_list|()
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
operator|.
name|ResolvedImpl
name|resolved
init|=
operator|new
name|SqlValidatorScope
operator|.
name|ResolvedImpl
argument_list|()
decl_stmt|;
name|lookup
operator|.
name|bb
operator|.
name|scope
argument_list|()
operator|.
name|resolve
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|originalRelName
argument_list|)
argument_list|,
name|nameMatcher
argument_list|,
literal|false
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
assert|assert
name|resolved
operator|.
name|count
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|SqlValidatorScope
operator|.
name|Resolve
name|resolve
init|=
name|resolved
operator|.
name|only
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|foundNs
init|=
name|resolve
operator|.
name|namespace
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|resolve
operator|.
name|rowType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|childNamespaceIndex
init|=
name|resolve
operator|.
name|path
operator|.
name|steps
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|i
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|ancestorScope
init|=
name|resolve
operator|.
name|scope
decl_stmt|;
name|boolean
name|correlInCurrentScope
init|=
name|bb
operator|.
name|scope
argument_list|()
operator|.
name|isWithin
argument_list|(
name|ancestorScope
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|correlInCurrentScope
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|prevNs
operator|==
literal|null
condition|)
block|{
name|prevNs
operator|=
name|foundNs
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|prevNs
operator|==
name|foundNs
operator|:
literal|"All correlation variables should resolve"
operator|+
literal|" to the same namespace."
operator|+
literal|" Prev ns="
operator|+
name|prevNs
operator|+
literal|", new ns="
operator|+
name|foundNs
assert|;
block|}
name|int
name|namespaceOffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|childNamespaceIndex
operator|>
literal|0
condition|)
block|{
comment|// If not the first child, need to figure out the width
comment|// of output types from all the preceding namespaces
assert|assert
name|ancestorScope
operator|instanceof
name|ListScope
assert|;
name|List
argument_list|<
name|SqlValidatorNamespace
argument_list|>
name|children
init|=
operator|(
operator|(
name|ListScope
operator|)
name|ancestorScope
operator|)
operator|.
name|getChildren
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childNamespaceIndex
condition|;
name|i
operator|++
control|)
block|{
name|SqlValidatorNamespace
name|child
init|=
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|namespaceOffset
operator|+=
name|child
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
block|}
name|RexFieldAccess
name|topLevelFieldAccess
init|=
name|fieldAccess
decl_stmt|;
while|while
condition|(
name|topLevelFieldAccess
operator|.
name|getReferenceExpr
argument_list|()
operator|instanceof
name|RexFieldAccess
condition|)
block|{
name|topLevelFieldAccess
operator|=
operator|(
name|RexFieldAccess
operator|)
name|topLevelFieldAccess
operator|.
name|getReferenceExpr
argument_list|()
expr_stmt|;
block|}
specifier|final
name|RelDataTypeField
name|field
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|topLevelFieldAccess
operator|.
name|getField
argument_list|()
operator|.
name|getIndex
argument_list|()
operator|-
name|namespaceOffset
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|namespaceOffset
operator|+
name|field
operator|.
name|getIndex
argument_list|()
decl_stmt|;
assert|assert
name|field
operator|.
name|getType
argument_list|()
operator|==
name|topLevelFieldAccess
operator|.
name|getField
argument_list|()
operator|.
name|getType
argument_list|()
assert|;
assert|assert
name|pos
operator|!=
operator|-
literal|1
assert|;
comment|// bb.root is an aggregate and only projects group by
comment|// keys.
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|exprProjection
init|=
name|bb
operator|.
name|mapRootRelToFieldProjection
operator|.
name|get
argument_list|(
name|bb
operator|.
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprProjection
operator|!=
literal|null
condition|)
block|{
comment|// sub-query can reference group by keys projected from
comment|// the root of the outer relation.
name|Integer
name|projection
init|=
name|exprProjection
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|projection
operator|!=
literal|null
condition|)
block|{
name|pos
operator|=
name|projection
expr_stmt|;
block|}
else|else
block|{
comment|// correl not grouped
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Identifier '"
operator|+
name|originalRelName
operator|+
literal|"."
operator|+
name|originalFieldName
operator|+
literal|"' is not a group expr"
argument_list|)
throw|;
block|}
block|}
name|requiredColumns
operator|.
name|set
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|correlNames
operator|.
name|add
argument_list|(
name|correlName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|correlNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// None of the correlating variables originated in this scope.
return|return
literal|null
return|;
block|}
name|RelNode
name|r
init|=
name|r0
decl_stmt|;
if|if
condition|(
name|correlNames
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// The same table was referenced more than once.
comment|// So we deduplicate.
name|r
operator|=
name|DeduplicateCorrelateVariables
operator|.
name|go
argument_list|(
name|rexBuilder
argument_list|,
name|correlNames
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Util
operator|.
name|skip
argument_list|(
name|correlNames
argument_list|)
argument_list|,
name|r0
argument_list|)
expr_stmt|;
comment|// Add new node to leaves.
name|leaves
operator|.
name|put
argument_list|(
name|r
argument_list|,
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|CorrelationUse
argument_list|(
name|correlNames
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|requiredColumns
operator|.
name|build
argument_list|()
argument_list|,
name|r
argument_list|)
return|;
block|}
comment|/**    * Determines whether a sub-query is non-correlated. Note that a    * non-correlated sub-query can contain correlated references, provided those    * references do not reference select statements that are parents of the    * sub-query.    *    * @param subq the sub-query    * @param bb   blackboard used while converting the sub-query, i.e., the    *             blackboard of the parent query of this sub-query    * @return true if the sub-query is non-correlated    */
specifier|private
name|boolean
name|isSubQueryNonCorrelated
parameter_list|(
name|RelNode
name|subq
parameter_list|,
name|Blackboard
name|bb
parameter_list|)
block|{
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|correlatedVariables
init|=
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|subq
argument_list|)
decl_stmt|;
for|for
control|(
name|CorrelationId
name|correlName
range|:
name|correlatedVariables
control|)
block|{
name|DeferredLookup
name|lookup
init|=
name|requireNonNull
argument_list|(
name|mapCorrelToDeferred
operator|.
name|get
argument_list|(
name|correlName
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"correlation variable is not found: "
operator|+
name|correlName
argument_list|)
decl_stmt|;
name|String
name|originalRelName
init|=
name|lookup
operator|.
name|getOriginalRelName
argument_list|()
decl_stmt|;
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|lookup
operator|.
name|bb
operator|.
name|scope
argument_list|()
operator|.
name|getValidator
argument_list|()
operator|.
name|getCatalogReader
argument_list|()
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
operator|.
name|ResolvedImpl
name|resolved
init|=
operator|new
name|SqlValidatorScope
operator|.
name|ResolvedImpl
argument_list|()
decl_stmt|;
name|lookup
operator|.
name|bb
operator|.
name|scope
argument_list|()
operator|.
name|resolve
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|originalRelName
argument_list|)
argument_list|,
name|nameMatcher
argument_list|,
literal|false
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
name|SqlValidatorScope
name|ancestorScope
init|=
name|resolved
operator|.
name|only
argument_list|()
operator|.
name|scope
decl_stmt|;
comment|// If the correlated reference is in a scope that's "above" the
comment|// sub-query, then this is a correlated sub-query.
name|SqlValidatorScope
name|parentScope
init|=
name|bb
operator|.
name|scope
decl_stmt|;
do|do
block|{
if|if
condition|(
name|ancestorScope
operator|==
name|parentScope
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|parentScope
operator|instanceof
name|DelegatingScope
condition|)
block|{
name|parentScope
operator|=
operator|(
operator|(
name|DelegatingScope
operator|)
name|parentScope
operator|)
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
do|while
condition|(
name|parentScope
operator|!=
literal|null
condition|)
do|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns a list of fields to be prefixed to each relational expression.    *    * @return List of system fields    */
specifier|protected
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|getSystemFields
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
specifier|private
name|void
name|convertJoin
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlJoin
name|join
parameter_list|)
block|{
name|SqlValidator
name|validator
init|=
name|validator
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|scope
init|=
name|validator
operator|.
name|getJoinScope
argument_list|(
name|join
argument_list|)
decl_stmt|;
specifier|final
name|Blackboard
name|fromBlackboard
init|=
name|createBlackboard
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|SqlNode
name|left
init|=
name|join
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|SqlNode
name|right
init|=
name|join
operator|.
name|getRight
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|leftScope
init|=
name|Util
operator|.
name|first
argument_list|(
name|validator
operator|.
name|getJoinScope
argument_list|(
name|left
argument_list|)
argument_list|,
operator|(
operator|(
name|DelegatingScope
operator|)
name|bb
operator|.
name|scope
argument_list|()
operator|)
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Blackboard
name|leftBlackboard
init|=
name|createBlackboard
argument_list|(
name|leftScope
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|rightScope
init|=
name|Util
operator|.
name|first
argument_list|(
name|validator
operator|.
name|getJoinScope
argument_list|(
name|right
argument_list|)
argument_list|,
operator|(
operator|(
name|DelegatingScope
operator|)
name|bb
operator|.
name|scope
argument_list|()
operator|)
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Blackboard
name|rightBlackboard
init|=
name|createBlackboard
argument_list|(
name|rightScope
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|convertFrom
argument_list|(
name|leftBlackboard
argument_list|,
name|left
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|leftRel
init|=
name|requireNonNull
argument_list|(
name|leftBlackboard
operator|.
name|root
argument_list|,
literal|"leftBlackboard.root"
argument_list|)
decl_stmt|;
name|convertFrom
argument_list|(
name|rightBlackboard
argument_list|,
name|right
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|tempRightRel
init|=
name|requireNonNull
argument_list|(
name|rightBlackboard
operator|.
name|root
argument_list|,
literal|"rightBlackboard.root"
argument_list|)
decl_stmt|;
specifier|final
name|JoinConditionType
name|conditionType
init|=
name|join
operator|.
name|getConditionType
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|condition
decl_stmt|;
specifier|final
name|RelNode
name|rightRel
decl_stmt|;
if|if
condition|(
name|join
operator|.
name|isNatural
argument_list|()
condition|)
block|{
name|condition
operator|=
name|convertNaturalCondition
argument_list|(
name|getNamespace
argument_list|(
name|left
argument_list|)
argument_list|,
name|getNamespace
argument_list|(
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|rightRel
operator|=
name|tempRightRel
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|conditionType
condition|)
block|{
case|case
name|NONE
case|:
name|condition
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|rightRel
operator|=
name|tempRightRel
expr_stmt|;
break|break;
case|case
name|USING
case|:
name|condition
operator|=
name|convertUsingCondition
argument_list|(
name|join
argument_list|,
name|getNamespace
argument_list|(
name|left
argument_list|)
argument_list|,
name|getNamespace
argument_list|(
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|rightRel
operator|=
name|tempRightRel
expr_stmt|;
break|break;
case|case
name|ON
case|:
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RelNode
argument_list|>
name|conditionAndRightNode
init|=
name|convertOnCondition
argument_list|(
name|fromBlackboard
argument_list|,
name|join
argument_list|,
name|leftRel
argument_list|,
name|tempRightRel
argument_list|)
decl_stmt|;
name|condition
operator|=
name|conditionAndRightNode
operator|.
name|left
expr_stmt|;
name|rightRel
operator|=
name|conditionAndRightNode
operator|.
name|right
expr_stmt|;
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|conditionType
argument_list|)
throw|;
block|}
block|}
specifier|final
name|RelNode
name|joinRel
init|=
name|createJoin
argument_list|(
name|fromBlackboard
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|condition
argument_list|,
name|convertJoinType
argument_list|(
name|join
operator|.
name|getJoinType
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|joinRel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|RexNode
name|convertNaturalCondition
parameter_list|(
name|SqlValidatorNamespace
name|leftNamespace
parameter_list|,
name|SqlValidatorNamespace
name|rightNamespace
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|columnList
init|=
name|SqlValidatorUtil
operator|.
name|deriveNaturalJoinColumnList
argument_list|(
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
argument_list|,
name|leftNamespace
operator|.
name|getRowType
argument_list|()
argument_list|,
name|rightNamespace
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|convertUsing
argument_list|(
name|leftNamespace
argument_list|,
name|rightNamespace
argument_list|,
name|columnList
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|convertUsingCondition
parameter_list|(
name|SqlJoin
name|join
parameter_list|,
name|SqlValidatorNamespace
name|leftNamespace
parameter_list|,
name|SqlValidatorNamespace
name|rightNamespace
parameter_list|)
block|{
specifier|final
name|SqlNodeList
name|list
init|=
operator|(
name|SqlNodeList
operator|)
name|requireNonNull
argument_list|(
name|join
operator|.
name|getCondition
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"getCondition for join "
operator|+
name|join
argument_list|)
decl_stmt|;
return|return
name|convertUsing
argument_list|(
name|leftNamespace
argument_list|,
name|rightNamespace
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|SqlIdentifier
operator|.
name|simpleNames
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * This currently does not expand correlated full outer joins correctly.  Replaying on the right    * side to correctly support left joins multiplicities.    *    *<blockquote><pre>    *   SELECT *    *   FROM t1    *   LEFT JOIN t2 ON    *    EXIST(SELECT t3.c3 WHERE t1.c1 = t3.c1 AND t2.c2 = t3.c2)    *    AND NOT (t2.t2 = 2)    *</pre></blockquote>    *    *<p>Given the de-correlated query produces:    *    *<blockquote><pre>    *  t1.c1 | t2.c2    *  ------+------    *    1   |  1    *    1   |  2    *</pre></blockquote>    *    *<p>If correlated query was replayed on the left side, then an extra rows would be emitted for    * every {code t1.c1 = 1}, where it failed to join to right side due to {code NOT(t2.t2 = 2)}.    * However, if the query is joined on the right, side multiplicity is maintained.    */
specifier|private
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RelNode
argument_list|>
name|convertOnCondition
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlJoin
name|join
parameter_list|,
name|RelNode
name|leftRel
parameter_list|,
name|RelNode
name|rightRel
parameter_list|)
block|{
name|SqlNode
name|condition
init|=
name|requireNonNull
argument_list|(
name|join
operator|.
name|getCondition
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"getCondition for join "
operator|+
name|join
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|leftRel
argument_list|,
name|rightRel
argument_list|)
argument_list|)
expr_stmt|;
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|condition
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|UNKNOWN_AS_FALSE
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|newRightRel
init|=
name|bb
operator|.
name|root
operator|==
literal|null
operator|||
name|bb
operator|.
name|registered
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
name|rightRel
else|:
name|bb
operator|.
name|reRegister
argument_list|(
name|rightRel
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|leftRel
argument_list|,
name|newRightRel
argument_list|)
argument_list|)
expr_stmt|;
name|RexNode
name|conditionExp
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|condition
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|conditionExp
argument_list|,
name|newRightRel
argument_list|)
return|;
block|}
comment|/**    * Returns an expression for matching columns of a USING clause or inferred    * from NATURAL JOIN. "a JOIN b USING (x, y)" becomes "a.x = b.x AND a.y =    * b.y". Returns null if the column list is empty.    *    * @param leftNamespace Namespace of left input to join    * @param rightNamespace Namespace of right input to join    * @param nameList List of column names to join on    * @return Expression to match columns from name list, or true if name list    * is empty    */
specifier|private
name|RexNode
name|convertUsing
parameter_list|(
name|SqlValidatorNamespace
name|leftNamespace
parameter_list|,
name|SqlValidatorNamespace
name|rightNamespace
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|)
block|{
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|nameList
control|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SqlValidatorNamespace
name|n
range|:
name|ImmutableList
operator|.
name|of
argument_list|(
name|leftNamespace
argument_list|,
name|rightNamespace
argument_list|)
control|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|n
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeField
name|field
init|=
name|nameMatcher
operator|.
name|field
argument_list|(
name|rowType
argument_list|,
name|name
argument_list|)
decl_stmt|;
assert|assert
name|field
operator|!=
literal|null
operator|:
literal|"field "
operator|+
name|name
operator|+
literal|" is not found in "
operator|+
name|rowType
operator|+
literal|" with "
operator|+
name|nameMatcher
assert|;
name|operands
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|offset
operator|+
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|operands
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|list
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|JoinRelType
name|convertJoinType
parameter_list|(
name|JoinType
name|joinType
parameter_list|)
block|{
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|COMMA
case|:
case|case
name|INNER
case|:
case|case
name|CROSS
case|:
return|return
name|JoinRelType
operator|.
name|INNER
return|;
case|case
name|FULL
case|:
return|return
name|JoinRelType
operator|.
name|FULL
return|;
case|case
name|LEFT
case|:
return|return
name|JoinRelType
operator|.
name|LEFT
return|;
case|case
name|RIGHT
case|:
return|return
name|JoinRelType
operator|.
name|RIGHT
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|joinType
argument_list|)
throw|;
block|}
block|}
comment|/**    * Converts the SELECT, GROUP BY and HAVING clauses of an aggregate query.    *    *<p>This method extracts SELECT, GROUP BY and HAVING clauses, and creates    * an {@link AggConverter}, then delegates to {@link #createAggImpl}.    * Derived class may override this method to change any of those clauses or    * specify a different {@link AggConverter}.    *    * @param bb            Scope within which to resolve identifiers    * @param select        Query    * @param orderExprList Additional expressions needed to implement ORDER BY    */
specifier|protected
name|void
name|convertAgg
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderExprList
parameter_list|)
block|{
assert|assert
name|bb
operator|.
name|root
operator|!=
literal|null
operator|:
literal|"precondition: child != null"
assert|;
name|SqlNodeList
name|groupList
init|=
name|select
operator|.
name|getGroup
argument_list|()
decl_stmt|;
name|SqlNodeList
name|selectList
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
name|SqlNode
name|having
init|=
name|select
operator|.
name|getHaving
argument_list|()
decl_stmt|;
specifier|final
name|AggConverter
name|aggConverter
init|=
operator|new
name|AggConverter
argument_list|(
name|bb
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|createAggImpl
argument_list|(
name|bb
argument_list|,
name|aggConverter
argument_list|,
name|selectList
argument_list|,
name|groupList
argument_list|,
name|having
argument_list|,
name|orderExprList
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|final
name|void
name|createAggImpl
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
specifier|final
name|AggConverter
name|aggConverter
parameter_list|,
name|SqlNodeList
name|selectList
parameter_list|,
annotation|@
name|Nullable
name|SqlNodeList
name|groupList
parameter_list|,
annotation|@
name|Nullable
name|SqlNode
name|having
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderExprList
parameter_list|)
block|{
comment|// Find aggregate functions in SELECT and HAVING clause
specifier|final
name|AggregateFinder
name|aggregateFinder
init|=
operator|new
name|AggregateFinder
argument_list|()
decl_stmt|;
name|selectList
operator|.
name|accept
argument_list|(
name|aggregateFinder
argument_list|)
expr_stmt|;
if|if
condition|(
name|having
operator|!=
literal|null
condition|)
block|{
name|having
operator|.
name|accept
argument_list|(
name|aggregateFinder
argument_list|)
expr_stmt|;
block|}
comment|// first replace the sub-queries inside the aggregates
comment|// because they will provide input rows to the aggregates.
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|aggregateFinder
operator|.
name|list
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
argument_list|)
expr_stmt|;
comment|// also replace sub-queries inside filters in the aggregates
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|aggregateFinder
operator|.
name|filterList
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
argument_list|)
expr_stmt|;
comment|// also replace sub-queries inside ordering spec in the aggregates
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|aggregateFinder
operator|.
name|orderList
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
argument_list|)
expr_stmt|;
comment|// If group-by clause is missing, pretend that it has zero elements.
if|if
condition|(
name|groupList
operator|==
literal|null
condition|)
block|{
name|groupList
operator|=
name|SqlNodeList
operator|.
name|EMPTY
expr_stmt|;
block|}
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|groupList
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
argument_list|)
expr_stmt|;
comment|// register the group exprs
comment|// build a map to remember the projections from the top scope to the
comment|// output of the current root.
comment|//
comment|// Calcite allows expressions, not just column references in
comment|// group by list. This is not SQL 2003 compliant, but hey.
specifier|final
name|AggregatingSelectScope
name|scope
init|=
name|requireNonNull
argument_list|(
name|aggConverter
operator|.
name|aggregatingSelectScope
argument_list|,
literal|"aggregatingSelectScope"
argument_list|)
decl_stmt|;
specifier|final
name|AggregatingSelectScope
operator|.
name|Resolved
name|r
init|=
name|scope
operator|.
name|resolved
operator|.
name|get
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|groupExpr
range|:
name|r
operator|.
name|groupExprList
control|)
block|{
name|aggConverter
operator|.
name|addGroupExpr
argument_list|(
name|groupExpr
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RexNode
name|havingExpr
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|bb
operator|.
name|agg
operator|==
literal|null
argument_list|,
literal|"already in agg mode"
argument_list|)
expr_stmt|;
name|bb
operator|.
name|agg
operator|=
name|aggConverter
expr_stmt|;
comment|// convert the select and having expressions, so that the
comment|// agg converter knows which aggregations are required
name|selectList
operator|.
name|accept
argument_list|(
name|aggConverter
argument_list|)
expr_stmt|;
comment|// Assert we don't have dangling items left in the stack
assert|assert
operator|!
name|aggConverter
operator|.
name|inOver
assert|;
for|for
control|(
name|SqlNode
name|expr
range|:
name|orderExprList
control|)
block|{
name|expr
operator|.
name|accept
argument_list|(
name|aggConverter
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|aggConverter
operator|.
name|inOver
assert|;
block|}
if|if
condition|(
name|having
operator|!=
literal|null
condition|)
block|{
name|having
operator|.
name|accept
argument_list|(
name|aggConverter
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|aggConverter
operator|.
name|inOver
assert|;
block|}
comment|// compute inputs to the aggregator
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
annotation|@
name|Nullable
name|String
argument_list|>
argument_list|>
name|preExprs
init|=
name|aggConverter
operator|.
name|getPreExprs
argument_list|()
decl_stmt|;
if|if
condition|(
name|preExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Special case for COUNT(*), where we can end up with no inputs
comment|// at all.  The rest of the system doesn't like 0-tuples, so we
comment|// select a dummy constant here.
specifier|final
name|RexNode
name|zero
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|preExprs
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|zero
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|inputRel
init|=
name|bb
operator|.
name|root
argument_list|()
decl_stmt|;
comment|// Project the expressions required by agg and having.
name|bb
operator|.
name|setRoot
argument_list|(
name|relBuilder
operator|.
name|push
argument_list|(
name|inputRel
argument_list|)
operator|.
name|projectNamed
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|preExprs
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|preExprs
argument_list|)
argument_list|,
literal|false
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|bb
operator|.
name|mapRootRelToFieldProjection
operator|.
name|put
argument_list|(
name|bb
operator|.
name|root
argument_list|()
argument_list|,
name|r
operator|.
name|groupExprProjection
argument_list|)
expr_stmt|;
comment|// REVIEW jvs 31-Oct-2007:  doesn't the declaration of
comment|// monotonicity here assume sort-based aggregation at
comment|// the physical level?
comment|// Tell bb which of group columns are sorted.
name|bb
operator|.
name|columnMonotonicities
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|SqlNode
name|groupItem
range|:
name|groupList
control|)
block|{
name|bb
operator|.
name|columnMonotonicities
operator|.
name|add
argument_list|(
name|bb
operator|.
name|scope
argument_list|()
operator|.
name|getMonotonicity
argument_list|(
name|groupItem
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Add the aggregator
name|bb
operator|.
name|setRoot
argument_list|(
name|createAggregate
argument_list|(
name|bb
argument_list|,
name|r
operator|.
name|groupSet
argument_list|,
name|r
operator|.
name|groupSets
operator|.
name|asList
argument_list|()
argument_list|,
name|aggConverter
operator|.
name|getAggCalls
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|bb
operator|.
name|mapRootRelToFieldProjection
operator|.
name|put
argument_list|(
name|bb
operator|.
name|root
argument_list|()
argument_list|,
name|r
operator|.
name|groupExprProjection
argument_list|)
expr_stmt|;
comment|// Replace sub-queries in having here and modify having to use
comment|// the replaced expressions
if|if
condition|(
name|having
operator|!=
literal|null
condition|)
block|{
name|SqlNode
name|newHaving
init|=
name|pushDownNotForIn
argument_list|(
name|bb
operator|.
name|scope
argument_list|()
argument_list|,
name|having
argument_list|)
decl_stmt|;
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|newHaving
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|UNKNOWN_AS_FALSE
argument_list|)
expr_stmt|;
name|havingExpr
operator|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|newHaving
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|havingExpr
operator|=
name|relBuilder
operator|.
name|literal
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Now convert the other sub-queries in the select list.
comment|// This needs to be done separately from the sub-query inside
comment|// any aggregate in the select list, and after the aggregate rel
comment|// is allocated.
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|selectList
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
argument_list|)
expr_stmt|;
comment|// Now sub-queries in the entire select list have been converted.
comment|// Convert the select expressions to get the final list to be
comment|// projected.
name|int
name|k
init|=
literal|0
decl_stmt|;
comment|// For select expressions, use the field names previously assigned
comment|// by the validator. If we derive afresh, we might generate names
comment|// like "EXPR$2" that don't match the names generated by the
comment|// validator. This is especially the case when there are system
comment|// fields; system fields appear in the relnode's rowtype but do not
comment|// (yet) appear in the validator type.
specifier|final
name|SelectScope
name|selectScope
init|=
name|SqlValidatorUtil
operator|.
name|getEnclosingSelectScope
argument_list|(
name|bb
operator|.
name|scope
argument_list|)
decl_stmt|;
assert|assert
name|selectScope
operator|!=
literal|null
assert|;
specifier|final
name|SqlValidatorNamespace
name|selectNamespace
init|=
name|getNamespaceOrNull
argument_list|(
name|selectScope
operator|.
name|getNode
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|selectNamespace
operator|!=
literal|null
operator|:
literal|"selectNamespace must not be null for "
operator|+
name|selectScope
assert|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|selectNamespace
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
name|int
name|sysFieldCount
init|=
name|selectList
operator|.
name|size
argument_list|()
operator|-
name|names
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|expr
range|:
name|selectList
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|expr
argument_list|)
argument_list|,
name|k
operator|<
name|sysFieldCount
condition|?
name|castNonNull
argument_list|(
name|validator
argument_list|()
operator|.
name|deriveAlias
argument_list|(
name|expr
argument_list|,
name|k
operator|++
argument_list|)
argument_list|)
else|:
name|names
operator|.
name|get
argument_list|(
name|k
operator|++
operator|-
name|sysFieldCount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SqlNode
name|expr
range|:
name|orderExprList
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|expr
argument_list|)
argument_list|,
name|castNonNull
argument_list|(
name|validator
argument_list|()
operator|.
name|deriveAlias
argument_list|(
name|expr
argument_list|,
name|k
operator|++
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|bb
operator|.
name|agg
operator|=
literal|null
expr_stmt|;
block|}
comment|// implement HAVING (we have already checked that it is non-trivial)
name|relBuilder
operator|.
name|push
argument_list|(
name|bb
operator|.
name|root
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|havingExpr
operator|!=
literal|null
condition|)
block|{
name|relBuilder
operator|.
name|filter
argument_list|(
name|havingExpr
argument_list|)
expr_stmt|;
block|}
comment|// implement the SELECT list
name|relBuilder
operator|.
name|project
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|projects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|projects
argument_list|)
argument_list|)
operator|.
name|rename
argument_list|(
name|Pair
operator|.
name|right
argument_list|(
name|projects
argument_list|)
argument_list|)
expr_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Tell bb which of group columns are sorted.
name|bb
operator|.
name|columnMonotonicities
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|SqlNode
name|selectItem
range|:
name|selectList
control|)
block|{
name|bb
operator|.
name|columnMonotonicities
operator|.
name|add
argument_list|(
name|bb
operator|.
name|scope
argument_list|()
operator|.
name|getMonotonicity
argument_list|(
name|selectItem
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates an Aggregate.    *    *<p>In case the aggregate rel changes the order in which it projects    * fields, the<code>groupExprProjection</code> parameter is provided, and    * the implementation of this method may modify it.    *    *<p>The<code>sortedCount</code> parameter is the number of expressions    * known to be monotonic. These expressions must be on the leading edge of    * the grouping keys. The default implementation of this method ignores this    * parameter.    *    * @param bb       Blackboard    * @param groupSet Bit set of ordinals of grouping columns    * @param groupSets Grouping sets    * @param aggCalls Array of calls to aggregate functions    * @return LogicalAggregate    */
specifier|protected
name|RelNode
name|createAggregate
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
parameter_list|,
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
parameter_list|)
block|{
name|relBuilder
operator|.
name|push
argument_list|(
name|bb
operator|.
name|root
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|RelBuilder
operator|.
name|GroupKey
name|groupKey
init|=
name|relBuilder
operator|.
name|groupKey
argument_list|(
name|groupSet
argument_list|,
name|groupSets
argument_list|)
decl_stmt|;
return|return
name|relBuilder
operator|.
name|aggregate
argument_list|(
name|groupKey
argument_list|,
name|aggCalls
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
name|RexDynamicParam
name|convertDynamicParam
parameter_list|(
specifier|final
name|SqlDynamicParam
name|dynamicParam
parameter_list|)
block|{
comment|// REVIEW jvs 8-Jan-2005:  dynamic params may be encountered out of
comment|// order.  Should probably cross-check with the count from the parser
comment|// at the end and make sure they all got filled in.  Why doesn't List
comment|// have a resize() method?!?  Make this a utility.
while|while
condition|(
name|dynamicParam
operator|.
name|getIndex
argument_list|()
operator|>=
name|dynamicParamSqlNodes
operator|.
name|size
argument_list|()
condition|)
block|{
name|dynamicParamSqlNodes
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|dynamicParamSqlNodes
operator|.
name|set
argument_list|(
name|dynamicParam
operator|.
name|getIndex
argument_list|()
argument_list|,
name|dynamicParam
argument_list|)
expr_stmt|;
return|return
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|getDynamicParamType
argument_list|(
name|dynamicParam
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|,
name|dynamicParam
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a list of collations required to implement the ORDER BY clause,    * if there is one. Populates<code>extraOrderExprs</code> with any sort    * expressions which are not in the select clause.    *    * @param bb              Scope within which to resolve identifiers    * @param select          Select clause. Never null, because we invent a    *                        dummy SELECT if ORDER BY is applied to a set    *                        operation (UNION etc.)    * @param orderList       Order by clause, may be null    * @param extraOrderExprs Sort expressions which are not in the select    *                        clause (output)    * @param collationList   List of collations (output)    */
specifier|protected
name|void
name|gatherOrderExprs
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
annotation|@
name|Nullable
name|SqlNodeList
name|orderList
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|extraOrderExprs
parameter_list|,
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|collationList
parameter_list|)
block|{
comment|// TODO:  add validation rules to SqlValidator also
assert|assert
name|bb
operator|.
name|root
operator|!=
literal|null
operator|:
literal|"precondition: child != null"
assert|;
assert|assert
name|select
operator|!=
literal|null
assert|;
if|if
condition|(
name|orderList
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|removeSortInSubQuery
argument_list|(
name|bb
operator|.
name|top
argument_list|)
condition|)
block|{
name|SqlNode
name|offset
init|=
name|select
operator|.
name|getOffset
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|offset
operator|==
literal|null
operator|||
operator|(
name|offset
operator|instanceof
name|SqlLiteral
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|SqlLiteral
operator|)
name|offset
operator|)
operator|.
name|bigDecimalValue
argument_list|()
argument_list|,
name|BigDecimal
operator|.
name|ZERO
argument_list|)
operator|)
operator|)
operator|&&
name|select
operator|.
name|getFetch
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return;
block|}
block|}
for|for
control|(
name|SqlNode
name|orderItem
range|:
name|orderList
control|)
block|{
name|collationList
operator|.
name|add
argument_list|(
name|convertOrderItem
argument_list|(
name|select
argument_list|,
name|orderItem
argument_list|,
name|extraOrderExprs
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|ASCENDING
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|RelFieldCollation
name|convertOrderItem
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlNode
name|orderItem
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|extraExprs
parameter_list|,
name|RelFieldCollation
operator|.
name|Direction
name|direction
parameter_list|,
name|RelFieldCollation
operator|.
name|NullDirection
name|nullDirection
parameter_list|)
block|{
assert|assert
name|select
operator|!=
literal|null
assert|;
comment|// Handle DESC keyword, e.g. 'select a, b from t order by a desc'.
switch|switch
condition|(
name|orderItem
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
return|return
name|convertOrderItem
argument_list|(
name|select
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|orderItem
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|extraExprs
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
argument_list|,
name|nullDirection
argument_list|)
return|;
case|case
name|NULLS_FIRST
case|:
return|return
name|convertOrderItem
argument_list|(
name|select
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|orderItem
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|extraExprs
argument_list|,
name|direction
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
argument_list|)
return|;
case|case
name|NULLS_LAST
case|:
return|return
name|convertOrderItem
argument_list|(
name|select
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|orderItem
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|extraExprs
argument_list|,
name|direction
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
argument_list|)
return|;
default|default:
break|break;
block|}
name|SqlNode
name|converted
init|=
name|validator
argument_list|()
operator|.
name|expandOrderExpr
argument_list|(
name|select
argument_list|,
name|orderItem
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nullDirection
condition|)
block|{
case|case
name|UNSPECIFIED
case|:
name|nullDirection
operator|=
name|validator
argument_list|()
operator|.
name|config
argument_list|()
operator|.
name|defaultNullCollation
argument_list|()
operator|.
name|last
argument_list|(
name|desc
argument_list|(
name|direction
argument_list|)
argument_list|)
condition|?
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
else|:
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|// Scan the select list and order exprs for an identical expression.
specifier|final
name|SelectScope
name|selectScope
init|=
name|requireNonNull
argument_list|(
name|validator
argument_list|()
operator|.
name|getRawSelectScope
argument_list|(
name|select
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"getRawSelectScope is not found for "
operator|+
name|select
argument_list|)
decl_stmt|;
name|int
name|ordinal
init|=
operator|-
literal|1
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|expandedSelectList
init|=
name|selectScope
operator|.
name|getExpandedSelectList
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|selectItem
range|:
name|requireNonNull
argument_list|(
name|expandedSelectList
argument_list|,
literal|"expandedSelectList"
argument_list|)
control|)
block|{
operator|++
name|ordinal
expr_stmt|;
if|if
condition|(
name|converted
operator|.
name|equalsDeep
argument_list|(
name|stripAs
argument_list|(
name|selectItem
argument_list|)
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
return|return
operator|new
name|RelFieldCollation
argument_list|(
name|ordinal
argument_list|,
name|direction
argument_list|,
name|nullDirection
argument_list|)
return|;
block|}
block|}
for|for
control|(
name|SqlNode
name|extraExpr
range|:
name|extraExprs
control|)
block|{
operator|++
name|ordinal
expr_stmt|;
if|if
condition|(
name|converted
operator|.
name|equalsDeep
argument_list|(
name|extraExpr
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
return|return
operator|new
name|RelFieldCollation
argument_list|(
name|ordinal
argument_list|,
name|direction
argument_list|,
name|nullDirection
argument_list|)
return|;
block|}
block|}
comment|// TODO:  handle collation sequence
comment|// TODO: flag expressions as non-standard
name|extraExprs
operator|.
name|add
argument_list|(
name|converted
argument_list|)
expr_stmt|;
return|return
operator|new
name|RelFieldCollation
argument_list|(
name|ordinal
operator|+
literal|1
argument_list|,
name|direction
argument_list|,
name|nullDirection
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|desc
parameter_list|(
name|RelFieldCollation
operator|.
name|Direction
name|direction
parameter_list|)
block|{
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|DESCENDING
case|:
case|case
name|STRICTLY_DESCENDING
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|protected
name|boolean
name|enableDecorrelation
parameter_list|()
block|{
comment|// disable sub-query decorrelation when needed.
comment|// e.g. if outer joins are not supported.
return|return
name|config
operator|.
name|isDecorrelationEnabled
argument_list|()
return|;
block|}
specifier|protected
name|RelNode
name|decorrelateQuery
parameter_list|(
name|RelNode
name|rootRel
parameter_list|)
block|{
return|return
name|RelDecorrelator
operator|.
name|decorrelateQuery
argument_list|(
name|rootRel
argument_list|,
name|relBuilder
argument_list|)
return|;
block|}
comment|/**    * Returns whether to trim unused fields as part of the conversion process.    *    * @return Whether to trim unused fields    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|boolean
name|isTrimUnusedFields
parameter_list|()
block|{
return|return
name|config
operator|.
name|isTrimUnusedFields
argument_list|()
return|;
block|}
comment|/**    * Recursively converts a query to a relational expression.    *    * @param query         Query    * @param top           Whether this query is the top-level query of the    *                      statement    * @param targetRowType Target row type, or null    * @return Relational expression    */
specifier|protected
name|RelRoot
name|convertQueryRecursive
parameter_list|(
name|SqlNode
name|query
parameter_list|,
name|boolean
name|top
parameter_list|,
annotation|@
name|Nullable
name|RelDataType
name|targetRowType
parameter_list|)
block|{
specifier|final
name|SqlKind
name|kind
init|=
name|query
operator|.
name|getKind
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|SELECT
case|:
return|return
name|RelRoot
operator|.
name|of
argument_list|(
name|convertSelect
argument_list|(
operator|(
name|SqlSelect
operator|)
name|query
argument_list|,
name|top
argument_list|)
argument_list|,
name|kind
argument_list|)
return|;
case|case
name|INSERT
case|:
return|return
name|RelRoot
operator|.
name|of
argument_list|(
name|convertInsert
argument_list|(
operator|(
name|SqlInsert
operator|)
name|query
argument_list|)
argument_list|,
name|kind
argument_list|)
return|;
case|case
name|DELETE
case|:
return|return
name|RelRoot
operator|.
name|of
argument_list|(
name|convertDelete
argument_list|(
operator|(
name|SqlDelete
operator|)
name|query
argument_list|)
argument_list|,
name|kind
argument_list|)
return|;
case|case
name|UPDATE
case|:
return|return
name|RelRoot
operator|.
name|of
argument_list|(
name|convertUpdate
argument_list|(
operator|(
name|SqlUpdate
operator|)
name|query
argument_list|)
argument_list|,
name|kind
argument_list|)
return|;
case|case
name|MERGE
case|:
return|return
name|RelRoot
operator|.
name|of
argument_list|(
name|convertMerge
argument_list|(
operator|(
name|SqlMerge
operator|)
name|query
argument_list|)
argument_list|,
name|kind
argument_list|)
return|;
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
return|return
name|RelRoot
operator|.
name|of
argument_list|(
name|convertSetOp
argument_list|(
operator|(
name|SqlCall
operator|)
name|query
argument_list|)
argument_list|,
name|kind
argument_list|)
return|;
case|case
name|WITH
case|:
return|return
name|convertWith
argument_list|(
operator|(
name|SqlWith
operator|)
name|query
argument_list|,
name|top
argument_list|)
return|;
case|case
name|VALUES
case|:
return|return
name|RelRoot
operator|.
name|of
argument_list|(
name|convertValues
argument_list|(
operator|(
name|SqlCall
operator|)
name|query
argument_list|,
name|targetRowType
argument_list|)
argument_list|,
name|kind
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"not a query: "
operator|+
name|query
argument_list|)
throw|;
block|}
block|}
comment|/**    * Converts a set operation (UNION, INTERSECT, MINUS) into relational    * expressions.    *    * @param call Call to set operator    * @return Relational expression    */
specifier|protected
name|RelNode
name|convertSetOp
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RelNode
name|left
init|=
name|convertQueryRecursive
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|right
init|=
name|convertQueryRecursive
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|UNION
case|:
return|return
name|LogicalUnion
operator|.
name|create
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|,
name|all
argument_list|(
name|call
argument_list|)
argument_list|)
return|;
case|case
name|INTERSECT
case|:
return|return
name|LogicalIntersect
operator|.
name|create
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|,
name|all
argument_list|(
name|call
argument_list|)
argument_list|)
return|;
case|case
name|EXCEPT
case|:
return|return
name|LogicalMinus
operator|.
name|create
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|,
name|all
argument_list|(
name|call
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|call
operator|.
name|getKind
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|all
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
return|return
operator|(
operator|(
name|SqlSetOperator
operator|)
name|call
operator|.
name|getOperator
argument_list|()
operator|)
operator|.
name|isAll
argument_list|()
return|;
block|}
specifier|protected
name|RelNode
name|convertInsert
parameter_list|(
name|SqlInsert
name|call
parameter_list|)
block|{
name|RelOptTable
name|targetTable
init|=
name|getTargetTable
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|targetRowType
init|=
name|validator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
assert|assert
name|targetRowType
operator|!=
literal|null
assert|;
name|RelNode
name|sourceRel
init|=
name|convertQueryRecursive
argument_list|(
name|call
operator|.
name|getSource
argument_list|()
argument_list|,
literal|true
argument_list|,
name|targetRowType
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
name|RelNode
name|massagedRel
init|=
name|convertColumnList
argument_list|(
name|call
argument_list|,
name|sourceRel
argument_list|)
decl_stmt|;
return|return
name|createModify
argument_list|(
name|targetTable
argument_list|,
name|massagedRel
argument_list|)
return|;
block|}
comment|/** Creates a relational expression to modify a table or modifiable view. */
specifier|private
name|RelNode
name|createModify
parameter_list|(
name|RelOptTable
name|targetTable
parameter_list|,
name|RelNode
name|source
parameter_list|)
block|{
specifier|final
name|ModifiableTable
name|modifiableTable
init|=
name|targetTable
operator|.
name|unwrap
argument_list|(
name|ModifiableTable
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifiableTable
operator|!=
literal|null
operator|&&
name|modifiableTable
operator|==
name|targetTable
operator|.
name|unwrap
argument_list|(
name|Table
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|modifiableTable
operator|.
name|toModificationRel
argument_list|(
name|cluster
argument_list|,
name|targetTable
argument_list|,
name|catalogReader
argument_list|,
name|source
argument_list|,
name|LogicalTableModify
operator|.
name|Operation
operator|.
name|INSERT
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|final
name|ModifiableView
name|modifiableView
init|=
name|targetTable
operator|.
name|unwrap
argument_list|(
name|ModifiableView
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifiableView
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Table
name|delegateTable
init|=
name|modifiableView
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|delegateRowType
init|=
name|delegateTable
operator|.
name|getRowType
argument_list|(
name|typeFactory
argument_list|)
decl_stmt|;
specifier|final
name|RelOptTable
name|delegateRelOptTable
init|=
name|RelOptTableImpl
operator|.
name|create
argument_list|(
literal|null
argument_list|,
name|delegateRowType
argument_list|,
name|delegateTable
argument_list|,
name|modifiableView
operator|.
name|getTablePath
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newSource
init|=
name|createSource
argument_list|(
name|targetTable
argument_list|,
name|source
argument_list|,
name|modifiableView
argument_list|,
name|delegateRowType
argument_list|)
decl_stmt|;
return|return
name|createModify
argument_list|(
name|delegateRelOptTable
argument_list|,
name|newSource
argument_list|)
return|;
block|}
return|return
name|LogicalTableModify
operator|.
name|create
argument_list|(
name|targetTable
argument_list|,
name|catalogReader
argument_list|,
name|source
argument_list|,
name|LogicalTableModify
operator|.
name|Operation
operator|.
name|INSERT
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Wraps a relational expression in the projects and filters implied by    * a {@link ModifiableView}.    *    *<p>The input relational expression is suitable for inserting into the view,    * and the returned relational expression is suitable for inserting into its    * delegate table.    *    *<p>In principle, the delegate table of a view might be another modifiable    * view, and if so, the process can be repeated. */
specifier|private
name|RelNode
name|createSource
parameter_list|(
name|RelOptTable
name|targetTable
parameter_list|,
name|RelNode
name|source
parameter_list|,
name|ModifiableView
name|modifiableView
parameter_list|,
name|RelDataType
name|delegateRowType
parameter_list|)
block|{
specifier|final
name|ImmutableIntList
name|mapping
init|=
name|modifiableView
operator|.
name|getColumnMapping
argument_list|()
decl_stmt|;
assert|assert
name|mapping
operator|.
name|size
argument_list|()
operator|==
name|targetTable
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
assert|;
comment|// For columns represented in the mapping, the expression is just a field
comment|// reference.
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|RexNode
argument_list|>
name|projectMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mapping
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|target
init|=
name|mapping
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|>=
literal|0
condition|)
block|{
name|projectMap
operator|.
name|put
argument_list|(
name|target
argument_list|,
name|RexInputRef
operator|.
name|of
argument_list|(
name|i
argument_list|,
name|source
operator|.
name|getRowType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// For columns that are not in the mapping, and have a constraint of the
comment|// form "column = value", the expression is the literal "value".
comment|//
comment|// If a column has multiple constraints, the extra ones will become a
comment|// filter.
specifier|final
name|RexNode
name|constraint
init|=
name|modifiableView
operator|.
name|getConstraint
argument_list|(
name|rexBuilder
argument_list|,
name|delegateRowType
argument_list|)
decl_stmt|;
name|RelOptUtil
operator|.
name|inferViewPredicates
argument_list|(
name|projectMap
argument_list|,
name|filters
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|delegateRowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|RexNode
name|node
init|=
name|projectMap
operator|.
name|get
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|node
operator|=
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|projects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|ensureType
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|node
argument_list|,
literal|false
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|source
argument_list|)
operator|.
name|projectNamed
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|projects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|projects
argument_list|)
argument_list|,
literal|false
argument_list|)
operator|.
name|filter
argument_list|(
name|filters
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
name|RelOptTable
operator|.
name|ToRelContext
name|createToRelContext
parameter_list|(
name|List
argument_list|<
name|RelHint
argument_list|>
name|hints
parameter_list|)
block|{
return|return
name|ViewExpanders
operator|.
name|toRelContext
argument_list|(
name|viewExpander
argument_list|,
name|cluster
argument_list|,
name|hints
argument_list|)
return|;
block|}
specifier|public
name|RelNode
name|toRel
parameter_list|(
specifier|final
name|RelOptTable
name|table
parameter_list|,
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|hints
parameter_list|)
block|{
specifier|final
name|RelNode
name|scan
init|=
name|table
operator|.
name|toRel
argument_list|(
name|createToRelContext
argument_list|(
name|hints
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|InitializerExpressionFactory
name|ief
init|=
name|table
operator|.
name|maybeUnwrap
argument_list|(
name|InitializerExpressionFactory
operator|.
name|class
argument_list|)
operator|.
name|orElse
argument_list|(
name|NullInitializerExpressionFactory
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|boolean
name|hasVirtualFields
init|=
name|table
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|f
lambda|->
name|ief
operator|.
name|generationStrategy
argument_list|(
name|table
argument_list|,
name|f
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|==
name|ColumnStrategy
operator|.
name|VIRTUAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasVirtualFields
condition|)
block|{
specifier|final
name|RexNode
name|sourceRef
init|=
name|rexBuilder
operator|.
name|makeRangeReference
argument_list|(
name|scan
argument_list|)
decl_stmt|;
specifier|final
name|Blackboard
name|bb
init|=
name|createInsertBlackboard
argument_list|(
name|table
argument_list|,
name|sourceRef
argument_list|,
name|table
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|f
range|:
name|table
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
specifier|final
name|ColumnStrategy
name|strategy
init|=
name|ief
operator|.
name|generationStrategy
argument_list|(
name|table
argument_list|,
name|f
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|strategy
condition|)
block|{
case|case
name|VIRTUAL
case|:
name|list
operator|.
name|add
argument_list|(
name|ief
operator|.
name|newColumnDefaultValue
argument_list|(
name|table
argument_list|,
name|f
operator|.
name|getIndex
argument_list|()
argument_list|,
name|bb
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|list
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|scan
argument_list|,
name|RelOptTableImpl
operator|.
name|realOrdinal
argument_list|(
name|table
argument_list|,
name|f
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|relBuilder
operator|.
name|push
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|list
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|project
init|=
name|relBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
name|BiFunction
argument_list|<
name|InitializerContext
argument_list|,
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|postConversionHook
init|=
name|ief
operator|.
name|postExpressionConversionHook
argument_list|()
decl_stmt|;
if|if
condition|(
name|postConversionHook
operator|!=
literal|null
condition|)
block|{
return|return
name|postConversionHook
operator|.
name|apply
argument_list|(
name|bb
argument_list|,
name|project
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|project
return|;
block|}
block|}
return|return
name|scan
return|;
block|}
specifier|protected
name|RelOptTable
name|getTargetTable
parameter_list|(
name|SqlNode
name|call
parameter_list|)
block|{
specifier|final
name|SqlValidatorNamespace
name|targetNs
init|=
name|getNamespace
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|SqlValidatorNamespace
name|namespace
decl_stmt|;
if|if
condition|(
name|targetNs
operator|.
name|isWrapperFor
argument_list|(
name|SqlValidatorImpl
operator|.
name|DmlNamespace
operator|.
name|class
argument_list|)
condition|)
block|{
name|namespace
operator|=
name|targetNs
operator|.
name|unwrap
argument_list|(
name|SqlValidatorImpl
operator|.
name|DmlNamespace
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|namespace
operator|=
name|targetNs
operator|.
name|resolve
argument_list|()
expr_stmt|;
block|}
name|RelOptTable
name|table
init|=
name|SqlValidatorUtil
operator|.
name|getRelOptTable
argument_list|(
name|namespace
argument_list|,
name|catalogReader
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|requireNonNull
argument_list|(
name|table
argument_list|,
literal|"no table found for "
operator|+
name|call
argument_list|)
return|;
block|}
comment|/**    * Creates a source for an INSERT statement.    *    *<p>If the column list is not specified, source expressions match target    * columns in order.    *    *<p>If the column list is specified, Source expressions are mapped to    * target columns by name via targetColumnList, and may not cover the entire    * target table. So, we'll make up a full row, using a combination of    * default values and the source expressions provided.    *    * @param call      Insert expression    * @param source Source relational expression    * @return Converted INSERT statement    */
specifier|protected
name|RelNode
name|convertColumnList
parameter_list|(
specifier|final
name|SqlInsert
name|call
parameter_list|,
name|RelNode
name|source
parameter_list|)
block|{
name|RelDataType
name|sourceRowType
init|=
name|source
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|sourceRef
init|=
name|rexBuilder
operator|.
name|makeRangeReference
argument_list|(
name|sourceRowType
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|targetColumnNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|columnExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|collectInsertTargets
argument_list|(
name|call
argument_list|,
name|sourceRef
argument_list|,
name|targetColumnNames
argument_list|,
name|columnExprs
argument_list|)
expr_stmt|;
specifier|final
name|RelOptTable
name|targetTable
init|=
name|getTargetTable
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|targetRowType
init|=
name|RelOptTableImpl
operator|.
name|realRowType
argument_list|(
name|targetTable
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|targetFields
init|=
name|targetRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
annotation|@
name|Nullable
name|RexNode
argument_list|>
name|sourceExps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|Collections
operator|.
name|nCopies
argument_list|(
name|targetFields
operator|.
name|size
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
annotation|@
name|Nullable
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|Collections
operator|.
name|nCopies
argument_list|(
name|targetFields
operator|.
name|size
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|InitializerExpressionFactory
name|initializerFactory
init|=
name|getInitializerFactory
argument_list|(
name|getNamespace
argument_list|(
name|call
argument_list|)
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
comment|// Walk the name list and place the associated value in the
comment|// expression list according to the ordinal value returned from
comment|// the table construct, leaving nulls in the list for columns
comment|// that are not referenced.
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|p
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|targetColumnNames
argument_list|,
name|columnExprs
argument_list|)
control|)
block|{
name|RelDataTypeField
name|field
init|=
name|nameMatcher
operator|.
name|field
argument_list|(
name|targetRowType
argument_list|,
name|p
operator|.
name|left
argument_list|)
decl_stmt|;
assert|assert
name|field
operator|!=
literal|null
operator|:
literal|"column "
operator|+
name|p
operator|.
name|left
operator|+
literal|" not found"
assert|;
name|sourceExps
operator|.
name|set
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|,
name|p
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
comment|// Lazily create a blackboard that contains all non-generated columns.
specifier|final
name|Supplier
argument_list|<
name|Blackboard
argument_list|>
name|bb
init|=
parameter_list|()
lambda|->
name|createInsertBlackboard
argument_list|(
name|targetTable
argument_list|,
name|sourceRef
argument_list|,
name|targetColumnNames
argument_list|)
decl_stmt|;
comment|// Walk the expression list and get default values for any columns
comment|// that were not supplied in the statement. Get field names too.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|targetFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|String
name|fieldName
init|=
name|field
operator|.
name|getName
argument_list|()
decl_stmt|;
name|fieldNames
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
name|RexNode
name|sourceExpression
init|=
name|sourceExps
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceExpression
operator|==
literal|null
operator|||
name|sourceExpression
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|DEFAULT
condition|)
block|{
name|sourceExpression
operator|=
name|initializerFactory
operator|.
name|newColumnDefaultValue
argument_list|(
name|targetTable
argument_list|,
name|i
argument_list|,
name|bb
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
comment|// bare nulls are dangerous in the wrong hands
name|sourceExpression
operator|=
name|castNullLiteralIfNeeded
argument_list|(
name|sourceExpression
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|sourceExps
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|sourceExpression
argument_list|)
expr_stmt|;
block|}
block|}
comment|// sourceExps should not contain nulls (see the loop above)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"assignment.type.incompatible"
argument_list|)
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonNullExprs
init|=
name|sourceExps
decl_stmt|;
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|source
argument_list|)
operator|.
name|projectNamed
argument_list|(
name|nonNullExprs
argument_list|,
name|fieldNames
argument_list|,
literal|false
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Creates a blackboard for translating the expressions of generated columns    * in an INSERT statement. */
specifier|private
name|Blackboard
name|createInsertBlackboard
parameter_list|(
name|RelOptTable
name|targetTable
parameter_list|,
name|RexNode
name|sourceRef
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|targetColumnNames
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|nameToNodeMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
comment|// Assign expressions for non-generated columns.
specifier|final
name|List
argument_list|<
name|ColumnStrategy
argument_list|>
name|strategies
init|=
name|targetTable
operator|.
name|getColumnStrategies
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|targetFields
init|=
name|targetTable
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|targetColumnName
range|:
name|targetColumnNames
control|)
block|{
specifier|final
name|int
name|i
init|=
name|targetFields
operator|.
name|indexOf
argument_list|(
name|targetColumnName
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|strategies
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|STORED
case|:
case|case
name|VIRTUAL
case|:
break|break;
default|default:
name|nameToNodeMap
operator|.
name|put
argument_list|(
name|targetColumnName
argument_list|,
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|sourceRef
argument_list|,
name|j
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|createBlackboard
argument_list|(
literal|null
argument_list|,
name|nameToNodeMap
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|InitializerExpressionFactory
name|getInitializerFactory
parameter_list|(
annotation|@
name|Nullable
name|SqlValidatorTable
name|validatorTable
parameter_list|)
block|{
comment|// We might unwrap a null instead of a InitializerExpressionFactory.
specifier|final
name|Table
name|table
init|=
name|unwrap
argument_list|(
name|validatorTable
argument_list|,
name|Table
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|!=
literal|null
condition|)
block|{
name|InitializerExpressionFactory
name|f
init|=
name|unwrap
argument_list|(
name|table
argument_list|,
name|InitializerExpressionFactory
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
return|return
name|f
return|;
block|}
block|}
return|return
name|NullInitializerExpressionFactory
operator|.
name|INSTANCE
return|;
block|}
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|Object
parameter_list|>
annotation|@
name|Nullable
name|T
name|unwrap
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Wrapper
condition|)
block|{
return|return
operator|(
operator|(
name|Wrapper
operator|)
name|o
operator|)
operator|.
name|unwrap
argument_list|(
name|clazz
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|RexNode
name|castNullLiteralIfNeeded
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|RexLiteral
operator|.
name|isNullLiteral
argument_list|(
name|node
argument_list|)
condition|)
block|{
return|return
name|node
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/**    * Given an INSERT statement, collects the list of names to be populated and    * the expressions to put in them.    *    * @param call              Insert statement    * @param sourceRef         Expression representing a row from the source    *                          relational expression    * @param targetColumnNames List of target column names, to be populated    * @param columnExprs       List of expressions, to be populated    */
specifier|protected
name|void
name|collectInsertTargets
parameter_list|(
name|SqlInsert
name|call
parameter_list|,
specifier|final
name|RexNode
name|sourceRef
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|targetColumnNames
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|columnExprs
parameter_list|)
block|{
specifier|final
name|RelOptTable
name|targetTable
init|=
name|getTargetTable
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|tableRowType
init|=
name|targetTable
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|SqlNodeList
name|targetColumnList
init|=
name|call
operator|.
name|getTargetColumnList
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetColumnList
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|validator
argument_list|()
operator|.
name|config
argument_list|()
operator|.
name|sqlConformance
argument_list|()
operator|.
name|isInsertSubsetColumnsAllowed
argument_list|()
condition|)
block|{
specifier|final
name|RelDataType
name|targetRowType
init|=
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|tableRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|sourceRef
operator|.
name|getType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|targetColumnNames
operator|.
name|addAll
argument_list|(
name|targetRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|targetColumnNames
operator|.
name|addAll
argument_list|(
name|tableRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetColumnList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|targetColumnList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RelDataTypeField
name|field
init|=
name|SqlValidatorUtil
operator|.
name|getTargetField
argument_list|(
name|tableRowType
argument_list|,
name|typeFactory
argument_list|,
name|id
argument_list|,
name|catalogReader
argument_list|,
name|targetTable
argument_list|)
decl_stmt|;
assert|assert
name|field
operator|!=
literal|null
operator|:
literal|"column "
operator|+
name|id
operator|.
name|toString
argument_list|()
operator|+
literal|" not found"
assert|;
name|targetColumnNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|Blackboard
name|bb
init|=
name|createInsertBlackboard
argument_list|(
name|targetTable
argument_list|,
name|sourceRef
argument_list|,
name|targetColumnNames
argument_list|)
decl_stmt|;
comment|// Next, assign expressions for generated columns.
specifier|final
name|List
argument_list|<
name|ColumnStrategy
argument_list|>
name|strategies
init|=
name|targetTable
operator|.
name|getColumnStrategies
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|columnName
range|:
name|targetColumnNames
control|)
block|{
specifier|final
name|int
name|i
init|=
name|tableRowType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|indexOf
argument_list|(
name|columnName
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|expr
decl_stmt|;
switch|switch
condition|(
name|strategies
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|STORED
case|:
specifier|final
name|InitializerExpressionFactory
name|f
init|=
name|targetTable
operator|.
name|maybeUnwrap
argument_list|(
name|InitializerExpressionFactory
operator|.
name|class
argument_list|)
operator|.
name|orElse
argument_list|(
name|NullInitializerExpressionFactory
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|expr
operator|=
name|f
operator|.
name|newColumnDefaultValue
argument_list|(
name|targetTable
argument_list|,
name|i
argument_list|,
name|bb
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIRTUAL
case|:
name|expr
operator|=
literal|null
expr_stmt|;
break|break;
default|default:
name|expr
operator|=
name|requireNonNull
argument_list|(
name|bb
operator|.
name|nameToNodeMap
argument_list|,
literal|"nameToNodeMap"
argument_list|)
operator|.
name|get
argument_list|(
name|columnName
argument_list|)
expr_stmt|;
block|}
comment|// expr is nullable, however, all the nulls will be removed in the loop below
name|columnExprs
operator|.
name|add
argument_list|(
name|castNonNull
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Remove virtual columns from the list.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetColumnNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|columnExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
condition|)
block|{
name|columnExprs
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|targetColumnNames
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|RelNode
name|convertDelete
parameter_list|(
name|SqlDelete
name|call
parameter_list|)
block|{
name|RelOptTable
name|targetTable
init|=
name|getTargetTable
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|RelNode
name|sourceRel
init|=
name|convertSelect
argument_list|(
name|requireNonNull
argument_list|(
name|call
operator|.
name|getSourceSelect
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"sourceSelect for "
operator|+
name|call
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|LogicalTableModify
operator|.
name|create
argument_list|(
name|targetTable
argument_list|,
name|catalogReader
argument_list|,
name|sourceRel
argument_list|,
name|LogicalTableModify
operator|.
name|Operation
operator|.
name|DELETE
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|convertUpdate
parameter_list|(
name|SqlUpdate
name|call
parameter_list|)
block|{
specifier|final
name|SqlValidatorScope
name|scope
init|=
name|validator
argument_list|()
operator|.
name|getWhereScope
argument_list|(
name|requireNonNull
argument_list|(
name|call
operator|.
name|getSourceSelect
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"sourceSelect for "
operator|+
name|call
argument_list|)
argument_list|)
decl_stmt|;
name|Blackboard
name|bb
init|=
name|createBlackboard
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|call
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
argument_list|)
expr_stmt|;
name|RelOptTable
name|targetTable
init|=
name|getTargetTable
argument_list|(
name|call
argument_list|)
decl_stmt|;
comment|// convert update column list from SqlIdentifier to String
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|targetColumnNameList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|targetRowType
init|=
name|targetTable
operator|.
name|getRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|call
operator|.
name|getTargetColumnList
argument_list|()
control|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|node
decl_stmt|;
name|RelDataTypeField
name|field
init|=
name|SqlValidatorUtil
operator|.
name|getTargetField
argument_list|(
name|targetRowType
argument_list|,
name|typeFactory
argument_list|,
name|id
argument_list|,
name|catalogReader
argument_list|,
name|targetTable
argument_list|)
decl_stmt|;
assert|assert
name|field
operator|!=
literal|null
operator|:
literal|"column "
operator|+
name|id
operator|.
name|toString
argument_list|()
operator|+
literal|" not found"
assert|;
name|targetColumnNameList
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|sourceRel
init|=
name|convertSelect
argument_list|(
name|requireNonNull
argument_list|(
name|call
operator|.
name|getSourceSelect
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"sourceSelect for "
operator|+
name|call
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|sourceRel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|rexNodeSourceExpressionListBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|n
range|:
name|call
operator|.
name|getSourceExpressionList
argument_list|()
control|)
block|{
name|RexNode
name|rn
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|rexNodeSourceExpressionListBuilder
operator|.
name|add
argument_list|(
name|rn
argument_list|)
expr_stmt|;
block|}
return|return
name|LogicalTableModify
operator|.
name|create
argument_list|(
name|targetTable
argument_list|,
name|catalogReader
argument_list|,
name|sourceRel
argument_list|,
name|LogicalTableModify
operator|.
name|Operation
operator|.
name|UPDATE
argument_list|,
name|targetColumnNameList
argument_list|,
name|rexNodeSourceExpressionListBuilder
operator|.
name|build
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|convertMerge
parameter_list|(
name|SqlMerge
name|call
parameter_list|)
block|{
name|RelOptTable
name|targetTable
init|=
name|getTargetTable
argument_list|(
name|call
argument_list|)
decl_stmt|;
comment|// convert update column list from SqlIdentifier to String
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|targetColumnNameList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|targetRowType
init|=
name|targetTable
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|SqlUpdate
name|updateCall
init|=
name|call
operator|.
name|getUpdateCall
argument_list|()
decl_stmt|;
if|if
condition|(
name|updateCall
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SqlNode
name|targetColumn
range|:
name|updateCall
operator|.
name|getTargetColumnList
argument_list|()
control|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|targetColumn
decl_stmt|;
name|RelDataTypeField
name|field
init|=
name|SqlValidatorUtil
operator|.
name|getTargetField
argument_list|(
name|targetRowType
argument_list|,
name|typeFactory
argument_list|,
name|id
argument_list|,
name|catalogReader
argument_list|,
name|targetTable
argument_list|)
decl_stmt|;
assert|assert
name|field
operator|!=
literal|null
operator|:
literal|"column "
operator|+
name|id
operator|.
name|toString
argument_list|()
operator|+
literal|" not found"
assert|;
name|targetColumnNameList
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// replace the projection of the source select with a
comment|// projection that contains the following:
comment|// 1) the expressions corresponding to the new insert row (if there is
comment|//    an insert)
comment|// 2) all columns from the target table (if there is an update)
comment|// 3) the set expressions in the update call (if there is an update)
comment|// first, convert the merge's source select to construct the columns
comment|// from the target table and the set expressions in the update call
name|RelNode
name|mergeSourceRel
init|=
name|convertSelect
argument_list|(
name|requireNonNull
argument_list|(
name|call
operator|.
name|getSourceSelect
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"sourceSelect for "
operator|+
name|call
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// then, convert the insert statement so we can get the insert
comment|// values expressions
name|SqlInsert
name|insertCall
init|=
name|call
operator|.
name|getInsertCall
argument_list|()
decl_stmt|;
name|int
name|nLevel1Exprs
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|level1InsertExprs
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|level2InsertExprs
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|insertCall
operator|!=
literal|null
condition|)
block|{
name|RelNode
name|insertRel
init|=
name|convertInsert
argument_list|(
name|insertCall
argument_list|)
decl_stmt|;
comment|// if there are 2 level of projections in the insert source, combine
comment|// them into a single project; level1 refers to the topmost project;
comment|// the level1 projection contains references to the level2
comment|// expressions, except in the case where no target expression was
comment|// provided, in which case, the expression is the default value for
comment|// the column; or if the expressions directly map to the source
comment|// table
name|level1InsertExprs
operator|=
operator|(
operator|(
name|LogicalProject
operator|)
name|insertRel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getProjects
argument_list|()
expr_stmt|;
if|if
condition|(
name|insertRel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|LogicalProject
condition|)
block|{
name|level2InsertExprs
operator|=
operator|(
operator|(
name|LogicalProject
operator|)
name|insertRel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getProjects
argument_list|()
expr_stmt|;
block|}
name|nLevel1Exprs
operator|=
name|level1InsertExprs
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|LogicalJoin
name|join
init|=
operator|(
name|LogicalJoin
operator|)
name|mergeSourceRel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|nSourceFields
init|=
name|join
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level1Idx
init|=
literal|0
init|;
name|level1Idx
operator|<
name|nLevel1Exprs
condition|;
name|level1Idx
operator|++
control|)
block|{
name|requireNonNull
argument_list|(
name|level1InsertExprs
argument_list|,
literal|"level1InsertExprs"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|level2InsertExprs
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|level1InsertExprs
operator|.
name|get
argument_list|(
name|level1Idx
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|int
name|level2Idx
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|level1InsertExprs
operator|.
name|get
argument_list|(
name|level1Idx
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|projects
operator|.
name|add
argument_list|(
name|level2InsertExprs
operator|.
name|get
argument_list|(
name|level2Idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|projects
operator|.
name|add
argument_list|(
name|level1InsertExprs
operator|.
name|get
argument_list|(
name|level1Idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|updateCall
operator|!=
literal|null
condition|)
block|{
specifier|final
name|LogicalProject
name|project
init|=
operator|(
name|LogicalProject
operator|)
name|mergeSourceRel
decl_stmt|;
name|projects
operator|.
name|addAll
argument_list|(
name|Util
operator|.
name|skip
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
name|nSourceFields
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|push
argument_list|(
name|join
argument_list|)
operator|.
name|project
argument_list|(
name|projects
argument_list|)
expr_stmt|;
return|return
name|LogicalTableModify
operator|.
name|create
argument_list|(
name|targetTable
argument_list|,
name|catalogReader
argument_list|,
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|LogicalTableModify
operator|.
name|Operation
operator|.
name|MERGE
argument_list|,
name|targetColumnNameList
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Converts an identifier into an expression in a given scope. For example,    * the "empno" in "select empno from emp join dept" becomes "emp.empno".    */
specifier|private
name|RexNode
name|convertIdentifier
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlIdentifier
name|identifier
parameter_list|)
block|{
comment|// first check for reserved identifiers like CURRENT_USER
specifier|final
name|SqlCall
name|call
init|=
name|bb
operator|.
name|getValidator
argument_list|()
operator|.
name|makeNullaryCall
argument_list|(
name|identifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
return|return
name|bb
operator|.
name|convertExpression
argument_list|(
name|call
argument_list|)
return|;
block|}
name|String
name|pv
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|bb
operator|.
name|isPatternVarRef
operator|&&
name|identifier
operator|.
name|names
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|pv
operator|=
name|identifier
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlQualified
name|qualified
decl_stmt|;
if|if
condition|(
name|bb
operator|.
name|scope
operator|!=
literal|null
condition|)
block|{
name|qualified
operator|=
name|bb
operator|.
name|scope
operator|.
name|fullyQualify
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qualified
operator|=
name|SqlQualified
operator|.
name|create
argument_list|(
literal|null
argument_list|,
literal|1
argument_list|,
literal|null
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
annotation|@
name|Nullable
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|e0
init|=
name|requireNonNull
argument_list|(
name|bb
operator|.
name|lookupExp
argument_list|(
name|qualified
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"no expression found for "
operator|+
name|qualified
argument_list|)
decl_stmt|;
name|RexNode
name|e
init|=
name|e0
operator|.
name|left
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|qualified
operator|.
name|suffix
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|==
name|e0
operator|.
name|left
operator|&&
name|e0
operator|.
name|right
operator|!=
literal|null
condition|)
block|{
name|Integer
name|i
init|=
name|requireNonNull
argument_list|(
name|e0
operator|.
name|right
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"e0.right.get(name) produced null for "
operator|+
name|name
argument_list|)
decl_stmt|;
name|e
operator|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|boolean
name|caseSensitive
init|=
literal|true
decl_stmt|;
comment|// name already fully-qualified
if|if
condition|(
name|identifier
operator|.
name|isStar
argument_list|()
operator|&&
name|bb
operator|.
name|scope
operator|instanceof
name|MatchRecognizeScope
condition|)
block|{
name|e
operator|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|e
argument_list|,
name|name
argument_list|,
name|caseSensitive
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|e
operator|instanceof
name|RexInputRef
condition|)
block|{
comment|// adjust the type to account for nulls introduced by outer joins
name|e
operator|=
name|adjustInputRef
argument_list|(
name|bb
argument_list|,
operator|(
name|RexInputRef
operator|)
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|!=
literal|null
condition|)
block|{
name|e
operator|=
name|RexPatternFieldRef
operator|.
name|of
argument_list|(
name|pv
argument_list|,
operator|(
name|RexInputRef
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e0
operator|.
name|left
operator|instanceof
name|RexCorrelVariable
condition|)
block|{
assert|assert
name|e
operator|instanceof
name|RexFieldAccess
assert|;
specifier|final
name|RexNode
name|prev
init|=
name|bb
operator|.
name|mapCorrelateToRex
operator|.
name|put
argument_list|(
operator|(
operator|(
name|RexCorrelVariable
operator|)
name|e0
operator|.
name|left
operator|)
operator|.
name|id
argument_list|,
operator|(
name|RexFieldAccess
operator|)
name|e
argument_list|)
decl_stmt|;
assert|assert
name|prev
operator|==
literal|null
assert|;
block|}
return|return
name|e
return|;
block|}
comment|/**    * Adjusts the type of a reference to an input field to account for nulls    * introduced by outer joins; and adjusts the offset to match the physical    * implementation.    *    * @param bb       Blackboard    * @param inputRef Input ref    * @return Adjusted input ref    */
specifier|protected
name|RexNode
name|adjustInputRef
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|RelDataTypeField
name|field
init|=
name|bb
operator|.
name|getRootField
argument_list|(
name|inputRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|equalSansNullability
argument_list|(
name|typeFactory
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|inputRef
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
return|return
name|inputRef
return|;
block|}
comment|/**    * Converts a row constructor into a relational expression.    *    * @param bb             Blackboard    * @param rowConstructor Row constructor expression    * @return Relational expression which returns a single row.    */
specifier|private
name|RelNode
name|convertRowConstructor
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlCall
name|rowConstructor
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|isRowConstructor
argument_list|(
name|rowConstructor
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|rowConstructor
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
return|return
name|convertMultisets
argument_list|(
name|operands
argument_list|,
name|bb
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|convertCursor
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SubQuery
name|subQuery
parameter_list|)
block|{
specifier|final
name|SqlCall
name|cursorCall
init|=
operator|(
name|SqlCall
operator|)
name|subQuery
operator|.
name|node
decl_stmt|;
assert|assert
name|cursorCall
operator|.
name|operandCount
argument_list|()
operator|==
literal|1
assert|;
name|SqlNode
name|query
init|=
name|cursorCall
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|converted
init|=
name|convertQuery
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
operator|.
name|rel
decl_stmt|;
name|int
name|iCursor
init|=
name|bb
operator|.
name|cursors
operator|.
name|size
argument_list|()
decl_stmt|;
name|bb
operator|.
name|cursors
operator|.
name|add
argument_list|(
name|converted
argument_list|)
expr_stmt|;
name|subQuery
operator|.
name|expr
operator|=
operator|new
name|RexInputRef
argument_list|(
name|iCursor
argument_list|,
name|converted
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|converted
return|;
block|}
specifier|private
name|RelNode
name|convertMultisets
parameter_list|(
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
parameter_list|,
name|Blackboard
name|bb
parameter_list|)
block|{
comment|// NOTE: Wael 2/04/05: this implementation is not the most efficient in
comment|// terms of planning since it generates XOs that can be reduced.
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|joinList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|lastList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|operand
init|=
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|operand
operator|instanceof
name|SqlCall
operator|)
condition|)
block|{
name|lastList
operator|.
name|add
argument_list|(
name|operand
argument_list|)
expr_stmt|;
continue|continue;
block|}
specifier|final
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|operand
decl_stmt|;
specifier|final
name|RelNode
name|input
decl_stmt|;
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|MULTISET_VALUE_CONSTRUCTOR
case|:
case|case
name|ARRAY_VALUE_CONSTRUCTOR
case|:
specifier|final
name|SqlNodeList
name|list
init|=
operator|new
name|SqlNodeList
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|,
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
name|CollectNamespace
name|nss
init|=
name|getNamespaceOrNull
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|Blackboard
name|usedBb
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|nss
condition|)
block|{
name|usedBb
operator|=
name|createBlackboard
argument_list|(
name|nss
operator|.
name|getScope
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usedBb
operator|=
name|createBlackboard
argument_list|(
operator|new
name|ListScope
argument_list|(
name|bb
operator|.
name|scope
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|SqlNode
name|getNode
parameter_list|()
block|{
return|return
name|call
return|;
block|}
block|}
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|RelDataType
name|multisetType
init|=
name|validator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|validator
argument_list|()
operator|.
name|setValidatedNodeType
argument_list|(
name|list
argument_list|,
name|requireNonNull
argument_list|(
name|multisetType
operator|.
name|getComponentType
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"componentType for multisetType "
operator|+
name|multisetType
argument_list|)
argument_list|)
expr_stmt|;
name|input
operator|=
name|convertQueryOrInList
argument_list|(
name|usedBb
argument_list|,
name|list
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULTISET_QUERY_CONSTRUCTOR
case|:
case|case
name|ARRAY_QUERY_CONSTRUCTOR
case|:
case|case
name|MAP_QUERY_CONSTRUCTOR
case|:
specifier|final
name|RelRoot
name|root
init|=
name|convertQuery
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|input
operator|=
name|root
operator|.
name|rel
expr_stmt|;
break|break;
default|default:
name|lastList
operator|.
name|add
argument_list|(
name|operand
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lastList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|joinList
operator|.
name|add
argument_list|(
name|lastList
argument_list|)
expr_stmt|;
block|}
name|lastList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
specifier|final
name|SqlTypeName
name|typeName
init|=
name|requireNonNull
argument_list|(
name|validator
argument_list|,
literal|"validator"
argument_list|)
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|Collect
operator|.
name|create
argument_list|(
name|requireNonNull
argument_list|(
name|input
argument_list|,
literal|"input"
argument_list|)
argument_list|,
name|typeName
argument_list|,
name|castNonNull
argument_list|(
name|validator
argument_list|()
operator|.
name|deriveAlias
argument_list|(
name|call
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|joinList
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|joinList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|joinList
operator|.
name|add
argument_list|(
name|lastList
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|joinList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|o
init|=
name|joinList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|List
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|SqlNode
argument_list|>
name|projectList
init|=
operator|(
name|List
argument_list|<
name|SqlNode
argument_list|>
operator|)
name|o
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|selectList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|projectList
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|SqlNode
name|operand
init|=
name|projectList
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
comment|// REVIEW angel 5-June-2005: Use deriveAliasFromOrdinal
comment|// instead of deriveAlias to match field names from
comment|// SqlRowOperator. Otherwise, get error   Type
comment|// 'RecordType(INTEGER EMPNO)' has no field 'EXPR$0' when
comment|// doing   select * from unnest(     select multiset[empno]
comment|// from sales.emps);
name|fieldNameList
operator|.
name|add
argument_list|(
name|SqlUtil
operator|.
name|deriveAliasFromOrdinal
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|push
argument_list|(
name|LogicalValues
operator|.
name|createOneRow
argument_list|(
name|cluster
argument_list|)
argument_list|)
operator|.
name|projectNamed
argument_list|(
name|selectList
argument_list|,
name|fieldNameList
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|joinList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|RelNode
name|ret
init|=
operator|(
name|RelNode
operator|)
name|joinList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|joinList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelNode
name|relNode
init|=
operator|(
name|RelNode
operator|)
name|joinList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ret
operator|=
name|RelFactories
operator|.
name|DEFAULT_JOIN_FACTORY
operator|.
name|createJoin
argument_list|(
name|ret
argument_list|,
name|relNode
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|private
name|void
name|convertSelectList
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderList
parameter_list|)
block|{
name|SqlNodeList
name|selectList
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
name|selectList
operator|=
name|validator
argument_list|()
operator|.
name|expandStar
argument_list|(
name|selectList
argument_list|,
name|select
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|replaceSubQueries
argument_list|(
name|bb
argument_list|,
name|selectList
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|aliases
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Project any system fields. (Must be done before regular select items,
comment|// because offsets may be affected.)
specifier|final
name|List
argument_list|<
name|SqlMonotonicity
argument_list|>
name|columnMonotonicityList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|extraSelectItems
argument_list|(
name|bb
argument_list|,
name|select
argument_list|,
name|exprs
argument_list|,
name|fieldNames
argument_list|,
name|aliases
argument_list|,
name|columnMonotonicityList
argument_list|)
expr_stmt|;
comment|// Project select clause.
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|SqlNode
name|expr
range|:
name|selectList
control|)
block|{
operator|++
name|i
expr_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|deriveAlias
argument_list|(
name|expr
argument_list|,
name|aliases
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Project extra fields for sorting.
for|for
control|(
name|SqlNode
name|expr
range|:
name|orderList
control|)
block|{
operator|++
name|i
expr_stmt|;
name|SqlNode
name|expr2
init|=
name|validator
argument_list|()
operator|.
name|expandOrderExpr
argument_list|(
name|select
argument_list|,
name|expr
argument_list|)
decl_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|expr2
argument_list|)
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|deriveAlias
argument_list|(
name|expr
argument_list|,
name|aliases
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fieldNames
operator|=
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|fieldNames
argument_list|,
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|bb
operator|.
name|root
argument_list|()
argument_list|)
operator|.
name|projectNamed
argument_list|(
name|exprs
argument_list|,
name|fieldNames
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
assert|assert
name|bb
operator|.
name|columnMonotonicities
operator|.
name|isEmpty
argument_list|()
assert|;
name|bb
operator|.
name|columnMonotonicities
operator|.
name|addAll
argument_list|(
name|columnMonotonicityList
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|selectItem
range|:
name|selectList
control|)
block|{
name|bb
operator|.
name|columnMonotonicities
operator|.
name|add
argument_list|(
name|selectItem
operator|.
name|getMonotonicity
argument_list|(
name|bb
operator|.
name|scope
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Adds extra select items. The default implementation adds nothing; derived    * classes may add columns to exprList, nameList, aliasList and    * columnMonotonicityList.    *    * @param bb                     Blackboard    * @param select                 Select statement being translated    * @param exprList               List of expressions in select clause    * @param nameList               List of names, one per column    * @param aliasList              Collection of aliases that have been used    *                               already    * @param columnMonotonicityList List of monotonicity, one per column    */
specifier|protected
name|void
name|extraSelectItems
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|aliasList
parameter_list|,
name|List
argument_list|<
name|SqlMonotonicity
argument_list|>
name|columnMonotonicityList
parameter_list|)
block|{
block|}
specifier|private
name|String
name|deriveAlias
parameter_list|(
specifier|final
name|SqlNode
name|node
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|,
specifier|final
name|int
name|ordinal
parameter_list|)
block|{
name|String
name|alias
init|=
name|validator
argument_list|()
operator|.
name|deriveAlias
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
operator|||
name|aliases
operator|.
name|contains
argument_list|(
name|alias
argument_list|)
condition|)
block|{
specifier|final
name|String
name|aliasBase
init|=
name|Util
operator|.
name|first
argument_list|(
name|alias
argument_list|,
name|SqlUtil
operator|.
name|GENERATED_EXPR_ALIAS_PREFIX
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
block|{
name|alias
operator|=
name|aliasBase
operator|+
name|j
expr_stmt|;
if|if
condition|(
operator|!
name|aliases
operator|.
name|contains
argument_list|(
name|alias
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
name|aliases
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
return|return
name|alias
return|;
block|}
comment|/**    * Converts a WITH sub-query into a relational expression.    */
specifier|public
name|RelRoot
name|convertWith
parameter_list|(
name|SqlWith
name|with
parameter_list|,
name|boolean
name|top
parameter_list|)
block|{
return|return
name|convertQuery
argument_list|(
name|with
operator|.
name|body
argument_list|,
literal|false
argument_list|,
name|top
argument_list|)
return|;
block|}
comment|/**    * Converts a SELECT statement's parse tree into a relational expression.    */
specifier|public
name|RelNode
name|convertValues
parameter_list|(
name|SqlCall
name|values
parameter_list|,
annotation|@
name|Nullable
name|RelDataType
name|targetRowType
parameter_list|)
block|{
specifier|final
name|SqlValidatorScope
name|scope
init|=
name|validator
argument_list|()
operator|.
name|getOverScope
argument_list|(
name|values
argument_list|)
decl_stmt|;
assert|assert
name|scope
operator|!=
literal|null
assert|;
specifier|final
name|Blackboard
name|bb
init|=
name|createBlackboard
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|convertValuesImpl
argument_list|(
name|bb
argument_list|,
name|values
argument_list|,
name|targetRowType
argument_list|)
expr_stmt|;
return|return
name|bb
operator|.
name|root
argument_list|()
return|;
block|}
comment|/**    * Converts a values clause (as in "INSERT INTO T(x,y) VALUES (1,2)") into a    * relational expression.    *    * @param bb            Blackboard    * @param values        Call to SQL VALUES operator    * @param targetRowType Target row type    */
specifier|private
name|void
name|convertValuesImpl
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlCall
name|values
parameter_list|,
annotation|@
name|Nullable
name|RelDataType
name|targetRowType
parameter_list|)
block|{
comment|// Attempt direct conversion to LogicalValues; if that fails, deal with
comment|// fancy stuff like sub-queries below.
name|RelNode
name|valuesRel
init|=
name|convertRowValues
argument_list|(
name|bb
argument_list|,
name|values
argument_list|,
name|values
operator|.
name|getOperandList
argument_list|()
argument_list|,
literal|true
argument_list|,
name|targetRowType
argument_list|)
decl_stmt|;
if|if
condition|(
name|valuesRel
operator|!=
literal|null
condition|)
block|{
name|bb
operator|.
name|setRoot
argument_list|(
name|valuesRel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|SqlNode
name|rowConstructor1
range|:
name|values
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|SqlCall
name|rowConstructor
init|=
operator|(
name|SqlCall
operator|)
name|rowConstructor1
decl_stmt|;
name|Blackboard
name|tmpBb
init|=
name|createBlackboard
argument_list|(
name|bb
operator|.
name|scope
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|replaceSubQueries
argument_list|(
name|tmpBb
argument_list|,
name|rowConstructor
argument_list|,
name|RelOptUtil
operator|.
name|Logic
operator|.
name|TRUE_FALSE_UNKNOWN
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|exps
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|SqlNode
argument_list|>
name|operand
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|rowConstructor
operator|.
name|getOperandList
argument_list|()
argument_list|)
control|)
block|{
name|exps
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|tmpBb
operator|.
name|convertExpression
argument_list|(
name|operand
operator|.
name|e
argument_list|)
argument_list|,
name|castNonNull
argument_list|(
name|validator
argument_list|()
operator|.
name|deriveAlias
argument_list|(
name|operand
operator|.
name|e
argument_list|,
name|operand
operator|.
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|in
init|=
operator|(
literal|null
operator|==
name|tmpBb
operator|.
name|root
operator|)
condition|?
name|LogicalValues
operator|.
name|createOneRow
argument_list|(
name|cluster
argument_list|)
else|:
name|tmpBb
operator|.
name|root
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|in
argument_list|)
operator|.
name|project
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|exps
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|exps
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bb
operator|.
name|setRoot
argument_list|(
name|relBuilder
operator|.
name|union
argument_list|(
literal|true
argument_list|,
name|values
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * A Tuple to remember all calls to Blackboard.register    */
specifier|private
specifier|static
class|class
name|RegisterArgs
block|{
specifier|final
name|RelNode
name|rel
decl_stmt|;
specifier|final
name|JoinRelType
name|joinType
decl_stmt|;
specifier|final
annotation|@
name|Nullable
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftKeys
decl_stmt|;
name|RegisterArgs
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftKeys
parameter_list|)
block|{
name|this
operator|.
name|rel
operator|=
name|rel
expr_stmt|;
name|this
operator|.
name|joinType
operator|=
name|joinType
expr_stmt|;
name|this
operator|.
name|leftKeys
operator|=
name|leftKeys
expr_stmt|;
block|}
block|}
comment|/** Function that can convert a sort specification (expression, direction    * and null direction) to a target format.    *    * @param<R> Target format, such as {@link RexFieldCollation} or    * {@link RexNode}    */
annotation|@
name|FunctionalInterface
interface|interface
name|SortExpressionConverter
parameter_list|<
name|R
parameter_list|>
block|{
name|R
name|convert
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|RelFieldCollation
operator|.
name|Direction
name|direction
parameter_list|,
name|RelFieldCollation
operator|.
name|NullDirection
name|nullDirection
parameter_list|)
function_decl|;
block|}
comment|/**    * Workspace for translating an individual SELECT statement (or sub-SELECT).    */
specifier|protected
class|class
name|Blackboard
implements|implements
name|SqlRexContext
implements|,
name|SqlVisitor
argument_list|<
name|RexNode
argument_list|>
implements|,
name|InitializerContext
block|{
comment|/**      * Collection of {@link RelNode} objects which correspond to a SELECT      * statement.      */
specifier|public
specifier|final
annotation|@
name|Nullable
name|SqlValidatorScope
name|scope
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|nameToNodeMap
decl_stmt|;
specifier|public
annotation|@
name|Nullable
name|RelNode
name|root
decl_stmt|;
specifier|private
annotation|@
name|Nullable
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|CorrelationId
argument_list|,
name|RexFieldAccess
argument_list|>
name|mapCorrelateToRex
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|RegisterArgs
argument_list|>
name|registered
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|isPatternVarRef
init|=
literal|false
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|cursors
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * List of<code>IN</code> and<code>EXISTS</code> nodes inside this      *<code>SELECT</code> statement (but not inside sub-queries).      */
specifier|private
specifier|final
name|List
argument_list|<
name|SubQuery
argument_list|>
name|subQueryList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * Workspace for building aggregates.      */
annotation|@
name|Nullable
name|AggConverter
name|agg
decl_stmt|;
comment|/**      * When converting window aggregate, we need to know if the window is      * guaranteed to be non-empty.      */
annotation|@
name|Nullable
name|SqlWindow
name|window
decl_stmt|;
comment|/**      * Project the groupby expressions out of the root of this sub-select.      * Sub-queries can reference group by expressions projected from the      * "right" to the sub-query.      */
specifier|private
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|mapRootRelToFieldProjection
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|SqlMonotonicity
argument_list|>
name|columnMonotonicities
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|systemFieldList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|top
decl_stmt|;
specifier|private
specifier|final
name|InitializerExpressionFactory
name|initializerExpressionFactory
init|=
operator|new
name|NullInitializerExpressionFactory
argument_list|()
decl_stmt|;
comment|/**      * Creates a Blackboard.      *      * @param scope         Name-resolution scope for expressions validated      *                      within this query. Can be null if this Blackboard is      *                      for a leaf node, say      * @param nameToNodeMap Map which translates the expression to map a      *                      given parameter into, if translating expressions;      *                      null otherwise      * @param top           Whether this is the root of the query      */
specifier|protected
name|Blackboard
parameter_list|(
annotation|@
name|Nullable
name|SqlValidatorScope
name|scope
parameter_list|,
annotation|@
name|Nullable
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|nameToNodeMap
parameter_list|,
name|boolean
name|top
parameter_list|)
block|{
name|this
operator|.
name|scope
operator|=
name|scope
expr_stmt|;
name|this
operator|.
name|nameToNodeMap
operator|=
name|nameToNodeMap
expr_stmt|;
name|this
operator|.
name|top
operator|=
name|top
expr_stmt|;
block|}
specifier|public
name|RelNode
name|root
parameter_list|()
block|{
return|return
name|requireNonNull
argument_list|(
name|root
argument_list|,
literal|"root"
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|scope
parameter_list|()
block|{
return|return
name|requireNonNull
argument_list|(
name|scope
argument_list|,
literal|"scope"
argument_list|)
return|;
block|}
specifier|public
name|void
name|setPatternVarRef
parameter_list|(
name|boolean
name|isVarRef
parameter_list|)
block|{
name|this
operator|.
name|isPatternVarRef
operator|=
name|isVarRef
expr_stmt|;
block|}
specifier|public
name|RexNode
name|register
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|)
block|{
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|joinType
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Registers a relational expression.      *      * @param rel               Relational expression      * @param joinType          Join type      * @param leftKeys LHS of IN clause, or null for expressions      *                          other than IN      * @return Expression with which to refer to the row (or partial row)      * coming from this relational expression's side of the join      */
specifier|public
name|RexNode
name|register
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftKeys
parameter_list|)
block|{
name|requireNonNull
argument_list|(
name|joinType
argument_list|,
literal|"joinType"
argument_list|)
expr_stmt|;
name|registered
operator|.
name|add
argument_list|(
operator|new
name|RegisterArgs
argument_list|(
name|rel
argument_list|,
name|joinType
argument_list|,
name|leftKeys
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
assert|assert
name|leftKeys
operator|==
literal|null
operator|:
literal|"leftKeys must be null"
assert|;
name|setRoot
argument_list|(
name|rel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|rexBuilder
operator|.
name|makeRangeReference
argument_list|(
name|root
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|final
name|RexNode
name|joinCond
decl_stmt|;
specifier|final
name|int
name|origLeftInputCount
init|=
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftKeys
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|newLeftInputExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|origLeftInputCount
condition|;
name|i
operator|++
control|)
block|{
name|newLeftInputExprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|root
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|leftJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|leftKey
range|:
name|leftKeys
control|)
block|{
name|int
name|index
init|=
name|newLeftInputExprs
operator|.
name|indexOf
argument_list|(
name|leftKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|joinType
operator|==
name|JoinRelType
operator|.
name|LEFT
condition|)
block|{
name|index
operator|=
name|newLeftInputExprs
operator|.
name|size
argument_list|()
expr_stmt|;
name|newLeftInputExprs
operator|.
name|add
argument_list|(
name|leftKey
argument_list|)
expr_stmt|;
block|}
name|leftJoinKeys
operator|.
name|add
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|newLeftInput
init|=
name|relBuilder
operator|.
name|push
argument_list|(
name|root
argument_list|()
argument_list|)
operator|.
name|project
argument_list|(
name|newLeftInputExprs
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// maintain the group by mapping in the new LogicalProject
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|currentProjection
init|=
name|mapRootRelToFieldProjection
operator|.
name|get
argument_list|(
name|root
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentProjection
operator|!=
literal|null
condition|)
block|{
name|mapRootRelToFieldProjection
operator|.
name|put
argument_list|(
name|newLeftInput
argument_list|,
name|currentProjection
argument_list|)
expr_stmt|;
block|}
name|setRoot
argument_list|(
name|newLeftInput
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// right fields appear after the LHS fields.
specifier|final
name|int
name|rightOffset
init|=
name|root
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
name|newLeftInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
init|=
name|Util
operator|.
name|range
argument_list|(
name|rightOffset
argument_list|,
name|rightOffset
operator|+
name|leftKeys
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|joinCond
operator|=
name|RelOptUtil
operator|.
name|createEquiJoinCondition
argument_list|(
name|newLeftInput
argument_list|,
name|leftJoinKeys
argument_list|,
name|rel
argument_list|,
name|rightKeys
argument_list|,
name|rexBuilder
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|joinCond
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|int
name|leftFieldCount
init|=
name|root
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|join
init|=
name|createJoin
argument_list|(
name|this
argument_list|,
name|root
argument_list|()
argument_list|,
name|rel
argument_list|,
name|joinCond
argument_list|,
name|joinType
argument_list|)
decl_stmt|;
name|setRoot
argument_list|(
name|join
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftKeys
operator|!=
literal|null
operator|&&
name|joinType
operator|==
name|JoinRelType
operator|.
name|LEFT
condition|)
block|{
specifier|final
name|int
name|leftKeyCount
init|=
name|leftKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|rightFieldLength
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
name|leftKeyCount
operator|==
name|rightFieldLength
operator|-
literal|1
assert|;
specifier|final
name|int
name|rexRangeRefLength
init|=
name|leftKeyCount
operator|+
name|rightFieldLength
decl_stmt|;
name|RelDataType
name|returnType
init|=
name|typeFactory
operator|.
name|createStructType
argument_list|(
operator|new
name|AbstractList
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|join
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|origLeftInputCount
operator|+
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rexRangeRefLength
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeRangeReference
argument_list|(
name|returnType
argument_list|,
name|origLeftInputCount
argument_list|,
literal|false
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|rexBuilder
operator|.
name|makeRangeReference
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|leftFieldCount
argument_list|,
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**      * Re-register the {@code registered} with given root node and      * return the new root node.      *      * @param root The given root, never leaf      *      * @return new root after the registration      */
specifier|public
name|RelNode
name|reRegister
parameter_list|(
name|RelNode
name|root
parameter_list|)
block|{
name|setRoot
argument_list|(
name|root
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RegisterArgs
argument_list|>
name|registerCopy
init|=
name|registered
decl_stmt|;
name|registered
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|RegisterArgs
name|reg
range|:
name|registerCopy
control|)
block|{
name|register
argument_list|(
name|reg
operator|.
name|rel
argument_list|,
name|reg
operator|.
name|joinType
argument_list|,
name|reg
operator|.
name|leftKeys
argument_list|)
expr_stmt|;
block|}
return|return
name|requireNonNull
argument_list|(
name|this
operator|.
name|root
argument_list|,
literal|"root"
argument_list|)
return|;
block|}
comment|/**      * Sets a new root relational expression, as the translation process      * backs its way further up the tree.      *      * @param root New root relational expression      * @param leaf Whether the relational expression is a leaf, that is,      *             derived from an atomic relational expression such as a table      *             name in the from clause, or the projection on top of a      *             select-sub-query. In particular, relational expressions      *             derived from JOIN operators are not leaves, but set      *             expressions are.      */
specifier|public
name|void
name|setRoot
parameter_list|(
name|RelNode
name|root
parameter_list|,
name|boolean
name|leaf
parameter_list|)
block|{
name|setRoot
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|root
argument_list|)
argument_list|,
name|root
argument_list|,
name|root
operator|instanceof
name|LogicalJoin
argument_list|)
expr_stmt|;
if|if
condition|(
name|leaf
condition|)
block|{
name|leaves
operator|.
name|put
argument_list|(
name|root
argument_list|,
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|columnMonotonicities
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|setRoot
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|,
annotation|@
name|Nullable
name|RelNode
name|root
parameter_list|,
name|boolean
name|hasSystemFields
parameter_list|)
block|{
name|this
operator|.
name|inputs
operator|=
name|inputs
expr_stmt|;
name|this
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|this
operator|.
name|systemFieldList
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|hasSystemFields
condition|)
block|{
name|this
operator|.
name|systemFieldList
operator|.
name|addAll
argument_list|(
name|getSystemFields
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Notifies this Blackboard that the root just set using      * {@link #setRoot(RelNode, boolean)} was derived using dataset      * substitution.      *      *<p>The default implementation is not interested in such      * notifications, and does nothing.      *      * @param datasetName Dataset name      */
specifier|public
name|void
name|setDataset
parameter_list|(
annotation|@
name|Nullable
name|String
name|datasetName
parameter_list|)
block|{
block|}
name|void
name|setRoot
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|)
block|{
name|setRoot
argument_list|(
name|inputs
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns an expression with which to reference a from-list item.      *      * @param qualified the alias of the from item      * @return a {@link RexFieldAccess} or {@link RexRangeRef}, or null if      * not found      */
annotation|@
name|Nullable
name|Pair
argument_list|<
name|RexNode
argument_list|,
annotation|@
name|Nullable
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|lookupExp
parameter_list|(
name|SqlQualified
name|qualified
parameter_list|)
block|{
if|if
condition|(
name|nameToNodeMap
operator|!=
literal|null
operator|&&
name|qualified
operator|.
name|prefixLength
operator|==
literal|1
condition|)
block|{
name|RexNode
name|node
init|=
name|nameToNodeMap
operator|.
name|get
argument_list|(
name|qualified
operator|.
name|identifier
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unknown identifier '"
operator|+
name|qualified
operator|.
name|identifier
operator|+
literal|"' encountered while expanding expression"
argument_list|)
throw|;
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|node
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|scope
argument_list|()
operator|.
name|getValidator
argument_list|()
operator|.
name|getCatalogReader
argument_list|()
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
operator|.
name|ResolvedImpl
name|resolved
init|=
operator|new
name|SqlValidatorScope
operator|.
name|ResolvedImpl
argument_list|()
decl_stmt|;
name|scope
argument_list|()
operator|.
name|resolve
argument_list|(
name|qualified
operator|.
name|prefix
argument_list|()
argument_list|,
name|nameMatcher
argument_list|,
literal|false
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|resolved
operator|.
name|count
argument_list|()
operator|==
literal|1
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|SqlValidatorScope
operator|.
name|Resolve
name|resolve
init|=
name|resolved
operator|.
name|only
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|resolve
operator|.
name|rowType
argument_list|()
decl_stmt|;
comment|// Found in current query's from list.  Find which from item.
comment|// We assume that the order of the from clause items has been
comment|// preserved.
specifier|final
name|SqlValidatorScope
name|ancestorScope
init|=
name|resolve
operator|.
name|scope
decl_stmt|;
name|boolean
name|isParent
init|=
name|ancestorScope
operator|!=
name|scope
decl_stmt|;
if|if
condition|(
operator|(
name|inputs
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|isParent
condition|)
block|{
specifier|final
name|LookupContext
name|rels
init|=
operator|new
name|LookupContext
argument_list|(
name|this
argument_list|,
name|inputs
argument_list|,
name|systemFieldList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|node
init|=
name|lookup
argument_list|(
name|resolve
operator|.
name|path
operator|.
name|steps
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|i
argument_list|,
name|rels
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|fieldOffsets
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|f
range|:
name|resolve
operator|.
name|rowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|fieldOffsets
operator|.
name|containsKey
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|fieldOffsets
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|f
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|fieldOffsets
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|node
argument_list|,
name|map
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// We're referencing a relational expression which has not been
comment|// converted yet. This occurs when from items are correlated,
comment|// e.g. "select from emp as emp join emp.getDepts() as dept".
comment|// Create a temporary expression.
name|DeferredLookup
name|lookup
init|=
operator|new
name|DeferredLookup
argument_list|(
name|this
argument_list|,
name|qualified
operator|.
name|identifier
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|CorrelationId
name|correlId
init|=
name|cluster
operator|.
name|createCorrel
argument_list|()
decl_stmt|;
name|mapCorrelToDeferred
operator|.
name|put
argument_list|(
name|correlId
argument_list|,
name|lookup
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolve
operator|.
name|path
operator|.
name|steps
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|i
operator|<
literal|0
condition|)
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeCorrel
argument_list|(
name|rowType
argument_list|,
name|correlId
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|builder
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|ListScope
name|ancestorScope1
init|=
operator|(
name|ListScope
operator|)
name|requireNonNull
argument_list|(
name|resolve
operator|.
name|scope
argument_list|,
literal|"resolve.scope"
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|fields
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SqlValidatorNamespace
name|c
range|:
name|ancestorScope1
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|builder
operator|.
name|addAll
argument_list|(
name|c
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|resolve
operator|.
name|path
operator|.
name|steps
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|i
condition|)
block|{
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|c
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|fields
operator|.
name|put
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|i
expr_stmt|;
name|offset
operator|+=
name|c
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
specifier|final
name|RexNode
name|c
init|=
name|rexBuilder
operator|.
name|makeCorrel
argument_list|(
name|builder
operator|.
name|uniquify
argument_list|()
operator|.
name|build
argument_list|()
argument_list|,
name|correlId
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|c
argument_list|,
name|fields
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
comment|/**      * Creates an expression with which to reference the expression whose      * offset in its from-list is {@code offset}.      */
name|RexNode
name|lookup
parameter_list|(
name|int
name|offset
parameter_list|,
name|LookupContext
name|lookupContext
parameter_list|)
block|{
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
name|pair
init|=
name|lookupContext
operator|.
name|findRel
argument_list|(
name|offset
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeRangeReference
argument_list|(
name|pair
operator|.
name|left
operator|.
name|getRowType
argument_list|()
argument_list|,
name|pair
operator|.
name|right
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Nullable
name|RelDataTypeField
name|getRootField
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|this
operator|.
name|inputs
decl_stmt|;
if|if
condition|(
name|inputs
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|fieldOffset
init|=
name|inputRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|inputs
control|)
block|{
name|RelDataType
name|rowType
init|=
name|input
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldOffset
operator|<
name|rowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|fieldOffset
argument_list|)
return|;
block|}
name|fieldOffset
operator|-=
name|rowType
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|void
name|flatten
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|rels
parameter_list|,
name|int
name|systemFieldCount
parameter_list|,
name|int
index|[]
name|start
parameter_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|relOffsetList
parameter_list|)
block|{
for|for
control|(
name|RelNode
name|rel
range|:
name|rels
control|)
block|{
if|if
condition|(
name|leaves
operator|.
name|containsKey
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|relOffsetList
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|rel
argument_list|,
name|start
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|start
index|[
literal|0
index|]
operator|+=
name|leaves
operator|.
name|get
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|rel
operator|instanceof
name|LogicalMatch
condition|)
block|{
name|relOffsetList
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|rel
argument_list|,
name|start
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|start
index|[
literal|0
index|]
operator|+=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rel
operator|instanceof
name|LogicalJoin
operator|||
name|rel
operator|instanceof
name|LogicalAggregate
condition|)
block|{
name|start
index|[
literal|0
index|]
operator|+=
name|systemFieldCount
expr_stmt|;
block|}
name|flatten
argument_list|(
name|rel
operator|.
name|getInputs
argument_list|()
argument_list|,
name|systemFieldCount
argument_list|,
name|start
argument_list|,
name|relOffsetList
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|void
name|registerSubQuery
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|RelOptUtil
operator|.
name|Logic
name|logic
parameter_list|)
block|{
for|for
control|(
name|SubQuery
name|subQuery
range|:
name|subQueryList
control|)
block|{
comment|// Compare the reference to make sure the matched node has
comment|// exact scope where it belongs.
if|if
condition|(
name|node
operator|==
name|subQuery
operator|.
name|node
condition|)
block|{
return|return;
block|}
block|}
name|subQueryList
operator|.
name|add
argument_list|(
operator|new
name|SubQuery
argument_list|(
name|node
argument_list|,
name|logic
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Nullable
name|SubQuery
name|getSubQuery
parameter_list|(
name|SqlNode
name|expr
parameter_list|)
block|{
for|for
control|(
name|SubQuery
name|subQuery
range|:
name|subQueryList
control|)
block|{
comment|// Compare the reference to make sure the matched node has
comment|// exact scope where it belongs.
if|if
condition|(
name|expr
operator|==
name|subQuery
operator|.
name|node
condition|)
block|{
return|return
name|subQuery
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
name|ImmutableList
argument_list|<
name|RelNode
argument_list|>
name|retrieveCursors
parameter_list|()
block|{
try|try
block|{
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|cursors
argument_list|)
return|;
block|}
finally|finally
block|{
name|cursors
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|convertExpression
parameter_list|(
name|SqlNode
name|expr
parameter_list|)
block|{
comment|// If we're in aggregation mode and this is an expression in the
comment|// GROUP BY clause, return a reference to the field.
name|AggConverter
name|agg
init|=
name|this
operator|.
name|agg
decl_stmt|;
if|if
condition|(
name|agg
operator|!=
literal|null
condition|)
block|{
specifier|final
name|SqlNode
name|expandedGroupExpr
init|=
name|validator
argument_list|()
operator|.
name|expand
argument_list|(
name|expr
argument_list|,
name|scope
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|ref
init|=
name|agg
operator|.
name|lookupGroupExpr
argument_list|(
name|expandedGroupExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|>=
literal|0
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|root
argument_list|()
argument_list|,
name|ref
argument_list|)
return|;
block|}
if|if
condition|(
name|expr
operator|instanceof
name|SqlCall
condition|)
block|{
specifier|final
name|RexNode
name|rex
init|=
name|agg
operator|.
name|lookupAggregates
argument_list|(
operator|(
name|SqlCall
operator|)
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|rex
operator|!=
literal|null
condition|)
block|{
return|return
name|rex
return|;
block|}
block|}
block|}
comment|// Allow the derived class chance to override the standard
comment|// behavior for special kinds of expressions.
name|RexNode
name|rex
init|=
name|convertExtendedExpression
argument_list|(
name|expr
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|rex
operator|!=
literal|null
condition|)
block|{
return|return
name|rex
return|;
block|}
comment|// Sub-queries and OVER expressions are not like ordinary
comment|// expressions.
specifier|final
name|SqlKind
name|kind
init|=
name|expr
operator|.
name|getKind
argument_list|()
decl_stmt|;
specifier|final
name|SubQuery
name|subQuery
decl_stmt|;
if|if
condition|(
operator|!
name|config
operator|.
name|isExpand
argument_list|()
condition|)
block|{
specifier|final
name|SqlCall
name|call
decl_stmt|;
specifier|final
name|SqlNode
name|query
decl_stmt|;
specifier|final
name|RelRoot
name|root
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|IN
case|:
case|case
name|NOT_IN
case|:
case|case
name|SOME
case|:
case|case
name|ALL
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|expr
expr_stmt|;
name|query
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|query
operator|instanceof
name|SqlNodeList
operator|)
condition|)
block|{
name|root
operator|=
name|convertQueryRecursive
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|operand
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodes
decl_stmt|;
switch|switch
condition|(
name|operand
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|ROW
case|:
name|nodes
operator|=
operator|(
operator|(
name|SqlCall
operator|)
name|operand
operator|)
operator|.
name|getOperandList
argument_list|()
expr_stmt|;
break|break;
default|default:
name|nodes
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|nodes
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|convertExpression
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|IN
case|:
return|return
name|RexSubQuery
operator|.
name|in
argument_list|(
name|root
operator|.
name|rel
argument_list|,
name|list
argument_list|)
return|;
case|case
name|NOT_IN
case|:
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|RexSubQuery
operator|.
name|in
argument_list|(
name|root
operator|.
name|rel
argument_list|,
name|list
argument_list|)
argument_list|)
return|;
case|case
name|SOME
case|:
return|return
name|RexSubQuery
operator|.
name|some
argument_list|(
name|root
operator|.
name|rel
argument_list|,
name|list
argument_list|,
operator|(
name|SqlQuantifyOperator
operator|)
name|call
operator|.
name|getOperator
argument_list|()
argument_list|)
return|;
case|case
name|ALL
case|:
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|RexSubQuery
operator|.
name|some
argument_list|(
name|root
operator|.
name|rel
argument_list|,
name|list
argument_list|,
name|negate
argument_list|(
operator|(
name|SqlQuantifyOperator
operator|)
name|call
operator|.
name|getOperator
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|kind
argument_list|)
throw|;
block|}
block|}
break|break;
case|case
name|EXISTS
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|expr
expr_stmt|;
name|query
operator|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|=
name|convertQueryRecursive
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|RelNode
name|rel
init|=
name|root
operator|.
name|rel
decl_stmt|;
while|while
condition|(
name|rel
operator|instanceof
name|Project
operator|||
name|rel
operator|instanceof
name|Sort
operator|&&
operator|(
operator|(
name|Sort
operator|)
name|rel
operator|)
operator|.
name|fetch
operator|==
literal|null
operator|&&
operator|(
operator|(
name|Sort
operator|)
name|rel
operator|)
operator|.
name|offset
operator|==
literal|null
condition|)
block|{
name|rel
operator|=
operator|(
operator|(
name|SingleRel
operator|)
name|rel
operator|)
operator|.
name|getInput
argument_list|()
expr_stmt|;
block|}
return|return
name|RexSubQuery
operator|.
name|exists
argument_list|(
name|rel
argument_list|)
return|;
case|case
name|UNIQUE
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|expr
expr_stmt|;
name|query
operator|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|=
name|convertQueryRecursive
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|RexSubQuery
operator|.
name|unique
argument_list|(
name|root
operator|.
name|rel
argument_list|)
return|;
case|case
name|SCALAR_QUERY
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|expr
expr_stmt|;
name|query
operator|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|=
name|convertQueryRecursive
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|RexSubQuery
operator|.
name|scalar
argument_list|(
name|root
operator|.
name|rel
argument_list|)
return|;
case|case
name|ARRAY_QUERY_CONSTRUCTOR
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|expr
expr_stmt|;
name|query
operator|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|=
name|convertQueryRecursive
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|RexSubQuery
operator|.
name|array
argument_list|(
name|root
operator|.
name|rel
argument_list|)
return|;
case|case
name|MAP_QUERY_CONSTRUCTOR
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|expr
expr_stmt|;
name|query
operator|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|=
name|convertQueryRecursive
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|RexSubQuery
operator|.
name|map
argument_list|(
name|root
operator|.
name|rel
argument_list|)
return|;
case|case
name|MULTISET_QUERY_CONSTRUCTOR
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|expr
expr_stmt|;
name|query
operator|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|=
name|convertQueryRecursive
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|RexSubQuery
operator|.
name|multiset
argument_list|(
name|root
operator|.
name|rel
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|SOME
case|:
case|case
name|ALL
case|:
case|case
name|UNIQUE
case|:
if|if
condition|(
name|config
operator|.
name|isExpand
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|kind
operator|+
literal|" is only supported if expand = false"
argument_list|)
throw|;
block|}
comment|// fall through
case|case
name|CURSOR
case|:
case|case
name|IN
case|:
case|case
name|NOT_IN
case|:
name|subQuery
operator|=
name|requireNonNull
argument_list|(
name|getSubQuery
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|rex
operator|=
name|requireNonNull
argument_list|(
name|subQuery
operator|.
name|expr
argument_list|)
expr_stmt|;
return|return
name|StandardConvertletTable
operator|.
name|castToValidatedType
argument_list|(
name|expr
argument_list|,
name|rex
argument_list|,
name|validator
argument_list|()
argument_list|,
name|rexBuilder
argument_list|)
return|;
case|case
name|SELECT
case|:
case|case
name|EXISTS
case|:
case|case
name|SCALAR_QUERY
case|:
case|case
name|ARRAY_QUERY_CONSTRUCTOR
case|:
case|case
name|MAP_QUERY_CONSTRUCTOR
case|:
case|case
name|MULTISET_QUERY_CONSTRUCTOR
case|:
name|subQuery
operator|=
name|getSubQuery
argument_list|(
name|expr
argument_list|)
expr_stmt|;
assert|assert
name|subQuery
operator|!=
literal|null
assert|;
name|rex
operator|=
name|subQuery
operator|.
name|expr
expr_stmt|;
assert|assert
name|rex
operator|!=
literal|null
operator|:
literal|"rex != null"
assert|;
if|if
condition|(
operator|(
operator|(
name|kind
operator|==
name|SqlKind
operator|.
name|SCALAR_QUERY
operator|)
operator|||
operator|(
name|kind
operator|==
name|SqlKind
operator|.
name|EXISTS
operator|)
operator|)
operator|&&
name|isConvertedSubq
argument_list|(
name|rex
argument_list|)
condition|)
block|{
comment|// scalar sub-query or EXISTS has been converted to a
comment|// constant
return|return
name|rex
return|;
block|}
comment|// The indicator column is the last field of the sub-query.
name|RexNode
name|fieldAccess
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|rex
argument_list|,
name|rex
operator|.
name|getType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// The indicator column will be nullable if it comes from
comment|// the null-generating side of the join. For EXISTS, add an
comment|// "IS TRUE" check so that the result is "BOOLEAN NOT NULL".
if|if
condition|(
name|fieldAccess
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
operator|&&
name|kind
operator|==
name|SqlKind
operator|.
name|EXISTS
condition|)
block|{
name|fieldAccess
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|fieldAccess
argument_list|)
expr_stmt|;
block|}
return|return
name|fieldAccess
return|;
case|case
name|OVER
case|:
return|return
name|convertOver
argument_list|(
name|this
argument_list|,
name|expr
argument_list|)
return|;
default|default:
comment|// fall through
block|}
comment|// Apply standard conversions.
name|rex
operator|=
name|expr
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|requireNonNull
argument_list|(
name|rex
argument_list|,
literal|"rex"
argument_list|)
return|;
block|}
comment|/**      * Converts an item in an ORDER BY clause inside a window (OVER) clause,      * extracting DESC, NULLS LAST and NULLS FIRST flags first.      */
specifier|public
name|RexFieldCollation
name|convertSortExpression
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|RelFieldCollation
operator|.
name|Direction
name|direction
parameter_list|,
name|RelFieldCollation
operator|.
name|NullDirection
name|nullDirection
parameter_list|)
block|{
return|return
name|convertSortExpression
argument_list|(
name|expr
argument_list|,
name|direction
argument_list|,
name|nullDirection
argument_list|,
name|this
operator|::
name|sortToRexFieldCollation
argument_list|)
return|;
block|}
comment|/** Handles an item in an ORDER BY clause, passing using a converter      * function to produce the final result. */
parameter_list|<
name|R
parameter_list|>
name|R
name|convertSortExpression
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|RelFieldCollation
operator|.
name|Direction
name|direction
parameter_list|,
name|RelFieldCollation
operator|.
name|NullDirection
name|nullDirection
parameter_list|,
name|SortExpressionConverter
argument_list|<
name|R
argument_list|>
name|converter
parameter_list|)
block|{
switch|switch
condition|(
name|expr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
return|return
name|convertSortExpression
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|expr
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
argument_list|,
name|nullDirection
argument_list|,
name|converter
argument_list|)
return|;
case|case
name|NULLS_LAST
case|:
return|return
name|convertSortExpression
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|expr
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|direction
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
argument_list|,
name|converter
argument_list|)
return|;
case|case
name|NULLS_FIRST
case|:
return|return
name|convertSortExpression
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|expr
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|direction
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
argument_list|,
name|converter
argument_list|)
return|;
default|default:
return|return
name|converter
operator|.
name|convert
argument_list|(
name|expr
argument_list|,
name|direction
argument_list|,
name|nullDirection
argument_list|)
return|;
block|}
block|}
specifier|private
name|RexFieldCollation
name|sortToRexFieldCollation
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|RelFieldCollation
operator|.
name|Direction
name|direction
parameter_list|,
name|RelFieldCollation
operator|.
name|NullDirection
name|nullDirection
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|SqlKind
argument_list|>
name|flags
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|SqlKind
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|direction
operator|==
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
condition|)
block|{
name|flags
operator|.
name|add
argument_list|(
name|SqlKind
operator|.
name|DESCENDING
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|nullDirection
condition|)
block|{
case|case
name|UNSPECIFIED
case|:
specifier|final
name|RelFieldCollation
operator|.
name|NullDirection
name|nullDefaultDirection
init|=
name|validator
argument_list|()
operator|.
name|config
argument_list|()
operator|.
name|defaultNullCollation
argument_list|()
operator|.
name|last
argument_list|(
name|desc
argument_list|(
name|direction
argument_list|)
argument_list|)
condition|?
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
else|:
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
decl_stmt|;
if|if
condition|(
name|nullDefaultDirection
operator|!=
name|direction
operator|.
name|defaultNullDirection
argument_list|()
condition|)
block|{
name|SqlKind
name|nullDirectionSqlKind
init|=
name|validator
argument_list|()
operator|.
name|config
argument_list|()
operator|.
name|defaultNullCollation
argument_list|()
operator|.
name|last
argument_list|(
name|desc
argument_list|(
name|direction
argument_list|)
argument_list|)
condition|?
name|SqlKind
operator|.
name|NULLS_LAST
else|:
name|SqlKind
operator|.
name|NULLS_FIRST
decl_stmt|;
name|flags
operator|.
name|add
argument_list|(
name|nullDirectionSqlKind
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FIRST
case|:
name|flags
operator|.
name|add
argument_list|(
name|SqlKind
operator|.
name|NULLS_FIRST
argument_list|)
expr_stmt|;
break|break;
case|case
name|LAST
case|:
name|flags
operator|.
name|add
argument_list|(
name|SqlKind
operator|.
name|NULLS_LAST
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|new
name|RexFieldCollation
argument_list|(
name|convertExpression
argument_list|(
name|expr
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|sortToRex
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|RelFieldCollation
operator|.
name|Direction
name|direction
parameter_list|,
name|RelFieldCollation
operator|.
name|NullDirection
name|nullDirection
parameter_list|)
block|{
name|RexNode
name|node
init|=
name|convertExpression
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|direction
operator|==
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
condition|)
block|{
name|node
operator|=
name|relBuilder
operator|.
name|desc
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nullDirection
operator|==
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
condition|)
block|{
name|node
operator|=
name|relBuilder
operator|.
name|nullsFirst
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nullDirection
operator|==
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
condition|)
block|{
name|node
operator|=
name|relBuilder
operator|.
name|nullsLast
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
comment|/**      * Determines whether a RexNode corresponds to a sub-query that's been      * converted to a constant.      *      * @param rex the expression to be examined      * @return true if the expression is a dynamic parameter, a literal, or      * a literal that is being cast      */
specifier|private
name|boolean
name|isConvertedSubq
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
if|if
condition|(
operator|(
name|rex
operator|instanceof
name|RexLiteral
operator|)
operator|||
operator|(
name|rex
operator|instanceof
name|RexDynamicParam
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|rex
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|rex
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|CAST
condition|)
block|{
name|RexNode
name|operand
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand
operator|instanceof
name|RexLiteral
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getGroupCount
parameter_list|()
block|{
if|if
condition|(
name|agg
operator|!=
literal|null
condition|)
block|{
return|return
name|agg
operator|.
name|groupExprs
operator|.
name|size
argument_list|()
return|;
block|}
if|if
condition|(
name|window
operator|!=
literal|null
condition|)
block|{
return|return
name|window
operator|.
name|isAlwaysNonEmpty
argument_list|()
condition|?
literal|1
else|:
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexBuilder
name|getRexBuilder
parameter_list|()
block|{
return|return
name|rexBuilder
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|validateExpression
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|SqlNode
name|expr
parameter_list|)
block|{
return|return
name|SqlValidatorUtil
operator|.
name|validateExprWithRowType
argument_list|(
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
operator|.
name|isCaseSensitive
argument_list|()
argument_list|,
name|opTab
argument_list|,
name|typeFactory
argument_list|,
name|rowType
argument_list|,
name|expr
argument_list|)
operator|.
name|left
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexRangeRef
name|getSubQueryExpr
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SubQuery
name|subQuery
init|=
name|getSubQuery
argument_list|(
name|call
argument_list|)
decl_stmt|;
assert|assert
name|subQuery
operator|!=
literal|null
assert|;
return|return
operator|(
name|RexRangeRef
operator|)
name|requireNonNull
argument_list|(
name|subQuery
operator|.
name|expr
argument_list|,
parameter_list|()
lambda|->
literal|"subQuery.expr for "
operator|+
name|call
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelDataTypeFactory
name|getTypeFactory
parameter_list|()
block|{
return|return
name|typeFactory
return|;
block|}
annotation|@
name|Override
specifier|public
name|InitializerExpressionFactory
name|getInitializerExpressionFactory
parameter_list|()
block|{
return|return
name|initializerExpressionFactory
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlValidator
name|getValidator
parameter_list|()
block|{
return|return
name|validator
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|convertLiteral
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
return|return
name|exprConverter
operator|.
name|convertLiteral
argument_list|(
name|this
argument_list|,
name|literal
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertInterval
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
name|exprConverter
operator|.
name|convertInterval
argument_list|(
name|this
argument_list|,
name|intervalQualifier
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
return|return
name|exprConverter
operator|.
name|convertLiteral
argument_list|(
name|this
argument_list|,
name|literal
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|agg
operator|!=
literal|null
condition|)
block|{
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|window
operator|==
literal|null
operator|&&
operator|(
name|op
operator|.
name|isAggregator
argument_list|()
operator|||
name|op
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|FILTER
operator|||
name|op
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|WITHIN_DISTINCT
operator|||
name|op
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|WITHIN_GROUP
operator|)
condition|)
block|{
return|return
name|requireNonNull
argument_list|(
name|agg
operator|.
name|lookupAggregates
argument_list|(
name|call
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"agg.lookupAggregates for call "
operator|+
name|call
argument_list|)
return|;
block|}
block|}
return|return
name|exprConverter
operator|.
name|convertCall
argument_list|(
name|this
argument_list|,
operator|new
name|SqlCallBinding
argument_list|(
name|validator
argument_list|()
argument_list|,
name|scope
argument_list|,
name|call
argument_list|)
operator|.
name|permutedCall
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
return|return
name|convertIdentifier
argument_list|(
name|this
argument_list|,
name|id
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlDataTypeSpec
name|type
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
return|return
name|convertDynamicParam
argument_list|(
name|param
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
name|convertInterval
argument_list|(
name|intervalQualifier
argument_list|)
return|;
block|}
specifier|public
name|List
argument_list|<
name|SqlMonotonicity
argument_list|>
name|getColumnMonotonicities
parameter_list|()
block|{
return|return
name|columnMonotonicities
return|;
block|}
block|}
specifier|private
specifier|static
name|SqlQuantifyOperator
name|negate
parameter_list|(
name|SqlQuantifyOperator
name|operator
parameter_list|)
block|{
assert|assert
name|operator
operator|.
name|kind
operator|==
name|SqlKind
operator|.
name|ALL
assert|;
return|return
name|SqlStdOperatorTable
operator|.
name|some
argument_list|(
name|operator
operator|.
name|comparisonKind
operator|.
name|negateNullSafe
argument_list|()
argument_list|)
return|;
block|}
comment|/** Deferred lookup. */
specifier|private
specifier|static
class|class
name|DeferredLookup
block|{
name|Blackboard
name|bb
decl_stmt|;
name|String
name|originalRelName
decl_stmt|;
name|DeferredLookup
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|String
name|originalRelName
parameter_list|)
block|{
name|this
operator|.
name|bb
operator|=
name|bb
expr_stmt|;
name|this
operator|.
name|originalRelName
operator|=
name|originalRelName
expr_stmt|;
block|}
specifier|public
name|RexFieldAccess
name|getFieldAccess
parameter_list|(
name|CorrelationId
name|name
parameter_list|)
block|{
return|return
operator|(
name|RexFieldAccess
operator|)
name|requireNonNull
argument_list|(
name|bb
operator|.
name|mapCorrelateToRex
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"Correlation "
operator|+
name|name
operator|+
literal|" is not found"
argument_list|)
return|;
block|}
specifier|public
name|String
name|getOriginalRelName
parameter_list|()
block|{
return|return
name|originalRelName
return|;
block|}
block|}
comment|/**    * A default implementation of SubQueryConverter that does no conversion.    */
specifier|private
specifier|static
class|class
name|NoOpSubQueryConverter
implements|implements
name|SubQueryConverter
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|canConvertSubQuery
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|convertSubQuery
parameter_list|(
name|SqlCall
name|subQuery
parameter_list|,
name|SqlToRelConverter
name|parentConverter
parameter_list|,
name|boolean
name|isExists
parameter_list|,
name|boolean
name|isExplain
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Converts expressions to aggregates.    *    *<p>Consider the expression    *    *<blockquote>    * {@code SELECT deptno, SUM(2 * sal) FROM emp GROUP BY deptno}    *</blockquote>    *    *<p>Then:    *    *<ul>    *<li>groupExprs = {SqlIdentifier(deptno)}</li>    *<li>convertedInputExprs = {RexInputRef(deptno), 2 *    * RefInputRef(sal)}</li>    *<li>inputRefs = {RefInputRef(#0), RexInputRef(#1)}</li>    *<li>aggCalls = {AggCall(SUM, {1})}</li>    *</ul>    */
specifier|protected
class|class
name|AggConverter
implements|implements
name|SqlVisitor
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|Blackboard
name|bb
decl_stmt|;
specifier|public
specifier|final
annotation|@
name|Nullable
name|AggregatingSelectScope
name|aggregatingSelectScope
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|nameMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * The group-by expressions, in {@link SqlNode} format.      */
specifier|private
specifier|final
name|SqlNodeList
name|groupExprs
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
comment|/**      * The auxiliary group-by expressions.      */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|Ord
argument_list|<
name|AuxiliaryConverter
argument_list|>
argument_list|>
name|auxiliaryGroupExprs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * Input expressions for the group columns and aggregates, in      * {@link RexNode} format. The first elements of the list correspond to the      * elements in {@link #groupExprs}; the remaining elements are for      * aggregates. The right field of each pair is the name of the expression,      * where the expressions are simple mappings to input fields.      */
specifier|private
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
annotation|@
name|Nullable
name|String
argument_list|>
argument_list|>
name|convertedInputExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Expressions to be evaluated as rows are being placed into the      * aggregate's hash table. This is when group functions such as TUMBLE      * cause rows to be expanded. */
specifier|private
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|RexNode
argument_list|>
name|aggMapping
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|AggregateCall
argument_list|,
name|RexNode
argument_list|>
name|aggCallMapping
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Whether we are directly inside a windowed aggregate. */
specifier|private
name|boolean
name|inOver
init|=
literal|false
decl_stmt|;
name|AggConverter
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
annotation|@
name|Nullable
name|AggregatingSelectScope
name|aggregatingSelectScope
parameter_list|)
block|{
name|this
operator|.
name|bb
operator|=
name|bb
expr_stmt|;
name|this
operator|.
name|aggregatingSelectScope
operator|=
name|aggregatingSelectScope
expr_stmt|;
block|}
comment|/**      * Creates an AggConverter.      *      *<p>The<code>select</code> parameter provides enough context to name      * aggregate calls which are top-level select list items.      *      * @param bb     Blackboard      * @param select Query being translated; provides context to give      */
specifier|public
name|AggConverter
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlSelect
name|select
parameter_list|)
block|{
name|this
argument_list|(
name|bb
argument_list|,
operator|(
name|AggregatingSelectScope
operator|)
name|bb
operator|.
name|getValidator
argument_list|()
operator|.
name|getSelectScope
argument_list|(
name|select
argument_list|)
argument_list|)
expr_stmt|;
comment|// Collect all expressions used in the select list so that aggregate
comment|// calls can be named correctly.
specifier|final
name|SqlNodeList
name|selectList
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|selectItem
init|=
name|selectList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|name
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|SqlUtil
operator|.
name|isCallTo
argument_list|(
name|selectItem
argument_list|,
name|SqlStdOperatorTable
operator|.
name|AS
argument_list|)
condition|)
block|{
specifier|final
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|selectItem
decl_stmt|;
name|selectItem
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|name
operator|=
name|validator
argument_list|()
operator|.
name|deriveAlias
argument_list|(
name|selectItem
argument_list|,
name|i
argument_list|)
expr_stmt|;
assert|assert
name|name
operator|!=
literal|null
operator|:
literal|"alias must not be null for "
operator|+
name|selectItem
operator|+
literal|", i="
operator|+
name|i
assert|;
block|}
name|nameMap
operator|.
name|put
argument_list|(
name|selectItem
operator|.
name|toString
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|int
name|addGroupExpr
parameter_list|(
name|SqlNode
name|expr
parameter_list|)
block|{
name|int
name|ref
init|=
name|lookupGroupExpr
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|>=
literal|0
condition|)
block|{
return|return
name|ref
return|;
block|}
specifier|final
name|int
name|index
init|=
name|groupExprs
operator|.
name|size
argument_list|()
decl_stmt|;
name|groupExprs
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|nameMap
operator|.
name|get
argument_list|(
name|expr
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|convExpr
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|addExpr
argument_list|(
name|convExpr
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|SqlCall
condition|)
block|{
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|expr
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|SqlNode
argument_list|,
name|AuxiliaryConverter
argument_list|>
name|p
range|:
name|SqlStdOperatorTable
operator|.
name|convertGroupToAuxiliaryCalls
argument_list|(
name|call
argument_list|)
control|)
block|{
name|addAuxiliaryGroupExpr
argument_list|(
name|p
operator|.
name|left
argument_list|,
name|index
argument_list|,
name|p
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|index
return|;
block|}
name|void
name|addAuxiliaryGroupExpr
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|int
name|index
parameter_list|,
name|AuxiliaryConverter
name|converter
parameter_list|)
block|{
for|for
control|(
name|SqlNode
name|node2
range|:
name|auxiliaryGroupExprs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|node2
operator|.
name|equalsDeep
argument_list|(
name|node
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|auxiliaryGroupExprs
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|Ord
operator|.
name|of
argument_list|(
name|index
argument_list|,
name|converter
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds an expression, deducing an appropriate name if possible.      *      * @param expr Expression      * @param name Suggested name      */
specifier|private
name|void
name|addExpr
parameter_list|(
name|RexNode
name|expr
parameter_list|,
annotation|@
name|Nullable
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
operator|(
name|name
operator|==
literal|null
operator|)
operator|&&
operator|(
name|expr
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
specifier|final
name|int
name|i
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|expr
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|name
operator|=
name|bb
operator|.
name|root
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|Pair
operator|.
name|right
argument_list|(
name|convertedInputExprs
argument_list|)
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|// In case like 'SELECT ... GROUP BY x, y, x', don't add
comment|// name 'x' twice.
name|name
operator|=
literal|null
expr_stmt|;
block|}
name|convertedInputExprs
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|expr
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|nodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlLiteral
name|lit
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlDataTypeSpec
name|type
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|FILTER
case|:
case|case
name|IGNORE_NULLS
case|:
case|case
name|RESPECT_NULLS
case|:
case|case
name|WITHIN_DISTINCT
case|:
case|case
name|WITHIN_GROUP
case|:
name|translateAgg
argument_list|(
name|call
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
case|case
name|SELECT
case|:
comment|// rchen 2006-10-17:
comment|// for now do not detect aggregates in sub-queries.
return|return
literal|null
return|;
default|default:
break|break;
block|}
specifier|final
name|boolean
name|prevInOver
init|=
name|inOver
decl_stmt|;
comment|// Ignore window aggregates and ranking functions (associated with OVER
comment|// operator). However, do not ignore nested window aggregates.
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|OVER
condition|)
block|{
comment|// Track aggregate nesting levels only within an OVER operator.
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operandList
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
assert|assert
name|operandList
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
comment|// Ignore the top level window aggregates and ranking functions
comment|// positioned as the first operand of a OVER operator
name|inOver
operator|=
literal|true
expr_stmt|;
name|operandList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Normal translation for the second operand of a OVER operator
name|inOver
operator|=
literal|false
expr_stmt|;
name|operandList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Do not translate the top level window aggregate. Only do so for
comment|// nested aggregates, if present
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|isAggregator
argument_list|()
condition|)
block|{
if|if
condition|(
name|inOver
condition|)
block|{
comment|// Add the parent aggregate level before visiting its children
name|inOver
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// We're beyond the one ignored level
name|translateAgg
argument_list|(
name|call
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
comment|// Operands are occasionally null, e.g. switched CASE arg 0.
if|if
condition|(
name|operand
operator|!=
literal|null
condition|)
block|{
name|operand
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Remove the parent aggregate level after visiting its children
name|inOver
operator|=
name|prevInOver
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|translateAgg
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
name|translateAgg
argument_list|(
name|call
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|translateAgg
parameter_list|(
name|SqlCall
name|call
parameter_list|,
annotation|@
name|Nullable
name|SqlNode
name|filter
parameter_list|,
annotation|@
name|Nullable
name|SqlNodeList
name|distinctList
parameter_list|,
annotation|@
name|Nullable
name|SqlNodeList
name|orderList
parameter_list|,
name|boolean
name|ignoreNulls
parameter_list|,
name|SqlCall
name|outerCall
parameter_list|)
block|{
assert|assert
name|bb
operator|.
name|agg
operator|==
name|this
assert|;
assert|assert
name|outerCall
operator|!=
literal|null
assert|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
specifier|final
name|SqlParserPos
name|pos
init|=
name|call
operator|.
name|getParserPosition
argument_list|()
decl_stmt|;
specifier|final
name|SqlCall
name|call2
decl_stmt|;
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|FILTER
case|:
assert|assert
name|filter
operator|==
literal|null
assert|;
name|translateAgg
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
argument_list|,
name|distinctList
argument_list|,
name|orderList
argument_list|,
name|ignoreNulls
argument_list|,
name|outerCall
argument_list|)
expr_stmt|;
return|return;
case|case
name|WITHIN_DISTINCT
case|:
assert|assert
name|orderList
operator|==
literal|null
assert|;
name|translateAgg
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|filter
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
argument_list|,
name|orderList
argument_list|,
name|ignoreNulls
argument_list|,
name|outerCall
argument_list|)
expr_stmt|;
return|return;
case|case
name|WITHIN_GROUP
case|:
assert|assert
name|orderList
operator|==
literal|null
assert|;
name|translateAgg
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|filter
argument_list|,
name|distinctList
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
argument_list|,
name|ignoreNulls
argument_list|,
name|outerCall
argument_list|)
expr_stmt|;
return|return;
case|case
name|IGNORE_NULLS
case|:
name|ignoreNulls
operator|=
literal|true
expr_stmt|;
comment|// fall through
case|case
name|RESPECT_NULLS
case|:
name|translateAgg
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|filter
argument_list|,
name|distinctList
argument_list|,
name|orderList
argument_list|,
name|ignoreNulls
argument_list|,
name|outerCall
argument_list|)
expr_stmt|;
return|return;
case|case
name|COUNTIF
case|:
comment|// COUNTIF(b)  ==> COUNT(*) FILTER (WHERE b)
comment|// COUNTIF(b) FILTER (WHERE b2)  ==> COUNT(*) FILTER (WHERE b2 AND b)
name|call2
operator|=
name|SqlStdOperatorTable
operator|.
name|COUNT
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|SqlIdentifier
operator|.
name|star
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|filter2
init|=
name|SqlUtil
operator|.
name|andExpressions
argument_list|(
name|filter
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|translateAgg
argument_list|(
name|call2
argument_list|,
name|filter2
argument_list|,
name|distinctList
argument_list|,
name|orderList
argument_list|,
name|ignoreNulls
argument_list|,
name|outerCall
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRING_AGG
case|:
comment|// Translate "STRING_AGG(s, sep ORDER BY x, y)"
comment|// as if it were "LISTAGG(s, sep) WITHIN GROUP (ORDER BY x, y)";
comment|// and "STRING_AGG(s, sep)" as "LISTAGG(s, sep)".
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands2
decl_stmt|;
if|if
condition|(
operator|!
name|operands
operator|.
name|isEmpty
argument_list|()
operator|&&
name|Util
operator|.
name|last
argument_list|(
name|operands
argument_list|)
operator|instanceof
name|SqlNodeList
condition|)
block|{
name|orderList
operator|=
operator|(
name|SqlNodeList
operator|)
name|Util
operator|.
name|last
argument_list|(
name|operands
argument_list|)
expr_stmt|;
name|operands2
operator|=
name|Util
operator|.
name|skipLast
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|operands2
operator|=
name|operands
expr_stmt|;
block|}
name|call2
operator|=
name|SqlStdOperatorTable
operator|.
name|LISTAGG
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getFunctionQuantifier
argument_list|()
argument_list|,
name|pos
argument_list|,
name|operands2
argument_list|)
expr_stmt|;
name|translateAgg
argument_list|(
name|call2
argument_list|,
name|filter
argument_list|,
name|distinctList
argument_list|,
name|orderList
argument_list|,
name|ignoreNulls
argument_list|,
name|outerCall
argument_list|)
expr_stmt|;
return|return;
case|case
name|GROUP_CONCAT
case|:
comment|// Translate "GROUP_CONCAT(s ORDER BY x, y SEPARATOR ',')"
comment|// as if it were "LISTAGG(s, ',') WITHIN GROUP (ORDER BY x, y)".
comment|// To do this, build a list of operands without ORDER BY with with sep.
name|operands2
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|operands
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|separator
decl_stmt|;
if|if
condition|(
operator|!
name|operands2
operator|.
name|isEmpty
argument_list|()
operator|&&
name|Util
operator|.
name|last
argument_list|(
name|operands2
argument_list|)
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|SEPARATOR
condition|)
block|{
specifier|final
name|SqlCall
name|sepCall
init|=
operator|(
name|SqlCall
operator|)
name|operands2
operator|.
name|remove
argument_list|(
name|operands
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|separator
operator|=
name|sepCall
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|separator
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|operands2
operator|.
name|isEmpty
argument_list|()
operator|&&
name|Util
operator|.
name|last
argument_list|(
name|operands2
argument_list|)
operator|instanceof
name|SqlNodeList
condition|)
block|{
name|orderList
operator|=
operator|(
name|SqlNodeList
operator|)
name|operands2
operator|.
name|remove
argument_list|(
name|operands2
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|separator
operator|!=
literal|null
condition|)
block|{
name|operands2
operator|.
name|add
argument_list|(
name|separator
argument_list|)
expr_stmt|;
block|}
name|call2
operator|=
name|SqlStdOperatorTable
operator|.
name|LISTAGG
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getFunctionQuantifier
argument_list|()
argument_list|,
name|pos
argument_list|,
name|operands2
argument_list|)
expr_stmt|;
name|translateAgg
argument_list|(
name|call2
argument_list|,
name|filter
argument_list|,
name|distinctList
argument_list|,
name|orderList
argument_list|,
name|ignoreNulls
argument_list|,
name|outerCall
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_AGG
case|:
case|case
name|ARRAY_CONCAT_AGG
case|:
comment|// Translate "ARRAY_AGG(s ORDER BY x, y)"
comment|// as if it were "ARRAY_AGG(s) WITHIN GROUP (ORDER BY x, y)";
comment|// similarly "ARRAY_CONCAT_AGG".
if|if
condition|(
operator|!
name|operands
operator|.
name|isEmpty
argument_list|()
operator|&&
name|Util
operator|.
name|last
argument_list|(
name|operands
argument_list|)
operator|instanceof
name|SqlNodeList
condition|)
block|{
name|orderList
operator|=
operator|(
name|SqlNodeList
operator|)
name|Util
operator|.
name|last
argument_list|(
name|operands
argument_list|)
expr_stmt|;
name|call2
operator|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getFunctionQuantifier
argument_list|()
argument_list|,
name|pos
argument_list|,
name|Util
operator|.
name|skipLast
argument_list|(
name|operands
argument_list|)
argument_list|)
expr_stmt|;
name|translateAgg
argument_list|(
name|call2
argument_list|,
name|filter
argument_list|,
name|distinctList
argument_list|,
name|orderList
argument_list|,
name|ignoreNulls
argument_list|,
name|outerCall
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// "ARRAY_AGG" and "ARRAY_CONCAT_AGG" without "ORDER BY"
comment|// are handled normally; fall through.
default|default:
break|break;
block|}
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|args
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|filterArg
init|=
operator|-
literal|1
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|distinctKeys
decl_stmt|;
try|try
block|{
comment|// switch out of agg mode
name|bb
operator|.
name|agg
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
comment|// special case for COUNT(*):  delete the *
if|if
condition|(
name|operand
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|operand
decl_stmt|;
if|if
condition|(
name|id
operator|.
name|isStar
argument_list|()
condition|)
block|{
assert|assert
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|1
assert|;
assert|assert
name|args
operator|.
name|isEmpty
argument_list|()
assert|;
break|break;
block|}
block|}
name|RexNode
name|convertedExpr
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|operand
argument_list|)
decl_stmt|;
name|args
operator|.
name|add
argument_list|(
name|lookupOrCreateGroupExpr
argument_list|(
name|convertedExpr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
name|RexNode
name|convertedExpr
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|filter
argument_list|)
decl_stmt|;
if|if
condition|(
name|convertedExpr
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|convertedExpr
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
argument_list|,
name|convertedExpr
argument_list|)
expr_stmt|;
block|}
name|filterArg
operator|=
name|lookupOrCreateGroupExpr
argument_list|(
name|convertedExpr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|distinctList
operator|==
literal|null
condition|)
block|{
name|distinctKeys
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|distinctBuilder
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|distinct
range|:
name|distinctList
control|)
block|{
name|RexNode
name|e
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|distinct
argument_list|)
decl_stmt|;
assert|assert
name|e
operator|!=
literal|null
assert|;
name|distinctBuilder
operator|.
name|set
argument_list|(
name|lookupOrCreateGroupExpr
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|distinctKeys
operator|=
name|distinctBuilder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// switch back into agg mode
name|bb
operator|.
name|agg
operator|=
name|this
expr_stmt|;
block|}
name|SqlAggFunction
name|aggFunction
init|=
operator|(
name|SqlAggFunction
operator|)
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|validator
argument_list|()
operator|.
name|deriveType
argument_list|(
name|bb
operator|.
name|scope
argument_list|()
argument_list|,
name|call
argument_list|)
decl_stmt|;
name|boolean
name|distinct
init|=
literal|false
decl_stmt|;
name|SqlLiteral
name|quantifier
init|=
name|call
operator|.
name|getFunctionQuantifier
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
literal|null
operator|!=
name|quantifier
operator|)
operator|&&
operator|(
name|quantifier
operator|.
name|getValue
argument_list|()
operator|==
name|SqlSelectKeyword
operator|.
name|DISTINCT
operator|)
condition|)
block|{
name|distinct
operator|=
literal|true
expr_stmt|;
block|}
name|boolean
name|approximate
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|aggFunction
operator|==
name|SqlStdOperatorTable
operator|.
name|APPROX_COUNT_DISTINCT
condition|)
block|{
name|aggFunction
operator|=
name|SqlStdOperatorTable
operator|.
name|COUNT
expr_stmt|;
name|distinct
operator|=
literal|true
expr_stmt|;
name|approximate
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|RelCollation
name|collation
decl_stmt|;
if|if
condition|(
name|orderList
operator|==
literal|null
operator|||
name|orderList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|collation
operator|=
name|RelCollations
operator|.
name|EMPTY
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
comment|// switch out of agg mode
name|bb
operator|.
name|agg
operator|=
literal|null
expr_stmt|;
name|collation
operator|=
name|RelCollations
operator|.
name|of
argument_list|(
name|orderList
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|order
lambda|->
name|bb
operator|.
name|convertSortExpression
argument_list|(
name|order
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|ASCENDING
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
argument_list|,
name|this
operator|::
name|sortToFieldCollation
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// switch back into agg mode
name|bb
operator|.
name|agg
operator|=
name|this
expr_stmt|;
block|}
block|}
specifier|final
name|AggregateCall
name|aggCall
init|=
name|AggregateCall
operator|.
name|create
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|approximate
argument_list|,
name|ignoreNulls
argument_list|,
name|args
argument_list|,
name|filterArg
argument_list|,
name|distinctKeys
argument_list|,
name|collation
argument_list|,
name|type
argument_list|,
name|nameMap
operator|.
name|get
argument_list|(
name|outerCall
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|rex
init|=
name|rexBuilder
operator|.
name|addAggCall
argument_list|(
name|aggCall
argument_list|,
name|groupExprs
operator|.
name|size
argument_list|()
argument_list|,
name|aggCalls
argument_list|,
name|aggCallMapping
argument_list|,
name|i
lambda|->
name|convertedInputExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|left
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|)
decl_stmt|;
name|aggMapping
operator|.
name|put
argument_list|(
name|outerCall
argument_list|,
name|rex
argument_list|)
expr_stmt|;
block|}
specifier|private
name|RelFieldCollation
name|sortToFieldCollation
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|RelFieldCollation
operator|.
name|Direction
name|direction
parameter_list|,
name|RelFieldCollation
operator|.
name|NullDirection
name|nullDirection
parameter_list|)
block|{
specifier|final
name|RexNode
name|node
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|expr
argument_list|)
decl_stmt|;
specifier|final
name|int
name|fieldIndex
init|=
name|lookupOrCreateGroupExpr
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|nullDirection
operator|==
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
condition|)
block|{
name|nullDirection
operator|=
name|direction
operator|.
name|defaultNullDirection
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|RelFieldCollation
argument_list|(
name|fieldIndex
argument_list|,
name|direction
argument_list|,
name|nullDirection
argument_list|)
return|;
block|}
specifier|private
name|int
name|lookupOrCreateGroupExpr
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexNode
name|convertedInputExpr
range|:
name|Pair
operator|.
name|left
argument_list|(
name|convertedInputExprs
argument_list|)
control|)
block|{
if|if
condition|(
name|expr
operator|.
name|equals
argument_list|(
name|convertedInputExpr
argument_list|)
condition|)
block|{
return|return
name|index
return|;
block|}
operator|++
name|index
expr_stmt|;
block|}
comment|// not found -- add it
name|addExpr
argument_list|(
name|expr
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
comment|/**      * If an expression is structurally identical to one of the group-by      * expressions, returns a reference to the expression, otherwise returns      * null.      */
specifier|public
name|int
name|lookupGroupExpr
parameter_list|(
name|SqlNode
name|expr
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|groupExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|groupExpr
init|=
name|groupExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|.
name|equalsDeep
argument_list|(
name|groupExpr
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
specifier|public
annotation|@
name|Nullable
name|RexNode
name|lookupAggregates
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
comment|// assert call.getOperator().isAggregator();
assert|assert
name|bb
operator|.
name|agg
operator|==
name|this
assert|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SqlNode
argument_list|,
name|Ord
argument_list|<
name|AuxiliaryConverter
argument_list|>
argument_list|>
name|e
range|:
name|auxiliaryGroupExprs
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|call
operator|.
name|equalsDeep
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
name|AuxiliaryConverter
name|converter
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|e
decl_stmt|;
specifier|final
name|int
name|groupOrdinal
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|i
decl_stmt|;
return|return
name|converter
operator|.
name|convert
argument_list|(
name|rexBuilder
argument_list|,
name|convertedInputExprs
operator|.
name|get
argument_list|(
name|groupOrdinal
argument_list|)
operator|.
name|left
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|castNonNull
argument_list|(
name|bb
operator|.
name|root
argument_list|)
argument_list|,
name|groupOrdinal
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|aggMapping
operator|.
name|get
argument_list|(
name|call
argument_list|)
return|;
block|}
specifier|public
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
annotation|@
name|Nullable
name|String
argument_list|>
argument_list|>
name|getPreExprs
parameter_list|()
block|{
return|return
name|convertedInputExprs
return|;
block|}
specifier|public
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|getAggCalls
parameter_list|()
block|{
return|return
name|aggCalls
return|;
block|}
specifier|public
name|RelDataTypeFactory
name|getTypeFactory
parameter_list|()
block|{
return|return
name|typeFactory
return|;
block|}
block|}
comment|/**    * Context to find a relational expression to a field offset.    */
specifier|private
specifier|static
class|class
name|LookupContext
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|relOffsetList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * Creates a LookupContext with multiple input relational expressions.      *      * @param bb               Context for translating this sub-query      * @param rels             Relational expressions      * @param systemFieldCount Number of system fields      */
name|LookupContext
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|rels
parameter_list|,
name|int
name|systemFieldCount
parameter_list|)
block|{
name|bb
operator|.
name|flatten
argument_list|(
name|rels
argument_list|,
name|systemFieldCount
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|}
argument_list|,
name|relOffsetList
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the relational expression with a given offset, and the      * ordinal in the combined row of its first field.      *      *<p>For example, in {@code Emp JOIN Dept}, findRel(1) returns the      * relational expression for {@code Dept} and offset 6 (because      * {@code Emp} has 6 fields, therefore the first field of {@code Dept}      * is field 6.      *      * @param offset Offset of relational expression in FROM clause      * @return Relational expression and the ordinal of its first field      */
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
name|findRel
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
return|return
name|relOffsetList
operator|.
name|get
argument_list|(
name|offset
argument_list|)
return|;
block|}
block|}
comment|/**    * Shuttle which walks over a tree of {@link RexNode}s and applies 'over' to    * all agg functions.    *    *<p>This is necessary because the returned expression is not necessarily a    * call to an agg function. For example,    *    *<blockquote><code>AVG(x)</code></blockquote>    *    *<p>becomes    *    *<blockquote><code>SUM(x) / COUNT(x)</code></blockquote>    *    *<p>Any aggregate functions are converted to calls to the internal<code>    * $Histogram</code> aggregation function and accessors such as<code>    * $HistogramMin</code>; for example,    *    *<blockquote><code>MIN(x), MAX(x)</code></blockquote>    *    *<p>are converted to    *    *<blockquote><code>$HistogramMin($Histogram(x)),    * $HistogramMax($Histogram(x))</code></blockquote>    *    *<p>Common sub-expression elimination will ensure that only one histogram is    * computed.    */
specifier|private
class|class
name|HistogramShuttle
extends|extends
name|RexShuttle
block|{
comment|/**      * Whether to convert calls to MIN(x) to HISTOGRAM_MIN(HISTOGRAM(x)).      * Histograms allow rolling computation, but require more space.      */
specifier|static
specifier|final
name|boolean
name|ENABLE_HISTOGRAM_AGG
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|partitionKeys
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|orderKeys
decl_stmt|;
specifier|private
specifier|final
name|RexWindowBound
name|lowerBound
decl_stmt|;
specifier|private
specifier|final
name|RexWindowBound
name|upperBound
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|rows
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|allowPartial
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|distinct
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|ignoreNulls
decl_stmt|;
name|HistogramShuttle
parameter_list|(
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|partitionKeys
parameter_list|,
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|orderKeys
parameter_list|,
name|boolean
name|rows
parameter_list|,
name|RexWindowBound
name|lowerBound
parameter_list|,
name|RexWindowBound
name|upperBound
parameter_list|,
name|boolean
name|allowPartial
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|boolean
name|ignoreNulls
parameter_list|)
block|{
name|this
operator|.
name|partitionKeys
operator|=
name|partitionKeys
expr_stmt|;
name|this
operator|.
name|orderKeys
operator|=
name|orderKeys
expr_stmt|;
name|this
operator|.
name|lowerBound
operator|=
name|lowerBound
expr_stmt|;
name|this
operator|.
name|upperBound
operator|=
name|upperBound
expr_stmt|;
name|this
operator|.
name|rows
operator|=
name|rows
expr_stmt|;
name|this
operator|.
name|allowPartial
operator|=
name|allowPartial
expr_stmt|;
name|this
operator|.
name|distinct
operator|=
name|distinct
expr_stmt|;
name|this
operator|.
name|ignoreNulls
operator|=
name|ignoreNulls
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|op
operator|instanceof
name|SqlAggFunction
operator|)
condition|)
block|{
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
specifier|final
name|SqlAggFunction
name|aggOp
init|=
operator|(
name|SqlAggFunction
operator|)
name|op
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|call
operator|.
name|getType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|SqlFunction
name|histogramOp
init|=
operator|!
name|ENABLE_HISTOGRAM_AGG
condition|?
literal|null
else|:
name|getHistogramOp
argument_list|(
name|aggOp
argument_list|)
decl_stmt|;
if|if
condition|(
name|histogramOp
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RelDataType
name|histogramType
init|=
name|computeHistogramType
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|// For DECIMAL, since it's already represented as a bigint we
comment|// want to do a reinterpretCast instead of a cast to avoid
comment|// losing any precision.
name|boolean
name|reinterpretCast
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|DECIMAL
decl_stmt|;
comment|// Replace original expression with CAST of not one
comment|// of the supported types
if|if
condition|(
name|histogramType
operator|!=
name|type
condition|)
block|{
name|exprs
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|exprs
argument_list|)
expr_stmt|;
name|exprs
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|reinterpretCast
condition|?
name|rexBuilder
operator|.
name|makeReinterpretCast
argument_list|(
name|histogramType
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
else|:
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|histogramType
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|over
init|=
name|relBuilder
operator|.
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|HISTOGRAM_AGG
argument_list|,
name|exprs
argument_list|)
operator|.
name|distinct
argument_list|(
name|distinct
argument_list|)
operator|.
name|ignoreNulls
argument_list|(
name|ignoreNulls
argument_list|)
operator|.
name|over
argument_list|()
operator|.
name|partitionBy
argument_list|(
name|partitionKeys
argument_list|)
operator|.
name|orderBy
argument_list|(
name|orderKeys
argument_list|)
operator|.
name|let
argument_list|(
name|c
lambda|->
name|rows
condition|?
name|c
operator|.
name|rowsBetween
argument_list|(
name|lowerBound
argument_list|,
name|upperBound
argument_list|)
else|:
name|c
operator|.
name|rangeBetween
argument_list|(
name|lowerBound
argument_list|,
name|upperBound
argument_list|)
argument_list|)
operator|.
name|allowPartial
argument_list|(
name|allowPartial
argument_list|)
operator|.
name|toRex
argument_list|()
decl_stmt|;
name|RexNode
name|histogramCall
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|histogramType
argument_list|,
name|histogramOp
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|over
argument_list|)
argument_list|)
decl_stmt|;
comment|// If needed, post Cast result back to original
comment|// type.
if|if
condition|(
name|histogramType
operator|!=
name|type
condition|)
block|{
if|if
condition|(
name|reinterpretCast
condition|)
block|{
name|histogramCall
operator|=
name|rexBuilder
operator|.
name|makeReinterpretCast
argument_list|(
name|type
argument_list|,
name|histogramCall
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|histogramCall
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|histogramCall
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|histogramCall
return|;
block|}
else|else
block|{
name|boolean
name|needSum0
init|=
name|aggOp
operator|==
name|SqlStdOperatorTable
operator|.
name|SUM
operator|&&
name|type
operator|.
name|isNullable
argument_list|()
decl_stmt|;
name|SqlAggFunction
name|aggOpToUse
init|=
name|needSum0
condition|?
name|SqlStdOperatorTable
operator|.
name|SUM0
else|:
name|aggOp
decl_stmt|;
return|return
name|relBuilder
operator|.
name|aggregateCall
argument_list|(
name|aggOpToUse
argument_list|,
name|exprs
argument_list|)
operator|.
name|distinct
argument_list|(
name|distinct
argument_list|)
operator|.
name|ignoreNulls
argument_list|(
name|ignoreNulls
argument_list|)
operator|.
name|over
argument_list|()
operator|.
name|partitionBy
argument_list|(
name|partitionKeys
argument_list|)
operator|.
name|orderBy
argument_list|(
name|orderKeys
argument_list|)
operator|.
name|let
argument_list|(
name|c
lambda|->
name|rows
condition|?
name|c
operator|.
name|rowsBetween
argument_list|(
name|lowerBound
argument_list|,
name|upperBound
argument_list|)
else|:
name|c
operator|.
name|rangeBetween
argument_list|(
name|lowerBound
argument_list|,
name|upperBound
argument_list|)
argument_list|)
operator|.
name|allowPartial
argument_list|(
name|allowPartial
argument_list|)
operator|.
name|nullWhenCountZero
argument_list|(
name|needSum0
argument_list|)
operator|.
name|toRex
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns the histogram operator corresponding to a given aggregate      * function.      *      *<p>For example,<code>getHistogramOp      *({@link SqlStdOperatorTable#MIN}}</code> returns      * {@link SqlStdOperatorTable#HISTOGRAM_MIN}.      *      * @param aggFunction An aggregate function      * @return Its histogram function, or null      */
annotation|@
name|Nullable
name|SqlFunction
name|getHistogramOp
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|)
block|{
if|if
condition|(
name|aggFunction
operator|==
name|SqlStdOperatorTable
operator|.
name|MIN
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|HISTOGRAM_MIN
return|;
block|}
if|else if
condition|(
name|aggFunction
operator|==
name|SqlStdOperatorTable
operator|.
name|MAX
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|HISTOGRAM_MAX
return|;
block|}
if|else if
condition|(
name|aggFunction
operator|==
name|SqlStdOperatorTable
operator|.
name|FIRST_VALUE
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|HISTOGRAM_FIRST_VALUE
return|;
block|}
if|else if
condition|(
name|aggFunction
operator|==
name|SqlStdOperatorTable
operator|.
name|LAST_VALUE
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|HISTOGRAM_LAST_VALUE
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Returns the type for a histogram function. It is either the actual      * type or an an approximation to it.      */
specifier|private
name|RelDataType
name|computeHistogramType
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type
argument_list|)
operator|&&
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|BIGINT
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
return|;
block|}
if|else if
condition|(
name|SqlTypeUtil
operator|.
name|isApproximateNumeric
argument_list|(
name|type
argument_list|)
operator|&&
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|DOUBLE
condition|)
block|{
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|type
return|;
block|}
block|}
block|}
comment|/** A sub-query, whether it needs to be translated using 2- or 3-valued    * logic. */
specifier|private
specifier|static
class|class
name|SubQuery
block|{
specifier|final
name|SqlNode
name|node
decl_stmt|;
specifier|final
name|RelOptUtil
operator|.
name|Logic
name|logic
decl_stmt|;
annotation|@
name|Nullable
name|RexNode
name|expr
decl_stmt|;
specifier|private
name|SubQuery
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|RelOptUtil
operator|.
name|Logic
name|logic
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|logic
operator|=
name|logic
expr_stmt|;
block|}
block|}
comment|/**    * Visitor that looks for an SqlIdentifier inside a tree of    * {@link SqlNode} objects and return {@link Boolean#TRUE} when it finds    * one.    */
specifier|public
specifier|static
class|class
name|SqlIdentifierFinder
implements|implements
name|SqlVisitor
argument_list|<
name|Boolean
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|visit
parameter_list|(
name|SqlCall
name|sqlCall
parameter_list|)
block|{
return|return
name|sqlCall
operator|.
name|getOperandList
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|sqlNode
lambda|->
name|sqlNode
operator|.
name|accept
argument_list|(
name|this
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visit
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
return|return
name|nodeList
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|sqlNode
lambda|->
name|sqlNode
operator|.
name|accept
argument_list|(
name|this
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visit
parameter_list|(
name|SqlIdentifier
name|identifier
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visit
parameter_list|(
name|SqlDataTypeSpec
name|type
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visit
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Visitor that collects all aggregate functions in a {@link SqlNode} tree.    */
specifier|private
specifier|static
class|class
name|AggregateFinder
extends|extends
name|SqlBasicVisitor
argument_list|<
name|Void
argument_list|>
block|{
specifier|final
name|SqlNodeList
name|list
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
specifier|final
name|SqlNodeList
name|filterList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
specifier|final
name|SqlNodeList
name|distinctList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
specifier|final
name|SqlNodeList
name|orderList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
comment|// ignore window aggregates and ranking functions (associated with OVER operator)
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|OVER
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|FILTER
condition|)
block|{
comment|// the WHERE in a FILTER must be tracked too so we can call replaceSubQueries on it.
comment|// see https://issues.apache.org/jira/browse/CALCITE-1910
specifier|final
name|SqlNode
name|aggCall
init|=
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|whereCall
init|=
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|aggCall
argument_list|)
expr_stmt|;
name|filterList
operator|.
name|add
argument_list|(
name|whereCall
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|WITHIN_DISTINCT
condition|)
block|{
specifier|final
name|SqlNode
name|aggCall
init|=
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlNodeList
name|distinctList
init|=
operator|(
name|SqlNodeList
operator|)
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|aggCall
argument_list|)
expr_stmt|;
name|distinctList
operator|.
name|getList
argument_list|()
operator|.
name|forEach
argument_list|(
name|this
operator|.
name|distinctList
operator|::
name|add
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|WITHIN_GROUP
condition|)
block|{
specifier|final
name|SqlNode
name|aggCall
init|=
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlNodeList
name|orderList
init|=
operator|(
name|SqlNodeList
operator|)
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|aggCall
argument_list|)
expr_stmt|;
name|this
operator|.
name|orderList
operator|.
name|addAll
argument_list|(
name|orderList
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|isAggregator
argument_list|()
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|call
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Don't traverse into sub-queries, even if they contain aggregate
comment|// functions.
if|if
condition|(
name|call
operator|instanceof
name|SqlSelect
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|acceptCall
argument_list|(
name|this
argument_list|,
name|call
argument_list|)
return|;
block|}
block|}
comment|/** Use of a row as a correlating variable by a given relational    * expression. */
specifier|private
specifier|static
class|class
name|CorrelationUse
block|{
specifier|private
specifier|final
name|CorrelationId
name|id
decl_stmt|;
specifier|private
specifier|final
name|ImmutableBitSet
name|requiredColumns
decl_stmt|;
comment|/** The relational expression that uses the variable. */
specifier|private
specifier|final
name|RelNode
name|r
decl_stmt|;
name|CorrelationUse
parameter_list|(
name|CorrelationId
name|id
parameter_list|,
name|ImmutableBitSet
name|requiredColumns
parameter_list|,
name|RelNode
name|r
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|requiredColumns
operator|=
name|requiredColumns
expr_stmt|;
name|this
operator|.
name|r
operator|=
name|r
expr_stmt|;
block|}
block|}
comment|/** Returns a default {@link Config}. */
specifier|public
specifier|static
name|Config
name|config
parameter_list|()
block|{
return|return
name|CONFIG
return|;
block|}
comment|/**    * Interface to define the configuration for a SqlToRelConverter.    * Provides methods to set each configuration option.    *    * @see SqlToRelConverter#CONFIG    */
annotation|@
name|Value
operator|.
name|Immutable
argument_list|(
name|singleton
operator|=
literal|false
argument_list|)
specifier|public
interface|interface
name|Config
block|{
comment|/** Returns the {@code decorrelationEnabled} option. Controls whether to      * disable sub-query decorrelation when needed. e.g. if outer joins are not      * supported. */
annotation|@
name|Value
operator|.
name|Default
specifier|default
name|boolean
name|isDecorrelationEnabled
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/** Sets {@link #isDecorrelationEnabled()}. */
name|Config
name|withDecorrelationEnabled
parameter_list|(
name|boolean
name|decorrelationEnabled
parameter_list|)
function_decl|;
comment|/** Returns the {@code trimUnusedFields} option. Controls whether to trim      * unused fields as part of the conversion process. */
annotation|@
name|Value
operator|.
name|Default
specifier|default
name|boolean
name|isTrimUnusedFields
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/** Sets {@link #isTrimUnusedFields()}. */
name|Config
name|withTrimUnusedFields
parameter_list|(
name|boolean
name|trimUnusedFields
parameter_list|)
function_decl|;
comment|/** Returns the {@code createValuesRel} option. Controls whether instances      * of {@link org.apache.calcite.rel.logical.LogicalValues} are generated.      * These may not be supported by all physical implementations. */
annotation|@
name|Value
operator|.
name|Default
specifier|default
name|boolean
name|isCreateValuesRel
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/** Sets {@link #isCreateValuesRel()}. */
name|Config
name|withCreateValuesRel
parameter_list|(
name|boolean
name|createValuesRel
parameter_list|)
function_decl|;
comment|/** Returns the {@code explain} option. Describes whether the current      * statement is part of an EXPLAIN PLAN statement. */
annotation|@
name|Value
operator|.
name|Default
specifier|default
name|boolean
name|isExplain
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/** Sets {@link #isExplain()}. */
name|Config
name|withExplain
parameter_list|(
name|boolean
name|explain
parameter_list|)
function_decl|;
comment|/** Returns the {@code expand} option. Controls whether to expand      * sub-queries. If false, each sub-query becomes a      * {@link org.apache.calcite.rex.RexSubQuery}. */
annotation|@
name|Value
operator|.
name|Default
specifier|default
name|boolean
name|isExpand
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/** Sets {@link #isExpand()}. */
name|Config
name|withExpand
parameter_list|(
name|boolean
name|expand
parameter_list|)
function_decl|;
comment|/** Returns the {@code inSubQueryThreshold} option,      * default {@link #DEFAULT_IN_SUB_QUERY_THRESHOLD}. Controls the list size      * threshold under which {@link #convertInToOr} is used. Lists of this size      * or greater will instead be converted to use a join against an inline      * table ({@link org.apache.calcite.rel.logical.LogicalValues}) rather than      * a predicate. A threshold of 0 forces usage of an inline table in all      * cases; a threshold of {@link Integer#MAX_VALUE} forces usage of OR in all      * cases. */
annotation|@
name|Value
operator|.
name|Default
specifier|default
name|int
name|getInSubQueryThreshold
parameter_list|()
block|{
return|return
name|DEFAULT_IN_SUB_QUERY_THRESHOLD
return|;
block|}
comment|/** Sets {@link #getInSubQueryThreshold()}. */
name|Config
name|withInSubQueryThreshold
parameter_list|(
name|int
name|threshold
parameter_list|)
function_decl|;
comment|/** Returns whether to remove Sort operator for a sub-query      * if the Sort has no offset and fetch limit attributes.      * Because the remove does not change the semantics,      * in many cases this is a promotion.      * Default is true. */
annotation|@
name|Value
operator|.
name|Default
specifier|default
name|boolean
name|isRemoveSortInSubQuery
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/** Sets {@link #isRemoveSortInSubQuery()}. */
name|Config
name|withRemoveSortInSubQuery
parameter_list|(
name|boolean
name|removeSortInSubQuery
parameter_list|)
function_decl|;
comment|/** Returns the factory to create {@link RelBuilder}, never null. Default is      * {@link RelFactories#LOGICAL_BUILDER}. */
name|RelBuilderFactory
name|getRelBuilderFactory
parameter_list|()
function_decl|;
comment|/** Sets {@link #getRelBuilderFactory()}. */
name|Config
name|withRelBuilderFactory
parameter_list|(
name|RelBuilderFactory
name|factory
parameter_list|)
function_decl|;
comment|/** Returns a function that takes a {@link RelBuilder.Config} and returns      * another. Default is the identity function. */
name|UnaryOperator
argument_list|<
name|RelBuilder
operator|.
name|Config
argument_list|>
name|getRelBuilderConfigTransform
parameter_list|()
function_decl|;
comment|/** Sets {@link #getRelBuilderConfigTransform()}.      *      * @see #addRelBuilderConfigTransform */
name|Config
name|withRelBuilderConfigTransform
parameter_list|(
name|UnaryOperator
argument_list|<
name|RelBuilder
operator|.
name|Config
argument_list|>
name|transform
parameter_list|)
function_decl|;
comment|/** Adds a transform to {@link #getRelBuilderConfigTransform()}. */
specifier|default
name|Config
name|addRelBuilderConfigTransform
parameter_list|(
name|UnaryOperator
argument_list|<
name|RelBuilder
operator|.
name|Config
argument_list|>
name|transform
parameter_list|)
block|{
return|return
name|withRelBuilderConfigTransform
argument_list|(
name|getRelBuilderConfigTransform
argument_list|()
operator|.
name|andThen
argument_list|(
name|transform
argument_list|)
operator|::
name|apply
argument_list|)
return|;
block|}
comment|/** Returns the hint strategies used to decide how the hints are propagated to      * the relational expressions. Default is      * {@link HintStrategyTable#EMPTY}. */
name|HintStrategyTable
name|getHintStrategyTable
parameter_list|()
function_decl|;
comment|/** Sets {@link #getHintStrategyTable()}. */
name|Config
name|withHintStrategyTable
parameter_list|(
name|HintStrategyTable
name|hintStrategyTable
parameter_list|)
function_decl|;
block|}
block|}
end_class

end_unit

