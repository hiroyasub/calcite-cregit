begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelHomogeneousShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalCorrelate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCorrelVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLocalRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexOver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexPatternFieldRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSubQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apiguardian
operator|.
name|api
operator|.
name|API
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * A visitor for relational expressions that extracts a {@link org.apache.calcite.rel.core.Project}, with a "simple"  * computation over the correlated variables, from the right side of a correlation  * ({@link org.apache.calcite.rel.core.Correlate}) and places it on the left side.  *  *<p>Plan before</p>  *<pre>  * LogicalCorrelate(correlation=[$cor0], joinType=[left], requiredColumns=[{7}])  *   LogicalTableScan(table=[[scott, EMP]])  *   LogicalFilter(condition=[=($0, +(10, $cor0.DEPTNO))])  *     LogicalTableScan(table=[[scott, DEPT]])  *</pre>  *  *<p>Plan after</p>  *<pre>  * LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3],... DNAME=[$10], LOC=[$11])  *   LogicalCorrelate(correlation=[$cor0], joinType=[left], requiredColumns=[{8}])  *     LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], ... COMM=[$6], DEPTNO=[$7], $f8=[+(10, $7)])  *       LogicalTableScan(table=[[scott, EMP]])  *     LogicalFilter(condition=[=($0, $cor0.$f8)])  *       LogicalTableScan(table=[[scott, DEPT]])  *</pre>  *  *<p>Essentially this transformation moves the computation over a correlated expression from the  * inner loop to the outer loop. It materializes the computation on the left side and flattens  * expressions on correlated variables on the right side.</p>  */
end_comment

begin_class
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.27"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
specifier|final
class|class
name|CorrelateProjectExtractor
extends|extends
name|RelHomogeneousShuttle
block|{
specifier|private
specifier|final
name|RelBuilderFactory
name|builderFactory
decl_stmt|;
specifier|public
name|CorrelateProjectExtractor
parameter_list|(
name|RelBuilderFactory
name|factory
parameter_list|)
block|{
name|this
operator|.
name|builderFactory
operator|=
name|factory
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|visit
parameter_list|(
name|LogicalCorrelate
name|correlate
parameter_list|)
block|{
name|RelNode
name|left
init|=
name|correlate
operator|.
name|getLeft
argument_list|()
operator|.
name|accept
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|RelNode
name|right
init|=
name|correlate
operator|.
name|getRight
argument_list|()
operator|.
name|accept
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|int
name|oldLeft
init|=
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
comment|// Find the correlated expressions from the right side that can be moved to the left
name|Set
argument_list|<
name|RexNode
argument_list|>
name|callsWithCorrelationInRight
init|=
name|findCorrelationDependentCalls
argument_list|(
name|correlate
operator|.
name|getCorrelationId
argument_list|()
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|boolean
name|isTrivialCorrelation
init|=
name|callsWithCorrelationInRight
operator|.
name|stream
argument_list|()
operator|.
name|allMatch
argument_list|(
name|exp
lambda|->
name|exp
operator|instanceof
name|RexFieldAccess
argument_list|)
decl_stmt|;
comment|// Early exit condition
if|if
condition|(
name|isTrivialCorrelation
condition|)
block|{
if|if
condition|(
name|correlate
operator|.
name|getLeft
argument_list|()
operator|.
name|equals
argument_list|(
name|left
argument_list|)
operator|&&
name|correlate
operator|.
name|getRight
argument_list|()
operator|.
name|equals
argument_list|(
name|right
argument_list|)
condition|)
block|{
return|return
name|correlate
return|;
block|}
else|else
block|{
return|return
name|correlate
operator|.
name|copy
argument_list|(
name|correlate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|correlate
operator|.
name|getCorrelationId
argument_list|()
argument_list|,
name|correlate
operator|.
name|getRequiredColumns
argument_list|()
argument_list|,
name|correlate
operator|.
name|getJoinType
argument_list|()
argument_list|)
return|;
block|}
block|}
name|RelBuilder
name|builder
init|=
name|builderFactory
operator|.
name|create
argument_list|(
name|correlate
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Transform the correlated expression from the right side to an expression over the left side
name|builder
operator|.
name|push
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|callsWithCorrelationOverLeft
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|callInRight
range|:
name|callsWithCorrelationInRight
control|)
block|{
name|callsWithCorrelationOverLeft
operator|.
name|add
argument_list|(
name|replaceCorrelationsWithInputRef
argument_list|(
name|callInRight
argument_list|,
name|builder
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|projectPlus
argument_list|(
name|callsWithCorrelationOverLeft
argument_list|)
expr_stmt|;
comment|// Construct the mapping to transform the expressions in the right side based on the new
comment|// projection in the left side.
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|transformMapping
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|callInRight
range|:
name|callsWithCorrelationInRight
control|)
block|{
name|RexBuilder
name|xb
init|=
name|builder
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexNode
name|v
init|=
name|xb
operator|.
name|makeCorrel
argument_list|(
name|builder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|correlate
operator|.
name|getCorrelationId
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|flatCorrelationInRight
init|=
name|xb
operator|.
name|makeFieldAccess
argument_list|(
name|v
argument_list|,
name|oldLeft
operator|+
name|transformMapping
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|transformMapping
operator|.
name|put
argument_list|(
name|callInRight
argument_list|,
name|flatCorrelationInRight
argument_list|)
expr_stmt|;
block|}
comment|// Select the required fields/columns from the left side of the correlation. Based on the code
comment|// above all these fields should be at the end of the left relational expression.
name|List
argument_list|<
name|RexNode
argument_list|>
name|requiredFields
init|=
name|builder
operator|.
name|fields
argument_list|(
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|oldLeft
argument_list|,
name|oldLeft
operator|+
name|callsWithCorrelationOverLeft
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|asList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|newLeft
init|=
name|builder
operator|.
name|fields
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Transform the expressions in the right side using the mapping constructed earlier.
name|right
operator|=
name|replaceExpressionsUsingMap
argument_list|(
name|right
argument_list|,
name|transformMapping
argument_list|)
expr_stmt|;
name|builder
operator|.
name|push
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|builder
operator|.
name|correlate
argument_list|(
name|correlate
operator|.
name|getJoinType
argument_list|()
argument_list|,
name|correlate
operator|.
name|getCorrelationId
argument_list|()
argument_list|,
name|requiredFields
argument_list|)
expr_stmt|;
comment|// Remove the additional fields that were added for the needs of the correlation to keep the old
comment|// and new plan equivalent.
name|List
argument_list|<
name|Integer
argument_list|>
name|retainFields
decl_stmt|;
switch|switch
condition|(
name|correlate
operator|.
name|getJoinType
argument_list|()
condition|)
block|{
case|case
name|SEMI
case|:
case|case
name|ANTI
case|:
name|retainFields
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|oldLeft
argument_list|)
operator|.
name|asList
argument_list|()
expr_stmt|;
break|break;
case|case
name|LEFT
case|:
case|case
name|INNER
case|:
name|retainFields
operator|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|oldLeft
argument_list|)
operator|.
name|set
argument_list|(
name|newLeft
argument_list|,
name|newLeft
operator|+
name|right
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
operator|.
name|asList
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|correlate
operator|.
name|getJoinType
argument_list|()
argument_list|)
throw|;
block|}
name|builder
operator|.
name|project
argument_list|(
name|builder
operator|.
name|fields
argument_list|(
name|retainFields
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Traverses a plan and finds all simply correlated row expressions with the specified id.    */
specifier|private
specifier|static
name|Set
argument_list|<
name|RexNode
argument_list|>
name|findCorrelationDependentCalls
parameter_list|(
name|CorrelationId
name|corrId
parameter_list|,
name|RelNode
name|plan
parameter_list|)
block|{
name|SimpleCorrelationCollector
name|finder
init|=
operator|new
name|SimpleCorrelationCollector
argument_list|(
name|corrId
argument_list|)
decl_stmt|;
name|plan
operator|.
name|accept
argument_list|(
operator|new
name|RelHomogeneousShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RelNode
name|visit
parameter_list|(
name|RelNode
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|instanceof
name|Project
operator|||
name|other
operator|instanceof
name|Filter
condition|)
block|{
name|other
operator|.
name|accept
argument_list|(
name|finder
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|other
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|finder
operator|.
name|correlations
return|;
block|}
comment|/**    * Replaces all row expressions in the plan using the provided mapping.    *    * @param plan the relational expression on which we want to perform the replacements.    * @param mapping a mapping defining how to replace row expressions in the plan    * @return a new relational expression where all expressions present in the mapping are replaced.    */
specifier|private
specifier|static
name|RelNode
name|replaceExpressionsUsingMap
parameter_list|(
name|RelNode
name|plan
parameter_list|,
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|mapping
parameter_list|)
block|{
name|CallReplacer
name|replacer
init|=
operator|new
name|CallReplacer
argument_list|(
name|mapping
argument_list|)
decl_stmt|;
return|return
name|plan
operator|.
name|accept
argument_list|(
operator|new
name|RelHomogeneousShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RelNode
name|visit
parameter_list|(
name|RelNode
name|other
parameter_list|)
block|{
name|RelNode
name|mNode
init|=
name|super
operator|.
name|visitChildren
argument_list|(
name|other
argument_list|)
decl_stmt|;
return|return
name|mNode
operator|.
name|accept
argument_list|(
name|replacer
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * A collector of simply correlated row expressions.    *    * The shuttle traverses the tree and collects all calls and field accesses that are classified    * as simply correlated expressions. Multiple nodes in a call hierarchy may satisfy the criteria    * of a simple correlation so we peek the expressions closest to the root.    *    * @see SimpleCorrelationDetector    */
specifier|private
specifier|static
specifier|final
class|class
name|SimpleCorrelationCollector
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|CorrelationId
name|correlationId
decl_stmt|;
comment|// Clients are iterating over the collection thus it is better to use LinkedHashSet to keep
comment|// plans stable among executions.
specifier|private
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|correlations
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|SimpleCorrelationCollector
parameter_list|(
name|CorrelationId
name|corrId
parameter_list|)
block|{
name|this
operator|.
name|correlationId
operator|=
name|corrId
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|isSimpleCorrelatedExpression
argument_list|(
name|call
argument_list|,
name|correlationId
argument_list|)
condition|)
block|{
name|correlations
operator|.
name|add
argument_list|(
name|call
argument_list|)
expr_stmt|;
return|return
name|call
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
if|if
condition|(
name|isSimpleCorrelatedExpression
argument_list|(
name|fieldAccess
argument_list|,
name|correlationId
argument_list|)
condition|)
block|{
name|correlations
operator|.
name|add
argument_list|(
name|fieldAccess
argument_list|)
expr_stmt|;
return|return
name|fieldAccess
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|visitFieldAccess
argument_list|(
name|fieldAccess
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Returns whether the specified node is a simply correlated expression.    */
specifier|private
specifier|static
name|boolean
name|isSimpleCorrelatedExpression
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|CorrelationId
name|id
parameter_list|)
block|{
name|Boolean
name|r
init|=
name|node
operator|.
name|accept
argument_list|(
operator|new
name|SimpleCorrelationDetector
argument_list|(
name|id
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|r
operator|==
literal|null
condition|?
name|Boolean
operator|.
name|FALSE
else|:
name|r
return|;
block|}
comment|/**    * A visitor classifying row expressions as simply correlated if they satisfy the conditions    * below.    *<ul>    *<li>all correlated variables have the specified correlation id</li>    *<li>all leafs are either correlated variables, dynamic parameters, or literals</li>    *<li>intermediate nodes are either calls or field access expressions</li>    *</ul>    *    * Examples:    *<pre>{@code    * +(10, $cor0.DEPTNO) -> TRUE    * /(100,+(10, $cor0.DEPTNO)) -> TRUE    * CAST(+(10, $cor0.DEPTNO)):INTEGER NOT NULL -> TRUE    * +($0, $cor0.DEPTNO) -> FALSE    * }</pre>    *    */
specifier|private
specifier|static
class|class
name|SimpleCorrelationDetector
extends|extends
name|RexVisitorImpl
argument_list|<
annotation|@
name|Nullable
name|Boolean
argument_list|>
block|{
specifier|private
specifier|final
name|CorrelationId
name|corrId
decl_stmt|;
specifier|private
name|SimpleCorrelationDetector
parameter_list|(
name|CorrelationId
name|corrId
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|corrId
operator|=
name|corrId
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitOver
parameter_list|(
name|RexOver
name|over
parameter_list|)
block|{
return|return
name|Boolean
operator|.
name|FALSE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitSubQuery
parameter_list|(
name|RexSubQuery
name|subQuery
parameter_list|)
block|{
return|return
name|Boolean
operator|.
name|FALSE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|Boolean
name|hasSimpleCorrelation
init|=
literal|null
decl_stmt|;
for|for
control|(
name|RexNode
name|op
range|:
name|call
operator|.
name|operands
control|)
block|{
name|Boolean
name|b
init|=
name|op
operator|.
name|accept
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|null
condition|)
block|{
name|hasSimpleCorrelation
operator|=
name|hasSimpleCorrelation
operator|==
literal|null
condition|?
name|b
else|:
name|hasSimpleCorrelation
operator|&&
name|b
expr_stmt|;
block|}
block|}
return|return
name|hasSimpleCorrelation
operator|==
literal|null
condition|?
name|Boolean
operator|.
name|FALSE
else|:
name|hasSimpleCorrelation
return|;
block|}
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|Boolean
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
return|return
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
return|return
name|Boolean
operator|.
name|FALSE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|correlVariable
parameter_list|)
block|{
return|return
name|correlVariable
operator|.
name|id
operator|.
name|equals
argument_list|(
name|corrId
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitTableInputRef
parameter_list|(
name|RexTableInputRef
name|ref
parameter_list|)
block|{
return|return
name|Boolean
operator|.
name|FALSE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
return|return
name|Boolean
operator|.
name|FALSE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|visitPatternFieldRef
parameter_list|(
name|RexPatternFieldRef
name|fieldRef
parameter_list|)
block|{
return|return
name|Boolean
operator|.
name|FALSE
return|;
block|}
block|}
specifier|private
specifier|static
name|RexNode
name|replaceCorrelationsWithInputRef
parameter_list|(
name|RexNode
name|exp
parameter_list|,
name|RelBuilder
name|b
parameter_list|)
block|{
return|return
name|exp
operator|.
name|accept
argument_list|(
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
if|if
condition|(
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
operator|instanceof
name|RexCorrelVariable
condition|)
block|{
return|return
name|b
operator|.
name|field
argument_list|(
name|fieldAccess
operator|.
name|getField
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|visitFieldAccess
argument_list|(
name|fieldAccess
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * A visitor traversing row expressions and replacing calls with other expressions according    * to the specified mapping.    */
specifier|private
specifier|static
specifier|final
class|class
name|CallReplacer
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|mapping
decl_stmt|;
name|CallReplacer
parameter_list|(
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|mapping
parameter_list|)
block|{
name|this
operator|.
name|mapping
operator|=
name|mapping
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|oldCall
parameter_list|)
block|{
name|RexNode
name|newCall
init|=
name|mapping
operator|.
name|get
argument_list|(
name|oldCall
argument_list|)
decl_stmt|;
if|if
condition|(
name|newCall
operator|!=
literal|null
condition|)
block|{
return|return
name|newCall
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|oldCall
argument_list|)
return|;
block|}
block|}
block|}
block|}
end_class

end_unit

