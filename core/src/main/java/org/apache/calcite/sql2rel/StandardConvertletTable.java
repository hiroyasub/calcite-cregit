begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|DateTimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCallBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexRangeRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|SqlFunctions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBasicCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBinaryOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDataTypeSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunctionCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIntervalLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIntervalQualifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlJdbcFunctionCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNumericLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperatorBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWindowTableFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlArrayValueConstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlBetweenOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlDatetimeSubtractionOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlExtractFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlJsonValueFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibrary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperators
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLiteralChainOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlMapValueConstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlMultisetQueryConstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlMultisetValueConstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlOverlapsOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlRowOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlSequenceValueOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlSubstringFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlTrimFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlOperandTypeChecker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|initialization
operator|.
name|qual
operator|.
name|UnknownInitialization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|RoundingMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|NonNullableAccessors
operator|.
name|getComponentTypeOrThrow
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * Standard implementation of {@link SqlRexConvertletTable}.  */
end_comment

begin_class
specifier|public
class|class
name|StandardConvertletTable
extends|extends
name|ReflectiveConvertletTable
block|{
comment|/** Singleton instance. */
specifier|public
specifier|static
specifier|final
name|StandardConvertletTable
name|INSTANCE
init|=
operator|new
name|StandardConvertletTable
argument_list|()
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|private
name|StandardConvertletTable
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
comment|// Register aliases (operators which have a different name but
comment|// identical behavior to other operators).
name|addAlias
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CHARACTER_LENGTH
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CHAR_LENGTH
argument_list|)
expr_stmt|;
name|addAlias
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_UNKNOWN
argument_list|,
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|)
expr_stmt|;
name|addAlias
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_UNKNOWN
argument_list|,
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|)
expr_stmt|;
name|addAlias
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PERCENT_REMAINDER
argument_list|,
name|SqlStdOperatorTable
operator|.
name|MOD
argument_list|)
expr_stmt|;
comment|// Register convertlets for specific objects.
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|,
name|this
operator|::
name|convertCast
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|INFIX_CAST
argument_list|,
name|this
operator|::
name|convertCast
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_DISTINCT_FROM
argument_list|,
parameter_list|(
name|cx
parameter_list|,
name|call
parameter_list|)
lambda|->
name|convertIsDistinctFrom
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
argument_list|,
parameter_list|(
name|cx
parameter_list|,
name|call
parameter_list|)
lambda|->
name|convertIsDistinctFrom
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|this
operator|::
name|convertPlus
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS
argument_list|,
parameter_list|(
name|cx
parameter_list|,
name|call
parameter_list|)
lambda|->
block|{
specifier|final
name|RexCall
name|e
init|=
operator|(
name|RexCall
operator|)
name|StandardConvertletTable
operator|.
name|this
operator|.
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|DATE
case|:
case|case
name|TIME
case|:
case|case
name|TIMESTAMP
case|:
return|return
name|convertDatetimeMinus
argument_list|(
name|cx
argument_list|,
name|SqlStdOperatorTable
operator|.
name|MINUS_DATE
argument_list|,
name|call
argument_list|)
return|;
default|default:
return|return
name|e
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|LTRIM
argument_list|,
operator|new
name|TrimConvertlet
argument_list|(
name|SqlTrimFunction
operator|.
name|Flag
operator|.
name|LEADING
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|RTRIM
argument_list|,
operator|new
name|TrimConvertlet
argument_list|(
name|SqlTrimFunction
operator|.
name|Flag
operator|.
name|TRAILING
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|GREATEST
argument_list|,
operator|new
name|GreatestConvertlet
argument_list|()
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|LEAST
argument_list|,
operator|new
name|GreatestConvertlet
argument_list|()
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|SUBSTR_BIG_QUERY
argument_list|,
operator|new
name|SubstrConvertlet
argument_list|(
name|SqlLibrary
operator|.
name|BIG_QUERY
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|SUBSTR_MYSQL
argument_list|,
operator|new
name|SubstrConvertlet
argument_list|(
name|SqlLibrary
operator|.
name|MYSQL
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|SUBSTR_ORACLE
argument_list|,
operator|new
name|SubstrConvertlet
argument_list|(
name|SqlLibrary
operator|.
name|ORACLE
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|SUBSTR_POSTGRESQL
argument_list|,
operator|new
name|SubstrConvertlet
argument_list|(
name|SqlLibrary
operator|.
name|POSTGRESQL
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|NVL
argument_list|,
name|StandardConvertletTable
operator|::
name|convertNvl
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|DECODE
argument_list|,
name|StandardConvertletTable
operator|::
name|convertDecode
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|IF
argument_list|,
name|StandardConvertletTable
operator|::
name|convertIf
argument_list|)
expr_stmt|;
comment|// Expand "x NOT LIKE y" into "NOT (x LIKE y)"
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_LIKE
argument_list|,
parameter_list|(
name|cx
parameter_list|,
name|call
parameter_list|)
lambda|->
name|cx
operator|.
name|convertExpression
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|SqlStdOperatorTable
operator|.
name|LIKE
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Expand "x NOT ILIKE y" into "NOT (x ILIKE y)"
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|NOT_ILIKE
argument_list|,
parameter_list|(
name|cx
parameter_list|,
name|call
parameter_list|)
lambda|->
name|cx
operator|.
name|convertExpression
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|SqlLibraryOperators
operator|.
name|ILIKE
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Expand "x NOT RLIKE y" into "NOT (x RLIKE y)"
name|registerOp
argument_list|(
name|SqlLibraryOperators
operator|.
name|NOT_RLIKE
argument_list|,
parameter_list|(
name|cx
parameter_list|,
name|call
parameter_list|)
lambda|->
name|cx
operator|.
name|convertExpression
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|SqlLibraryOperators
operator|.
name|RLIKE
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Expand "x NOT SIMILAR y" into "NOT (x SIMILAR y)"
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_SIMILAR_TO
argument_list|,
parameter_list|(
name|cx
parameter_list|,
name|call
parameter_list|)
lambda|->
name|cx
operator|.
name|convertExpression
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|SqlStdOperatorTable
operator|.
name|SIMILAR_TO
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Unary "+" has no effect, so expand "+ x" into "x".
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|UNARY_PLUS
argument_list|,
parameter_list|(
name|cx
parameter_list|,
name|call
parameter_list|)
lambda|->
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// "DOT"
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DOT
argument_list|,
parameter_list|(
name|cx
parameter_list|,
name|call
parameter_list|)
lambda|->
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// "ITEM"
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ITEM
argument_list|,
name|this
operator|::
name|convertItem
argument_list|)
expr_stmt|;
comment|// "AS" has no effect, so expand "x AS id" into "x".
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AS
argument_list|,
parameter_list|(
name|cx
parameter_list|,
name|call
parameter_list|)
lambda|->
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// "SQRT(x)" is equivalent to "POWER(x, .5)"
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SQRT
argument_list|,
parameter_list|(
name|cx
parameter_list|,
name|call
parameter_list|)
lambda|->
name|cx
operator|.
name|convertExpression
argument_list|(
name|SqlStdOperatorTable
operator|.
name|POWER
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"0.5"
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// REVIEW jvs 24-Apr-2006: This only seems to be working from within a
comment|// windowed agg.  I have added an optimizer rule
comment|// org.apache.calcite.rel.rules.AggregateReduceFunctionsRule which handles
comment|// other cases post-translation.  The reason I did that was to defer the
comment|// implementation decision; e.g. we may want to push it down to a foreign
comment|// server directly rather than decomposed; decomposition is easier than
comment|// recognition.
comment|// Convert "avg(<expr>)" to "cast(sum(<expr>) / count(<expr>) as
comment|//<type>)". We don't need to handle the empty set specially, because
comment|// the SUM is already supposed to come out as NULL in cases where the
comment|// COUNT is zero, so the null check should take place first and prevent
comment|// division by zero. We need the cast because SUM and COUNT may use
comment|// different types, say BIGINT.
comment|//
comment|// Similarly STDDEV_POP and STDDEV_SAMP, VAR_POP and VAR_SAMP.
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AVG
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|AVG
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|STDDEV_POP
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|STDDEV_POP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|STDDEV_SAMP
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|STDDEV_SAMP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|STDDEV
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|STDDEV_SAMP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|VAR_POP
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|VAR_POP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|VAR_SAMP
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|VAR_SAMP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|VARIANCE
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|VAR_SAMP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COVAR_POP
argument_list|,
operator|new
name|RegrCovarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|COVAR_POP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COVAR_SAMP
argument_list|,
operator|new
name|RegrCovarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|COVAR_SAMP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|REGR_SXX
argument_list|,
operator|new
name|RegrCovarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|REGR_SXX
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|REGR_SYY
argument_list|,
operator|new
name|RegrCovarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|REGR_SYY
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|SqlRexConvertlet
name|floorCeilConvertlet
init|=
operator|new
name|FloorCeilConvertlet
argument_list|()
decl_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|FLOOR
argument_list|,
name|floorCeilConvertlet
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CEIL
argument_list|,
name|floorCeilConvertlet
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|TIMESTAMP_ADD
argument_list|,
operator|new
name|TimestampAddConvertlet
argument_list|()
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|TIMESTAMP_DIFF
argument_list|,
operator|new
name|TimestampDiffConvertlet
argument_list|()
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|INTERVAL
argument_list|,
name|StandardConvertletTable
operator|::
name|convertInterval
argument_list|)
expr_stmt|;
comment|// Convert "element(<expr>)" to "$element_slice(<expr>)", if the
comment|// expression is a multiset of scalars.
if|if
condition|(
literal|false
condition|)
block|{
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ELEMENT
argument_list|,
parameter_list|(
name|cx
parameter_list|,
name|call
parameter_list|)
lambda|->
block|{
assert|assert
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|SqlNode
name|operand
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|getComponentTypeOrThrow
argument_list|(
name|type
argument_list|)
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ELEMENT_SLICE
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|operand
argument_list|)
argument_list|)
return|;
block|}
comment|// fallback on default behavior
return|return
name|StandardConvertletTable
operator|.
name|this
operator|.
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
argument_list|)
expr_stmt|;
block|}
comment|// Convert "$element_slice(<expr>)" to "element(<expr>).field#0"
if|if
condition|(
literal|false
condition|)
block|{
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ELEMENT_SLICE
argument_list|,
parameter_list|(
name|cx
parameter_list|,
name|call
parameter_list|)
lambda|->
block|{
assert|assert
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|SqlNode
name|operand
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|expr
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ELEMENT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|operand
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
return|;
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Converts a call to the NVL function. */
specifier|private
specifier|static
name|RexNode
name|convertNvl
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|operand0
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|operand1
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
comment|// Preserve Operand Nullability
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|operand0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|operand0
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|)
argument_list|,
name|operand0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|operand1
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|)
argument_list|,
name|operand1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Converts a call to the DECODE function. */
specifier|private
specifier|static
name|RexNode
name|convertDecode
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|convertOperands
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|RelOptUtil
operator|.
name|isDistinctFrom
argument_list|(
name|rexBuilder
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|operands
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|operands
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|exprs
argument_list|)
return|;
block|}
comment|/** Converts a call to the IF function.    *    *<p>{@code IF(b, x, y)}&rarr; {@code CASE WHEN b THEN x ELSE y END}. */
specifier|private
specifier|static
name|RexNode
name|convertIf
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|convertOperands
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|/** Converts an interval expression to a numeric multiplied by an interval    * literal. */
specifier|private
specifier|static
name|RexNode
name|convertInterval
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// "INTERVAL n HOUR" becomes "n * INTERVAL '1' HOUR"
specifier|final
name|SqlNode
name|n
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlIntervalQualifier
name|intervalQualifier
init|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|SqlIntervalLiteral
name|literal
init|=
name|SqlLiteral
operator|.
name|createInterval
argument_list|(
literal|1
argument_list|,
literal|"1"
argument_list|,
name|intervalQualifier
argument_list|,
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlCall
name|multiply
init|=
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|n
argument_list|,
name|literal
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|multiply
argument_list|)
return|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|private
specifier|static
name|RexNode
name|or
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|a0
parameter_list|,
name|RexNode
name|a1
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|eq
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|a0
parameter_list|,
name|RexNode
name|a1
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|ge
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|a0
parameter_list|,
name|RexNode
name|a1
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|le
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|a0
parameter_list|,
name|RexNode
name|a1
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|and
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|a0
parameter_list|,
name|RexNode
name|a1
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|divideInt
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|a0
parameter_list|,
name|RexNode
name|a1
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DIVIDE_INTEGER
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|plus
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|a0
parameter_list|,
name|RexNode
name|a1
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|minus
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|a0
parameter_list|,
name|RexNode
name|a1
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|multiply
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|a0
parameter_list|,
name|RexNode
name|a1
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|case_
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
modifier|...
name|args
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|// SqlNode helpers
specifier|private
specifier|static
name|SqlCall
name|plus
parameter_list|(
name|SqlParserPos
name|pos
parameter_list|,
name|SqlNode
name|a0
parameter_list|,
name|SqlNode
name|a1
parameter_list|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|PLUS
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|)
return|;
block|}
comment|/**    * Converts a CASE expression.    */
specifier|public
name|RexNode
name|convertCase
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCase
name|call
parameter_list|)
block|{
name|SqlNodeList
name|whenList
init|=
name|call
operator|.
name|getWhenOperands
argument_list|()
decl_stmt|;
name|SqlNodeList
name|thenList
init|=
name|call
operator|.
name|getThenOperands
argument_list|()
decl_stmt|;
assert|assert
name|whenList
operator|.
name|size
argument_list|()
operator|==
name|thenList
operator|.
name|size
argument_list|()
assert|;
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RexLiteral
name|unknownLiteral
init|=
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|nullLiteral
init|=
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|whenList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SqlUtil
operator|.
name|isNullLiteral
argument_list|(
name|whenList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|exprList
operator|.
name|add
argument_list|(
name|unknownLiteral
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exprList
operator|.
name|add
argument_list|(
name|cx
operator|.
name|convertExpression
argument_list|(
name|whenList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SqlUtil
operator|.
name|isNullLiteral
argument_list|(
name|thenList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|exprList
operator|.
name|add
argument_list|(
name|nullLiteral
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exprList
operator|.
name|add
argument_list|(
name|cx
operator|.
name|convertExpression
argument_list|(
name|thenList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SqlNode
name|elseOperand
init|=
name|call
operator|.
name|getElseOperand
argument_list|()
decl_stmt|;
if|if
condition|(
name|SqlUtil
operator|.
name|isNullLiteral
argument_list|(
name|elseOperand
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|exprList
operator|.
name|add
argument_list|(
name|nullLiteral
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exprList
operator|.
name|add
argument_list|(
name|cx
operator|.
name|convertExpression
argument_list|(
name|requireNonNull
argument_list|(
name|elseOperand
argument_list|,
literal|"elseOperand"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RelDataType
name|type
init|=
name|rexBuilder
operator|.
name|deriveReturnType
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|exprList
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|elseArgs
argument_list|(
name|exprList
operator|.
name|size
argument_list|()
argument_list|)
control|)
block|{
name|exprList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|rexBuilder
operator|.
name|ensureType
argument_list|(
name|type
argument_list|,
name|exprList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|exprList
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertMultiset
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlMultisetValueConstructor
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RelDataType
name|originalType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|RexRangeRef
name|rr
init|=
name|cx
operator|.
name|getSubQueryExpr
argument_list|(
name|call
argument_list|)
decl_stmt|;
assert|assert
name|rr
operator|!=
literal|null
assert|;
name|RelDataType
name|msType
init|=
name|rr
operator|.
name|getType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RexNode
name|expr
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|msType
argument_list|,
name|rr
operator|.
name|getOffset
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|msType
operator|.
name|getComponentType
argument_list|()
operator|!=
literal|null
operator|&&
name|msType
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
operator|:
literal|"componentType of "
operator|+
name|msType
operator|+
literal|" must be struct"
assert|;
assert|assert
name|originalType
operator|.
name|getComponentType
argument_list|()
operator|!=
literal|null
operator|:
literal|"componentType of "
operator|+
name|originalType
operator|+
literal|" must be struct"
assert|;
if|if
condition|(
operator|!
name|originalType
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
comment|// If the type is not a struct, the multiset operator will have
comment|// wrapped the type as a record. Add a call to the $SLICE operator
comment|// to compensate. For example,
comment|// if '<ms>' has type 'RECORD (INTEGER x) MULTISET',
comment|// then '$SLICE(<ms>) has type 'INTEGER MULTISET'.
comment|// This will be removed as the expression is translated.
name|expr
operator|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|originalType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|SLICE
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
specifier|public
name|RexNode
name|convertArray
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlArrayValueConstructor
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertMap
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlMapValueConstructor
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertMultisetQuery
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlMultisetQueryConstructor
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RelDataType
name|originalType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|RexRangeRef
name|rr
init|=
name|cx
operator|.
name|getSubQueryExpr
argument_list|(
name|call
argument_list|)
decl_stmt|;
assert|assert
name|rr
operator|!=
literal|null
assert|;
name|RelDataType
name|msType
init|=
name|rr
operator|.
name|getType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RexNode
name|expr
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|msType
argument_list|,
name|rr
operator|.
name|getOffset
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|msType
operator|.
name|getComponentType
argument_list|()
operator|!=
literal|null
operator|&&
name|msType
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
operator|:
literal|"componentType of "
operator|+
name|msType
operator|+
literal|" must be struct"
assert|;
assert|assert
name|originalType
operator|.
name|getComponentType
argument_list|()
operator|!=
literal|null
operator|:
literal|"componentType of "
operator|+
name|originalType
operator|+
literal|" must be struct"
assert|;
if|if
condition|(
operator|!
name|originalType
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
comment|// If the type is not a struct, the multiset operator will have
comment|// wrapped the type as a record. Add a call to the $SLICE operator
comment|// to compensate. For example,
comment|// if '<ms>' has type 'RECORD (INTEGER x) MULTISET',
comment|// then '$SLICE(<ms>) has type 'INTEGER MULTISET'.
comment|// This will be removed as the expression is translated.
name|expr
operator|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SLICE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
specifier|public
name|RexNode
name|convertJdbc
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlJdbcFunctionCall
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Yuck!! The function definition contains arguments!
comment|// TODO: adopt a more conventional definition/instance structure
specifier|final
name|SqlCall
name|convertedCall
init|=
name|op
operator|.
name|getLookupCall
argument_list|()
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|convertedCall
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|convertCast
parameter_list|(
annotation|@
name|UnknownInitialization
name|StandardConvertletTable
name|this
parameter_list|,
name|SqlRexContext
name|cx
parameter_list|,
specifier|final
name|SqlCall
name|call
parameter_list|)
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
assert|assert
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
assert|;
specifier|final
name|SqlNode
name|left
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|right
init|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|right
operator|instanceof
name|SqlIntervalQualifier
condition|)
block|{
specifier|final
name|SqlIntervalQualifier
name|intervalQualifier
init|=
operator|(
name|SqlIntervalQualifier
operator|)
name|right
decl_stmt|;
if|if
condition|(
name|left
operator|instanceof
name|SqlIntervalLiteral
condition|)
block|{
name|RexLiteral
name|sourceInterval
init|=
operator|(
name|RexLiteral
operator|)
name|cx
operator|.
name|convertExpression
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|BigDecimal
name|sourceValue
init|=
operator|(
name|BigDecimal
operator|)
name|sourceInterval
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|RexLiteral
name|castedInterval
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeIntervalLiteral
argument_list|(
name|sourceValue
argument_list|,
name|intervalQualifier
argument_list|)
decl_stmt|;
return|return
name|castToValidatedType
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|castedInterval
argument_list|)
return|;
block|}
if|else if
condition|(
name|left
operator|instanceof
name|SqlNumericLiteral
condition|)
block|{
name|RexLiteral
name|sourceInterval
init|=
operator|(
name|RexLiteral
operator|)
name|cx
operator|.
name|convertExpression
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|BigDecimal
name|sourceValue
init|=
operator|(
name|BigDecimal
operator|)
name|sourceInterval
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|BigDecimal
name|multiplier
init|=
name|intervalQualifier
operator|.
name|getUnit
argument_list|()
operator|.
name|multiplier
decl_stmt|;
name|sourceValue
operator|=
name|SqlFunctions
operator|.
name|multiply
argument_list|(
name|sourceValue
argument_list|,
name|multiplier
argument_list|)
expr_stmt|;
name|RexLiteral
name|castedInterval
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeIntervalLiteral
argument_list|(
name|sourceValue
argument_list|,
name|intervalQualifier
argument_list|)
decl_stmt|;
return|return
name|castToValidatedType
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|castedInterval
argument_list|)
return|;
block|}
return|return
name|castToValidatedType
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|left
argument_list|)
argument_list|)
return|;
block|}
name|SqlDataTypeSpec
name|dataType
init|=
operator|(
name|SqlDataTypeSpec
operator|)
name|right
decl_stmt|;
name|RelDataType
name|type
init|=
name|dataType
operator|.
name|deriveType
argument_list|(
name|cx
operator|.
name|getValidator
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
name|type
operator|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|dataType
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|arg
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|left
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SqlUtil
operator|.
name|isNullLiteral
argument_list|(
name|left
argument_list|,
literal|false
argument_list|)
condition|)
block|{
specifier|final
name|SqlValidatorImpl
name|validator
init|=
operator|(
name|SqlValidatorImpl
operator|)
name|cx
operator|.
name|getValidator
argument_list|()
decl_stmt|;
name|validator
operator|.
name|setValidatedNodeType
argument_list|(
name|left
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|left
argument_list|)
return|;
block|}
if|if
condition|(
literal|null
operator|!=
name|dataType
operator|.
name|getCollectionsTypeName
argument_list|()
condition|)
block|{
specifier|final
name|RelDataType
name|argComponentType
init|=
name|requireNonNull
argument_list|(
name|arg
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"componentType of "
operator|+
name|arg
argument_list|)
decl_stmt|;
name|RelDataType
name|typeFinal
init|=
name|type
decl_stmt|;
specifier|final
name|RelDataType
name|componentType
init|=
name|requireNonNull
argument_list|(
name|type
operator|.
name|getComponentType
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"componentType of "
operator|+
name|typeFinal
argument_list|)
decl_stmt|;
if|if
condition|(
name|argComponentType
operator|.
name|isStruct
argument_list|()
operator|&&
operator|!
name|componentType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|RelDataType
name|tt
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
name|argComponentType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
name|componentType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|tt
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|tt
argument_list|,
name|componentType
operator|.
name|isNullable
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|isn
init|=
name|type
operator|.
name|isNullable
argument_list|()
decl_stmt|;
name|type
operator|=
name|typeFactory
operator|.
name|createMultisetType
argument_list|(
name|tt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|isn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|convertFloorCeil
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|boolean
name|floor
init|=
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|FLOOR
decl_stmt|;
comment|// Rewrite floor, ceil of interval
if|if
condition|(
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|1
operator|&&
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|SqlIntervalLiteral
condition|)
block|{
specifier|final
name|SqlIntervalLiteral
name|literal
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|SqlIntervalLiteral
operator|.
name|IntervalValue
name|interval
init|=
name|literal
operator|.
name|getValueAs
argument_list|(
name|SqlIntervalLiteral
operator|.
name|IntervalValue
operator|.
name|class
argument_list|)
decl_stmt|;
name|BigDecimal
name|val
init|=
name|interval
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getStartUnit
argument_list|()
operator|.
name|multiplier
decl_stmt|;
name|RexNode
name|rexInterval
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|literal
argument_list|)
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexNode
name|zero
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|cond
init|=
name|ge
argument_list|(
name|rexBuilder
argument_list|,
name|rexInterval
argument_list|,
name|zero
argument_list|)
decl_stmt|;
name|RexNode
name|pad
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|val
operator|.
name|subtract
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|cast
init|=
name|rexBuilder
operator|.
name|makeReinterpretCast
argument_list|(
name|rexInterval
operator|.
name|getType
argument_list|()
argument_list|,
name|pad
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|sum
init|=
name|floor
condition|?
name|minus
argument_list|(
name|rexBuilder
argument_list|,
name|rexInterval
argument_list|,
name|cast
argument_list|)
else|:
name|plus
argument_list|(
name|rexBuilder
argument_list|,
name|rexInterval
argument_list|,
name|cast
argument_list|)
decl_stmt|;
name|RexNode
name|kase
init|=
name|floor
condition|?
name|case_
argument_list|(
name|rexBuilder
argument_list|,
name|rexInterval
argument_list|,
name|cond
argument_list|,
name|sum
argument_list|)
else|:
name|case_
argument_list|(
name|rexBuilder
argument_list|,
name|sum
argument_list|,
name|cond
argument_list|,
name|rexInterval
argument_list|)
decl_stmt|;
name|RexNode
name|factor
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|RexNode
name|div
init|=
name|divideInt
argument_list|(
name|rexBuilder
argument_list|,
name|kase
argument_list|,
name|factor
argument_list|)
decl_stmt|;
return|return
name|multiply
argument_list|(
name|rexBuilder
argument_list|,
name|div
argument_list|,
name|factor
argument_list|)
return|;
block|}
comment|// normal floor, ceil function
return|return
name|convertFunction
argument_list|(
name|cx
argument_list|,
operator|(
name|SqlFunction
operator|)
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|call
argument_list|)
return|;
block|}
comment|/**    * Converts a call to the {@code EXTRACT} function.    *    *<p>Called automatically via reflection.    */
specifier|public
name|RexNode
name|convertExtract
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlExtractFunction
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertFunction
argument_list|(
name|cx
argument_list|,
operator|(
name|SqlFunction
operator|)
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|call
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
specifier|static
name|RexNode
name|mod
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelDataType
name|resType
parameter_list|,
name|RexNode
name|res
parameter_list|,
name|BigDecimal
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|.
name|equals
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
condition|)
block|{
return|return
name|res
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MOD
argument_list|,
name|res
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|val
argument_list|,
name|resType
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|divide
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|res
parameter_list|,
name|BigDecimal
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|.
name|equals
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
condition|)
block|{
return|return
name|res
return|;
block|}
comment|// If val is between 0 and 1, rather than divide by val, multiply by its
comment|// reciprocal. For example, rather than divide by 0.001 multiply by 1000.
if|if
condition|(
name|val
operator|.
name|compareTo
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
operator|<
literal|0
operator|&&
name|val
operator|.
name|signum
argument_list|()
operator|==
literal|1
condition|)
block|{
try|try
block|{
specifier|final
name|BigDecimal
name|reciprocal
init|=
name|BigDecimal
operator|.
name|ONE
operator|.
name|divide
argument_list|(
name|val
argument_list|,
name|RoundingMode
operator|.
name|UNNECESSARY
argument_list|)
decl_stmt|;
return|return
name|multiply
argument_list|(
name|rexBuilder
argument_list|,
name|res
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|reciprocal
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|e
parameter_list|)
block|{
comment|// ignore - reciprocal is not an integer
block|}
block|}
return|return
name|divideInt
argument_list|(
name|rexBuilder
argument_list|,
name|res
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertDatetimeMinus
parameter_list|(
annotation|@
name|UnknownInitialization
name|StandardConvertletTable
name|this
parameter_list|,
name|SqlRexContext
name|cx
parameter_list|,
name|SqlDatetimeSubtractionOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Rewrite datetime minus
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|convertOperands
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|resType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|resType
argument_list|,
name|op
argument_list|,
name|exprs
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertFunction
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlFunction
name|fun
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|convertOperands
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
decl_stmt|;
if|if
condition|(
name|fun
operator|.
name|getFunctionType
argument_list|()
operator|==
name|SqlFunctionCategory
operator|.
name|USER_DEFINED_CONSTRUCTOR
condition|)
block|{
return|return
name|makeConstructorCall
argument_list|(
name|cx
argument_list|,
name|fun
argument_list|,
name|exprs
argument_list|)
return|;
block|}
name|RelDataType
name|returnType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeTypeIfKnown
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|returnType
operator|==
literal|null
condition|)
block|{
name|returnType
operator|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|deriveReturnType
argument_list|(
name|fun
argument_list|,
name|exprs
argument_list|)
expr_stmt|;
block|}
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|returnType
argument_list|,
name|fun
argument_list|,
name|exprs
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertWindowFunction
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlWindowTableFunction
name|fun
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// The first operand of window function is actually a query, skip that.
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|Util
operator|.
name|skip
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|convertOperands
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|operands
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
decl_stmt|;
name|RelDataType
name|returnType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeTypeIfKnown
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|returnType
operator|==
literal|null
condition|)
block|{
name|returnType
operator|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|deriveReturnType
argument_list|(
name|fun
argument_list|,
name|exprs
argument_list|)
expr_stmt|;
block|}
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|returnType
argument_list|,
name|fun
argument_list|,
name|exprs
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertJsonValueFunction
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlJsonValueFunction
name|fun
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// For Expression with explicit return type:
comment|// i.e. json_value('{"foo":"bar"}', 'lax $.foo', returning varchar(2000))
comment|// use the specified type as the return type.
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"all"
argument_list|)
name|boolean
name|hasExplicitReturningType
init|=
name|SqlJsonValueFunction
operator|.
name|hasExplicitTypeSpec
argument_list|(
name|operands
operator|.
name|toArray
argument_list|(
name|SqlNode
operator|.
name|EMPTY_ARRAY
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasExplicitReturningType
condition|)
block|{
name|operands
operator|=
name|SqlJsonValueFunction
operator|.
name|removeTypeSpecOperands
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|convertOperands
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|operands
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
decl_stmt|;
name|RelDataType
name|returnType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeTypeIfKnown
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|requireNonNull
argument_list|(
name|returnType
argument_list|,
parameter_list|()
lambda|->
literal|"Unable to get type of "
operator|+
name|call
argument_list|)
expr_stmt|;
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|returnType
argument_list|,
name|fun
argument_list|,
name|exprs
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertSequenceValue
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlSequenceValueOperator
name|fun
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
assert|assert
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
assert|assert
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|SqlIdentifier
assert|;
specifier|final
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|String
name|key
init|=
name|Util
operator|.
name|listToString
argument_list|(
name|id
operator|.
name|names
argument_list|)
decl_stmt|;
name|RelDataType
name|returnType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|returnType
argument_list|,
name|fun
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertAggregateFunction
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlAggFunction
name|fun
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|isCountStar
argument_list|()
condition|)
block|{
name|exprs
operator|=
name|ImmutableList
operator|.
name|of
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|exprs
operator|=
name|convertOperands
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
expr_stmt|;
block|}
name|RelDataType
name|returnType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeTypeIfKnown
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|int
name|groupCount
init|=
name|cx
operator|.
name|getGroupCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|returnType
operator|==
literal|null
condition|)
block|{
name|RexCallBinding
name|binding
init|=
operator|new
name|RexCallBinding
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|fun
argument_list|,
name|exprs
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|int
name|getGroupCount
parameter_list|()
block|{
return|return
name|groupCount
return|;
block|}
block|}
decl_stmt|;
name|returnType
operator|=
name|fun
operator|.
name|inferReturnType
argument_list|(
name|binding
argument_list|)
expr_stmt|;
block|}
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|returnType
argument_list|,
name|fun
argument_list|,
name|exprs
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|makeConstructorCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlFunction
name|constructor
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataType
name|type
init|=
name|rexBuilder
operator|.
name|deriveReturnType
argument_list|(
name|constructor
argument_list|,
name|exprs
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|type
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|initializationExprs
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|InitializerContext
name|initializerContext
init|=
operator|new
name|InitializerContext
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexBuilder
name|getRexBuilder
parameter_list|()
block|{
return|return
name|rexBuilder
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|validateExpression
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|SqlNode
name|expr
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|convertExpression
parameter_list|(
name|SqlNode
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|initializationExprs
operator|.
name|add
argument_list|(
name|cx
operator|.
name|getInitializerExpressionFactory
argument_list|()
operator|.
name|newAttributeInitializer
argument_list|(
name|type
argument_list|,
name|constructor
argument_list|,
name|i
argument_list|,
name|exprs
argument_list|,
name|initializerContext
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|defaultCasts
init|=
name|RexUtil
operator|.
name|generateCastExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|type
argument_list|,
name|initializationExprs
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeNewInvocation
argument_list|(
name|type
argument_list|,
name|defaultCasts
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|convertItem
parameter_list|(
annotation|@
name|UnknownInitialization
name|StandardConvertletTable
name|this
parameter_list|,
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
name|SqlOperandTypeChecker
name|operandTypeChecker
init|=
name|op
operator|.
name|getOperandTypeChecker
argument_list|()
decl_stmt|;
specifier|final
name|SqlOperandTypeChecker
operator|.
name|Consistency
name|consistency
init|=
name|operandTypeChecker
operator|==
literal|null
condition|?
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
else|:
name|operandTypeChecker
operator|.
name|getConsistency
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|convertOperands
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|consistency
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|collectionType
init|=
name|exprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isRowTypeField
init|=
name|SqlTypeUtil
operator|.
name|isRow
argument_list|(
name|collectionType
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isNumericIndex
init|=
name|SqlTypeUtil
operator|.
name|isIntType
argument_list|(
name|exprs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|isRowTypeField
operator|&&
name|isNumericIndex
condition|)
block|{
specifier|final
name|SqlOperatorBinding
name|opBinding
init|=
operator|new
name|RexCallBinding
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|op
argument_list|,
name|exprs
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|operandType
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Integer
name|index
init|=
name|opBinding
operator|.
name|getOperandLiteralValue
argument_list|(
literal|1
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|null
operator|||
name|index
operator|<
literal|1
operator|||
name|index
operator|>
name|operandType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Cannot access field at position "
operator|+
name|index
operator|+
literal|" within ROW type: "
operator|+
name|operandType
argument_list|)
throw|;
block|}
else|else
block|{
name|RelDataTypeField
name|relDataTypeField
init|=
name|collectionType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|index
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|exprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|relDataTypeField
operator|.
name|getName
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
name|RelDataType
name|type
init|=
name|rexBuilder
operator|.
name|deriveReturnType
argument_list|(
name|op
argument_list|,
name|exprs
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|op
argument_list|,
name|RexUtil
operator|.
name|flatten
argument_list|(
name|exprs
argument_list|,
name|op
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Converts a call to an operator into a {@link RexCall} to the same    * operator.    *    *<p>Called automatically via reflection.    *    * @param cx   Context    * @param call Call    * @return Rex call    */
specifier|public
name|RexNode
name|convertCall
parameter_list|(
annotation|@
name|UnknownInitialization
name|StandardConvertletTable
name|this
parameter_list|,
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|SqlOperandTypeChecker
name|operandTypeChecker
init|=
name|op
operator|.
name|getOperandTypeChecker
argument_list|()
decl_stmt|;
specifier|final
name|SqlOperandTypeChecker
operator|.
name|Consistency
name|consistency
init|=
name|operandTypeChecker
operator|==
literal|null
condition|?
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
else|:
name|operandTypeChecker
operator|.
name|getConsistency
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|convertOperands
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|consistency
argument_list|)
decl_stmt|;
name|RelDataType
name|type
init|=
name|rexBuilder
operator|.
name|deriveReturnType
argument_list|(
name|op
argument_list|,
name|exprs
argument_list|)
decl_stmt|;
comment|// Expand 'ROW (x0, x1, ...) = ROW (y0, y1, ...)'
comment|// to 'x0 = y0 AND x1 = y1 AND ...'
if|if
condition|(
name|op
operator|.
name|kind
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
specifier|final
name|RexNode
name|expr0
init|=
name|RexUtil
operator|.
name|removeCast
argument_list|(
name|exprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|expr1
init|=
name|RexUtil
operator|.
name|removeCast
argument_list|(
name|exprs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr0
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ROW
operator|&&
name|expr1
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ROW
condition|)
block|{
specifier|final
name|RexCall
name|call0
init|=
operator|(
name|RexCall
operator|)
name|expr0
decl_stmt|;
specifier|final
name|RexCall
name|call1
init|=
operator|(
name|RexCall
operator|)
name|expr1
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|eqList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Pair
operator|.
name|forEach
argument_list|(
name|call0
operator|.
name|getOperands
argument_list|()
argument_list|,
name|call1
operator|.
name|getOperands
argument_list|()
argument_list|,
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
lambda|->
name|eqList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|eqList
argument_list|)
return|;
block|}
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|op
argument_list|,
name|RexUtil
operator|.
name|flatten
argument_list|(
name|exprs
argument_list|,
name|op
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|elseArgs
parameter_list|(
name|int
name|count
parameter_list|)
block|{
comment|// If list is odd, e.g. [0, 1, 2, 3, 4] we get [1, 3, 4]
comment|// If list is even, e.g. [0, 1, 2, 3, 4, 5] we get [2, 4, 5]
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|count
operator|%
literal|2
init|;
condition|;
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|count
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|list
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|convertOperands
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
name|consistency
parameter_list|)
block|{
return|return
name|convertOperands
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|,
name|consistency
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|convertOperands
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodes
parameter_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
name|consistency
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|nodes
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|cx
operator|.
name|convertExpression
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|operandTypes
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedOperandTypes
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|operandTypes
operator|!=
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|oldExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|exprs
argument_list|)
decl_stmt|;
name|exprs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Pair
operator|.
name|forEach
argument_list|(
name|oldExprs
argument_list|,
name|operandTypes
argument_list|,
parameter_list|(
name|expr
parameter_list|,
name|type
parameter_list|)
lambda|->
name|exprs
operator|.
name|add
argument_list|(
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exprs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|consistentType
argument_list|(
name|cx
argument_list|,
name|consistency
argument_list|,
name|RexUtil
operator|.
name|types
argument_list|(
name|exprs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|oldExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|exprs
argument_list|)
decl_stmt|;
name|exprs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|oldExprs
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|exprs
return|;
block|}
specifier|private
specifier|static
annotation|@
name|Nullable
name|RelDataType
name|consistentType
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
name|consistency
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
parameter_list|)
block|{
switch|switch
condition|(
name|consistency
condition|)
block|{
case|case
name|COMPARE
case|:
if|if
condition|(
name|SqlTypeUtil
operator|.
name|areSameFamily
argument_list|(
name|types
argument_list|)
condition|)
block|{
comment|// All arguments are of same family. No need for explicit casts.
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|nonCharacterTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataType
name|type
range|:
name|types
control|)
block|{
if|if
condition|(
name|type
operator|.
name|getFamily
argument_list|()
operator|!=
name|SqlTypeFamily
operator|.
name|CHARACTER
condition|)
block|{
name|nonCharacterTypes
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|nonCharacterTypes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|int
name|typeCount
init|=
name|types
operator|.
name|size
argument_list|()
decl_stmt|;
name|types
operator|=
name|nonCharacterTypes
expr_stmt|;
if|if
condition|(
name|nonCharacterTypes
operator|.
name|size
argument_list|()
operator|<
name|typeCount
condition|)
block|{
specifier|final
name|RelDataTypeFamily
name|family
init|=
name|nonCharacterTypes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFamily
argument_list|()
decl_stmt|;
if|if
condition|(
name|family
operator|instanceof
name|SqlTypeFamily
condition|)
block|{
comment|// The character arguments might be larger than the numeric
comment|// argument. Give ourselves some headroom.
switch|switch
condition|(
operator|(
name|SqlTypeFamily
operator|)
name|family
condition|)
block|{
case|case
name|INTEGER
case|:
case|case
name|NUMERIC
case|:
name|nonCharacterTypes
operator|.
name|add
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
block|}
comment|// fall through
case|case
name|LEAST_RESTRICTIVE
case|:
return|return
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|leastRestrictive
argument_list|(
name|types
argument_list|)
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|RexNode
name|convertPlus
parameter_list|(
annotation|@
name|UnknownInitialization
name|StandardConvertletTable
name|this
parameter_list|,
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RexNode
name|rex
init|=
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rex
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|DATE
case|:
case|case
name|TIME
case|:
case|case
name|TIMESTAMP
case|:
comment|// Use special "+" operator for datetime + interval.
comment|// Re-order operands, if necessary, so that interval is second.
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
specifier|final
name|SqlTypeName
name|sqlTypeName
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|sqlTypeName
condition|)
block|{
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
name|operands
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|rex
operator|.
name|getType
argument_list|()
argument_list|,
name|SqlStdOperatorTable
operator|.
name|DATETIME_PLUS
argument_list|,
name|operands
argument_list|)
return|;
default|default:
return|return
name|rex
return|;
block|}
block|}
specifier|private
name|RexNode
name|convertIsDistinctFrom
parameter_list|(
annotation|@
name|UnknownInitialization
name|StandardConvertletTable
name|this
parameter_list|,
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|boolean
name|neg
parameter_list|)
block|{
name|RexNode
name|op0
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|op1
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|RelOptUtil
operator|.
name|isDistinctFrom
argument_list|(
name|cx
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|neg
argument_list|)
return|;
block|}
comment|/**    * Converts a BETWEEN expression.    *    *<p>Called automatically via reflection.    */
specifier|public
name|RexNode
name|convertBetween
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlBetweenOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
name|SqlOperandTypeChecker
name|operandTypeChecker
init|=
name|op
operator|.
name|getOperandTypeChecker
argument_list|()
decl_stmt|;
specifier|final
name|SqlOperandTypeChecker
operator|.
name|Consistency
name|consistency
init|=
name|operandTypeChecker
operator|==
literal|null
condition|?
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
else|:
name|operandTypeChecker
operator|.
name|getConsistency
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|convertOperands
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|consistency
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|x
init|=
name|list
operator|.
name|get
argument_list|(
name|SqlBetweenOperator
operator|.
name|VALUE_OPERAND
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|y
init|=
name|list
operator|.
name|get
argument_list|(
name|SqlBetweenOperator
operator|.
name|LOWER_OPERAND
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|z
init|=
name|list
operator|.
name|get
argument_list|(
name|SqlBetweenOperator
operator|.
name|UPPER_OPERAND
argument_list|)
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexNode
name|ge1
init|=
name|ge
argument_list|(
name|rexBuilder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|RexNode
name|le1
init|=
name|le
argument_list|(
name|rexBuilder
argument_list|,
name|x
argument_list|,
name|z
argument_list|)
decl_stmt|;
name|RexNode
name|and1
init|=
name|and
argument_list|(
name|rexBuilder
argument_list|,
name|ge1
argument_list|,
name|le1
argument_list|)
decl_stmt|;
name|RexNode
name|res
decl_stmt|;
specifier|final
name|SqlBetweenOperator
operator|.
name|Flag
name|symmetric
init|=
name|op
operator|.
name|flag
decl_stmt|;
switch|switch
condition|(
name|symmetric
condition|)
block|{
case|case
name|ASYMMETRIC
case|:
name|res
operator|=
name|and1
expr_stmt|;
break|break;
case|case
name|SYMMETRIC
case|:
name|RexNode
name|ge2
init|=
name|ge
argument_list|(
name|rexBuilder
argument_list|,
name|x
argument_list|,
name|z
argument_list|)
decl_stmt|;
name|RexNode
name|le2
init|=
name|le
argument_list|(
name|rexBuilder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|RexNode
name|and2
init|=
name|and
argument_list|(
name|rexBuilder
argument_list|,
name|ge2
argument_list|,
name|le2
argument_list|)
decl_stmt|;
name|res
operator|=
name|or
argument_list|(
name|rexBuilder
argument_list|,
name|and1
argument_list|,
name|and2
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|symmetric
argument_list|)
throw|;
block|}
specifier|final
name|SqlBetweenOperator
name|betweenOp
init|=
operator|(
name|SqlBetweenOperator
operator|)
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|betweenOp
operator|.
name|isNegated
argument_list|()
condition|)
block|{
name|res
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/**    * Converts a SUBSTRING expression.    *    *<p>Called automatically via reflection.    */
specifier|public
name|RexNode
name|convertSubstring
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlSubstringFunction
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlLibrary
name|library
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|config
argument_list|()
operator|.
name|conformance
argument_list|()
operator|.
name|semantics
argument_list|()
decl_stmt|;
specifier|final
name|SqlBasicCall
name|basicCall
init|=
operator|(
name|SqlBasicCall
operator|)
name|call
decl_stmt|;
switch|switch
condition|(
name|library
condition|)
block|{
case|case
name|BIG_QUERY
case|:
return|return
name|toRex
argument_list|(
name|cx
argument_list|,
name|basicCall
argument_list|,
name|SqlLibraryOperators
operator|.
name|SUBSTR_BIG_QUERY
argument_list|)
return|;
case|case
name|MYSQL
case|:
return|return
name|toRex
argument_list|(
name|cx
argument_list|,
name|basicCall
argument_list|,
name|SqlLibraryOperators
operator|.
name|SUBSTR_MYSQL
argument_list|)
return|;
case|case
name|ORACLE
case|:
return|return
name|toRex
argument_list|(
name|cx
argument_list|,
name|basicCall
argument_list|,
name|SqlLibraryOperators
operator|.
name|SUBSTR_ORACLE
argument_list|)
return|;
case|case
name|POSTGRESQL
case|:
default|default:
return|return
name|convertFunction
argument_list|(
name|cx
argument_list|,
name|op
argument_list|,
name|call
argument_list|)
return|;
block|}
block|}
specifier|private
name|RexNode
name|toRex
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlBasicCall
name|call
parameter_list|,
name|SqlFunction
name|f
parameter_list|)
block|{
specifier|final
name|SqlCall
name|call2
init|=
operator|new
name|SqlBasicCall
argument_list|(
name|f
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|,
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlRexConvertlet
name|convertlet
init|=
name|requireNonNull
argument_list|(
name|get
argument_list|(
name|call2
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|convertlet
operator|.
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call2
argument_list|)
return|;
block|}
comment|/**    * Converts a LiteralChain expression: that is, concatenates the operands    * immediately, to produce a single literal string.    *    *<p>Called automatically via reflection.    */
specifier|public
name|RexNode
name|convertLiteralChain
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlLiteralChainOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
name|Util
operator|.
name|discard
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|SqlLiteral
name|sum
init|=
name|SqlLiteralChainOperator
operator|.
name|concatenateOperands
argument_list|(
name|call
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertLiteral
argument_list|(
name|sum
argument_list|)
return|;
block|}
comment|/**    * Converts a ROW.    *    *<p>Called automatically via reflection.    */
specifier|public
name|RexNode
name|convertRow
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlRowOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|COLUMN_LIST
condition|)
block|{
return|return
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|operand
range|:
name|SqlIdentifier
operator|.
name|simpleNames
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
control|)
block|{
name|columns
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataType
name|type
init|=
name|rexBuilder
operator|.
name|deriveReturnType
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COLUMN_LIST
argument_list|,
name|columns
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|COLUMN_LIST
argument_list|,
name|columns
argument_list|)
return|;
block|}
comment|/**    * Converts a call to OVERLAPS.    *    *<p>Called automatically via reflection.    */
specifier|public
name|RexNode
name|convertOverlaps
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlOverlapsOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// for intervals [t0, t1] overlaps [t2, t3], we can find if the
comment|// intervals overlaps by: ~(t1< t2 or t3< t0)
assert|assert
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|left
init|=
name|convertOverlapsOperand
argument_list|(
name|cx
argument_list|,
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|r0
init|=
name|left
operator|.
name|left
decl_stmt|;
specifier|final
name|RexNode
name|r1
init|=
name|left
operator|.
name|right
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|right
init|=
name|convertOverlapsOperand
argument_list|(
name|cx
argument_list|,
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|r2
init|=
name|right
operator|.
name|left
decl_stmt|;
specifier|final
name|RexNode
name|r3
init|=
name|right
operator|.
name|right
decl_stmt|;
comment|// Sort end points into start and end, such that (s0<= e0) and (s1<= e1).
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexNode
name|leftSwap
init|=
name|le
argument_list|(
name|rexBuilder
argument_list|,
name|r0
argument_list|,
name|r1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|s0
init|=
name|case_
argument_list|(
name|rexBuilder
argument_list|,
name|leftSwap
argument_list|,
name|r0
argument_list|,
name|r1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|e0
init|=
name|case_
argument_list|(
name|rexBuilder
argument_list|,
name|leftSwap
argument_list|,
name|r1
argument_list|,
name|r0
argument_list|)
decl_stmt|;
name|RexNode
name|rightSwap
init|=
name|le
argument_list|(
name|rexBuilder
argument_list|,
name|r2
argument_list|,
name|r3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|s1
init|=
name|case_
argument_list|(
name|rexBuilder
argument_list|,
name|rightSwap
argument_list|,
name|r2
argument_list|,
name|r3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|e1
init|=
name|case_
argument_list|(
name|rexBuilder
argument_list|,
name|rightSwap
argument_list|,
name|r3
argument_list|,
name|r2
argument_list|)
decl_stmt|;
comment|// (e0>= s1) AND (e1>= s0)
switch|switch
condition|(
name|op
operator|.
name|kind
condition|)
block|{
case|case
name|OVERLAPS
case|:
return|return
name|and
argument_list|(
name|rexBuilder
argument_list|,
name|ge
argument_list|(
name|rexBuilder
argument_list|,
name|e0
argument_list|,
name|s1
argument_list|)
argument_list|,
name|ge
argument_list|(
name|rexBuilder
argument_list|,
name|e1
argument_list|,
name|s0
argument_list|)
argument_list|)
return|;
case|case
name|CONTAINS
case|:
return|return
name|and
argument_list|(
name|rexBuilder
argument_list|,
name|le
argument_list|(
name|rexBuilder
argument_list|,
name|s0
argument_list|,
name|s1
argument_list|)
argument_list|,
name|ge
argument_list|(
name|rexBuilder
argument_list|,
name|e0
argument_list|,
name|e1
argument_list|)
argument_list|)
return|;
case|case
name|PERIOD_EQUALS
case|:
return|return
name|and
argument_list|(
name|rexBuilder
argument_list|,
name|eq
argument_list|(
name|rexBuilder
argument_list|,
name|s0
argument_list|,
name|s1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|rexBuilder
argument_list|,
name|e0
argument_list|,
name|e1
argument_list|)
argument_list|)
return|;
case|case
name|PRECEDES
case|:
return|return
name|le
argument_list|(
name|rexBuilder
argument_list|,
name|e0
argument_list|,
name|s1
argument_list|)
return|;
case|case
name|IMMEDIATELY_PRECEDES
case|:
return|return
name|eq
argument_list|(
name|rexBuilder
argument_list|,
name|e0
argument_list|,
name|s1
argument_list|)
return|;
case|case
name|SUCCEEDS
case|:
return|return
name|ge
argument_list|(
name|rexBuilder
argument_list|,
name|s0
argument_list|,
name|e1
argument_list|)
return|;
case|case
name|IMMEDIATELY_SUCCEEDS
case|:
return|return
name|eq
argument_list|(
name|rexBuilder
argument_list|,
name|s0
argument_list|,
name|e1
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|op
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|convertOverlapsOperand
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
name|SqlNode
name|operand
parameter_list|)
block|{
specifier|final
name|SqlNode
name|a0
decl_stmt|;
specifier|final
name|SqlNode
name|a1
decl_stmt|;
switch|switch
condition|(
name|operand
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|ROW
case|:
name|a0
operator|=
operator|(
operator|(
name|SqlCall
operator|)
name|operand
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|a10
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|operand
operator|)
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|t1
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|a10
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isInterval
argument_list|(
name|t1
argument_list|)
condition|)
block|{
comment|// make t1 = t0 + t1 when t1 is an interval.
name|a1
operator|=
name|plus
argument_list|(
name|pos
argument_list|,
name|a0
argument_list|,
name|a10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a1
operator|=
name|a10
expr_stmt|;
block|}
break|break;
default|default:
name|a0
operator|=
name|operand
expr_stmt|;
name|a1
operator|=
name|operand
expr_stmt|;
block|}
specifier|final
name|RexNode
name|r0
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|a0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|r1
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|a1
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|r0
argument_list|,
name|r1
argument_list|)
return|;
block|}
comment|/**    * Casts a RexNode value to the validated type of a SqlCall. If the value    * was already of the validated type, then the value is returned without an    * additional cast.    */
specifier|public
name|RexNode
name|castToValidatedType
parameter_list|(
annotation|@
name|UnknownInitialization
name|StandardConvertletTable
name|this
parameter_list|,
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|RexNode
name|value
parameter_list|)
block|{
return|return
name|castToValidatedType
argument_list|(
name|call
argument_list|,
name|value
argument_list|,
name|cx
operator|.
name|getValidator
argument_list|()
argument_list|,
name|cx
operator|.
name|getRexBuilder
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Casts a RexNode value to the validated type of a SqlCall. If the value    * was already of the validated type, then the value is returned without an    * additional cast.    */
specifier|public
specifier|static
name|RexNode
name|castToValidatedType
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|RexNode
name|e
parameter_list|,
name|SqlValidator
name|validator
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getType
argument_list|()
operator|==
name|type
condition|)
block|{
return|return
name|e
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
return|;
block|}
comment|/** Convertlet that handles {@code COVAR_POP}, {@code COVAR_SAMP},    * {@code REGR_SXX}, {@code REGR_SYY} windowed aggregate functions.    */
specifier|private
specifier|static
class|class
name|RegrCovarianceConvertlet
implements|implements
name|SqlRexConvertlet
block|{
specifier|private
specifier|final
name|SqlKind
name|kind
decl_stmt|;
name|RegrCovarianceConvertlet
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
name|this
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|2
assert|;
specifier|final
name|SqlNode
name|arg1
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|arg2
init|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|expr
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|COVAR_POP
case|:
name|expr
operator|=
name|expandCovariance
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|null
argument_list|,
name|type
argument_list|,
name|cx
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|COVAR_SAMP
case|:
name|expr
operator|=
name|expandCovariance
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|null
argument_list|,
name|type
argument_list|,
name|cx
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGR_SXX
case|:
name|expr
operator|=
name|expandRegrSzz
argument_list|(
name|arg2
argument_list|,
name|arg1
argument_list|,
name|type
argument_list|,
name|cx
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGR_SYY
case|:
name|expr
operator|=
name|expandRegrSzz
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|type
argument_list|,
name|cx
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|kind
argument_list|)
throw|;
block|}
name|RexNode
name|rex
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|type
argument_list|,
name|rex
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|SqlNode
name|expandRegrSzz
parameter_list|(
specifier|final
name|SqlNode
name|arg1
parameter_list|,
specifier|final
name|SqlNode
name|arg2
parameter_list|,
specifier|final
name|RelDataType
name|avgType
parameter_list|,
specifier|final
name|SqlRexContext
name|cx
parameter_list|,
name|boolean
name|variance
parameter_list|)
block|{
specifier|final
name|SqlParserPos
name|pos
init|=
name|SqlParserPos
operator|.
name|ZERO
decl_stmt|;
specifier|final
name|SqlNode
name|count
init|=
name|SqlStdOperatorTable
operator|.
name|REGR_COUNT
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|varPop
init|=
name|expandCovariance
argument_list|(
name|arg1
argument_list|,
name|variance
condition|?
name|arg1
else|:
name|arg2
argument_list|,
name|arg2
argument_list|,
name|avgType
argument_list|,
name|cx
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|varPopRex
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|varPop
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|varPopCast
decl_stmt|;
name|varPopCast
operator|=
name|getCastedSqlNode
argument_list|(
name|varPop
argument_list|,
name|avgType
argument_list|,
name|pos
argument_list|,
name|varPopRex
argument_list|)
expr_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|varPopCast
argument_list|,
name|count
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|SqlNode
name|expandCovariance
parameter_list|(
specifier|final
name|SqlNode
name|arg0Input
parameter_list|,
specifier|final
name|SqlNode
name|arg1Input
parameter_list|,
specifier|final
annotation|@
name|Nullable
name|SqlNode
name|dependent
parameter_list|,
specifier|final
name|RelDataType
name|varType
parameter_list|,
specifier|final
name|SqlRexContext
name|cx
parameter_list|,
name|boolean
name|biased
parameter_list|)
block|{
comment|// covar_pop(x1, x2) ==>
comment|//     (sum(x1 * x2) - sum(x2) * sum(x1) / count(x1, x2))
comment|//     / count(x1, x2)
comment|//
comment|// covar_samp(x1, x2) ==>
comment|//     (sum(x1 * x2) - sum(x1) * sum(x2) / count(x1, x2))
comment|//     / (count(x1, x2) - 1)
specifier|final
name|SqlParserPos
name|pos
init|=
name|SqlParserPos
operator|.
name|ZERO
decl_stmt|;
specifier|final
name|SqlLiteral
name|nullLiteral
init|=
name|SqlLiteral
operator|.
name|createNull
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|arg0Rex
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|arg0Input
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|arg1Rex
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|arg1Input
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|arg0
init|=
name|getCastedSqlNode
argument_list|(
name|arg0Input
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
name|arg0Rex
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|arg1
init|=
name|getCastedSqlNode
argument_list|(
name|arg1Input
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
name|arg1Rex
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|argSquared
init|=
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sumArgSquared
decl_stmt|;
specifier|final
name|SqlNode
name|sum0
decl_stmt|;
specifier|final
name|SqlNode
name|sum1
decl_stmt|;
specifier|final
name|SqlNode
name|count
decl_stmt|;
if|if
condition|(
name|dependent
operator|==
literal|null
condition|)
block|{
name|sumArgSquared
operator|=
name|SqlStdOperatorTable
operator|.
name|SUM
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|argSquared
argument_list|)
expr_stmt|;
name|sum0
operator|=
name|SqlStdOperatorTable
operator|.
name|SUM
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|sum1
operator|=
name|SqlStdOperatorTable
operator|.
name|SUM
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|count
operator|=
name|SqlStdOperatorTable
operator|.
name|REGR_COUNT
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sumArgSquared
operator|=
name|SqlStdOperatorTable
operator|.
name|SUM
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|argSquared
argument_list|,
name|dependent
argument_list|)
expr_stmt|;
name|sum0
operator|=
name|SqlStdOperatorTable
operator|.
name|SUM
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg0
argument_list|,
name|Objects
operator|.
name|equals
argument_list|(
name|dependent
argument_list|,
name|arg0Input
argument_list|)
condition|?
name|arg1
else|:
name|dependent
argument_list|)
expr_stmt|;
name|sum1
operator|=
name|SqlStdOperatorTable
operator|.
name|SUM
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg1
argument_list|,
name|Objects
operator|.
name|equals
argument_list|(
name|dependent
argument_list|,
name|arg1Input
argument_list|)
condition|?
name|arg0
else|:
name|dependent
argument_list|)
expr_stmt|;
name|count
operator|=
name|SqlStdOperatorTable
operator|.
name|REGR_COUNT
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg0
argument_list|,
name|Objects
operator|.
name|equals
argument_list|(
name|dependent
argument_list|,
name|arg0Input
argument_list|)
condition|?
name|arg1
else|:
name|dependent
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlNode
name|sumSquared
init|=
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sum0
argument_list|,
name|sum1
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|countCasted
init|=
name|getCastedSqlNode
argument_list|(
name|count
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|count
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|avgSumSquared
init|=
name|SqlStdOperatorTable
operator|.
name|DIVIDE
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sumSquared
argument_list|,
name|countCasted
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|diff
init|=
name|SqlStdOperatorTable
operator|.
name|MINUS
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sumArgSquared
argument_list|,
name|avgSumSquared
argument_list|)
decl_stmt|;
name|SqlNode
name|denominator
decl_stmt|;
if|if
condition|(
name|biased
condition|)
block|{
name|denominator
operator|=
name|countCasted
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|SqlNumericLiteral
name|one
init|=
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"1"
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|denominator
operator|=
operator|new
name|SqlCase
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|countCasted
argument_list|,
name|SqlNodeList
operator|.
name|of
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|countCasted
argument_list|,
name|one
argument_list|)
argument_list|)
argument_list|,
name|SqlNodeList
operator|.
name|of
argument_list|(
name|getCastedSqlNode
argument_list|(
name|nullLiteral
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|,
name|SqlStdOperatorTable
operator|.
name|MINUS
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|countCasted
argument_list|,
name|one
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SqlStdOperatorTable
operator|.
name|DIVIDE
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|diff
argument_list|,
name|denominator
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|SqlNode
name|getCastedSqlNode
parameter_list|(
name|SqlNode
name|argInput
parameter_list|,
name|RelDataType
name|varType
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|argRex
parameter_list|)
block|{
name|SqlNode
name|arg
decl_stmt|;
if|if
condition|(
name|argRex
operator|!=
literal|null
operator|&&
operator|!
name|argRex
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|varType
argument_list|)
condition|)
block|{
name|arg
operator|=
name|SqlStdOperatorTable
operator|.
name|CAST
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|argInput
argument_list|,
name|SqlTypeUtil
operator|.
name|convertTypeToSpec
argument_list|(
name|varType
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|=
name|argInput
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
block|}
comment|/** Convertlet that handles {@code AVG} and {@code VARIANCE}    * windowed aggregate functions. */
specifier|private
specifier|static
class|class
name|AvgVarianceConvertlet
implements|implements
name|SqlRexConvertlet
block|{
specifier|private
specifier|final
name|SqlKind
name|kind
decl_stmt|;
name|AvgVarianceConvertlet
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
name|this
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|SqlNode
name|arg
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|expr
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|AVG
case|:
name|expr
operator|=
name|expandAvg
argument_list|(
name|arg
argument_list|,
name|type
argument_list|,
name|cx
argument_list|)
expr_stmt|;
break|break;
case|case
name|STDDEV_POP
case|:
name|expr
operator|=
name|expandVariance
argument_list|(
name|arg
argument_list|,
name|type
argument_list|,
name|cx
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|STDDEV_SAMP
case|:
name|expr
operator|=
name|expandVariance
argument_list|(
name|arg
argument_list|,
name|type
argument_list|,
name|cx
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_POP
case|:
name|expr
operator|=
name|expandVariance
argument_list|(
name|arg
argument_list|,
name|type
argument_list|,
name|cx
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_SAMP
case|:
name|expr
operator|=
name|expandVariance
argument_list|(
name|arg
argument_list|,
name|type
argument_list|,
name|cx
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|kind
argument_list|)
throw|;
block|}
name|RexNode
name|rex
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|type
argument_list|,
name|rex
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|SqlNode
name|expandAvg
parameter_list|(
specifier|final
name|SqlNode
name|arg
parameter_list|,
specifier|final
name|RelDataType
name|avgType
parameter_list|,
specifier|final
name|SqlRexContext
name|cx
parameter_list|)
block|{
specifier|final
name|SqlParserPos
name|pos
init|=
name|SqlParserPos
operator|.
name|ZERO
decl_stmt|;
specifier|final
name|SqlNode
name|sum
init|=
name|SqlStdOperatorTable
operator|.
name|SUM
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|sumRex
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|sum
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sumCast
decl_stmt|;
name|sumCast
operator|=
name|getCastedSqlNode
argument_list|(
name|sum
argument_list|,
name|avgType
argument_list|,
name|pos
argument_list|,
name|sumRex
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|count
init|=
name|SqlStdOperatorTable
operator|.
name|COUNT
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|DIVIDE
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sumCast
argument_list|,
name|count
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|SqlNode
name|expandVariance
parameter_list|(
specifier|final
name|SqlNode
name|argInput
parameter_list|,
specifier|final
name|RelDataType
name|varType
parameter_list|,
specifier|final
name|SqlRexContext
name|cx
parameter_list|,
name|boolean
name|biased
parameter_list|,
name|boolean
name|sqrt
parameter_list|)
block|{
comment|// stddev_pop(x) ==>
comment|//   power(
comment|//     (sum(x * x) - sum(x) * sum(x) / count(x))
comment|//     / count(x),
comment|//     .5)
comment|//
comment|// stddev_samp(x) ==>
comment|//   power(
comment|//     (sum(x * x) - sum(x) * sum(x) / count(x))
comment|//     / (count(x) - 1),
comment|//     .5)
comment|//
comment|// var_pop(x) ==>
comment|//     (sum(x * x) - sum(x) * sum(x) / count(x))
comment|//     / count(x)
comment|//
comment|// var_samp(x) ==>
comment|//     (sum(x * x) - sum(x) * sum(x) / count(x))
comment|//     / (count(x) - 1)
specifier|final
name|SqlParserPos
name|pos
init|=
name|SqlParserPos
operator|.
name|ZERO
decl_stmt|;
specifier|final
name|SqlNode
name|arg
init|=
name|getCastedSqlNode
argument_list|(
name|argInput
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|argInput
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|argSquared
init|=
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|argSquaredCasted
init|=
name|getCastedSqlNode
argument_list|(
name|argSquared
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|argSquared
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sumArgSquared
init|=
name|SqlStdOperatorTable
operator|.
name|SUM
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|argSquaredCasted
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sumArgSquaredCasted
init|=
name|getCastedSqlNode
argument_list|(
name|sumArgSquared
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|sumArgSquared
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sum
init|=
name|SqlStdOperatorTable
operator|.
name|SUM
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sumCasted
init|=
name|getCastedSqlNode
argument_list|(
name|sum
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|sum
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sumSquared
init|=
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sumCasted
argument_list|,
name|sumCasted
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sumSquaredCasted
init|=
name|getCastedSqlNode
argument_list|(
name|sumSquared
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|sumSquared
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|count
init|=
name|SqlStdOperatorTable
operator|.
name|COUNT
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|countCasted
init|=
name|getCastedSqlNode
argument_list|(
name|count
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|count
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|avgSumSquared
init|=
name|SqlStdOperatorTable
operator|.
name|DIVIDE
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sumSquaredCasted
argument_list|,
name|countCasted
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|avgSumSquaredCasted
init|=
name|getCastedSqlNode
argument_list|(
name|avgSumSquared
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|avgSumSquared
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|diff
init|=
name|SqlStdOperatorTable
operator|.
name|MINUS
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sumArgSquaredCasted
argument_list|,
name|avgSumSquaredCasted
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|diffCasted
init|=
name|getCastedSqlNode
argument_list|(
name|diff
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|diff
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|denominator
decl_stmt|;
if|if
condition|(
name|biased
condition|)
block|{
name|denominator
operator|=
name|countCasted
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|SqlNumericLiteral
name|one
init|=
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"1"
argument_list|,
name|pos
argument_list|)
decl_stmt|;
specifier|final
name|SqlLiteral
name|nullLiteral
init|=
name|SqlLiteral
operator|.
name|createNull
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|denominator
operator|=
operator|new
name|SqlCase
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|count
argument_list|,
name|SqlNodeList
operator|.
name|of
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|count
argument_list|,
name|one
argument_list|)
argument_list|)
argument_list|,
name|SqlNodeList
operator|.
name|of
argument_list|(
name|getCastedSqlNode
argument_list|(
name|nullLiteral
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|,
name|SqlStdOperatorTable
operator|.
name|MINUS
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|count
argument_list|,
name|one
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlNode
name|div
init|=
name|SqlStdOperatorTable
operator|.
name|DIVIDE
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|diffCasted
argument_list|,
name|denominator
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|divCasted
init|=
name|getCastedSqlNode
argument_list|(
name|div
argument_list|,
name|varType
argument_list|,
name|pos
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|div
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|result
init|=
name|div
decl_stmt|;
if|if
condition|(
name|sqrt
condition|)
block|{
specifier|final
name|SqlNumericLiteral
name|half
init|=
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"0.5"
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|result
operator|=
name|SqlStdOperatorTable
operator|.
name|POWER
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|divCasted
argument_list|,
name|half
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|SqlNode
name|getCastedSqlNode
parameter_list|(
name|SqlNode
name|argInput
parameter_list|,
name|RelDataType
name|varType
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|argRex
parameter_list|)
block|{
name|SqlNode
name|arg
decl_stmt|;
if|if
condition|(
name|argRex
operator|!=
literal|null
operator|&&
operator|!
name|argRex
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|varType
argument_list|)
condition|)
block|{
name|arg
operator|=
name|SqlStdOperatorTable
operator|.
name|CAST
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|argInput
argument_list|,
name|SqlTypeUtil
operator|.
name|convertTypeToSpec
argument_list|(
name|varType
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|=
name|argInput
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
block|}
comment|/** Convertlet that converts {@code LTRIM} and {@code RTRIM} to    * {@code TRIM}. */
specifier|private
specifier|static
class|class
name|TrimConvertlet
implements|implements
name|SqlRexConvertlet
block|{
specifier|private
specifier|final
name|SqlTrimFunction
operator|.
name|Flag
name|flag
decl_stmt|;
name|TrimConvertlet
parameter_list|(
name|SqlTrimFunction
operator|.
name|Flag
name|flag
parameter_list|)
block|{
name|this
operator|.
name|flag
operator|=
name|flag
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|operand
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|TRIM
argument_list|,
name|rexBuilder
operator|.
name|makeFlag
argument_list|(
name|flag
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|" "
argument_list|)
argument_list|,
name|operand
argument_list|)
return|;
block|}
block|}
comment|/** Convertlet that converts {@code GREATEST} and {@code LEAST}. */
specifier|private
specifier|static
class|class
name|GreatestConvertlet
implements|implements
name|SqlRexConvertlet
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Translate
comment|//   GREATEST(a, b, c, d)
comment|// to
comment|//   CASE
comment|//   WHEN a IS NULL OR b IS NULL OR c IS NULL OR d IS NULL
comment|//   THEN NULL
comment|//   WHEN a> b AND a> c AND a> d
comment|//   THEN a
comment|//   WHEN b> c AND b> d
comment|//   THEN b
comment|//   WHEN c> d
comment|//   THEN c
comment|//   ELSE d
comment|//   END
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|SqlBinaryOperator
name|op
decl_stmt|;
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|GREATEST
case|:
name|op
operator|=
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
expr_stmt|;
break|break;
case|case
name|LEAST
case|:
name|op
operator|=
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|convertOperands
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|orList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
name|orList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|RexUtil
operator|.
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|orList
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|andList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|RexNode
name|expr2
init|=
name|exprs
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|andList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|,
name|expr
argument_list|,
name|expr2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|andList
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|exprs
operator|.
name|get
argument_list|(
name|exprs
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|list
argument_list|)
return|;
block|}
block|}
comment|/** Convertlet that handles {@code FLOOR} and {@code CEIL} functions. */
specifier|private
class|class
name|FloorCeilConvertlet
implements|implements
name|SqlRexConvertlet
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertFloorCeil
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
block|}
comment|/** Convertlet that handles the {@code SUBSTR} function; various dialects    * have slightly different specifications. PostgreSQL seems to comply with    * the ISO standard for the {@code SUBSTRING} function, and therefore    * Calcite's default behavior matches PostgreSQL. */
specifier|private
specifier|static
class|class
name|SubstrConvertlet
implements|implements
name|SqlRexConvertlet
block|{
specifier|private
specifier|final
name|SqlLibrary
name|library
decl_stmt|;
name|SubstrConvertlet
parameter_list|(
name|SqlLibrary
name|library
parameter_list|)
block|{
name|this
operator|.
name|library
operator|=
name|library
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|library
operator|==
name|SqlLibrary
operator|.
name|ORACLE
operator|||
name|library
operator|==
name|SqlLibrary
operator|.
name|MYSQL
operator|||
name|library
operator|==
name|SqlLibrary
operator|.
name|BIG_QUERY
operator|||
name|library
operator|==
name|SqlLibrary
operator|.
name|POSTGRESQL
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Translate
comment|//   SUBSTR(value, start, length)
comment|//
comment|// to the following if we want PostgreSQL semantics:
comment|//   SUBSTRING(value, start, length)
comment|//
comment|// to the following if we want Oracle semantics:
comment|//   SUBSTRING(
comment|//     value
comment|//     FROM CASE
comment|//          WHEN start = 0
comment|//          THEN 1
comment|//          WHEN start + (length(value) + 1)< 1
comment|//          THEN length(value) + 1
comment|//          WHEN start< 0
comment|//          THEN start + (length(value) + 1)
comment|//          ELSE start)
comment|//     FOR CASE WHEN length< 0 THEN 0 ELSE length END)
comment|//
comment|// to the following in MySQL:
comment|//   SUBSTRING(
comment|//     value
comment|//     FROM CASE
comment|//          WHEN start = 0
comment|//          THEN length(value) + 1    -- different from Oracle
comment|//          WHEN start + (length(value) + 1)< 1
comment|//          THEN length(value) + 1
comment|//          WHEN start< 0
comment|//          THEN start + length(value) + 1
comment|//          ELSE start)
comment|//     FOR CASE WHEN length< 0 THEN 0 ELSE length END)
comment|//
comment|// to the following if we want BigQuery semantics:
comment|//   CASE
comment|//   WHEN start + (length(value) + 1)< 1
comment|//   THEN value
comment|//   ELSE SUBSTRING(
comment|//       value
comment|//       FROM CASE
comment|//            WHEN start = 0
comment|//            THEN 1
comment|//            WHEN start< 0
comment|//            THEN start + length(value) + 1
comment|//            ELSE start)
comment|//       FOR CASE WHEN length< 0 THEN 0 ELSE length END)
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|convertOperands
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|value
init|=
name|exprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|start
init|=
name|exprs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|startType
init|=
name|start
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RexLiteral
name|zeroLiteral
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|0
argument_list|,
name|startType
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|oneLiteral
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|1
argument_list|,
name|startType
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|valueLength
init|=
name|SqlTypeUtil
operator|.
name|isBinary
argument_list|(
name|value
operator|.
name|getType
argument_list|()
argument_list|)
condition|?
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OCTET_LENGTH
argument_list|,
name|value
argument_list|)
else|:
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CHAR_LENGTH
argument_list|,
name|value
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|valueLengthPlusOne
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|valueLength
argument_list|,
name|oneLiteral
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|newStart
decl_stmt|;
switch|switch
condition|(
name|library
condition|)
block|{
case|case
name|POSTGRESQL
case|:
if|if
condition|(
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|newStart
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|start
argument_list|,
name|oneLiteral
argument_list|)
argument_list|,
name|oneLiteral
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newStart
operator|=
name|start
expr_stmt|;
block|}
break|break;
case|case
name|BIG_QUERY
case|:
name|newStart
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|start
argument_list|,
name|zeroLiteral
argument_list|)
argument_list|,
name|oneLiteral
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|start
argument_list|,
name|zeroLiteral
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|start
argument_list|,
name|valueLengthPlusOne
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
default|default:
name|newStart
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|start
argument_list|,
name|zeroLiteral
argument_list|)
argument_list|,
name|library
operator|==
name|SqlLibrary
operator|.
name|MYSQL
condition|?
name|valueLengthPlusOne
else|:
name|oneLiteral
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|start
argument_list|,
name|valueLengthPlusOne
argument_list|)
argument_list|,
name|oneLiteral
argument_list|)
argument_list|,
name|valueLengthPlusOne
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|start
argument_list|,
name|zeroLiteral
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|start
argument_list|,
name|valueLengthPlusOne
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|2
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUBSTRING
argument_list|,
name|value
argument_list|,
name|newStart
argument_list|)
return|;
block|}
assert|assert
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|3
assert|;
specifier|final
name|RexNode
name|length
init|=
name|exprs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|newLength
decl_stmt|;
switch|switch
condition|(
name|library
condition|)
block|{
case|case
name|POSTGRESQL
case|:
name|newLength
operator|=
name|length
expr_stmt|;
break|break;
default|default:
name|newLength
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|length
argument_list|,
name|zeroLiteral
argument_list|)
argument_list|,
name|zeroLiteral
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RexNode
name|substringCall
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUBSTRING
argument_list|,
name|value
argument_list|,
name|newStart
argument_list|,
name|newLength
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|library
condition|)
block|{
case|case
name|BIG_QUERY
case|:
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|start
argument_list|,
name|valueLengthPlusOne
argument_list|)
argument_list|,
name|oneLiteral
argument_list|)
argument_list|,
name|value
argument_list|,
name|substringCall
argument_list|)
return|;
default|default:
return|return
name|substringCall
return|;
block|}
block|}
block|}
comment|/** Convertlet that handles the {@code TIMESTAMPADD} function. */
specifier|private
specifier|static
class|class
name|TimestampAddConvertlet
implements|implements
name|SqlRexConvertlet
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// TIMESTAMPADD(unit, count, timestamp)
comment|//  => timestamp + count * INTERVAL '1' UNIT
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|SqlLiteral
name|unitLiteral
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|TimeUnit
name|unit
init|=
name|unitLiteral
operator|.
name|getValueAs
argument_list|(
name|TimeUnit
operator|.
name|class
argument_list|)
decl_stmt|;
name|RexNode
name|interval2Add
decl_stmt|;
name|SqlIntervalQualifier
name|qualifier
init|=
operator|new
name|SqlIntervalQualifier
argument_list|(
name|unit
argument_list|,
literal|null
argument_list|,
name|unitLiteral
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|op1
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|MICROSECOND
case|:
case|case
name|NANOSECOND
case|:
name|interval2Add
operator|=
name|divide
argument_list|(
name|rexBuilder
argument_list|,
name|multiply
argument_list|(
name|rexBuilder
argument_list|,
name|rexBuilder
operator|.
name|makeIntervalLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|,
name|qualifier
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|,
name|BigDecimal
operator|.
name|ONE
operator|.
name|divide
argument_list|(
name|unit
operator|.
name|multiplier
argument_list|,
name|RoundingMode
operator|.
name|UNNECESSARY
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|interval2Add
operator|=
name|multiply
argument_list|(
name|rexBuilder
argument_list|,
name|rexBuilder
operator|.
name|makeIntervalLiteral
argument_list|(
name|unit
operator|.
name|multiplier
argument_list|,
name|qualifier
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DATETIME_PLUS
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|,
name|interval2Add
argument_list|)
return|;
block|}
block|}
comment|/** Convertlet that handles the {@code TIMESTAMPDIFF} function. */
specifier|private
specifier|static
class|class
name|TimestampDiffConvertlet
implements|implements
name|SqlRexConvertlet
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// TIMESTAMPDIFF(unit, t1, t2)
comment|//    => (t2 - t1) UNIT
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|SqlLiteral
name|unitLiteral
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|TimeUnit
name|unit
init|=
name|unitLiteral
operator|.
name|getValueAs
argument_list|(
name|TimeUnit
operator|.
name|class
argument_list|)
decl_stmt|;
name|BigDecimal
name|multiplier
init|=
name|BigDecimal
operator|.
name|ONE
decl_stmt|;
name|BigDecimal
name|divider
init|=
name|BigDecimal
operator|.
name|ONE
decl_stmt|;
name|SqlTypeName
name|sqlTypeName
init|=
name|unit
operator|==
name|TimeUnit
operator|.
name|NANOSECOND
condition|?
name|SqlTypeName
operator|.
name|BIGINT
else|:
name|SqlTypeName
operator|.
name|INTEGER
decl_stmt|;
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|MICROSECOND
case|:
case|case
name|MILLISECOND
case|:
case|case
name|NANOSECOND
case|:
case|case
name|WEEK
case|:
name|multiplier
operator|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|DateTimeUtils
operator|.
name|MILLIS_PER_SECOND
argument_list|)
expr_stmt|;
name|divider
operator|=
name|unit
operator|.
name|multiplier
expr_stmt|;
name|unit
operator|=
name|TimeUnit
operator|.
name|SECOND
expr_stmt|;
break|break;
case|case
name|QUARTER
case|:
name|divider
operator|=
name|unit
operator|.
name|multiplier
expr_stmt|;
name|unit
operator|=
name|TimeUnit
operator|.
name|MONTH
expr_stmt|;
break|break;
default|default:
break|break;
block|}
specifier|final
name|SqlIntervalQualifier
name|qualifier
init|=
operator|new
name|SqlIntervalQualifier
argument_list|(
name|unit
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op2
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op1
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intervalType
init|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlIntervalType
argument_list|(
name|qualifier
argument_list|)
argument_list|,
name|op1
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
operator|||
name|op2
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexCall
name|rexCall
init|=
operator|(
name|RexCall
operator|)
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|intervalType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|MINUS_DATE
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|op2
argument_list|,
name|op1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|sqlTypeName
argument_list|)
argument_list|,
name|SqlTypeUtil
operator|.
name|containsNullable
argument_list|(
name|rexCall
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|e
init|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|intType
argument_list|,
name|rexCall
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|multiplyDivide
argument_list|(
name|e
argument_list|,
name|multiplier
argument_list|,
name|divider
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

