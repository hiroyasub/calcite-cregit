begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|DateTimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnitRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCallBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexRangeRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBasicCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBinaryOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDataTypeSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunctionCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIntervalLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIntervalQualifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlJdbcFunctionCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNumericLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|OracleSqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlArrayValueConstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlBetweenOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlDatetimeSubtractionOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlExtractFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLiteralChainOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlMapValueConstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlMultisetQueryConstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlMultisetValueConstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlOverlapsOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlRowOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlSequenceValueOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlTrimFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlOperandTypeChecker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|RoundingMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Standard implementation of {@link SqlRexConvertletTable}.  */
end_comment

begin_class
specifier|public
class|class
name|StandardConvertletTable
extends|extends
name|ReflectiveConvertletTable
block|{
comment|/** Singleton instance. */
specifier|public
specifier|static
specifier|final
name|StandardConvertletTable
name|INSTANCE
init|=
operator|new
name|StandardConvertletTable
argument_list|()
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|private
name|StandardConvertletTable
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
comment|// Register aliases (operators which have a different name but
comment|// identical behavior to other operators).
name|addAlias
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CHARACTER_LENGTH
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CHAR_LENGTH
argument_list|)
expr_stmt|;
name|addAlias
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_UNKNOWN
argument_list|,
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|)
expr_stmt|;
name|addAlias
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_UNKNOWN
argument_list|,
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|)
expr_stmt|;
comment|// Register convertlets for specific objects.
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertCast
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_DISTINCT_FROM
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertIsDistinctFrom
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertIsDistinctFrom
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertPlus
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RexCall
name|e
init|=
operator|(
name|RexCall
operator|)
name|StandardConvertletTable
operator|.
name|this
operator|.
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|call
operator|.
name|getOperator
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|DATE
case|:
case|case
name|TIME
case|:
case|case
name|TIMESTAMP
case|:
return|return
name|convertDatetimeMinus
argument_list|(
name|cx
argument_list|,
name|SqlStdOperatorTable
operator|.
name|MINUS_DATE
argument_list|,
name|call
argument_list|)
return|;
default|default:
return|return
name|e
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|OracleSqlOperatorTable
operator|.
name|LTRIM
argument_list|,
operator|new
name|TrimConvertlet
argument_list|(
name|SqlTrimFunction
operator|.
name|Flag
operator|.
name|LEADING
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|OracleSqlOperatorTable
operator|.
name|RTRIM
argument_list|,
operator|new
name|TrimConvertlet
argument_list|(
name|SqlTrimFunction
operator|.
name|Flag
operator|.
name|TRAILING
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|OracleSqlOperatorTable
operator|.
name|GREATEST
argument_list|,
operator|new
name|GreatestConvertlet
argument_list|()
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|OracleSqlOperatorTable
operator|.
name|LEAST
argument_list|,
operator|new
name|GreatestConvertlet
argument_list|()
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|OracleSqlOperatorTable
operator|.
name|NVL
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|operand0
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|operand1
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|operand0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|operand0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|operand1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|OracleSqlOperatorTable
operator|.
name|DECODE
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|convertExpressionList
argument_list|(
name|cx
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|RelOptUtil
operator|.
name|isDistinctFrom
argument_list|(
name|rexBuilder
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|operands
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|operands
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|exprs
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Expand "x NOT LIKE y" into "NOT (x LIKE y)"
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_LIKE
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlCall
name|expanded
init|=
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|SqlStdOperatorTable
operator|.
name|LIKE
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|expanded
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Expand "x NOT SIMILAR y" into "NOT (x SIMILAR y)"
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_SIMILAR_TO
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlCall
name|expanded
init|=
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|SqlStdOperatorTable
operator|.
name|SIMILAR_TO
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|expanded
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Unary "+" has no effect, so expand "+ x" into "x".
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|UNARY_PLUS
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
name|SqlNode
name|expanded
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|expanded
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// "AS" has no effect, so expand "x AS id" into "x".
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AS
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
name|SqlNode
name|expanded
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|expanded
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// "SQRT(x)" is equivalent to "POWER(x, .5)"
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SQRT
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
name|SqlNode
name|expanded
init|=
name|SqlStdOperatorTable
operator|.
name|POWER
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"0.5"
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|expanded
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// REVIEW jvs 24-Apr-2006: This only seems to be working from within a
comment|// windowed agg.  I have added an optimizer rule
comment|// org.apache.calcite.rel.rules.AggregateReduceFunctionsRule which handles
comment|// other cases post-translation.  The reason I did that was to defer the
comment|// implementation decision; e.g. we may want to push it down to a foreign
comment|// server directly rather than decomposed; decomposition is easier than
comment|// recognition.
comment|// Convert "avg(<expr>)" to "cast(sum(<expr>) / count(<expr>) as
comment|//<type>)". We don't need to handle the empty set specially, because
comment|// the SUM is already supposed to come out as NULL in cases where the
comment|// COUNT is zero, so the null check should take place first and prevent
comment|// division by zero. We need the cast because SUM and COUNT may use
comment|// different types, say BIGINT.
comment|//
comment|// Similarly STDDEV_POP and STDDEV_SAMP, VAR_POP and VAR_SAMP.
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AVG
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|AVG
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|STDDEV_POP
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|STDDEV_POP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|STDDEV_SAMP
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|STDDEV_SAMP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|VAR_POP
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|VAR_POP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|VAR_SAMP
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlKind
operator|.
name|VAR_SAMP
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|SqlRexConvertlet
name|floorCeilConvertlet
init|=
operator|new
name|FloorCeilConvertlet
argument_list|()
decl_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|FLOOR
argument_list|,
name|floorCeilConvertlet
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CEIL
argument_list|,
name|floorCeilConvertlet
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|TIMESTAMP_ADD
argument_list|,
operator|new
name|TimestampAddConvertlet
argument_list|()
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|TIMESTAMP_DIFF
argument_list|,
operator|new
name|TimestampDiffConvertlet
argument_list|()
argument_list|)
expr_stmt|;
comment|// Convert "element(<expr>)" to "$element_slice(<expr>)", if the
comment|// expression is a multiset of scalars.
if|if
condition|(
literal|false
condition|)
block|{
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ELEMENT
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|SqlNode
name|operand
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ELEMENT_SLICE
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|operand
argument_list|)
argument_list|)
return|;
block|}
comment|// fallback on default behavior
return|return
name|StandardConvertletTable
operator|.
name|this
operator|.
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// Convert "$element_slice(<expr>)" to "element(<expr>).field#0"
if|if
condition|(
literal|false
condition|)
block|{
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ELEMENT_SLICE
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|SqlNode
name|operand
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|expr
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ELEMENT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|operand
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Converts a CASE expression.    */
specifier|public
name|RexNode
name|convertCase
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCase
name|call
parameter_list|)
block|{
name|SqlNodeList
name|whenList
init|=
name|call
operator|.
name|getWhenOperands
argument_list|()
decl_stmt|;
name|SqlNodeList
name|thenList
init|=
name|call
operator|.
name|getThenOperands
argument_list|()
decl_stmt|;
assert|assert
name|whenList
operator|.
name|size
argument_list|()
operator|==
name|thenList
operator|.
name|size
argument_list|()
assert|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|whenList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprList
operator|.
name|add
argument_list|(
name|cx
operator|.
name|convertExpression
argument_list|(
name|whenList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exprList
operator|.
name|add
argument_list|(
name|cx
operator|.
name|convertExpression
argument_list|(
name|thenList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exprList
operator|.
name|add
argument_list|(
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|getElseOperand
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataType
name|type
init|=
name|rexBuilder
operator|.
name|deriveReturnType
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|exprList
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|elseArgs
argument_list|(
name|exprList
operator|.
name|size
argument_list|()
argument_list|)
control|)
block|{
name|exprList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|rexBuilder
operator|.
name|ensureType
argument_list|(
name|type
argument_list|,
name|exprList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|exprList
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertMultiset
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlMultisetValueConstructor
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RelDataType
name|originalType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|RexRangeRef
name|rr
init|=
name|cx
operator|.
name|getSubQueryExpr
argument_list|(
name|call
argument_list|)
decl_stmt|;
assert|assert
name|rr
operator|!=
literal|null
assert|;
name|RelDataType
name|msType
init|=
name|rr
operator|.
name|getType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RexNode
name|expr
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|msType
argument_list|,
name|rr
operator|.
name|getOffset
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|msType
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
assert|;
if|if
condition|(
operator|!
name|originalType
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
comment|// If the type is not a struct, the multiset operator will have
comment|// wrapped the type as a record. Add a call to the $SLICE operator
comment|// to compensate. For example,
comment|// if '<ms>' has type 'RECORD (INTEGER x) MULTISET',
comment|// then '$SLICE(<ms>) has type 'INTEGER MULTISET'.
comment|// This will be removed as the expression is translated.
name|expr
operator|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|originalType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|SLICE
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
specifier|public
name|RexNode
name|convertArray
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlArrayValueConstructor
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertMap
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlMapValueConstructor
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertMultisetQuery
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlMultisetQueryConstructor
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RelDataType
name|originalType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|RexRangeRef
name|rr
init|=
name|cx
operator|.
name|getSubQueryExpr
argument_list|(
name|call
argument_list|)
decl_stmt|;
assert|assert
name|rr
operator|!=
literal|null
assert|;
name|RelDataType
name|msType
init|=
name|rr
operator|.
name|getType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RexNode
name|expr
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|msType
argument_list|,
name|rr
operator|.
name|getOffset
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|msType
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
assert|;
if|if
condition|(
operator|!
name|originalType
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
comment|// If the type is not a struct, the multiset operator will have
comment|// wrapped the type as a record. Add a call to the $SLICE operator
comment|// to compensate. For example,
comment|// if '<ms>' has type 'RECORD (INTEGER x) MULTISET',
comment|// then '$SLICE(<ms>) has type 'INTEGER MULTISET'.
comment|// This will be removed as the expression is translated.
name|expr
operator|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SLICE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
specifier|public
name|RexNode
name|convertJdbc
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlJdbcFunctionCall
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Yuck!! The function definition contains arguments!
comment|// TODO: adopt a more conventional definition/instance structure
specifier|final
name|SqlCall
name|convertedCall
init|=
name|op
operator|.
name|getLookupCall
argument_list|()
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|convertedCall
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|convertCast
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
specifier|final
name|SqlCall
name|call
parameter_list|)
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
assert|assert
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
assert|;
specifier|final
name|SqlNode
name|left
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|right
init|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|right
operator|instanceof
name|SqlIntervalQualifier
condition|)
block|{
specifier|final
name|SqlIntervalQualifier
name|intervalQualifier
init|=
operator|(
name|SqlIntervalQualifier
operator|)
name|right
decl_stmt|;
if|if
condition|(
name|left
operator|instanceof
name|SqlIntervalLiteral
condition|)
block|{
name|RexLiteral
name|sourceInterval
init|=
operator|(
name|RexLiteral
operator|)
name|cx
operator|.
name|convertExpression
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|BigDecimal
name|sourceValue
init|=
operator|(
name|BigDecimal
operator|)
name|sourceInterval
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|RexLiteral
name|castedInterval
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeIntervalLiteral
argument_list|(
name|sourceValue
argument_list|,
name|intervalQualifier
argument_list|)
decl_stmt|;
return|return
name|castToValidatedType
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|castedInterval
argument_list|)
return|;
block|}
if|else if
condition|(
name|left
operator|instanceof
name|SqlNumericLiteral
condition|)
block|{
name|RexLiteral
name|sourceInterval
init|=
operator|(
name|RexLiteral
operator|)
name|cx
operator|.
name|convertExpression
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|BigDecimal
name|sourceValue
init|=
operator|(
name|BigDecimal
operator|)
name|sourceInterval
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|BigDecimal
name|multiplier
init|=
name|intervalQualifier
operator|.
name|getUnit
argument_list|()
operator|.
name|multiplier
decl_stmt|;
name|sourceValue
operator|=
name|sourceValue
operator|.
name|multiply
argument_list|(
name|multiplier
argument_list|)
expr_stmt|;
name|RexLiteral
name|castedInterval
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeIntervalLiteral
argument_list|(
name|sourceValue
argument_list|,
name|intervalQualifier
argument_list|)
decl_stmt|;
return|return
name|castToValidatedType
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|castedInterval
argument_list|)
return|;
block|}
return|return
name|castToValidatedType
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|left
argument_list|)
argument_list|)
return|;
block|}
name|SqlDataTypeSpec
name|dataType
init|=
operator|(
name|SqlDataTypeSpec
operator|)
name|right
decl_stmt|;
if|if
condition|(
name|SqlUtil
operator|.
name|isNullLiteral
argument_list|(
name|left
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|left
argument_list|)
return|;
block|}
name|RexNode
name|arg
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|RelDataType
name|type
init|=
name|dataType
operator|.
name|deriveType
argument_list|(
name|typeFactory
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|dataType
operator|.
name|getCollectionsTypeName
argument_list|()
condition|)
block|{
specifier|final
name|RelDataType
name|argComponentType
init|=
name|arg
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|componentType
init|=
name|type
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|argComponentType
operator|.
name|isStruct
argument_list|()
operator|&&
operator|!
name|componentType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|RelDataType
name|tt
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
name|argComponentType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
name|componentType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|tt
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|tt
argument_list|,
name|componentType
operator|.
name|isNullable
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|isn
init|=
name|type
operator|.
name|isNullable
argument_list|()
decl_stmt|;
name|type
operator|=
name|typeFactory
operator|.
name|createMultisetType
argument_list|(
name|tt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|isn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|convertFloorCeil
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|boolean
name|floor
init|=
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|FLOOR
decl_stmt|;
comment|// Rewrite floor, ceil of interval
if|if
condition|(
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|1
operator|&&
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|SqlIntervalLiteral
condition|)
block|{
specifier|final
name|SqlIntervalLiteral
name|literal
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|SqlIntervalLiteral
operator|.
name|IntervalValue
name|interval
init|=
operator|(
name|SqlIntervalLiteral
operator|.
name|IntervalValue
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|BigDecimal
name|val
init|=
name|interval
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getStartUnit
argument_list|()
operator|.
name|multiplier
decl_stmt|;
name|RexNode
name|rexInterval
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|literal
argument_list|)
decl_stmt|;
name|RexNode
name|res
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexNode
name|zero
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|cond
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|,
name|rexInterval
argument_list|,
name|zero
argument_list|)
decl_stmt|;
name|RexNode
name|pad
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|val
operator|.
name|subtract
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|cast
init|=
name|rexBuilder
operator|.
name|makeReinterpretCast
argument_list|(
name|rexInterval
operator|.
name|getType
argument_list|()
argument_list|,
name|pad
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|SqlOperator
name|op
init|=
name|floor
condition|?
name|SqlStdOperatorTable
operator|.
name|MINUS
else|:
name|SqlStdOperatorTable
operator|.
name|PLUS
decl_stmt|;
name|RexNode
name|sum
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|,
name|rexInterval
argument_list|,
name|cast
argument_list|)
decl_stmt|;
name|RexNode
name|kase
init|=
name|floor
condition|?
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|cond
argument_list|,
name|rexInterval
argument_list|,
name|sum
argument_list|)
else|:
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|cond
argument_list|,
name|sum
argument_list|,
name|rexInterval
argument_list|)
decl_stmt|;
name|RexNode
name|factor
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|RexNode
name|div
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DIVIDE_INTEGER
argument_list|,
name|kase
argument_list|,
name|factor
argument_list|)
decl_stmt|;
name|RexNode
name|mult
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
argument_list|,
name|div
argument_list|,
name|factor
argument_list|)
decl_stmt|;
name|res
operator|=
name|mult
expr_stmt|;
return|return
name|res
return|;
block|}
comment|// normal floor, ceil function
return|return
name|convertFunction
argument_list|(
name|cx
argument_list|,
operator|(
name|SqlFunction
operator|)
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|call
argument_list|)
return|;
block|}
comment|/**    * Converts a call to the {@code EXTRACT} function.    *    *<p>Called automatically via reflection.    */
specifier|public
name|RexNode
name|convertExtract
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlExtractFunction
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|convertExpressionList
argument_list|(
name|cx
argument_list|,
name|operands
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
decl_stmt|;
comment|// TODO: Will need to use decimal type for seconds with precision
name|RelDataType
name|resType
init|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
name|resType
operator|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|resType
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|)
expr_stmt|;
name|RexNode
name|res
init|=
name|rexBuilder
operator|.
name|makeReinterpretCast
argument_list|(
name|resType
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|TimeUnit
name|unit
init|=
operator|(
operator|(
name|SqlIntervalQualifier
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getStartUnit
argument_list|()
decl_stmt|;
specifier|final
name|SqlTypeName
name|sqlTypeName
init|=
name|exprs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|YEAR
case|:
case|case
name|MONTH
case|:
case|case
name|DAY
case|:
switch|switch
condition|(
name|sqlTypeName
condition|)
block|{
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
break|break;
case|case
name|TIMESTAMP
case|:
name|res
operator|=
name|divide
argument_list|(
name|rexBuilder
argument_list|,
name|res
argument_list|,
name|TimeUnit
operator|.
name|DAY
operator|.
name|multiplier
argument_list|)
expr_stmt|;
comment|// fall through
case|case
name|DATE
case|:
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|resType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|EXTRACT_DATE
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|exprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|res
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected "
operator|+
name|sqlTypeName
argument_list|)
throw|;
block|}
break|break;
case|case
name|MILLENNIUM
case|:
case|case
name|CENTURY
case|:
case|case
name|DECADE
case|:
switch|switch
condition|(
name|sqlTypeName
condition|)
block|{
case|case
name|TIMESTAMP
case|:
name|res
operator|=
name|divide
argument_list|(
name|rexBuilder
argument_list|,
name|res
argument_list|,
name|TimeUnit
operator|.
name|DAY
operator|.
name|multiplier
argument_list|)
expr_stmt|;
comment|// fall through
case|case
name|DATE
case|:
name|res
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|resType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|EXTRACT_DATE
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|YEAR
argument_list|)
argument_list|,
name|res
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|divide
argument_list|(
name|rexBuilder
argument_list|,
name|res
argument_list|,
name|unit
operator|.
name|multiplier
operator|.
name|divide
argument_list|(
name|TimeUnit
operator|.
name|YEAR
operator|.
name|multiplier
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|QUARTER
case|:
switch|switch
condition|(
name|sqlTypeName
condition|)
block|{
case|case
name|TIMESTAMP
case|:
name|res
operator|=
name|divide
argument_list|(
name|rexBuilder
argument_list|,
name|res
argument_list|,
name|TimeUnit
operator|.
name|DAY
operator|.
name|multiplier
argument_list|)
expr_stmt|;
comment|// fall through
case|case
name|DATE
case|:
name|res
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|resType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|EXTRACT_DATE
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|MONTH
argument_list|)
argument_list|,
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS
argument_list|,
name|res
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|divide
argument_list|(
name|rexBuilder
argument_list|,
name|res
argument_list|,
name|unit
operator|.
name|multiplier
argument_list|)
expr_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|res
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|EPOCH
case|:
switch|switch
condition|(
name|sqlTypeName
condition|)
block|{
case|case
name|DATE
case|:
comment|// convert to milliseconds
name|res
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|resType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|res
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|TimeUnit
operator|.
name|DAY
operator|.
name|multiplier
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// fall through
case|case
name|TIMESTAMP
case|:
comment|// convert to seconds
return|return
name|divide
argument_list|(
name|rexBuilder
argument_list|,
name|res
argument_list|,
name|TimeUnit
operator|.
name|SECOND
operator|.
name|multiplier
argument_list|)
return|;
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
comment|// no convertlet conversion, pass it as extract
return|return
name|convertFunction
argument_list|(
name|cx
argument_list|,
operator|(
name|SqlFunction
operator|)
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|call
argument_list|)
return|;
block|}
break|break;
case|case
name|DOW
case|:
case|case
name|DOY
case|:
case|case
name|WEEK
case|:
switch|switch
condition|(
name|sqlTypeName
condition|)
block|{
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
comment|// TODO: is this check better to do in validation phase?
comment|// Currently there is parameter on TimeUnit to identify these type of units.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Extract "
operator|+
name|unit
operator|+
literal|" from "
operator|+
name|sqlTypeName
operator|+
literal|" type data is not supported"
argument_list|)
throw|;
case|case
name|TIMESTAMP
case|:
comment|// fall through
case|case
name|DATE
case|:
comment|// no convertlet conversion, pass it as extract
return|return
name|convertFunction
argument_list|(
name|cx
argument_list|,
operator|(
name|SqlFunction
operator|)
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|call
argument_list|)
return|;
block|}
block|}
name|res
operator|=
name|mod
argument_list|(
name|rexBuilder
argument_list|,
name|resType
argument_list|,
name|res
argument_list|,
name|getFactor
argument_list|(
name|unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|TimeUnit
operator|.
name|QUARTER
condition|)
block|{
name|res
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS
argument_list|,
name|res
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|divide
argument_list|(
name|rexBuilder
argument_list|,
name|res
argument_list|,
name|unit
operator|.
name|multiplier
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|TimeUnit
operator|.
name|QUARTER
condition|)
block|{
name|res
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|res
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
specifier|private
specifier|static
name|BigDecimal
name|getFactor
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
block|{
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|DAY
case|:
return|return
name|BigDecimal
operator|.
name|ONE
return|;
case|case
name|HOUR
case|:
return|return
name|TimeUnit
operator|.
name|DAY
operator|.
name|multiplier
return|;
case|case
name|MINUTE
case|:
return|return
name|TimeUnit
operator|.
name|HOUR
operator|.
name|multiplier
return|;
case|case
name|SECOND
case|:
return|return
name|TimeUnit
operator|.
name|MINUTE
operator|.
name|multiplier
return|;
case|case
name|MONTH
case|:
return|return
name|TimeUnit
operator|.
name|YEAR
operator|.
name|multiplier
return|;
case|case
name|QUARTER
case|:
return|return
name|TimeUnit
operator|.
name|YEAR
operator|.
name|multiplier
return|;
case|case
name|YEAR
case|:
case|case
name|DECADE
case|:
case|case
name|CENTURY
case|:
case|case
name|MILLENNIUM
case|:
return|return
name|BigDecimal
operator|.
name|ONE
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|unit
argument_list|)
throw|;
block|}
block|}
specifier|private
name|RexNode
name|mod
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelDataType
name|resType
parameter_list|,
name|RexNode
name|res
parameter_list|,
name|BigDecimal
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|.
name|equals
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
condition|)
block|{
return|return
name|res
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MOD
argument_list|,
name|res
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|val
argument_list|,
name|resType
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|divide
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|res
parameter_list|,
name|BigDecimal
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|.
name|equals
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
condition|)
block|{
return|return
name|res
return|;
block|}
comment|// If val is between 0 and 1, rather than divide by val, multiply by its
comment|// reciprocal. For example, rather than divide by 0.001 multiply by 1000.
if|if
condition|(
name|val
operator|.
name|compareTo
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
operator|<
literal|0
operator|&&
name|val
operator|.
name|signum
argument_list|()
operator|==
literal|1
condition|)
block|{
try|try
block|{
specifier|final
name|BigDecimal
name|reciprocal
init|=
name|BigDecimal
operator|.
name|ONE
operator|.
name|divide
argument_list|(
name|val
argument_list|,
name|RoundingMode
operator|.
name|UNNECESSARY
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
argument_list|,
name|res
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|reciprocal
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|e
parameter_list|)
block|{
comment|// ignore - reciprocal is not an integer
block|}
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DIVIDE_INTEGER
argument_list|,
name|res
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertDatetimeMinus
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlDatetimeSubtractionOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Rewrite datetime minus
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|convertExpressionList
argument_list|(
name|cx
argument_list|,
name|operands
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
decl_stmt|;
name|RelDataType
name|int8Type
init|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
index|[]
name|casts
init|=
operator|new
name|RexNode
index|[
literal|2
index|]
decl_stmt|;
name|casts
index|[
literal|0
index|]
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|int8Type
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|)
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|casts
index|[
literal|1
index|]
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|int8Type
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|)
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|resType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|resType
argument_list|,
name|op
argument_list|,
name|exprs
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertFunction
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlFunction
name|fun
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|convertExpressionList
argument_list|(
name|cx
argument_list|,
name|operands
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
decl_stmt|;
if|if
condition|(
name|fun
operator|.
name|getFunctionType
argument_list|()
operator|==
name|SqlFunctionCategory
operator|.
name|USER_DEFINED_CONSTRUCTOR
condition|)
block|{
return|return
name|makeConstructorCall
argument_list|(
name|cx
argument_list|,
name|fun
argument_list|,
name|exprs
argument_list|)
return|;
block|}
name|RelDataType
name|returnType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeTypeIfKnown
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|returnType
operator|==
literal|null
condition|)
block|{
name|returnType
operator|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|deriveReturnType
argument_list|(
name|fun
argument_list|,
name|exprs
argument_list|)
expr_stmt|;
block|}
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|returnType
argument_list|,
name|fun
argument_list|,
name|exprs
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertSequenceValue
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlSequenceValueOperator
name|fun
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
assert|assert
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
assert|assert
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|SqlIdentifier
assert|;
specifier|final
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|String
name|key
init|=
name|Util
operator|.
name|listToString
argument_list|(
name|id
operator|.
name|names
argument_list|)
decl_stmt|;
name|RelDataType
name|returnType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|returnType
argument_list|,
name|fun
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RexNode
operator|>
name|of
argument_list|(
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertAggregateFunction
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlAggFunction
name|fun
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|isCountStar
argument_list|()
condition|)
block|{
name|exprs
operator|=
name|ImmutableList
operator|.
name|of
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|exprs
operator|=
name|convertExpressionList
argument_list|(
name|cx
argument_list|,
name|operands
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
expr_stmt|;
block|}
name|RelDataType
name|returnType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeTypeIfKnown
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|int
name|groupCount
init|=
name|cx
operator|.
name|getGroupCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|returnType
operator|==
literal|null
condition|)
block|{
name|RexCallBinding
name|binding
init|=
operator|new
name|RexCallBinding
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|fun
argument_list|,
name|exprs
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RelCollation
operator|>
name|of
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|int
name|getGroupCount
parameter_list|()
block|{
return|return
name|groupCount
return|;
block|}
block|}
decl_stmt|;
name|returnType
operator|=
name|fun
operator|.
name|inferReturnType
argument_list|(
name|binding
argument_list|)
expr_stmt|;
block|}
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|returnType
argument_list|,
name|fun
argument_list|,
name|exprs
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|makeConstructorCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlFunction
name|constructor
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataType
name|type
init|=
name|rexBuilder
operator|.
name|deriveReturnType
argument_list|(
name|constructor
argument_list|,
name|exprs
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|type
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|initializationExprs
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|initializationExprs
operator|.
name|add
argument_list|(
name|cx
operator|.
name|getInitializerExpressionFactory
argument_list|()
operator|.
name|newAttributeInitializer
argument_list|(
name|type
argument_list|,
name|constructor
argument_list|,
name|i
argument_list|,
name|exprs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|defaultCasts
init|=
name|RexUtil
operator|.
name|generateCastExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|type
argument_list|,
name|initializationExprs
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeNewInvocation
argument_list|(
name|type
argument_list|,
name|defaultCasts
argument_list|)
return|;
block|}
comment|/**    * Converts a call to an operator into a {@link RexCall} to the same    * operator.    *    *<p>Called automatically via reflection.    *    * @param cx   Context    * @param call Call    * @return Rex call    */
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|call
operator|.
name|getOperator
argument_list|()
argument_list|)
return|;
block|}
comment|/** Converts a {@link SqlCall} to a {@link RexCall} with a perhaps different    * operator. */
specifier|private
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|SqlOperator
name|op
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|SqlOperandTypeChecker
operator|.
name|Consistency
name|consistency
init|=
name|op
operator|.
name|getOperandTypeChecker
argument_list|()
operator|==
literal|null
condition|?
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
else|:
name|op
operator|.
name|getOperandTypeChecker
argument_list|()
operator|.
name|getConsistency
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|convertExpressionList
argument_list|(
name|cx
argument_list|,
name|operands
argument_list|,
name|consistency
argument_list|)
decl_stmt|;
name|RelDataType
name|type
init|=
name|rexBuilder
operator|.
name|deriveReturnType
argument_list|(
name|op
argument_list|,
name|exprs
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|op
argument_list|,
name|RexUtil
operator|.
name|flatten
argument_list|(
name|exprs
argument_list|,
name|op
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|elseArgs
parameter_list|(
name|int
name|count
parameter_list|)
block|{
comment|// If list is odd, e.g. [0, 1, 2, 3, 4] we get [1, 3, 4]
comment|// If list is even, e.g. [0, 1, 2, 3, 4, 5] we get [2, 4, 5]
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|count
operator|%
literal|2
init|;
condition|;
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|count
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|list
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|convertExpressionList
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodes
parameter_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
name|consistency
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|nodes
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|cx
operator|.
name|convertExpression
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exprs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|consistentType
argument_list|(
name|cx
argument_list|,
name|consistency
argument_list|,
name|RexUtil
operator|.
name|types
argument_list|(
name|exprs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|oldExprs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|exprs
argument_list|)
decl_stmt|;
name|exprs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|oldExprs
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|exprs
return|;
block|}
specifier|private
specifier|static
name|RelDataType
name|consistentType
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
name|consistency
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
parameter_list|)
block|{
switch|switch
condition|(
name|consistency
condition|)
block|{
case|case
name|COMPARE
case|:
specifier|final
name|Set
argument_list|<
name|RelDataTypeFamily
argument_list|>
name|families
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|RexUtil
operator|.
name|families
argument_list|(
name|types
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|families
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
comment|// All arguments are of same family. No need for explicit casts.
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|nonCharacterTypes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataType
name|type
range|:
name|types
control|)
block|{
if|if
condition|(
name|type
operator|.
name|getFamily
argument_list|()
operator|!=
name|SqlTypeFamily
operator|.
name|CHARACTER
condition|)
block|{
name|nonCharacterTypes
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|nonCharacterTypes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|int
name|typeCount
init|=
name|types
operator|.
name|size
argument_list|()
decl_stmt|;
name|types
operator|=
name|nonCharacterTypes
expr_stmt|;
if|if
condition|(
name|nonCharacterTypes
operator|.
name|size
argument_list|()
operator|<
name|typeCount
condition|)
block|{
specifier|final
name|RelDataTypeFamily
name|family
init|=
name|nonCharacterTypes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFamily
argument_list|()
decl_stmt|;
if|if
condition|(
name|family
operator|instanceof
name|SqlTypeFamily
condition|)
block|{
comment|// The character arguments might be larger than the numeric
comment|// argument. Give ourselves some headroom.
switch|switch
condition|(
operator|(
name|SqlTypeFamily
operator|)
name|family
condition|)
block|{
case|case
name|INTEGER
case|:
case|case
name|NUMERIC
case|:
name|nonCharacterTypes
operator|.
name|add
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// fall through
case|case
name|LEAST_RESTRICTIVE
case|:
return|return
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|leastRestrictive
argument_list|(
name|types
argument_list|)
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|RexNode
name|convertPlus
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RexNode
name|rex
init|=
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rex
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|DATE
case|:
case|case
name|TIME
case|:
case|case
name|TIMESTAMP
case|:
comment|// Use special "+" operator for datetime + interval.
comment|// Re-order operands, if necessary, so that interval is second.
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
specifier|final
name|SqlTypeName
name|sqlTypeName
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|sqlTypeName
condition|)
block|{
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
name|operands
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|rex
operator|.
name|getType
argument_list|()
argument_list|,
name|SqlStdOperatorTable
operator|.
name|DATETIME_PLUS
argument_list|,
name|operands
argument_list|)
return|;
default|default:
return|return
name|rex
return|;
block|}
block|}
specifier|private
name|RexNode
name|convertIsDistinctFrom
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|boolean
name|neg
parameter_list|)
block|{
name|RexNode
name|op0
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|op1
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|RelOptUtil
operator|.
name|isDistinctFrom
argument_list|(
name|cx
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|neg
argument_list|)
return|;
block|}
comment|/**    * Converts a BETWEEN expression.    *    *<p>Called automatically via reflection.    */
specifier|public
name|RexNode
name|convertBetween
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlBetweenOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
name|convertExpressionList
argument_list|(
name|cx
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|,
name|op
operator|.
name|getOperandTypeChecker
argument_list|()
operator|.
name|getConsistency
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|x
init|=
name|list
operator|.
name|get
argument_list|(
name|SqlBetweenOperator
operator|.
name|VALUE_OPERAND
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|y
init|=
name|list
operator|.
name|get
argument_list|(
name|SqlBetweenOperator
operator|.
name|LOWER_OPERAND
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|z
init|=
name|list
operator|.
name|get
argument_list|(
name|SqlBetweenOperator
operator|.
name|UPPER_OPERAND
argument_list|)
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexNode
name|ge1
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|RexNode
name|le1
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
argument_list|,
name|x
argument_list|,
name|z
argument_list|)
decl_stmt|;
name|RexNode
name|and1
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|ge1
argument_list|,
name|le1
argument_list|)
decl_stmt|;
name|RexNode
name|res
decl_stmt|;
specifier|final
name|SqlBetweenOperator
operator|.
name|Flag
name|symmetric
init|=
name|op
operator|.
name|flag
decl_stmt|;
switch|switch
condition|(
name|symmetric
condition|)
block|{
case|case
name|ASYMMETRIC
case|:
name|res
operator|=
name|and1
expr_stmt|;
break|break;
case|case
name|SYMMETRIC
case|:
name|RexNode
name|ge2
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|,
name|x
argument_list|,
name|z
argument_list|)
decl_stmt|;
name|RexNode
name|le2
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|RexNode
name|and2
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|ge2
argument_list|,
name|le2
argument_list|)
decl_stmt|;
name|res
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|and1
argument_list|,
name|and2
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|symmetric
argument_list|)
throw|;
block|}
specifier|final
name|SqlBetweenOperator
name|betweenOp
init|=
operator|(
name|SqlBetweenOperator
operator|)
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|betweenOp
operator|.
name|isNegated
argument_list|()
condition|)
block|{
name|res
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/**    * Converts a LiteralChain expression: that is, concatenates the operands    * immediately, to produce a single literal string.    *    *<p>Called automatically via reflection.    */
specifier|public
name|RexNode
name|convertLiteralChain
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlLiteralChainOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
name|Util
operator|.
name|discard
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|SqlLiteral
name|sum
init|=
name|SqlLiteralChainOperator
operator|.
name|concatenateOperands
argument_list|(
name|call
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertLiteral
argument_list|(
name|sum
argument_list|)
return|;
block|}
comment|/**    * Converts a ROW.    *    *<p>Called automatically via reflection.    */
specifier|public
name|RexNode
name|convertRow
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlRowOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|COLUMN_LIST
condition|)
block|{
return|return
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|columns
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|(
operator|(
name|SqlIdentifier
operator|)
name|operand
operator|)
operator|.
name|getSimple
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataType
name|type
init|=
name|rexBuilder
operator|.
name|deriveReturnType
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COLUMN_LIST
argument_list|,
name|columns
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|COLUMN_LIST
argument_list|,
name|columns
argument_list|)
return|;
block|}
comment|/**    * Converts a call to OVERLAPS.    *    *<p>Called automatically via reflection.    */
specifier|public
name|RexNode
name|convertOverlaps
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlOverlapsOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// for intervals [t0, t1] overlaps [t2, t3], we can find if the
comment|// intervals overlaps by: ~(t1< t2 or t3< t0)
specifier|final
name|SqlNode
index|[]
name|operands
init|=
operator|(
operator|(
name|SqlBasicCall
operator|)
name|call
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
assert|assert
name|operands
operator|.
name|length
operator|==
literal|4
assert|;
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|instanceof
name|SqlIntervalLiteral
condition|)
block|{
comment|// make t1 = t0 + t1 when t1 is an interval.
name|SqlOperator
name|op1
init|=
name|SqlStdOperatorTable
operator|.
name|PLUS
decl_stmt|;
name|SqlNode
index|[]
name|second
init|=
operator|new
name|SqlNode
index|[
literal|2
index|]
decl_stmt|;
name|second
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|second
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|op1
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|second
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operands
index|[
literal|3
index|]
operator|instanceof
name|SqlIntervalLiteral
condition|)
block|{
comment|// make t3 = t2 + t3 when t3 is an interval.
name|SqlOperator
name|op1
init|=
name|SqlStdOperatorTable
operator|.
name|PLUS
decl_stmt|;
name|SqlNode
index|[]
name|four
init|=
operator|new
name|SqlNode
index|[
literal|2
index|]
decl_stmt|;
name|four
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|four
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|op1
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|four
argument_list|)
expr_stmt|;
block|}
comment|// This captures t1>= t2
name|SqlOperator
name|op1
init|=
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
decl_stmt|;
name|SqlNode
index|[]
name|left
init|=
operator|new
name|SqlNode
index|[
literal|2
index|]
decl_stmt|;
name|left
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|left
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|SqlCall
name|call1
init|=
name|op1
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|left
argument_list|)
decl_stmt|;
comment|// This captures t3>= t0
name|SqlOperator
name|op2
init|=
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
decl_stmt|;
name|SqlNode
index|[]
name|right
init|=
operator|new
name|SqlNode
index|[
literal|2
index|]
decl_stmt|;
name|right
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|right
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|SqlCall
name|call2
init|=
name|op2
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|right
argument_list|)
decl_stmt|;
comment|// This captures t1>= t2 and t3>= t0
name|SqlOperator
name|and
init|=
name|SqlStdOperatorTable
operator|.
name|AND
decl_stmt|;
name|SqlNode
index|[]
name|overlaps
init|=
operator|new
name|SqlNode
index|[
literal|2
index|]
decl_stmt|;
name|overlaps
index|[
literal|0
index|]
operator|=
name|call1
expr_stmt|;
name|overlaps
index|[
literal|1
index|]
operator|=
name|call2
expr_stmt|;
name|SqlCall
name|call3
init|=
name|and
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|overlaps
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|call3
argument_list|)
return|;
block|}
comment|/**    * Casts a RexNode value to the validated type of a SqlCall. If the value    * was already of the validated type, then the value is returned without an    * additional cast.    */
specifier|public
name|RexNode
name|castToValidatedType
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|RexNode
name|value
parameter_list|)
block|{
return|return
name|castToValidatedType
argument_list|(
name|call
argument_list|,
name|value
argument_list|,
name|cx
operator|.
name|getValidator
argument_list|()
argument_list|,
name|cx
operator|.
name|getRexBuilder
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Casts a RexNode value to the validated type of a SqlCall. If the value    * was already of the validated type, then the value is returned without an    * additional cast.    */
specifier|public
specifier|static
name|RexNode
name|castToValidatedType
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|RexNode
name|e
parameter_list|,
name|SqlValidator
name|validator
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getType
argument_list|()
operator|==
name|type
condition|)
block|{
return|return
name|e
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
return|;
block|}
comment|/** Convertlet that handles {@code AVG} and {@code VARIANCE}    * windowed aggregate functions. */
specifier|private
specifier|static
class|class
name|AvgVarianceConvertlet
implements|implements
name|SqlRexConvertlet
block|{
specifier|private
specifier|final
name|SqlKind
name|kind
decl_stmt|;
specifier|public
name|AvgVarianceConvertlet
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
name|this
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
block|}
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|SqlNode
name|arg
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|expr
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|AVG
case|:
name|expr
operator|=
name|expandAvg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|STDDEV_POP
case|:
name|expr
operator|=
name|expandVariance
argument_list|(
name|arg
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|STDDEV_SAMP
case|:
name|expr
operator|=
name|expandVariance
argument_list|(
name|arg
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_POP
case|:
name|expr
operator|=
name|expandVariance
argument_list|(
name|arg
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_SAMP
case|:
name|expr
operator|=
name|expandVariance
argument_list|(
name|arg
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|kind
argument_list|)
throw|;
block|}
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|RexNode
name|rex
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|type
argument_list|,
name|rex
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
name|SqlNode
name|expandAvg
parameter_list|(
specifier|final
name|SqlNode
name|arg
parameter_list|)
block|{
specifier|final
name|SqlParserPos
name|pos
init|=
name|SqlParserPos
operator|.
name|ZERO
decl_stmt|;
specifier|final
name|SqlNode
name|sum
init|=
name|SqlStdOperatorTable
operator|.
name|SUM
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|count
init|=
name|SqlStdOperatorTable
operator|.
name|COUNT
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|DIVIDE
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sum
argument_list|,
name|count
argument_list|)
return|;
block|}
specifier|private
name|SqlNode
name|expandVariance
parameter_list|(
specifier|final
name|SqlNode
name|arg
parameter_list|,
name|boolean
name|biased
parameter_list|,
name|boolean
name|sqrt
parameter_list|)
block|{
comment|// stddev_pop(x) ==>
comment|//   power(
comment|//     (sum(x * x) - sum(x) * sum(x) / count(x))
comment|//     / count(x),
comment|//     .5)
comment|//
comment|// stddev_samp(x) ==>
comment|//   power(
comment|//     (sum(x * x) - sum(x) * sum(x) / count(x))
comment|//     / (count(x) - 1),
comment|//     .5)
comment|//
comment|// var_pop(x) ==>
comment|//     (sum(x * x) - sum(x) * sum(x) / count(x))
comment|//     / count(x)
comment|//
comment|// var_samp(x) ==>
comment|//     (sum(x * x) - sum(x) * sum(x) / count(x))
comment|//     / (count(x) - 1)
specifier|final
name|SqlParserPos
name|pos
init|=
name|SqlParserPos
operator|.
name|ZERO
decl_stmt|;
specifier|final
name|SqlNode
name|argSquared
init|=
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sumArgSquared
init|=
name|SqlStdOperatorTable
operator|.
name|SUM
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|argSquared
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sum
init|=
name|SqlStdOperatorTable
operator|.
name|SUM
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sumSquared
init|=
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sum
argument_list|,
name|sum
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|count
init|=
name|SqlStdOperatorTable
operator|.
name|COUNT
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|avgSumSquared
init|=
name|SqlStdOperatorTable
operator|.
name|DIVIDE
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sumSquared
argument_list|,
name|count
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|diff
init|=
name|SqlStdOperatorTable
operator|.
name|MINUS
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sumArgSquared
argument_list|,
name|avgSumSquared
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|denominator
decl_stmt|;
if|if
condition|(
name|biased
condition|)
block|{
name|denominator
operator|=
name|count
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|SqlNumericLiteral
name|one
init|=
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"1"
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|denominator
operator|=
name|SqlStdOperatorTable
operator|.
name|MINUS
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|count
argument_list|,
name|one
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlNode
name|div
init|=
name|SqlStdOperatorTable
operator|.
name|DIVIDE
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|diff
argument_list|,
name|denominator
argument_list|)
decl_stmt|;
name|SqlNode
name|result
init|=
name|div
decl_stmt|;
if|if
condition|(
name|sqrt
condition|)
block|{
specifier|final
name|SqlNumericLiteral
name|half
init|=
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"0.5"
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|result
operator|=
name|SqlStdOperatorTable
operator|.
name|POWER
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|div
argument_list|,
name|half
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
comment|/** Convertlet that converts {@code LTRIM} and {@code RTRIM} to    * {@code TRIM}. */
specifier|private
specifier|static
class|class
name|TrimConvertlet
implements|implements
name|SqlRexConvertlet
block|{
specifier|private
specifier|final
name|SqlTrimFunction
operator|.
name|Flag
name|flag
decl_stmt|;
specifier|public
name|TrimConvertlet
parameter_list|(
name|SqlTrimFunction
operator|.
name|Flag
name|flag
parameter_list|)
block|{
name|this
operator|.
name|flag
operator|=
name|flag
expr_stmt|;
block|}
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|operand
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|TRIM
argument_list|,
name|rexBuilder
operator|.
name|makeFlag
argument_list|(
name|flag
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|" "
argument_list|)
argument_list|,
name|operand
argument_list|)
return|;
block|}
block|}
comment|/** Convertlet that converts {@code GREATEST} and {@code LEAST}. */
specifier|private
specifier|static
class|class
name|GreatestConvertlet
implements|implements
name|SqlRexConvertlet
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Translate
comment|//   GREATEST(a, b, c, d)
comment|// to
comment|//   CASE
comment|//   WHEN a IS NULL OR b IS NULL OR c IS NULL OR d IS NULL
comment|//   THEN NULL
comment|//   WHEN a> b AND a> c AND a> d
comment|//   THEN a
comment|//   WHEN b> c AND b> d
comment|//   THEN b
comment|//   WHEN c> d
comment|//   THEN c
comment|//   ELSE d
comment|//   END
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|SqlBinaryOperator
name|op
decl_stmt|;
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|GREATEST
case|:
name|op
operator|=
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
expr_stmt|;
break|break;
case|case
name|LEAST
case|:
name|op
operator|=
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|convertExpressionList
argument_list|(
name|cx
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|,
name|SqlOperandTypeChecker
operator|.
name|Consistency
operator|.
name|NONE
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|orList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
name|orList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|RexUtil
operator|.
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|orList
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|andList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|RexNode
name|expr2
init|=
name|exprs
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|andList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|,
name|expr
argument_list|,
name|expr2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|andList
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|exprs
operator|.
name|get
argument_list|(
name|exprs
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|list
argument_list|)
return|;
block|}
block|}
comment|/** Convertlet that handles {@code FLOOR} and {@code CEIL} functions. */
specifier|private
class|class
name|FloorCeilConvertlet
implements|implements
name|SqlRexConvertlet
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertFloorCeil
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
block|}
comment|/** Convertlet that handles the {@code TIMESTAMPADD} function. */
specifier|private
specifier|static
class|class
name|TimestampAddConvertlet
implements|implements
name|SqlRexConvertlet
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// TIMESTAMPADD(unit, count, timestamp)
comment|//  => timestamp + count * INTERVAL '1' UNIT
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|SqlLiteral
name|unitLiteral
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|TimeUnit
name|unit
init|=
name|unitLiteral
operator|.
name|symbolValue
argument_list|(
name|TimeUnit
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DATETIME_PLUS
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
argument_list|,
name|rexBuilder
operator|.
name|makeIntervalLiteral
argument_list|(
name|unit
operator|.
name|multiplier
argument_list|,
operator|new
name|SqlIntervalQualifier
argument_list|(
name|unit
argument_list|,
literal|null
argument_list|,
name|unitLiteral
operator|.
name|getParserPosition
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Convertlet that handles the {@code TIMESTAMPDIFF} function. */
specifier|private
specifier|static
class|class
name|TimestampDiffConvertlet
implements|implements
name|SqlRexConvertlet
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// TIMESTAMPDIFF(unit, t1, t2)
comment|//    => (t2 - t1) UNIT
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|SqlLiteral
name|unitLiteral
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|TimeUnit
name|unit
init|=
name|unitLiteral
operator|.
name|symbolValue
argument_list|(
name|TimeUnit
operator|.
name|class
argument_list|)
decl_stmt|;
name|BigDecimal
name|multiplier
init|=
name|BigDecimal
operator|.
name|ONE
decl_stmt|;
name|BigDecimal
name|divider
init|=
name|BigDecimal
operator|.
name|ONE
decl_stmt|;
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|MICROSECOND
case|:
case|case
name|MILLISECOND
case|:
case|case
name|WEEK
case|:
name|multiplier
operator|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|DateTimeUtils
operator|.
name|MILLIS_PER_SECOND
argument_list|)
expr_stmt|;
name|divider
operator|=
name|unit
operator|.
name|multiplier
expr_stmt|;
name|unit
operator|=
name|TimeUnit
operator|.
name|SECOND
expr_stmt|;
break|break;
case|case
name|QUARTER
case|:
name|divider
operator|=
name|unit
operator|.
name|multiplier
expr_stmt|;
name|unit
operator|=
name|TimeUnit
operator|.
name|MONTH
expr_stmt|;
break|break;
block|}
specifier|final
name|SqlIntervalQualifier
name|qualifier
init|=
operator|new
name|SqlIntervalQualifier
argument_list|(
name|unit
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op2
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op1
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intervalType
init|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlIntervalType
argument_list|(
name|qualifier
argument_list|)
argument_list|,
name|op1
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
operator|||
name|op2
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexCall
name|rexCall
init|=
operator|(
name|RexCall
operator|)
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|intervalType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|MINUS_DATE
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|op2
argument_list|,
name|op1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|,
name|SqlTypeUtil
operator|.
name|containsNullable
argument_list|(
name|rexCall
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|e
init|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|intType
argument_list|,
name|rexCall
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|multiplyDivide
argument_list|(
name|e
argument_list|,
name|multiplier
argument_list|,
name|divider
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End StandardConvertletTable.java
end_comment

end_unit

