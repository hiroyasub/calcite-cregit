begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteSystemProperty
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_comment
comment|/**  * Partially-ordered set.  *  *<p>When you create a partially-ordered set ('poset' for short) you must  * provide an {@link Ordering} that determines the order relation. The  * ordering must be:</p>  *  *<ul>  *<li>reflexive: e.lte(e) returns true;</li>  *<li>anti-symmetric: if e.lte(f) returns true,  *     then f.lte(e) returns false only if e = f;</li>  *<li>transitive: if e.lte(f) returns true and  *     f.lte(g) returns true, then e.lte(g) must return true.</li>  *</ul>  *  *<p>Note that not all pairs of elements are related. If is OK if e.lte(f)  * returns false and f.lte(e) returns false also.</p>  *  *<p>In addition to the usual set methods, there are methods to determine the  * immediate parents and children of an element in the set, and method to find  * all elements which have no parents or no children (i.e. "root" and "leaf"  * elements).</p>  *  *<p>A lattice is a special kind of poset where there is a unique top and  * bottom element. You can use a PartiallyOrderedSet for a lattice also. It may  * be helpful to add the top and bottom elements to the poset on  * construction.</p>  *  * @param<E> Element type  */
end_comment

begin_class
specifier|public
class|class
name|PartiallyOrderedSet
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractSet
argument_list|<
name|E
argument_list|>
block|{
comment|/** Ordering that orders bit sets by inclusion.    *    *<p>For example, the children of 14 (1110) are 12 (1100), 10 (1010) and    * 6 (0110).    */
specifier|public
specifier|static
specifier|final
name|Ordering
argument_list|<
name|ImmutableBitSet
argument_list|>
name|BIT_SET_INCLUSION_ORDERING
init|=
name|ImmutableBitSet
operator|::
name|contains
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|E
argument_list|,
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|map
decl_stmt|;
specifier|private
specifier|final
name|Function
argument_list|<
name|E
argument_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|>
name|parentFunction
decl_stmt|;
specifier|private
specifier|final
name|Function
argument_list|<
name|E
argument_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|>
name|childFunction
decl_stmt|;
specifier|private
specifier|final
name|Ordering
argument_list|<
name|E
argument_list|>
name|ordering
decl_stmt|;
comment|/**    * Synthetic node to hold all nodes that have no parents. It does not appear    * in the set.    */
specifier|private
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|topNode
decl_stmt|;
specifier|private
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|bottomNode
decl_stmt|;
comment|/**    * Creates a partially-ordered set.    *    * @param ordering Ordering relation    */
specifier|public
name|PartiallyOrderedSet
parameter_list|(
name|Ordering
argument_list|<
name|E
argument_list|>
name|ordering
parameter_list|)
block|{
name|this
argument_list|(
name|ordering
argument_list|,
operator|new
name|HashMap
argument_list|<>
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a partially-ordered set with a parent-generating function.    *    * @param ordering Ordering relation    * @param parentFunction Function to compute parents of a node; may be null    */
specifier|public
name|PartiallyOrderedSet
parameter_list|(
name|Ordering
argument_list|<
name|E
argument_list|>
name|ordering
parameter_list|,
name|Function
argument_list|<
name|E
argument_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|>
name|childFunction
parameter_list|,
name|Function
argument_list|<
name|E
argument_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|>
name|parentFunction
parameter_list|)
block|{
name|this
argument_list|(
name|ordering
argument_list|,
operator|new
name|HashMap
argument_list|<>
argument_list|()
argument_list|,
name|childFunction
argument_list|,
name|parentFunction
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"Guava"
argument_list|)
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|PartiallyOrderedSet
parameter_list|(
name|Ordering
argument_list|<
name|E
argument_list|>
name|ordering
parameter_list|,
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
argument_list|<
name|E
argument_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|>
name|childFunction
parameter_list|,
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
argument_list|<
name|E
argument_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|>
name|parentFunction
parameter_list|)
block|{
name|this
argument_list|(
name|ordering
argument_list|,
operator|(
name|Function
argument_list|<
name|E
argument_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|>
operator|)
name|childFunction
operator|::
name|apply
argument_list|,
name|parentFunction
operator|::
name|apply
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a partially-ordered set, and populates it with a given    * collection.    *    * @param ordering Ordering relation    * @param collection Initial contents of partially-ordered set    */
specifier|public
name|PartiallyOrderedSet
parameter_list|(
name|Ordering
argument_list|<
name|E
argument_list|>
name|ordering
parameter_list|,
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
parameter_list|)
block|{
name|this
argument_list|(
name|ordering
argument_list|,
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|collection
operator|.
name|size
argument_list|()
operator|*
literal|3
operator|/
literal|2
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|addAll
argument_list|(
name|collection
argument_list|)
expr_stmt|;
block|}
comment|/**    * Internal constructor.    *    * @param ordering Ordering relation    * @param map Map from values to nodes    * @param parentFunction Function to compute parents of a node; may be null    */
specifier|private
name|PartiallyOrderedSet
parameter_list|(
name|Ordering
argument_list|<
name|E
argument_list|>
name|ordering
parameter_list|,
name|Map
argument_list|<
name|E
argument_list|,
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|map
parameter_list|,
name|Function
argument_list|<
name|E
argument_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|>
name|childFunction
parameter_list|,
name|Function
argument_list|<
name|E
argument_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|>
name|parentFunction
parameter_list|)
block|{
name|this
operator|.
name|ordering
operator|=
name|ordering
expr_stmt|;
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
name|this
operator|.
name|childFunction
operator|=
name|childFunction
expr_stmt|;
name|this
operator|.
name|parentFunction
operator|=
name|parentFunction
expr_stmt|;
name|this
operator|.
name|topNode
operator|=
operator|new
name|TopBottomNode
argument_list|<>
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|bottomNode
operator|=
operator|new
name|TopBottomNode
argument_list|<>
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|topNode
operator|.
name|childList
operator|.
name|add
argument_list|(
name|bottomNode
argument_list|)
expr_stmt|;
name|this
operator|.
name|bottomNode
operator|.
name|parentList
operator|.
name|add
argument_list|(
name|topNode
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"NullableProblems"
argument_list|)
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
init|=
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
name|E
name|previous
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|E
name|next
parameter_list|()
block|{
return|return
name|previous
operator|=
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
operator|!
name|PartiallyOrderedSet
operator|.
name|this
operator|.
name|remove
argument_list|(
name|previous
argument_list|)
condition|)
block|{
comment|// Object was not present.
comment|// Maybe they have never called 'next'?
comment|// Maybe they called 'remove' twice?
comment|// Either way, something is screwy.
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
comment|//noinspection SuspiciousMethodCalls
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"SuspiciousMethodCalls"
argument_list|)
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|map
operator|.
name|remove
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|node
operator|.
name|parentList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|parent
init|=
name|node
operator|.
name|parentList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|child
range|:
name|node
operator|.
name|childList
control|)
block|{
if|if
condition|(
name|parent
operator|.
name|e
operator|==
literal|null
operator|&&
name|child
operator|.
name|e
operator|==
literal|null
condition|)
block|{
name|parent
operator|.
name|childList
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|replace
argument_list|(
name|parent
operator|.
name|childList
argument_list|,
name|node
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|node
operator|.
name|childList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|child
init|=
name|node
operator|.
name|childList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|parent
range|:
name|node
operator|.
name|parentList
control|)
block|{
if|if
condition|(
name|child
operator|.
name|e
operator|==
literal|null
operator|&&
name|parent
operator|.
name|e
operator|==
literal|null
condition|)
block|{
name|child
operator|.
name|parentList
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|replace
argument_list|(
name|child
operator|.
name|parentList
argument_list|,
name|node
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Adds an element to this lattice.    */
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
assert|assert
name|e
operator|!=
literal|null
assert|;
assert|assert
operator|!
name|CalciteSystemProperty
operator|.
name|DEBUG
operator|.
name|value
argument_list|()
operator|||
name|isValid
argument_list|(
literal|true
argument_list|)
assert|;
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|map
operator|.
name|get
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
comment|// already present
return|return
literal|false
return|;
block|}
name|Set
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|parents
init|=
name|findParents
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|children
init|=
name|findChildren
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|node
operator|=
operator|new
name|Node
argument_list|<>
argument_list|(
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|parent
range|:
name|parents
control|)
block|{
name|node
operator|.
name|parentList
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parent
operator|.
name|childList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|child
init|=
name|parent
operator|.
name|childList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|e
operator|==
literal|null
operator|||
name|ordering
operator|.
name|lessThan
argument_list|(
name|child
operator|.
name|e
argument_list|,
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
name|parent
operator|.
name|childList
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|parent
operator|.
name|childList
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|.
name|childList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|replace
argument_list|(
name|child
operator|.
name|parentList
argument_list|,
name|parent
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|.
name|childList
operator|.
name|contains
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|node
operator|.
name|childList
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|parent
operator|.
name|childList
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Nodes reachable from parents.
specifier|final
name|Set
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|childSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|node
operator|.
name|childList
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|child
range|:
name|children
control|)
block|{
if|if
condition|(
operator|!
name|isDescendantOfAny
argument_list|(
name|child
argument_list|,
name|childSet
argument_list|)
condition|)
block|{
name|node
operator|.
name|childList
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|child
operator|.
name|parentList
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|child
operator|.
name|parentList
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|map
operator|.
name|put
argument_list|(
name|node
operator|.
name|e
argument_list|,
name|node
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|CalciteSystemProperty
operator|.
name|DEBUG
operator|.
name|value
argument_list|()
operator|||
name|isValid
argument_list|(
literal|true
argument_list|)
assert|;
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether node's value is a descendant of any of the values in    * nodeSet.    *    * @param node Node    * @param nodeSet Suspected ancestors    * @return Whether node is a descendant of any of the nodes    */
specifier|private
name|boolean
name|isDescendantOfAny
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|nodeSet
parameter_list|)
block|{
specifier|final
name|Deque
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|seen
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|deque
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|deque
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|node1
init|=
name|deque
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodeSet
operator|.
name|contains
argument_list|(
name|node1
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|parent
range|:
name|node1
operator|.
name|parentList
control|)
block|{
if|if
condition|(
name|seen
operator|.
name|add
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|deque
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|Set
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|findChildren
parameter_list|(
name|E
name|e
parameter_list|)
block|{
specifier|final
name|Deque
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|descendants
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
name|descendants
operator|.
name|add
argument_list|(
name|bottomNode
argument_list|)
expr_stmt|;
return|return
name|findParentsChildren
argument_list|(
name|e
argument_list|,
name|descendants
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|Set
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|findParents
parameter_list|(
name|E
name|e
parameter_list|)
block|{
specifier|final
name|Deque
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|ancestors
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
name|ancestors
operator|.
name|add
argument_list|(
name|topNode
argument_list|)
expr_stmt|;
return|return
name|findParentsChildren
argument_list|(
name|e
argument_list|,
name|ancestors
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
name|Set
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|findParentsChildren
parameter_list|(
name|E
name|e
parameter_list|,
name|Deque
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|ancestors
parameter_list|,
name|boolean
name|up
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|parents
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|ancestors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|ancestor
init|=
name|ancestors
operator|.
name|pop
argument_list|()
decl_stmt|;
assert|assert
name|ancestor
operator|.
name|e
operator|==
literal|null
operator|||
operator|(
name|up
condition|?
operator|!
name|ordering
operator|.
name|lessThan
argument_list|(
name|ancestor
operator|.
name|e
argument_list|,
name|e
argument_list|)
else|:
operator|!
name|ordering
operator|.
name|lessThan
argument_list|(
name|e
argument_list|,
name|ancestor
operator|.
name|e
argument_list|)
operator|)
assert|;
assert|assert
name|ancestor
operator|.
name|e
operator|!=
name|e
assert|;
comment|// e not in tree yet
comment|// Example: e = "a", ancestor = "abc".
comment|// If there is at least one child c of ancestor such that e<= c
comment|// (e.g. "ab", "ac") examine those children. If there are no
comment|// such children, ancestor becomes a parent
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|child
range|:
name|up
condition|?
name|ancestor
operator|.
name|childList
else|:
name|ancestor
operator|.
name|parentList
control|)
block|{
if|if
condition|(
name|child
operator|.
name|e
operator|==
literal|null
condition|)
block|{
continue|continue;
comment|// child is the bottom node
block|}
if|if
condition|(
name|up
condition|?
name|ordering
operator|.
name|lessThan
argument_list|(
name|e
argument_list|,
name|child
operator|.
name|e
argument_list|)
else|:
name|ordering
operator|.
name|lessThan
argument_list|(
name|child
operator|.
name|e
argument_list|,
name|e
argument_list|)
condition|)
block|{
name|ancestors
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
operator|++
name|found
expr_stmt|;
block|}
if|else if
condition|(
name|up
condition|?
operator|!
name|ordering
operator|.
name|lessThan
argument_list|(
name|child
operator|.
name|e
argument_list|,
name|e
argument_list|)
else|:
operator|!
name|ordering
operator|.
name|lessThan
argument_list|(
name|e
argument_list|,
name|child
operator|.
name|e
argument_list|)
condition|)
block|{
comment|// e is not less than child (and therefore some descendant
comment|// of child might be less than e). Recurse into its
comment|// children.
name|ancestors
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
comment|// None of the descendants of the node are greater than e.
comment|// Therefore node is a parent, provided that e is definitely
comment|// less than node
if|if
condition|(
name|ancestor
operator|.
name|e
operator|==
literal|null
operator|||
operator|(
name|up
condition|?
name|ordering
operator|.
name|lessThan
argument_list|(
name|e
argument_list|,
name|ancestor
operator|.
name|e
argument_list|)
else|:
name|ordering
operator|.
name|lessThan
argument_list|(
name|ancestor
operator|.
name|e
argument_list|,
name|e
argument_list|)
operator|)
condition|)
block|{
name|parents
operator|.
name|add
argument_list|(
name|ancestor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|parents
return|;
block|}
specifier|private
parameter_list|<
name|T
parameter_list|>
name|void
name|replace
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
name|T
name|remove
parameter_list|,
name|T
name|add
parameter_list|)
block|{
if|if
condition|(
name|list
operator|.
name|contains
argument_list|(
name|add
argument_list|)
condition|)
block|{
name|list
operator|.
name|remove
argument_list|(
name|remove
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|index
init|=
name|list
operator|.
name|indexOf
argument_list|(
name|remove
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|list
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|add
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|add
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Checks internal consistency of this lattice.    *    * @param fail Whether to throw an assertion error    * @return Whether valid    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"ConstantConditions"
block|}
argument_list|)
specifier|public
name|boolean
name|isValid
parameter_list|(
name|boolean
name|fail
parameter_list|)
block|{
comment|// Top has no parents.
comment|// Bottom has no children.
comment|// Each node except top has at least one parent.
comment|// Each node except bottom has at least one child.
comment|// Every node's children list it as a parent.
comment|// Every node's parents list it as a child.
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|(
name|node
operator|==
name|topNode
operator|)
operator|!=
name|node
operator|.
name|parentList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"only top node should have no parents "
operator|+
name|node
operator|+
literal|", parents "
operator|+
name|node
operator|.
name|parentList
assert|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|node
operator|==
name|bottomNode
operator|)
operator|!=
name|node
operator|.
name|childList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"only bottom node should have no children "
operator|+
name|node
operator|+
literal|", children "
operator|+
name|node
operator|.
name|childList
assert|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|node
operator|.
name|childList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|child
init|=
name|node
operator|.
name|childList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|child
operator|.
name|parentList
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"child "
operator|+
name|child
operator|+
literal|" of "
operator|+
name|node
operator|+
literal|" does not know its parent"
assert|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|child
operator|.
name|e
operator|!=
literal|null
operator|&&
operator|!
name|ordering
operator|.
name|lessThan
argument_list|(
name|child
operator|.
name|e
argument_list|,
name|node
operator|.
name|e
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"child "
operator|+
name|child
operator|.
name|e
operator|+
literal|" not less than parent "
operator|+
name|node
operator|.
name|e
assert|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i2
init|=
literal|0
init|;
name|i2
operator|<
name|node
operator|.
name|childList
operator|.
name|size
argument_list|()
condition|;
name|i2
operator|++
control|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|child2
init|=
name|node
operator|.
name|childList
operator|.
name|get
argument_list|(
name|i2
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
name|child2
operator|&&
name|i
operator|!=
name|i2
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"duplicate child "
operator|+
name|child
operator|+
literal|" of parent "
operator|+
name|node
assert|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|child
operator|.
name|e
operator|!=
literal|null
operator|&&
name|child2
operator|.
name|e
operator|!=
literal|null
operator|&&
name|child
operator|!=
name|child2
operator|&&
name|ordering
operator|.
name|lessThan
argument_list|(
name|child
operator|.
name|e
argument_list|,
name|child2
operator|.
name|e
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"relation between children "
operator|+
name|child
operator|.
name|e
operator|+
literal|" and "
operator|+
name|child2
operator|.
name|e
operator|+
literal|" of node "
operator|+
name|node
operator|.
name|e
assert|;
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|parent
range|:
name|node
operator|.
name|parentList
control|)
block|{
if|if
condition|(
operator|!
name|parent
operator|.
name|childList
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
block|}
block|}
specifier|final
name|Map
argument_list|<
name|Node
argument_list|,
name|Integer
argument_list|>
name|distanceToRoot
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|distanceRecurse
argument_list|(
name|distanceToRoot
argument_list|,
name|topNode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|distanceToRoot
operator|.
name|containsKey
argument_list|(
name|node
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"node "
operator|+
name|node
operator|+
literal|" is not reachable"
assert|;
return|return
literal|false
return|;
block|}
block|}
comment|// For each pair of elements, ensure that elements are related if and
comment|// only if they are in the ancestors or descendants lists.
specifier|final
name|Map
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|,
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
name|nodeAncestors
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|,
name|Set
argument_list|<
name|E
argument_list|>
argument_list|>
name|nodeDescendants
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
name|nodeAncestors
operator|.
name|put
argument_list|(
name|node
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|getAncestors
argument_list|(
name|node
operator|.
name|e
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nodeDescendants
operator|.
name|put
argument_list|(
name|node
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|getDescendants
argument_list|(
name|node
operator|.
name|e
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|node1
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|node2
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
specifier|final
name|boolean
name|lt12
init|=
name|ordering
operator|.
name|lessThan
argument_list|(
name|node1
operator|.
name|e
argument_list|,
name|node2
operator|.
name|e
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|lt21
init|=
name|ordering
operator|.
name|lessThan
argument_list|(
name|node2
operator|.
name|e
argument_list|,
name|node1
operator|.
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|node1
operator|==
name|node2
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|lt12
operator|&&
name|lt21
operator|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"self should be less than self: "
operator|+
name|node1
assert|;
block|}
block|}
if|if
condition|(
name|lt12
operator|&&
name|lt21
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|node1
operator|==
name|node2
operator|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"node "
operator|+
name|node1
operator|.
name|e
operator|+
literal|" and node "
operator|+
name|node2
operator|.
name|e
operator|+
literal|" are less than each other but are not the same"
operator|+
literal|" value"
assert|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|lt12
operator|&&
operator|!
name|lt21
condition|)
block|{
if|if
condition|(
operator|!
name|nodeAncestors
operator|.
name|get
argument_list|(
name|node1
argument_list|)
operator|.
name|contains
argument_list|(
name|node2
operator|.
name|e
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
name|node1
operator|.
name|e
operator|+
literal|" is less than "
operator|+
name|node2
operator|.
name|e
operator|+
literal|" but "
operator|+
name|node2
operator|.
name|e
operator|+
literal|" is not in the ancestor set of "
operator|+
name|node1
operator|.
name|e
assert|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|nodeDescendants
operator|.
name|get
argument_list|(
name|node2
argument_list|)
operator|.
name|contains
argument_list|(
name|node1
operator|.
name|e
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
name|node1
operator|.
name|e
operator|+
literal|" is less than "
operator|+
name|node2
operator|.
name|e
operator|+
literal|" but "
operator|+
name|node1
operator|.
name|e
operator|+
literal|" is not in the descendant set of "
operator|+
name|node2
operator|.
name|e
assert|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|lt21
operator|&&
operator|!
name|lt12
condition|)
block|{
if|if
condition|(
operator|!
name|nodeAncestors
operator|.
name|get
argument_list|(
name|node2
argument_list|)
operator|.
name|contains
argument_list|(
name|node1
operator|.
name|e
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
name|node2
operator|.
name|e
operator|+
literal|" is less than "
operator|+
name|node1
operator|.
name|e
operator|+
literal|" but "
operator|+
name|node1
operator|.
name|e
operator|+
literal|" is not in the ancestor set of "
operator|+
name|node2
operator|.
name|e
assert|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|nodeDescendants
operator|.
name|get
argument_list|(
name|node1
argument_list|)
operator|.
name|contains
argument_list|(
name|node2
operator|.
name|e
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
name|node2
operator|.
name|e
operator|+
literal|" is less than "
operator|+
name|node1
operator|.
name|e
operator|+
literal|" but "
operator|+
name|node2
operator|.
name|e
operator|+
literal|" is not in the descendant set of "
operator|+
name|node1
operator|.
name|e
assert|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|distanceRecurse
parameter_list|(
name|Map
argument_list|<
name|Node
argument_list|,
name|Integer
argument_list|>
name|distanceToRoot
parameter_list|,
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|,
name|int
name|distance
parameter_list|)
block|{
specifier|final
name|Integer
name|best
init|=
name|distanceToRoot
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|best
operator|==
literal|null
operator|||
name|distance
operator|<
name|best
condition|)
block|{
name|distanceToRoot
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|distance
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|best
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|child
range|:
name|node
operator|.
name|childList
control|)
block|{
name|distanceRecurse
argument_list|(
name|distanceToRoot
argument_list|,
name|child
argument_list|,
name|distance
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|out
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"PartiallyOrderedSet size: "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" elements: {\n"
argument_list|)
expr_stmt|;
comment|// breadth-first search, to iterate over every element once, printing
comment|// those nearest the top element first
specifier|final
name|Set
argument_list|<
name|E
argument_list|>
name|seen
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Deque
argument_list|<
name|E
argument_list|>
name|unseen
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|(
name|getNonChildren
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|unseen
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|E
name|e
init|=
name|unseen
operator|.
name|pop
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" parents: "
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|parents
init|=
name|getParents
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" children: "
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|children
init|=
name|getChildren
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|children
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|E
name|child
range|:
name|children
control|)
block|{
if|if
condition|(
name|seen
operator|.
name|add
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|unseen
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the values in this partially-ordered set that are less-than    * a given value and there are no intervening values.    *    *<p>If the value is not in this set, returns null.    *    * @see #getDescendants    *    * @param e Value    * @return List of values in this set that are directly less than the given    *   value    */
specifier|public
name|List
argument_list|<
name|E
argument_list|>
name|getChildren
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|getChildren
argument_list|(
name|e
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns the values in this partially-ordered set that are less-than    * a given value and there are no intervening values.    *    *<p>If the value is not in this set, returns null if {@code hypothetical}    * is false.    *    * @see #getDescendants    *    * @param e Value    * @param hypothetical Whether to generate a list if value is not in the set    * @return List of values in this set that are directly less than the given    *   value    */
specifier|public
name|List
argument_list|<
name|E
argument_list|>
name|getChildren
parameter_list|(
name|E
name|e
parameter_list|,
name|boolean
name|hypothetical
parameter_list|)
block|{
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|map
operator|.
name|get
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|hypothetical
condition|)
block|{
return|return
name|strip
argument_list|(
name|findChildren
argument_list|(
name|e
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
return|return
name|strip
argument_list|(
name|node
operator|.
name|childList
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns the values in this partially-ordered set that are greater-than    * a given value and there are no intervening values.    *    *<p>If the value is not in this set, returns null.    *    * @see #getAncestors    *    * @param e Value    * @return List of values in this set that are directly greater than the    *   given value    */
specifier|public
name|List
argument_list|<
name|E
argument_list|>
name|getParents
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|getParents
argument_list|(
name|e
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns the values in this partially-ordered set that are greater-than    * a given value and there are no intervening values.    *    *<p>If the value is not in this set, returns {@code null} if    * {@code hypothetical} is false.    *    * @see #getAncestors    *    * @param e Value    * @param hypothetical Whether to generate a list if value is not in the set    * @return List of values in this set that are directly greater than the    *   given value    */
specifier|public
name|List
argument_list|<
name|E
argument_list|>
name|getParents
parameter_list|(
name|E
name|e
parameter_list|,
name|boolean
name|hypothetical
parameter_list|)
block|{
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|map
operator|.
name|get
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|hypothetical
condition|)
block|{
if|if
condition|(
name|parentFunction
operator|!=
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|closure
argument_list|(
name|parentFunction
argument_list|,
name|e
argument_list|,
name|list
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
else|else
block|{
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|strip
argument_list|(
name|findParents
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
return|return
name|strip
argument_list|(
name|node
operator|.
name|parentList
argument_list|)
return|;
block|}
block|}
specifier|private
name|void
name|closure
parameter_list|(
name|Function
argument_list|<
name|E
argument_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|>
name|generator
parameter_list|,
name|E
name|e
parameter_list|,
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|Set
argument_list|<
name|E
argument_list|>
name|set
parameter_list|)
block|{
for|for
control|(
name|E
name|p
range|:
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|generator
operator|.
name|apply
argument_list|(
name|e
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|set
operator|.
name|add
argument_list|(
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
name|map
operator|.
name|containsKey
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|closure
argument_list|(
name|generator
argument_list|,
name|p
argument_list|,
name|list
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|List
argument_list|<
name|E
argument_list|>
name|getNonChildren
parameter_list|()
block|{
return|return
name|strip
argument_list|(
name|topNode
operator|.
name|childList
argument_list|)
return|;
block|}
specifier|public
name|List
argument_list|<
name|E
argument_list|>
name|getNonParents
parameter_list|()
block|{
return|return
name|strip
argument_list|(
name|bottomNode
operator|.
name|parentList
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
assert|assert
name|topNode
operator|.
name|parentList
operator|.
name|isEmpty
argument_list|()
assert|;
name|topNode
operator|.
name|childList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|topNode
operator|.
name|childList
operator|.
name|add
argument_list|(
name|bottomNode
argument_list|)
expr_stmt|;
assert|assert
name|bottomNode
operator|.
name|childList
operator|.
name|isEmpty
argument_list|()
assert|;
name|bottomNode
operator|.
name|parentList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bottomNode
operator|.
name|parentList
operator|.
name|add
argument_list|(
name|topNode
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns a list of values in the set that are less-than a given value.    * The list is in topological order but order is otherwise    * non-deterministic.    *    * @param e Value    * @return Values less than given value    */
specifier|public
name|List
argument_list|<
name|E
argument_list|>
name|getDescendants
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|descendants
argument_list|(
name|e
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Returns a list, backed by a list of    * {@link org.apache.calcite.util.PartiallyOrderedSet.Node}s, that strips    * away the node and returns the element inside.    *    * @param<E> Element type    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|strip
parameter_list|(
name|List
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|e
operator|==
literal|null
condition|)
block|{
comment|// If parent list contains top element, a node whose element is null,
comment|// officially there are no parents.
comment|// Similarly child list and bottom element.
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
return|return
name|Util
operator|.
name|transform
argument_list|(
name|list
argument_list|,
name|node
lambda|->
name|node
operator|.
name|e
argument_list|)
return|;
block|}
comment|/** Converts an iterable of nodes into the list of the elements inside.    * If there is one node whose element is null, it represents a list    * containing either the top or bottom element, so we return the empty list.    *    * @param<E> Element type    */
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|strip
parameter_list|(
name|Iterable
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|iterable
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|iterator
init|=
name|iterable
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|e
operator|==
literal|null
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|node
operator|.
name|e
argument_list|)
return|;
block|}
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|node
operator|.
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
name|node
operator|=
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns a list of values in the set that are less-than a given value.    * The list is in topological order but order is otherwise    * non-deterministic.    *    * @param e Value    * @return Values less than given value    */
specifier|public
name|List
argument_list|<
name|E
argument_list|>
name|getAncestors
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|descendants
argument_list|(
name|e
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|E
argument_list|>
name|descendants
parameter_list|(
name|E
name|e
parameter_list|,
name|boolean
name|up
parameter_list|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|map
operator|.
name|get
argument_list|(
name|e
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|c
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|c
operator|=
name|up
condition|?
name|findChildren
argument_list|(
name|e
argument_list|)
else|:
name|findParents
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|up
condition|?
name|node
operator|.
name|childList
else|:
name|node
operator|.
name|parentList
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|c
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|e
operator|==
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
specifier|final
name|Deque
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|deque
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|(
name|c
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|seen
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|deque
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|node1
init|=
name|deque
operator|.
name|pop
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|node1
operator|.
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|child
range|:
name|up
condition|?
name|node1
operator|.
name|childList
else|:
name|node1
operator|.
name|parentList
control|)
block|{
if|if
condition|(
name|child
operator|.
name|e
operator|==
literal|null
condition|)
block|{
comment|// Node is top or bottom.
break|break;
block|}
if|if
condition|(
name|seen
operator|.
name|add
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|deque
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**    * Holds a value, its parent nodes, and child nodes.    *    *<p>We deliberately do not override {@link #hashCode} or    * {@link #equals(Object)}. A canonizing map ensures that within a    * given PartiallyOrderedSet, two nodes are identical if and only if they    * contain the same value.</p>    *    * @param<E> Element type    */
specifier|private
specifier|static
class|class
name|Node
parameter_list|<
name|E
parameter_list|>
block|{
specifier|final
name|List
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|parentList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Node
argument_list|<
name|E
argument_list|>
argument_list|>
name|childList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|E
name|e
decl_stmt|;
name|Node
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|this
operator|.
name|e
operator|=
name|e
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|e
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Subclass of Node for top/bottom nodes. Improves readability when    * debugging.    *    * @param<E> Element type    */
specifier|private
specifier|static
class|class
name|TopBottomNode
parameter_list|<
name|E
parameter_list|>
extends|extends
name|Node
argument_list|<
name|E
argument_list|>
block|{
specifier|private
specifier|final
name|String
name|description
decl_stmt|;
name|TopBottomNode
parameter_list|(
name|boolean
name|top
parameter_list|)
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|description
operator|=
name|top
condition|?
literal|"top"
else|:
literal|"bottom"
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|description
return|;
block|}
block|}
comment|/**    * Ordering relation.    *    *<p>To obey the constraints of the partially-ordered set, the function    * must be consistent with the reflexive, anti-symmetric, and transitive    * properties required by a partially ordered set.</p>    *    *<p>For instance, if {@code ordering(foo, foo)} returned false for any    * not-null value of foo, it would violate the reflexive property.</p>    *    *<p>If an ordering violates any of these required properties, the behavior    * of a {@link PartiallyOrderedSet} is unspecified. (But mayhem is    * likely.)</p>    *    * @param<E> Element type    */
specifier|public
interface|interface
name|Ordering
parameter_list|<
name|E
parameter_list|>
block|{
comment|/**      * Returns whether element e1 is&le; e2 according to      * the relation that defines a partially-ordered set.      *      * @param e1 Element 1      * @param e2 Element 2      * @return Whether element 1 is&le; element 2      */
name|boolean
name|lessThan
parameter_list|(
name|E
name|e1
parameter_list|,
name|E
name|e2
parameter_list|)
function_decl|;
block|}
block|}
end_class

end_unit

