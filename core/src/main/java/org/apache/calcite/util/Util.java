begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|DateTimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|Spaces
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteSystemProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|CalciteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlValuesOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlRowOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlBasicVisitor
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Throwables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheLoader
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LoadingCache
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Collections2
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|FluentIterable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apiguardian
operator|.
name|api
operator|.
name|API
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|PolyNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|dataflow
operator|.
name|qual
operator|.
name|Pure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiFunction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|ObjIntConsumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|UnaryOperator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|JarFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collector
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Nullness
operator|.
name|castNonNull
import|;
end_import

begin_comment
comment|/**  * Miscellaneous utility functions.  */
end_comment

begin_class
specifier|public
class|class
name|Util
block|{
specifier|private
specifier|static
specifier|final
name|int
name|QUICK_DISTINCT
init|=
literal|15
decl_stmt|;
specifier|private
name|Util
parameter_list|()
block|{
block|}
comment|//~ Static fields/initializers ---------------------------------------------
comment|/**    * System-dependent newline character.    *    *<p>In general, you should not use this in expected results of tests.    * Expected results should be the expected result on Linux (or Mac OS) using    * '\n'. Apply {@link Util#toLinux(String)} to Windows actual results, if    * necessary, to make them look like Linux actual.</p>    */
specifier|public
specifier|static
specifier|final
name|String
name|LINE_SEPARATOR
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
comment|/**    * System-dependent file separator, for example, "/" or "\."    */
specifier|public
specifier|static
specifier|final
name|String
name|FILE_SEPARATOR
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
decl_stmt|;
comment|/**    * Datetime format string for generating a timestamp string to be used as    * part of a filename. Conforms to SimpleDateFormat conventions.    */
specifier|public
specifier|static
specifier|final
name|String
name|FILE_TIMESTAMP_FORMAT
init|=
literal|"yyyy-MM-dd_HH_mm_ss"
decl_stmt|;
comment|/**    * Regular expression for a valid java identifier which contains no    * underscores and can therefore be returned intact by {@link #toJavaId}.    */
specifier|private
specifier|static
specifier|final
name|Pattern
name|JAVA_ID_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[a-zA-Z_$][a-zA-Z0-9$]*"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|DEFAULT_CHARSET
init|=
name|Charset
operator|.
name|forName
argument_list|(
name|CalciteSystemProperty
operator|.
name|DEFAULT_CHARSET
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Maps classes to the map of their enum values. Uses a weak map so that    * classes are not prevented from being unloaded.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
specifier|final
name|LoadingCache
argument_list|<
name|Class
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Enum
argument_list|>
argument_list|>
name|ENUM_CONSTANTS
init|=
name|CacheBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|weakKeys
argument_list|()
operator|.
name|build
argument_list|(
name|CacheLoader
operator|.
name|from
argument_list|(
name|Util
operator|::
name|enumConstants
argument_list|)
argument_list|)
decl_stmt|;
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Does nothing with its argument. Returns whether it is ensured that    * the call produces a single value    *    * @param call      the expression to evaluate    * @return Whether it is ensured that the call produces a single value    */
specifier|public
specifier|static
name|boolean
name|isSingleValue
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlAggFunction
condition|)
block|{
return|return
literal|true
return|;
block|}
if|else if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlValuesOperator
operator|||
name|call
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlRowOperator
condition|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|SqlNode
name|operand
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand
operator|instanceof
name|SqlLiteral
condition|)
block|{
return|return
literal|true
return|;
block|}
if|else if
condition|(
name|operand
operator|instanceof
name|SqlCall
condition|)
block|{
return|return
name|isSingleValue
argument_list|(
operator|(
name|SqlCall
operator|)
name|operand
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
name|boolean
name|isScalar
init|=
literal|true
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
if|if
condition|(
name|operand
operator|instanceof
name|SqlLiteral
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|operand
operator|instanceof
name|SqlCall
operator|)
operator|||
operator|!
name|Util
operator|.
name|isSingleValue
argument_list|(
operator|(
name|SqlCall
operator|)
name|operand
argument_list|)
condition|)
block|{
name|isScalar
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
return|return
name|isScalar
return|;
block|}
block|}
comment|/**    * Does nothing with its argument. Call this method when you have a value    * you are not interested in, but you don't want the compiler to warn that    * you are not using it.    */
specifier|public
specifier|static
name|void
name|discard
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
name|discard
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Does nothing with its argument. Call this method when you have a value    * you are not interested in, but you don't want the compiler to warn that    * you are not using it.    */
specifier|public
specifier|static
name|void
name|discard
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
name|discard
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Does nothing with its argument. Call this method when you have a value    * you are not interested in, but you don't want the compiler to warn that    * you are not using it.    */
specifier|public
specifier|static
name|void
name|discard
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
name|discard
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Does nothing with its argument. Call this method when you have a value    * you are not interested in, but you don't want the compiler to warn that    * you are not using it.    */
specifier|public
specifier|static
name|void
name|discard
parameter_list|(
name|double
name|d
parameter_list|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
name|discard
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Records that an exception has been caught but will not be re-thrown. If    * the tracer is not null, logs the exception to the tracer.    *    * @param e      Exception    * @param logger If not null, logs exception to this logger    */
specifier|public
specifier|static
name|void
name|swallow
parameter_list|(
name|Throwable
name|e
parameter_list|,
annotation|@
name|Nullable
name|Logger
name|logger
parameter_list|)
block|{
if|if
condition|(
name|logger
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"Discarding exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns whether two lists are equal to each other using shallow    * comparisons.    *    * @param list0 First list    * @param list1 Second list    * @return Whether lists are same length and all of their elements are    * equal using {@code ==} (may be null).    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|equalShallow
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|list0
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|list1
parameter_list|)
block|{
if|if
condition|(
name|list0
operator|.
name|size
argument_list|()
operator|!=
name|list1
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list0
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list0
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
name|list1
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Combines two integers into a hash code.    *    * @deprecated Use {@link Objects#hash(Object...)}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|int
name|hash
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
return|return
operator|(
name|i
operator|<<
literal|4
operator|)
operator|^
name|j
return|;
block|}
comment|/**    * Computes a hash code from an existing hash code and an object (which may    * be null).    *    * @deprecated Use {@link Objects#hash(Object...)}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|int
name|hash
parameter_list|(
name|int
name|h
parameter_list|,
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
name|int
name|k
init|=
operator|(
name|o
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|o
operator|.
name|hashCode
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|h
operator|<<
literal|4
operator|)
operator||
name|h
operator|)
operator|^
name|k
return|;
block|}
comment|/**    * Computes a hash code from an existing hash code and an array of objects    * (which may be null).    *    * @deprecated Use {@link Objects#hash(Object...)}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|int
name|hashArray
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
index|[]
name|a
parameter_list|)
block|{
return|return
name|h
operator|^
name|Arrays
operator|.
name|hashCode
argument_list|(
name|a
argument_list|)
return|;
block|}
comment|/** Computes the hash code of a {@code double} value. Equivalent to    * {@link Double}{@code .hashCode(double)}, but that method was only    * introduced in JDK 1.8.    *    * @param v Value    * @return Hash code    *    * @deprecated Use {@link org.apache.calcite.runtime.Utilities#hashCode(double)}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|int
name|hashCode
parameter_list|(
name|double
name|v
parameter_list|)
block|{
name|long
name|bits
init|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|v
argument_list|)
decl_stmt|;
return|return
operator|(
name|int
operator|)
operator|(
name|bits
operator|^
operator|(
name|bits
operator|>>>
literal|32
operator|)
operator|)
return|;
block|}
comment|/**    * Returns a set of the elements which are in<code>set1</code> but not in    *<code>set2</code>, without modifying either.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|T
argument_list|>
name|minus
parameter_list|(
name|Set
argument_list|<
name|T
argument_list|>
name|set1
parameter_list|,
name|Set
argument_list|<
name|T
argument_list|>
name|set2
parameter_list|)
block|{
if|if
condition|(
name|set1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|set1
return|;
block|}
if|else if
condition|(
name|set2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|set1
return|;
block|}
else|else
block|{
name|Set
argument_list|<
name|T
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|set1
argument_list|)
decl_stmt|;
name|set
operator|.
name|removeAll
argument_list|(
name|set2
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
block|}
comment|/**    * Computes<code>nlogn(n)</code> using the natural logarithm (or<code>    * n</code> if<code>n&lt; {@link Math#E}</code>, so the result is never    * negative.    */
specifier|public
specifier|static
name|double
name|nLogN
parameter_list|(
name|double
name|d
parameter_list|)
block|{
return|return
operator|(
name|d
operator|<
name|Math
operator|.
name|E
operator|)
condition|?
name|d
else|:
operator|(
name|d
operator|*
name|Math
operator|.
name|log
argument_list|(
name|d
argument_list|)
operator|)
return|;
block|}
comment|/**    * Prints an object using reflection. We can handle<code>null</code>;    * arrays of objects and primitive values; for regular objects, we print all    * public fields.    */
specifier|public
specifier|static
name|void
name|print
parameter_list|(
name|PrintWriter
name|pw
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
name|print
argument_list|(
name|pw
argument_list|,
name|o
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"JdkObsolete"
argument_list|)
specifier|public
specifier|static
name|void
name|print
parameter_list|(
name|PrintWriter
name|pw
parameter_list|,
annotation|@
name|Nullable
name|Object
name|o
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Class
name|clazz
init|=
name|o
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|String
condition|)
block|{
name|printJavaString
argument_list|(
name|pw
argument_list|,
operator|(
name|String
operator|)
name|o
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|clazz
operator|==
name|Integer
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Boolean
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Character
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Byte
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Short
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Long
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Float
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Double
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Void
operator|.
name|class
operator|)
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|clazz
operator|.
name|isArray
argument_list|()
condition|)
block|{
comment|// o is an array, but we can't cast to Object[] because it may be
comment|// an array of primitives.
name|Object
index|[]
name|a
decl_stmt|;
comment|// for debug
if|if
condition|(
name|o
operator|instanceof
name|Object
index|[]
condition|)
block|{
name|a
operator|=
operator|(
name|Object
index|[]
operator|)
name|o
expr_stmt|;
name|discard
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|int
name|n
init|=
name|Array
operator|.
name|getLength
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|indent
condition|;
name|j
operator|++
control|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
name|print
argument_list|(
name|pw
argument_list|,
name|Array
operator|.
name|get
argument_list|(
name|o
argument_list|,
name|i
argument_list|)
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|o
operator|instanceof
name|Iterator
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
name|iter
init|=
operator|(
name|Iterator
operator|)
name|o
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" {"
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|print
argument_list|(
name|pw
argument_list|,
name|iter
operator|.
name|next
argument_list|()
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|o
operator|instanceof
name|Enumeration
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Enumeration
name|e
init|=
operator|(
name|Enumeration
operator|)
name|o
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" {"
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|print
argument_list|(
name|pw
argument_list|,
name|e
operator|.
name|nextElement
argument_list|()
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pw
operator|.
name|print
argument_list|(
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" {"
argument_list|)
expr_stmt|;
name|Field
index|[]
name|fields
init|=
name|clazz
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|int
name|printed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Field
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|Modifier
operator|.
name|isStatic
argument_list|(
name|field
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|printed
operator|++
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|indent
condition|;
name|j
operator|++
control|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
name|Object
name|val
decl_stmt|;
try|try
block|{
name|val
operator|=
name|field
operator|.
name|get
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|print
argument_list|(
name|pw
argument_list|,
name|val
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Prints a string, enclosing in double quotes (") and escaping if    * necessary. For example,<code>printDoubleQuoted(w,"x\"y",false)</code>    * prints<code>"x\"y"</code>.    *    *<p>The appendable where the value is printed must not incur I/O operations. This method is    * not meant to be used for writing the values to permanent storage.</p>    *    * @throws IllegalStateException if the print to the specified appendable fails due to I/O    */
specifier|public
specifier|static
name|void
name|printJavaString
parameter_list|(
name|Appendable
name|appendable
parameter_list|,
annotation|@
name|Nullable
name|String
name|s
parameter_list|,
name|boolean
name|nullMeansNull
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|nullMeansNull
condition|)
block|{
name|appendable
operator|.
name|append
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|s1
init|=
name|replace
argument_list|(
name|s
argument_list|,
literal|"\\"
argument_list|,
literal|"\\\\"
argument_list|)
decl_stmt|;
name|String
name|s2
init|=
name|replace
argument_list|(
name|s1
argument_list|,
literal|"\""
argument_list|,
literal|"\\\""
argument_list|)
decl_stmt|;
name|String
name|s3
init|=
name|replace
argument_list|(
name|s2
argument_list|,
literal|"\n\r"
argument_list|,
literal|"\\n"
argument_list|)
decl_stmt|;
name|String
name|s4
init|=
name|replace
argument_list|(
name|s3
argument_list|,
literal|"\n"
argument_list|,
literal|"\\n"
argument_list|)
decl_stmt|;
name|String
name|s5
init|=
name|replace
argument_list|(
name|s4
argument_list|,
literal|"\r"
argument_list|,
literal|"\\r"
argument_list|)
decl_stmt|;
name|appendable
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|appendable
operator|.
name|append
argument_list|(
name|s5
argument_list|)
expr_stmt|;
name|appendable
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The specified appendable should not incur I/O."
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
name|void
name|println
parameter_list|(
name|PrintWriter
name|pw
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
name|print
argument_list|(
name|pw
argument_list|,
name|o
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|/**    * Formats a {@link BigDecimal} value to a string in scientific notation For    * example<br>    *    *<ul>    *<li>A value of 0.00001234 would be formated as<code>1.234E-5</code></li>    *<li>A value of 100000.00 would be formated as<code>1.00E5</code></li>    *<li>A value of 100 (scale zero) would be formated as    *<code>1E2</code></li>    *</ul>    *    *<p>If<code>bd</code> has a precision higher than 20, this method will    * truncate the output string to have a precision of 20 (no rounding will be    * done, just a truncate).    */
specifier|public
specifier|static
name|String
name|toScientificNotation
parameter_list|(
name|BigDecimal
name|bd
parameter_list|)
block|{
specifier|final
name|int
name|truncateAt
init|=
literal|20
decl_stmt|;
name|String
name|unscaled
init|=
name|bd
operator|.
name|unscaledValue
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|bd
operator|.
name|signum
argument_list|()
operator|<
literal|0
condition|)
block|{
name|unscaled
operator|=
name|unscaled
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|len
init|=
name|unscaled
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|scale
init|=
name|bd
operator|.
name|scale
argument_list|()
decl_stmt|;
name|int
name|e
init|=
name|len
operator|-
name|scale
operator|-
literal|1
decl_stmt|;
name|StringBuilder
name|ret
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|bd
operator|.
name|signum
argument_list|()
operator|<
literal|0
condition|)
block|{
name|ret
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
comment|// do truncation
name|unscaled
operator|=
name|unscaled
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|truncateAt
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|unscaled
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
comment|// trim trailing zeros since they aren't significant
name|int
name|i
init|=
name|unscaled
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|unscaled
operator|.
name|charAt
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|!=
literal|'0'
condition|)
block|{
break|break;
block|}
operator|--
name|i
expr_stmt|;
block|}
name|unscaled
operator|=
name|unscaled
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unscaled
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ret
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|unscaled
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|.
name|append
argument_list|(
literal|"E"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|ret
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Replaces every occurrence of<code>find</code> in<code>s</code> with    *<code>replace</code>.    */
specifier|public
specifier|static
name|String
name|replace
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|find
parameter_list|,
name|String
name|replace
parameter_list|)
block|{
comment|// let's be optimistic
name|int
name|found
init|=
name|s
operator|.
name|indexOf
argument_list|(
name|find
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|s
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|s
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
name|start
operator|<
name|found
condition|;
name|start
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
name|replace
argument_list|)
expr_stmt|;
name|start
operator|+=
name|find
operator|.
name|length
argument_list|()
expr_stmt|;
name|found
operator|=
name|s
operator|.
name|indexOf
argument_list|(
name|find
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
operator|-
literal|1
condition|)
block|{
name|found
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Creates a file-protocol URL for the given file.    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|URL
name|toURL
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|MalformedURLException
block|{
name|String
name|path
init|=
name|file
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
comment|// This is a bunch of weird code that is required to
comment|// make a valid URL on the Windows platform, due
comment|// to inconsistencies in what getAbsolutePath returns.
name|String
name|fs
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|)
block|{
name|char
name|sep
init|=
name|fs
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|'/'
condition|)
block|{
name|path
operator|=
name|path
operator|.
name|replace
argument_list|(
name|sep
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'/'
condition|)
block|{
name|path
operator|=
literal|'/'
operator|+
name|path
expr_stmt|;
block|}
block|}
name|path
operator|=
literal|"file://"
operator|+
name|path
expr_stmt|;
return|return
operator|new
name|URL
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/**    * Gets a timestamp string for use in file names. The generated timestamp    * string reflects the current time.    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
annotation|@
name|SuppressWarnings
argument_list|(
literal|"JdkObsolete"
argument_list|)
specifier|public
specifier|static
name|String
name|getFileTimestamp
parameter_list|()
block|{
name|SimpleDateFormat
name|sdf
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|FILE_TIMESTAMP_FORMAT
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
return|return
name|sdf
operator|.
name|format
argument_list|(
operator|new
name|java
operator|.
name|util
operator|.
name|Date
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Converts double-quoted Java strings to their contents. For example,    *<code>"foo\"bar"</code> becomes<code>foo"bar</code>.    */
specifier|public
specifier|static
name|String
name|stripDoubleQuotes
parameter_list|(
name|String
name|value
parameter_list|)
block|{
assert|assert
name|value
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'"'
assert|;
assert|assert
name|value
operator|.
name|charAt
argument_list|(
name|value
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'"'
assert|;
name|String
name|s5
init|=
name|value
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|value
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|String
name|s4
init|=
name|Util
operator|.
name|replace
argument_list|(
name|s5
argument_list|,
literal|"\\r"
argument_list|,
literal|"\r"
argument_list|)
decl_stmt|;
name|String
name|s3
init|=
name|Util
operator|.
name|replace
argument_list|(
name|s4
argument_list|,
literal|"\\n"
argument_list|,
literal|"\n"
argument_list|)
decl_stmt|;
name|String
name|s2
init|=
name|Util
operator|.
name|replace
argument_list|(
name|s3
argument_list|,
literal|"\\\""
argument_list|,
literal|"\""
argument_list|)
decl_stmt|;
name|String
name|s1
init|=
name|Util
operator|.
name|replace
argument_list|(
name|s2
argument_list|,
literal|"\\\\"
argument_list|,
literal|"\\"
argument_list|)
decl_stmt|;
return|return
name|s1
return|;
block|}
comment|/**    * Converts an arbitrary string into a string suitable for use as a Java    * identifier.    *    *<p>The mapping is one-to-one (that is, distinct strings will produce    * distinct java identifiers). The mapping is also reversible, but the    * inverse mapping is not implemented.</p>    *    *<p>A valid Java identifier must start with a Unicode letter, underscore,    * or dollar sign ($). The other characters, if any, can be a Unicode    * letter, underscore, dollar sign, or digit.</p>    *    *<p>This method uses an algorithm similar to URL encoding. Valid    * characters are unchanged; invalid characters are converted to an    * underscore followed by the hex code of the character; and underscores are    * doubled.</p>    *    *<p>Examples:    *    *<ul>    *<li><code>toJavaId("foo")</code> returns<code>"foo"</code>    *<li><code>toJavaId("foo bar")</code> returns<code>"foo_20_bar"</code>    *<li><code>toJavaId("foo_bar")</code> returns<code>"foo__bar"</code>    *<li><code>toJavaId("0bar")</code> returns<code>"_40_bar"</code> (digits    * are illegal as a prefix)    *<li><code>toJavaId("foo0bar")</code> returns<code>"foo0bar"</code>    *</ul>    */
specifier|public
specifier|static
name|String
name|toJavaId
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
comment|// If it's already a valid Java id (and doesn't contain any
comment|// underscores), return it unchanged.
if|if
condition|(
name|JAVA_ID_PATTERN
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
comment|// prepend "ID$" to string so it doesn't clash with java keywords
return|return
literal|"ID$"
operator|+
name|ordinal
operator|+
literal|"$"
operator|+
name|s
return|;
block|}
comment|// Escape underscores and other undesirables.
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|s
operator|.
name|length
argument_list|()
operator|+
literal|10
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"ID$"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|ordinal
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"__"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|c
operator|<
literal|0x7F
operator|)
comment|/* Normal ascii character */
operator|&&
operator|!
name|Character
operator|.
name|isISOControl
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|Character
operator|.
name|isJavaIdentifierStart
argument_list|(
name|c
argument_list|)
else|:
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|c
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns true when input string is a valid Java identifier.    * @param s input string    * @return true when input string is a valid Java identifier    */
specifier|public
specifier|static
name|boolean
name|isValidJavaIdentifier
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|Character
operator|.
name|isJavaIdentifierStart
argument_list|(
name|s
operator|.
name|codePointAt
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
name|int
name|codePoint
init|=
name|s
operator|.
name|codePointAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|codePoint
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|i
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|codePoint
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|String
name|toLinux
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|s
operator|.
name|replace
argument_list|(
literal|"\r\n"
argument_list|,
literal|"\n"
argument_list|)
return|;
block|}
comment|/**    * Materializes the results of a {@link java.util.Iterator} as a    * {@link java.util.List}.    *    * @param iter iterator to materialize    * @return materialized list    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|toList
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iter
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**    * Returns whether s == null or if s.length() == 0.    */
specifier|public
specifier|static
name|boolean
name|isNullOrEmpty
parameter_list|(
annotation|@
name|Nullable
name|String
name|s
parameter_list|)
block|{
return|return
operator|(
literal|null
operator|==
name|s
operator|)
operator|||
operator|(
name|s
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
return|;
block|}
comment|/**    * Converts a list of a string, with commas between elements.    *    *<p>For example,    *<code>commaList(Arrays.asList({"a", "b"}))</code>    * returns "a, b".    *    * @param list List    * @return String representation of string    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|String
name|commaList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|sepList
argument_list|(
name|list
argument_list|,
literal|", "
argument_list|)
return|;
block|}
comment|/** Converts a list of a string, with a given separator between elements. */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|String
name|sepList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
name|String
name|sep
parameter_list|)
block|{
specifier|final
name|int
name|max
init|=
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|max
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
literal|""
return|;
case|case
literal|0
case|:
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|max
condition|)
block|{
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|sep
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Prints a collection of elements to a StringBuilder, in the same format as    * {@link AbstractCollection#toString()}. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|StringBuilder
name|printIterable
parameter_list|(
name|StringBuilder
name|sb
parameter_list|,
name|Iterable
argument_list|<
name|E
argument_list|>
name|iterable
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|E
argument_list|>
name|it
init|=
name|iterable
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|sb
operator|.
name|append
argument_list|(
literal|"[]"
argument_list|)
return|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|E
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|sb
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
return|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Prints a set of elements to a StringBuilder, in the same format same as    * {@link AbstractCollection#toString()}.    *    *<p>The 'set' is represented by the number of elements and an action to    * perform for each element.    *    *<p>This method can be a very efficient way to convert a structure to a    * string, because the components can write directly to the StringBuilder    * rather than constructing intermediate strings.    *    * @see org.apache.calcite.linq4j.function.Functions#generate */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|StringBuilder
name|printList
parameter_list|(
name|StringBuilder
name|sb
parameter_list|,
name|int
name|elementCount
parameter_list|,
name|ObjIntConsumer
argument_list|<
name|StringBuilder
argument_list|>
name|consumer
parameter_list|)
block|{
if|if
condition|(
name|elementCount
operator|==
literal|0
condition|)
block|{
return|return
name|sb
operator|.
name|append
argument_list|(
literal|"[]"
argument_list|)
return|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
condition|;
control|)
block|{
name|consumer
operator|.
name|accept
argument_list|(
name|sb
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|elementCount
condition|)
block|{
return|return
name|sb
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
return|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns the {@link Charset} object representing the value of    * {@link CalciteSystemProperty#DEFAULT_CHARSET}.    *    * @throws java.nio.charset.IllegalCharsetNameException If the given charset    *                                                      name is illegal    * @throws java.nio.charset.UnsupportedCharsetException If no support for    *                                                      the named charset is    *                                                      available in this    *                                                      instance of the Java    *                                                      virtual machine    */
specifier|public
specifier|static
name|Charset
name|getDefaultCharset
parameter_list|()
block|{
return|return
name|DEFAULT_CHARSET
return|;
block|}
comment|// CHECKSTYLE: IGNORE 1
comment|/** @deprecated Throw new {@link AssertionError} */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|()
block|{
return|return
operator|new
name|AssertionError
argument_list|(
literal|"(unknown cause)"
argument_list|)
return|;
block|}
comment|// CHECKSTYLE: IGNORE 1
comment|/** @deprecated Throw new {@link AssertionError} */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
operator|new
name|AssertionError
argument_list|(
name|s
argument_list|)
return|;
block|}
comment|// CHECKSTYLE: IGNORE 1
comment|/** @deprecated Throw new {@link RuntimeException} if checked; throw raw    * exception if unchecked or {@link Error} */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
return|return
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|// CHECKSTYLE: IGNORE 1
comment|/** @deprecated Throw new {@link AssertionError} if applicable;    * or {@link RuntimeException} if e is checked;    * or raw exception if e is unchecked or {@link Error}. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"MissingSummary"
argument_list|)
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|(
name|Throwable
name|e
parameter_list|,
name|String
name|s
parameter_list|)
block|{
return|return
operator|new
name|AssertionError
argument_list|(
literal|"Internal error: "
operator|+
name|s
argument_list|,
name|e
argument_list|)
return|;
block|}
comment|/** As {@link Throwables}{@code .throwIfUnchecked(Throwable)},    * which was introduced in Guava 20,    * but we don't require Guava version 20 yet. */
specifier|public
specifier|static
name|void
name|throwIfUnchecked
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|Bug
operator|.
name|upgrade
argument_list|(
literal|"Remove when minimum Guava version is 20"
argument_list|)
expr_stmt|;
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
if|if
condition|(
name|throwable
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|throwable
throw|;
block|}
if|if
condition|(
name|throwable
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|throwable
throw|;
block|}
block|}
comment|/**    * This method rethrows input throwable as is (if its unchecked) or    * wraps it with {@link RuntimeException} and throws.    *<p>The typical usage would be {@code throw throwAsRuntime(...)}, where {@code throw} statement    * is needed so Java compiler knows the execution stops at that line.</p>    *    * @param throwable input throwable    * @return the method never returns, it always throws an unchecked exception    */
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.26"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
specifier|static
name|RuntimeException
name|throwAsRuntime
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|throwIfUnchecked
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|throwable
argument_list|)
throw|;
block|}
comment|/**    * This method rethrows input throwable as is (if its unchecked) with an extra message or    * wraps it with {@link RuntimeException} and throws.    *<p>The typical usage would be {@code throw throwAsRuntime(...)}, where {@code throw} statement    * is needed so Java compiler knows the execution stops at that line.</p>    *    * @param throwable input throwable    * @return the method never returns, it always throws an unchecked exception    */
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.26"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
specifier|static
name|RuntimeException
name|throwAsRuntime
parameter_list|(
name|String
name|message
parameter_list|,
name|Throwable
name|throwable
parameter_list|)
block|{
if|if
condition|(
name|throwable
operator|instanceof
name|RuntimeException
condition|)
block|{
name|throwable
operator|.
name|addSuppressed
argument_list|(
operator|new
name|Throwable
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|RuntimeException
operator|)
name|throwable
throw|;
block|}
if|if
condition|(
name|throwable
operator|instanceof
name|Error
condition|)
block|{
name|throwable
operator|.
name|addSuppressed
argument_list|(
operator|new
name|Throwable
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|Error
operator|)
name|throwable
throw|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|message
argument_list|,
name|throwable
argument_list|)
throw|;
block|}
comment|/**    * Wraps an exception with {@link RuntimeException} and return it.    * If the exception is already an instance of RuntimeException,    * returns it directly.    */
specifier|public
specifier|static
name|RuntimeException
name|toUnchecked
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RuntimeException
condition|)
block|{
return|return
operator|(
name|RuntimeException
operator|)
name|e
return|;
block|}
return|return
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|/**    * Returns cause of the given throwable if it is non-null or the throwable itself.    * @param throwable input throwable    * @return cause of the given throwable if it is non-null or the throwable itself    */
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.26"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
specifier|static
name|Throwable
name|causeOrSelf
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|throwable
operator|.
name|getCause
argument_list|()
decl_stmt|;
return|return
name|cause
operator|!=
literal|null
condition|?
name|cause
else|:
name|throwable
return|;
block|}
comment|/**    * Retrieves messages in a exception and writes them to a string. In the    * string returned, each message will appear on a different line.    *    * @return a non-null string containing all messages of the exception    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|String
name|getMessages
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Throwable
name|curr
init|=
name|t
init|;
name|curr
operator|!=
literal|null
condition|;
name|curr
operator|=
name|curr
operator|.
name|getCause
argument_list|()
control|)
block|{
name|String
name|msg
init|=
operator|(
operator|(
name|curr
operator|instanceof
name|CalciteException
operator|)
operator|||
operator|(
name|curr
operator|instanceof
name|SQLException
operator|)
operator|)
condition|?
name|curr
operator|.
name|getMessage
argument_list|()
else|:
name|curr
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns the stack trace of a throwable. Called from native code.    *    * @param t Throwable    * @return Stack trace    *    * @deprecated Use {@link com.google.common.base.Throwables#getStackTraceAsString(Throwable)}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|String
name|getStackTrace
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
specifier|final
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|t
operator|.
name|printStackTrace
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// CHECKSTYLE: IGNORE 1
comment|/** @deprecated Use {@link Preconditions#checkArgument}    * or {@link Objects#requireNonNull(Object)} */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|void
name|pre
parameter_list|(
name|boolean
name|b
parameter_list|,
name|String
name|description
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"pre-condition failed: "
operator|+
name|description
argument_list|)
throw|;
block|}
block|}
comment|// CHECKSTYLE: IGNORE 1
comment|/** @deprecated Use {@link Preconditions#checkArgument}    * or {@link Objects#requireNonNull(Object)} */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|void
name|post
parameter_list|(
name|boolean
name|b
parameter_list|,
name|String
name|description
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"post-condition failed: "
operator|+
name|description
argument_list|)
throw|;
block|}
block|}
comment|// CHECKSTYLE: IGNORE 1
comment|/** @deprecated Use {@link Preconditions#checkArgument} */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|void
name|permAssert
parameter_list|(
name|boolean
name|b
parameter_list|,
name|String
name|description
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"invariant violated: "
operator|+
name|description
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns a {@link java.lang.RuntimeException} indicating that a particular    * feature has not been implemented, but should be.    *    *<p>If every 'hole' in our functionality uses this method, it will be    * easier for us to identity the holes. Throwing a    * {@link java.lang.UnsupportedOperationException} isn't as good, because    * sometimes we actually want to partially implement an API.    *    *<p>Example usage:    *    *<blockquote>    *<pre><code>class MyVisitor extends BaseVisitor {    *     void accept(Foo foo) {    *         // Exception will identify which subclass forgot to override    *         // this method    *         throw Util.needToImplement(this);    *     }    * }</code></pre>    *</blockquote>    *    * @param o The object which was the target of the call, or null. Passing    *          the object gives crucial information if a method needs to be    *          overridden and a subclass forgot to do so.    * @return an {@link UnsupportedOperationException}.    */
specifier|public
specifier|static
name|RuntimeException
name|needToImplement
parameter_list|(
annotation|@
name|Nullable
name|Object
name|o
parameter_list|)
block|{
name|String
name|description
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|description
operator|=
name|o
operator|.
name|getClass
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|o
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|description
argument_list|)
throw|;
block|}
comment|/**    * Flags a piece of code as needing to be cleaned up before you check in.    *    *<p>Introduce a call to this method to indicate that a piece of code, or a    * javadoc comment, needs work before you check in. If you have an IDE which    * can easily trace references, this is an easy way to maintain a to-do    * list.    *    *<p><strong>Checked-in code must never call this method</strong>: you must    * remove all calls/references to this method before you check in.    *    *<p>The<code>argument</code> has generic type and determines the type of    * the result. This allows you to use the method inside an expression, for    * example    *    *<blockquote>    *<pre><code>int x = Util.deprecated(0, false);</code></pre>    *</blockquote>    *    *<p>but the usual usage is to pass in a descriptive string.    *    *<p><b>Examples</b>    *    *<p><b>Example #1: Using<code>deprecated</code> to fail if a piece of    * supposedly dead code is reached</b>    *    *<blockquote>    *<pre><code>void foo(int x) {    *     if (x&lt; 0) {    *         // If this code is executed, an error will be thrown.    *         Util.deprecated(    *             "no longer need to handle negative numbers", true);    *         bar(x);    *     } else {    *         baz(x);    *     }    * }</code></pre>    *</blockquote>    *    *<p><b>Example #2: Using<code>deprecated</code> to comment out dead    * code</b>    *    *<blockquote>    *<pre>if (Util.deprecated(false, false)) {    *     // This code will not be executed, but an error will not be thrown.    *     baz();    * }</pre>    *</blockquote>    *    * @param argument Arbitrary argument to the method.    * @param fail     Whether to throw an exception if this method is called    * @return The value of the<code>argument</code>.    * @deprecated If a piece of code calls this method, it indicates that the    * code needs to be cleaned up.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|deprecated
parameter_list|(
name|T
name|argument
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
if|if
condition|(
name|fail
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
return|return
name|argument
return|;
block|}
comment|/**    * Returns whether an array of strings contains a given string among the    * first<code>length</code> entries.    *    * @param a      Array of strings    * @param length Number of entries to search    * @param s      String to seek    * @return Whether array contains the name    */
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|String
index|[]
name|a
parameter_list|,
name|int
name|length
parameter_list|,
name|String
name|s
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Reads all remaining contents from a {@link java.io.Reader} and returns    * them as a string.    *    * @param reader reader to read from    * @return reader contents as string    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|String
name|readAllAsString
parameter_list|(
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|char
index|[]
name|buf
init|=
operator|new
name|char
index|[
literal|4096
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|n
init|=
name|reader
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Closes a Jar, ignoring any I/O exception. This should only be    * used in finally blocks when it's necessary to avoid throwing an exception    * which might mask a real exception.    *    * @param jar jar to close    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|void
name|squelchJar
parameter_list|(
annotation|@
name|Nullable
name|JarFile
name|jar
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|jar
operator|!=
literal|null
condition|)
block|{
name|jar
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Closes an InputStream, ignoring any I/O exception. This should only be    * used in finally blocks when it's necessary to avoid throwing an exception    * which might mask a real exception.    *    * @param stream stream to close    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|void
name|squelchStream
parameter_list|(
annotation|@
name|Nullable
name|InputStream
name|stream
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|stream
operator|!=
literal|null
condition|)
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Closes an OutputStream, ignoring any I/O exception. This should only be    * used in finally blocks when it's necessary to avoid throwing an exception    * which might mask a real exception. If you want to make sure that data has    * been successfully flushed, do NOT use this anywhere else; use    * stream.close() instead.    *    * @param stream stream to close    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|void
name|squelchStream
parameter_list|(
annotation|@
name|Nullable
name|OutputStream
name|stream
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|stream
operator|!=
literal|null
condition|)
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Closes a Reader, ignoring any I/O exception. This should only be used in    * finally blocks when it's necessary to avoid throwing an exception which    * might mask a real exception.    *    * @param reader reader to close    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|void
name|squelchReader
parameter_list|(
annotation|@
name|Nullable
name|Reader
name|reader
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Closes a Writer, ignoring any I/O exception. This should only be used in    * finally blocks when it's necessary to avoid throwing an exception which    * might mask a real exception. If you want to make sure that data has been    * successfully flushed, do NOT use this anywhere else; use writer.close()    * instead.    *    * @param writer writer to close    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|void
name|squelchWriter
parameter_list|(
annotation|@
name|Nullable
name|Writer
name|writer
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Closes a Statement, ignoring any SQL exception. This should only be used    * in finally blocks when it's necessary to avoid throwing an exception    * which might mask a real exception.    *    * @param stmt stmt to close    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|void
name|squelchStmt
parameter_list|(
annotation|@
name|Nullable
name|Statement
name|stmt
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|stmt
operator|!=
literal|null
condition|)
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Closes a Connection, ignoring any SQL exception. This should only be used    * in finally blocks when it's necessary to avoid throwing an exception    * which might mask a real exception.    *    * @param connection connection to close    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|void
name|squelchConnection
parameter_list|(
annotation|@
name|Nullable
name|Connection
name|connection
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Trims trailing spaces from a string.    *    * @param s string to be trimmed    * @return trimmed string    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|String
name|rtrim
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|int
name|n
init|=
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
operator|!=
literal|' '
condition|)
block|{
return|return
name|s
return|;
block|}
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
operator|!=
literal|' '
condition|)
block|{
return|return
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|n
operator|+
literal|1
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|""
return|;
block|}
comment|/**    * Pads a string with spaces up to a given length.    *    * @param s   string to be padded    * @param len desired length    * @return padded string    *    * @deprecated Use {@link Spaces#padRight(String, int)}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|static
name|String
name|rpad
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>=
name|len
condition|)
block|{
return|return
name|s
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|<
name|len
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Converts an iterable to a string.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|String
name|toString
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|String
name|start
parameter_list|,
name|String
name|sep
parameter_list|,
name|String
name|end
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|T
argument_list|>
name|ord
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|iterable
argument_list|)
control|)
block|{
if|if
condition|(
name|ord
operator|.
name|i
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|sep
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|ord
operator|.
name|e
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|end
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Converts a list of strings to a string separated by newlines. */
specifier|public
specifier|static
name|String
name|lines
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|strings
parameter_list|)
block|{
return|return
name|toString
argument_list|(
name|strings
argument_list|,
literal|""
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/** Converts a string into tokens. */
specifier|public
specifier|static
name|Iterable
argument_list|<
name|String
argument_list|>
name|tokenize
parameter_list|(
specifier|final
name|String
name|s
parameter_list|,
specifier|final
name|String
name|delim
parameter_list|)
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
specifier|final
name|StringTokenizer
name|t
init|=
operator|new
name|StringTokenizer
argument_list|(
name|s
argument_list|,
name|delim
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|t
operator|.
name|hasMoreTokens
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|next
parameter_list|()
block|{
return|return
name|t
operator|.
name|nextToken
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"remove"
argument_list|)
throw|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**    * Converts a Java timezone to POSIX format, so that the boost C++ library    * can instantiate timezone objects.    *    *<p><a    * href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap08.html">POSIX    * IEEE 1003.1</a> defines a format for timezone specifications.    *    *<p>The boost C++ library can read these specifications and instantiate<a    * href="http://www.boost.org/doc/html/date_time/local_time.html#date_time.local_time.posix_time_zone">    * posix_time_zone</a> objects from them. The purpose of this method,    * therefore, is to allow the C++ code such as the fennel calculator to use    * the same notion of timezone as Java code.    *    *<p>The format is as follows:    *    *<blockquote>"std offset dst [offset],start[/time],end[/time]"    *</blockquote>    *    *<p>where:    *    *<ul>    *<li>'std' specifies the abbrev of the time zone.    *<li>'offset' is the offset from UTC, and takes the form    *<code>[+|-]hh[:mm[:ss]] {h=0-23, m/s=0-59}</code></li>    *<li>'dst' specifies the abbrev of the time zone during daylight savings    * time    *<li>The second offset is how many hours changed during DST. Default=1    *<li>'start' and 'end' are the dates when DST goes into (and out of)    *     effect.<br>    *<br>    *     They can each be one of three forms:    *    *<ol>    *<li>Mm.w.d {month=1-12, week=1-5 (5 is always last), day=0-6}    *<li>Jn {n=1-365 Feb29 is never counted}    *<li>n {n=0-365 Feb29 is counted in leap years}    *</ol>    *</li>    *    *<li>'time' has the same format as 'offset', and defaults to 02:00:00.</li>    *</ul>    *    *<p>For example:</p>    *    *<ul>    *<li>"PST-8PDT01:00:00,M4.1.0/02:00:00,M10.1.0/02:00:00"; or more tersely    *<li>"PST-8PDT,M4.1.0,M10.1.0"    *</ul>    *    *<p>(Real format strings do not contain spaces; they are in the above    * template only for readability.)    *    *<p>Boost apparently diverges from the POSIX standard in how it treats the    * sign of timezone offsets. The POSIX standard states '<i>If preceded by a    * '-', the timezone shall be east of the Prime Meridian; otherwise, it    * shall be west</i>', yet boost requires the opposite. For instance, PST    * has offset '-8' above. This method generates timezone strings consistent    * with boost's expectations.    *    * @param tz      Timezone    * @param verbose Whether to include fields which can be omitted because    *                they have their default values    * @return Timezone in POSIX format (offset sign reversed, per boost's    * idiosyncracies)    */
specifier|public
specifier|static
name|String
name|toPosix
parameter_list|(
name|TimeZone
name|tz
parameter_list|,
name|boolean
name|verbose
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|tz
operator|.
name|getDisplayName
argument_list|(
literal|false
argument_list|,
name|TimeZone
operator|.
name|SHORT
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
expr_stmt|;
name|appendPosixTime
argument_list|(
name|buf
argument_list|,
name|tz
operator|.
name|getRawOffset
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|dstSavings
init|=
name|tz
operator|.
name|getDSTSavings
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstSavings
operator|==
literal|0
condition|)
block|{
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|tz
operator|.
name|getDisplayName
argument_list|(
literal|true
argument_list|,
name|TimeZone
operator|.
name|SHORT
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
operator|(
name|dstSavings
operator|!=
literal|3600000
operator|)
condition|)
block|{
comment|// POSIX allows us to omit DST offset if it is 1:00:00
name|appendPosixTime
argument_list|(
name|buf
argument_list|,
name|dstSavings
argument_list|)
expr_stmt|;
block|}
name|String
name|patternString
init|=
literal|".*,"
operator|+
literal|"startMode=([0-9]*),"
operator|+
literal|"startMonth=([0-9]*),"
operator|+
literal|"startDay=([-0-9]*),"
operator|+
literal|"startDayOfWeek=([0-9]*),"
operator|+
literal|"startTime=([0-9]*),"
operator|+
literal|"startTimeMode=([0-9]*),"
operator|+
literal|"endMode=([0-9]*),"
operator|+
literal|"endMonth=([0-9]*),"
operator|+
literal|"endDay=([-0-9]*),"
operator|+
literal|"endDayOfWeek=([0-9]*),"
operator|+
literal|"endTime=([0-9]*),"
operator|+
literal|"endTimeMode=([0-9]*).*"
decl_stmt|;
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|patternString
argument_list|)
decl_stmt|;
name|String
name|tzString
init|=
name|tz
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Matcher
name|matcher
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|tzString
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matcher
operator|.
name|matches
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"tz.toString not of expected format: "
operator|+
name|tzString
argument_list|)
throw|;
block|}
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|startMode
init|=
name|groupAsInt
argument_list|(
name|matcher
argument_list|,
operator|++
name|j
argument_list|)
decl_stmt|;
name|int
name|startMonth
init|=
name|groupAsInt
argument_list|(
name|matcher
argument_list|,
operator|++
name|j
argument_list|)
decl_stmt|;
name|int
name|startDay
init|=
name|groupAsInt
argument_list|(
name|matcher
argument_list|,
operator|++
name|j
argument_list|)
decl_stmt|;
name|int
name|startDayOfWeek
init|=
name|groupAsInt
argument_list|(
name|matcher
argument_list|,
operator|++
name|j
argument_list|)
decl_stmt|;
name|int
name|startTime
init|=
name|groupAsInt
argument_list|(
name|matcher
argument_list|,
operator|++
name|j
argument_list|)
decl_stmt|;
name|int
name|startTimeMode
init|=
name|groupAsInt
argument_list|(
name|matcher
argument_list|,
operator|++
name|j
argument_list|)
decl_stmt|;
name|int
name|endMode
init|=
name|groupAsInt
argument_list|(
name|matcher
argument_list|,
operator|++
name|j
argument_list|)
decl_stmt|;
name|int
name|endMonth
init|=
name|groupAsInt
argument_list|(
name|matcher
argument_list|,
operator|++
name|j
argument_list|)
decl_stmt|;
name|int
name|endDay
init|=
name|groupAsInt
argument_list|(
name|matcher
argument_list|,
operator|++
name|j
argument_list|)
decl_stmt|;
name|int
name|endDayOfWeek
init|=
name|groupAsInt
argument_list|(
name|matcher
argument_list|,
operator|++
name|j
argument_list|)
decl_stmt|;
name|int
name|endTime
init|=
name|groupAsInt
argument_list|(
name|matcher
argument_list|,
operator|++
name|j
argument_list|)
decl_stmt|;
name|int
name|endTimeMode
init|=
name|groupAsInt
argument_list|(
name|matcher
argument_list|,
operator|++
name|j
argument_list|)
decl_stmt|;
name|appendPosixDaylightTransition
argument_list|(
name|tz
argument_list|,
name|buf
argument_list|,
name|startMode
argument_list|,
name|startDay
argument_list|,
name|startMonth
argument_list|,
name|startDayOfWeek
argument_list|,
name|startTime
argument_list|,
name|startTimeMode
argument_list|,
name|verbose
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|appendPosixDaylightTransition
argument_list|(
name|tz
argument_list|,
name|buf
argument_list|,
name|endMode
argument_list|,
name|endDay
argument_list|,
name|endMonth
argument_list|,
name|endDayOfWeek
argument_list|,
name|endTime
argument_list|,
name|endTimeMode
argument_list|,
name|verbose
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|int
name|groupAsInt
parameter_list|(
name|Matcher
name|matcher
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|String
name|value
init|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
name|index
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"no group for index "
operator|+
name|index
operator|+
literal|", matcher "
operator|+
name|matcher
argument_list|)
decl_stmt|;
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Writes a daylight savings time transition to a POSIX timezone    * description.    *    * @param tz        Timezone    * @param buf       Buffer to append to    * @param mode      Transition mode    * @param day       Day of transition    * @param month     Month of transition    * @param dayOfWeek Day of week of transition    * @param time      Time of transition in millis    * @param timeMode  Mode of time transition    * @param verbose   Verbose    * @param isEnd     Whether this transition is leaving DST    */
specifier|private
specifier|static
name|void
name|appendPosixDaylightTransition
parameter_list|(
name|TimeZone
name|tz
parameter_list|,
name|StringBuilder
name|buf
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|day
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|dayOfWeek
parameter_list|,
name|int
name|time
parameter_list|,
name|int
name|timeMode
parameter_list|,
name|boolean
name|verbose
parameter_list|,
name|boolean
name|isEnd
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|int
name|week
init|=
name|day
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|1
case|:
comment|// SimpleTimeZone.DOM_MODE
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|0
argument_list|)
throw|;
case|case
literal|3
case|:
comment|// SimpleTimeZone.DOW_GE_DOM_MODE
comment|// If the day is 1, 8, 15, 22, we can translate this to case 2.
switch|switch
condition|(
name|day
condition|)
block|{
case|case
literal|1
case|:
name|week
operator|=
literal|1
expr_stmt|;
comment|// 1st week of month
break|break;
case|case
literal|8
case|:
name|week
operator|=
literal|2
expr_stmt|;
comment|// 2nd week of month
break|break;
case|case
literal|15
case|:
name|week
operator|=
literal|3
expr_stmt|;
comment|// 3rd week of month
break|break;
case|case
literal|22
case|:
name|week
operator|=
literal|4
expr_stmt|;
comment|// 4th week of month
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"POSIX timezone format cannot represent "
operator|+
name|tz
argument_list|)
throw|;
block|}
comment|// fall through
case|case
literal|2
case|:
comment|// SimpleTimeZone.DOW_IN_MONTH_MODE
name|buf
operator|.
name|append
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|month
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// 1<= m<= 12
name|buf
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|week
operator|==
operator|-
literal|1
condition|)
block|{
comment|// java represents 'last week' differently from POSIX
name|week
operator|=
literal|5
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|week
argument_list|)
expr_stmt|;
comment|// 1<= n<= 5, 5 means 'last'
name|buf
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|dayOfWeek
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// 0<= d<= 6, 0=Sunday
break|break;
case|case
literal|4
case|:
comment|// SimpleTimeZone.DOW_LE_DOM_MODE
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|0
argument_list|)
throw|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected value: "
operator|+
name|mode
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|timeMode
condition|)
block|{
case|case
literal|0
case|:
comment|// SimpleTimeZone.WALL_TIME
break|break;
case|case
literal|1
case|:
comment|// SimpleTimeZone.STANDARD_TIME, e.g. Australia/Sydney
if|if
condition|(
name|isEnd
condition|)
block|{
name|time
operator|+=
name|tz
operator|.
name|getDSTSavings
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|// SimpleTimeZone.UTC_TIME, e.g. Europe/Paris
name|time
operator|+=
name|tz
operator|.
name|getRawOffset
argument_list|()
expr_stmt|;
if|if
condition|(
name|isEnd
condition|)
block|{
name|time
operator|+=
name|tz
operator|.
name|getDSTSavings
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|verbose
operator|||
operator|(
name|time
operator|!=
literal|7200000
operator|)
condition|)
block|{
comment|// POSIX allows us to omit the time if it is 2am (the default)
name|buf
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|appendPosixTime
argument_list|(
name|buf
argument_list|,
name|time
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Given a time expressed in milliseconds, append the time formatted as    * "hh[:mm[:ss]]".    *    * @param buf    Buffer to append to    * @param millis Milliseconds    */
specifier|private
specifier|static
name|void
name|appendPosixTime
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|int
name|millis
parameter_list|)
block|{
if|if
condition|(
name|millis
operator|<
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|millis
operator|=
operator|-
name|millis
expr_stmt|;
block|}
name|int
name|hours
init|=
name|millis
operator|/
literal|3600000
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|hours
argument_list|)
expr_stmt|;
name|millis
operator|-=
name|hours
operator|*
literal|3600000
expr_stmt|;
if|if
condition|(
name|millis
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|int
name|minutes
init|=
name|millis
operator|/
literal|60000
decl_stmt|;
if|if
condition|(
name|minutes
operator|<
literal|10
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|minutes
argument_list|)
expr_stmt|;
name|millis
operator|-=
name|minutes
operator|*
literal|60000
expr_stmt|;
if|if
condition|(
name|millis
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|int
name|seconds
init|=
name|millis
operator|/
literal|1000
decl_stmt|;
if|if
condition|(
name|seconds
operator|<
literal|10
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|seconds
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parses a locale string.    *    *<p>The inverse operation of {@link java.util.Locale#toString()}.    *    * @param localeString Locale string, e.g. "en" or "en_US"    * @return Java locale object    */
specifier|public
specifier|static
name|Locale
name|parseLocale
parameter_list|(
name|String
name|localeString
parameter_list|)
block|{
name|String
index|[]
name|strings
init|=
name|localeString
operator|.
name|split
argument_list|(
literal|"_"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|strings
operator|.
name|length
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|new
name|Locale
argument_list|(
name|strings
index|[
literal|0
index|]
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|new
name|Locale
argument_list|(
name|strings
index|[
literal|0
index|]
argument_list|,
name|strings
index|[
literal|1
index|]
argument_list|)
return|;
case|case
literal|3
case|:
return|return
operator|new
name|Locale
argument_list|(
name|strings
index|[
literal|0
index|]
argument_list|,
name|strings
index|[
literal|1
index|]
argument_list|,
name|strings
index|[
literal|2
index|]
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"bad locale string '"
operator|+
name|localeString
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Converts a list whose members are automatically down-cast to a given    * type.    *    *<p>If a member of the backing list is not an instanceof<code>E</code>,    * the accessing method (such as {@link List#get}) will throw a    * {@link ClassCastException}.    *    *<p>All modifications are automatically written to the backing list. Not    * synchronized.    *    * @param list  Backing list.    * @param clazz Class to cast to.    * @return A list whose members are of the desired type.    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|cast
parameter_list|(
name|List
argument_list|<
name|?
super|super
name|E
argument_list|>
name|list
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
operator|new
name|CastingList
argument_list|<>
argument_list|(
name|list
argument_list|,
name|clazz
argument_list|)
return|;
block|}
comment|/**    * Converts a iterator whose members are automatically down-cast to a given    * type.    *    *<p>If a member of the backing iterator is not an instance of {@code E},    * {@link Iterator#next()}) will throw a    * {@link ClassCastException}.    *    *<p>All modifications are automatically written to the backing iterator.    * Not synchronized.    *    *<p>If the backing iterator has not-nullable elements,    * the returned iterator has not-nullable elements.    *    * @param iter  Backing iterator    * @param clazz Class to cast to    * @return An iterator whose members are of the desired type.    */
specifier|public
specifier|static
operator|<
name|E
expr|extends @
name|PolyNull
name|Object
operator|>
name|Iterator
argument_list|<
name|E
argument_list|>
name|cast
argument_list|(
name|final
name|Iterator
operator|<
condition|?
then|extends @
name|PolyNull
name|Object
operator|>
name|iter
argument_list|,
name|final
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
argument_list|)
block|{
return|return
name|transform
argument_list|(
name|iter
argument_list|,
name|x
lambda|->
name|clazz
operator|.
name|cast
argument_list|(
name|castNonNull
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Converts an {@link Iterable} whose members are automatically down-cast to    * a given type.    *    *<p>All modifications are automatically written to the backing iterator.    * Not synchronized.    *    * @param iterable Backing iterable    * @param clazz    Class to cast to    * @return An iterable whose members are of the desired type.    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Iterable
argument_list|<
name|E
argument_list|>
name|cast
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
super|super
name|E
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|)
block|{
comment|// FluentIterable provides toString
return|return
operator|new
name|FluentIterable
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Util
operator|.
name|cast
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|clazz
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Makes a collection of untyped elements appear as a list of strictly typed    * elements, by filtering out those which are not of the correct type.    *    *<p>The returned object is an {@link Iterable},    * which makes it ideal for use with the 'foreach' construct. For example,    *    *<blockquote><code>List&lt;Number&gt; numbers = Arrays.asList(1, 2, 3.14,    * 4, null, 6E23);<br>    * for (int myInt : filter(numbers, Integer.class)) {<br>    *&nbsp;&nbsp;&nbsp;&nbsp;print(i);<br>    * }</code></blockquote>    *    *<p>will print 1, 2, 4.    *    * @param iterable      Iterable    * @param includeFilter Class whose instances to include    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Iterable
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|includeFilter
parameter_list|)
block|{
comment|// FluentIterable provides toString
return|return
operator|new
name|FluentIterable
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Filterator
argument_list|<>
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|includeFilter
argument_list|)
return|;
block|}
block|}
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Collection
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|includeFilter
parameter_list|)
block|{
return|return
operator|new
name|AbstractCollection
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Filterator
argument_list|<>
argument_list|(
name|collection
operator|.
name|iterator
argument_list|()
argument_list|,
name|includeFilter
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Compute size.  This is expensive, but the value
comment|// collection.size() is not correct since we're
comment|// filtering values.  (Some java.util algorithms
comment|// call next() on the result of iterator() size() times.)
name|int
name|s
init|=
literal|0
decl_stmt|;
for|for
control|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|E
name|e
range|:
name|this
control|)
block|{
name|s
operator|++
expr_stmt|;
block|}
name|size
operator|=
name|s
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a subset of a list containing only elements of a given type.    *    *<p>Modifications to the list are NOT written back to the source list.    *    * @param list          List of objects    * @param includeFilter Class to filter for    * @return List of objects of given class (or a subtype)    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
argument_list|>
name|list
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|includeFilter
parameter_list|)
block|{
name|List
argument_list|<
name|E
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|list
control|)
block|{
if|if
condition|(
name|includeFilter
operator|.
name|isInstance
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|includeFilter
operator|.
name|cast
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Converts a {@link Properties} object to a<code>{@link Map}&lt;String,    * String&gt;</code>.    *    *<p>This is necessary because {@link Properties} is a dinosaur class. It    * ought to extend<code>Map&lt;String,String&gt;</code>, but instead    * extends<code>{@link Hashtable}&lt;Object,Object&gt;</code>.    *    *<p>Typical usage, to iterate over a {@link Properties}:    *    *<blockquote>    *<code>    * Properties properties;<br>    * for (Map.Entry&lt;String, String&gt; entry =    * Util.toMap(properties).entrySet()) {<br>    * println("key=" + entry.getKey() + ", value=" + entry.getValue());<br>    * }    *</code>    *</blockquote>    */
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|toMap
parameter_list|(
specifier|final
name|Properties
name|properties
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|Map
operator|)
name|properties
return|;
block|}
comment|/**    * Returns a hashmap with given contents.    *    *<p>Use this method in initializers. Type parameters are inferred from    * context, and the contents are initialized declaratively. For example,    *    *<blockquote><code>Map&lt;String, Integer&gt; population =<br>    *&nbsp;&nbsp;Olap4jUtil.mapOf(<br>    *&nbsp;&nbsp;&nbsp;&nbsp;"UK", 65000000,<br>    *&nbsp;&nbsp;&nbsp;&nbsp;"USA", 300000000);</code></blockquote>    *    * @param key       First key    * @param value     First value    * @param keyValues Second and sequent key/value pairs    * @param<K>       Key type    * @param<V>       Value type    * @return Map with given contents    */
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|mapOf
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|Object
modifier|...
name|keyValues
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
literal|1
operator|+
name|keyValues
operator|.
name|length
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyValues
operator|.
name|length
condition|;
control|)
block|{
comment|//noinspection unchecked
name|map
operator|.
name|put
argument_list|(
operator|(
name|K
operator|)
name|keyValues
index|[
name|i
operator|++
index|]
argument_list|,
operator|(
name|V
operator|)
name|keyValues
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
comment|/**    * Returns an exception indicating that we didn't expect to find this    * enumeration here.    *    * @param value Enumeration value which was not expected    * @return an error, to be thrown    */
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|Error
name|unexpected
parameter_list|(
name|E
name|value
parameter_list|)
block|{
return|return
operator|new
name|AssertionError
argument_list|(
literal|"Was not expecting value '"
operator|+
name|value
operator|+
literal|"' for enumeration '"
operator|+
name|value
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' in this context"
argument_list|)
return|;
block|}
comment|/**    * Creates a map of the values of an enumeration by name.    *    * @param clazz Enumeration class    * @return map of values    */
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|Enum
argument_list|<
name|T
argument_list|>
parameter_list|>
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|enumConstants
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
block|{
specifier|final
name|T
index|[]
name|ts
init|=
name|clazz
operator|.
name|getEnumConstants
argument_list|()
decl_stmt|;
if|if
condition|(
name|ts
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"not an enum type"
argument_list|)
throw|;
block|}
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|ts
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|t
operator|.
name|name
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Returns the value of an enumeration with a particular name.    *    *<p>Similar to {@link Enum#valueOf(Class, String)}, but returns {@code    * null} rather than throwing {@link IllegalArgumentException}.    *    * @param clazz Enum class    * @param name  Name of enum constant    * @param<T>   Enum class type    * @return Enum constant or null    */
specifier|public
specifier|static
specifier|synchronized
parameter_list|<
name|T
extends|extends
name|Enum
argument_list|<
name|T
argument_list|>
parameter_list|>
annotation|@
name|Nullable
name|T
name|enumVal
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
name|ENUM_CONSTANTS
operator|.
name|getUnchecked
argument_list|(
name|clazz
argument_list|)
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns the value of an enumeration with a particular or default value if    * not found.    *    * @param default_ Default value (not null)    * @param name     Name of enum constant    * @param<T>      Enum class type    * @return         Enum constant, never null    */
specifier|public
specifier|static
specifier|synchronized
parameter_list|<
name|T
extends|extends
name|Enum
argument_list|<
name|T
argument_list|>
parameter_list|>
name|T
name|enumVal
parameter_list|(
name|T
name|default_
parameter_list|,
annotation|@
name|Nullable
name|String
name|name
parameter_list|)
block|{
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
init|=
name|default_
operator|.
name|getDeclaringClass
argument_list|()
decl_stmt|;
specifier|final
name|T
name|t
init|=
name|clazz
operator|.
name|cast
argument_list|(
name|ENUM_CONSTANTS
operator|.
name|getUnchecked
argument_list|(
name|clazz
argument_list|)
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
return|return
name|default_
return|;
block|}
return|return
name|t
return|;
block|}
comment|/**    * Creates a list that returns every {@code n}th element of a list,    * starting at element {@code k}.    *    *<p>It is OK if the list is empty or its size is not a multiple of    * {@code n}.</p>    *    *<p>For instance, {@code quotientList(list, 2, 0)} returns the even    * elements of a list, and {@code quotientList(list, 2, 1)} returns the odd    * elements. Those lists are the same length only if list has even size.</p>    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|quotientList
parameter_list|(
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
specifier|final
name|int
name|n
parameter_list|,
specifier|final
name|int
name|k
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<=
literal|0
operator|||
name|k
operator|<
literal|0
operator|||
name|k
operator|>=
name|n
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"n must be positive; k must be between 0 and n - 1"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|size
init|=
operator|(
name|list
operator|.
name|size
argument_list|()
operator|+
name|n
operator|-
name|k
operator|-
literal|1
operator|)
operator|/
name|n
decl_stmt|;
return|return
operator|new
name|AbstractList
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|index
operator|*
name|n
operator|+
name|k
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
block|}
return|;
block|}
comment|/** Given a list with N elements    * [e<sub>0</sub>, e<sub>1</sub>, ..., e<sub>N-1</sub>]    * (where N is even), returns a list of the N / 2 elements    * [ (e<sub>0</sub>, e<sub>1</sub>),    * (e<sub>2</sub>, e<sub>3</sub>), ... ]. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|Pair
argument_list|<
name|E
argument_list|,
name|E
argument_list|>
argument_list|>
name|pairs
parameter_list|(
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
name|Pair
operator|.
name|zip
argument_list|(
name|quotientList
argument_list|(
name|list
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|quotientList
argument_list|(
name|list
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns the first value if it is not null,    * otherwise the second value.    *    *<p>The result may be null only if the second argument is not null.    *    *<p>Equivalent to the Elvis operator ({@code ?:}) of languages such as    * Groovy or PHP. */
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|Object
parameter_list|>
annotation|@
name|PolyNull
name|T
name|first
parameter_list|(
annotation|@
name|Nullable
name|T
name|v0
parameter_list|,
annotation|@
name|PolyNull
name|T
name|v1
parameter_list|)
block|{
return|return
name|v0
operator|!=
literal|null
condition|?
name|v0
else|:
name|v1
return|;
block|}
comment|/** Unboxes a {@link Double} value,    * using a given default value if it is null. */
specifier|public
specifier|static
name|double
name|first
parameter_list|(
annotation|@
name|Nullable
name|Double
name|v0
parameter_list|,
name|double
name|v1
parameter_list|)
block|{
return|return
name|v0
operator|!=
literal|null
condition|?
name|v0
else|:
name|v1
return|;
block|}
comment|/** Unboxes a {@link Float} value,    * using a given default value if it is null. */
specifier|public
specifier|static
name|float
name|first
parameter_list|(
annotation|@
name|Nullable
name|Float
name|v0
parameter_list|,
name|float
name|v1
parameter_list|)
block|{
return|return
name|v0
operator|!=
literal|null
condition|?
name|v0
else|:
name|v1
return|;
block|}
comment|/** Unboxes a {@link Integer} value,    * using a given default value if it is null. */
specifier|public
specifier|static
name|int
name|first
parameter_list|(
annotation|@
name|Nullable
name|Integer
name|v0
parameter_list|,
name|int
name|v1
parameter_list|)
block|{
return|return
name|v0
operator|!=
literal|null
condition|?
name|v0
else|:
name|v1
return|;
block|}
comment|/** Unboxes a {@link Long} value,    * using a given default value if it is null. */
specifier|public
specifier|static
name|long
name|first
parameter_list|(
annotation|@
name|Nullable
name|Long
name|v0
parameter_list|,
name|long
name|v1
parameter_list|)
block|{
return|return
name|v0
operator|!=
literal|null
condition|?
name|v0
else|:
name|v1
return|;
block|}
comment|/** Unboxes a {@link Boolean} value,    * using a given default value if it is null. */
specifier|public
specifier|static
name|boolean
name|first
parameter_list|(
annotation|@
name|Nullable
name|Boolean
name|v0
parameter_list|,
name|boolean
name|v1
parameter_list|)
block|{
return|return
name|v0
operator|!=
literal|null
condition|?
name|v0
else|:
name|v1
return|;
block|}
comment|/** Unboxes a {@link Short} value,    * using a given default value if it is null. */
specifier|public
specifier|static
name|short
name|first
parameter_list|(
annotation|@
name|Nullable
name|Short
name|v0
parameter_list|,
name|short
name|v1
parameter_list|)
block|{
return|return
name|v0
operator|!=
literal|null
condition|?
name|v0
else|:
name|v1
return|;
block|}
comment|/** Unboxes a {@link Character} value,    * using a given default value if it is null. */
specifier|public
specifier|static
name|char
name|first
parameter_list|(
annotation|@
name|Nullable
name|Character
name|v0
parameter_list|,
name|char
name|v1
parameter_list|)
block|{
return|return
name|v0
operator|!=
literal|null
condition|?
name|v0
else|:
name|v1
return|;
block|}
comment|/** Unboxes a {@link Byte} value,    * using a given default value if it is null. */
specifier|public
specifier|static
name|byte
name|first
parameter_list|(
annotation|@
name|Nullable
name|Byte
name|v0
parameter_list|,
name|byte
name|v1
parameter_list|)
block|{
return|return
name|v0
operator|!=
literal|null
condition|?
name|v0
else|:
name|v1
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|orEmpty
parameter_list|(
annotation|@
name|Nullable
name|Iterable
argument_list|<
name|T
argument_list|>
name|v0
parameter_list|)
block|{
return|return
name|v0
operator|!=
literal|null
condition|?
name|v0
else|:
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
comment|/** Returns the first element of a list.    *    * @throws java.lang.IndexOutOfBoundsException if the list is empty    */
specifier|public
parameter_list|<
name|E
parameter_list|>
name|E
name|first
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/** Returns the last element of a list.    *    * @throws java.lang.IndexOutOfBoundsException if the list is empty    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|E
name|last
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/** Returns the first {@code n} elements of a list. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|first
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|list
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Returns every element of a list but its last element. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|skipLast
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|skipLast
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/** Returns every element of a list but its last {@code n} elements. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|skipLast
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|list
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|list
operator|.
name|size
argument_list|()
operator|-
name|n
argument_list|)
return|;
block|}
comment|/** Returns the last {@code n} elements of a list. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|last
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|list
operator|.
name|subList
argument_list|(
name|list
operator|.
name|size
argument_list|()
operator|-
name|n
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/** Returns all but the first element of a list. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|skip
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|skip
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/** Returns all but the first {@code n} elements of a list. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|skip
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|fromIndex
parameter_list|)
block|{
return|return
name|fromIndex
operator|==
literal|0
condition|?
name|list
else|:
name|list
operator|.
name|subList
argument_list|(
name|fromIndex
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|range
parameter_list|(
specifier|final
name|int
name|end
parameter_list|)
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|end
return|;
block|}
annotation|@
name|Override
specifier|public
name|Integer
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|index
return|;
block|}
block|}
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|range
parameter_list|(
specifier|final
name|int
name|start
parameter_list|,
specifier|final
name|int
name|end
parameter_list|)
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|end
operator|-
name|start
return|;
block|}
annotation|@
name|Override
specifier|public
name|Integer
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|start
operator|+
name|index
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns whether the elements of {@code list} are distinct.    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|isDistinct
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|firstDuplicate
argument_list|(
name|list
argument_list|)
operator|<
literal|0
return|;
block|}
comment|/**    * Returns the ordinal of the first element in the list which is equal to a    * previous element in the list.    *    *<p>For example,    *<code>firstDuplicate(Arrays.asList("a", "b", "c", "b", "a"))</code>    * returns 3, the ordinal of the 2nd "b".    *    * @param list List    * @return Ordinal of first duplicate, or -1 if not found    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|int
name|firstDuplicate
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|2
condition|)
block|{
comment|// Lists of size 0 and 1 are always distinct.
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|size
operator|<
name|QUICK_DISTINCT
condition|)
block|{
comment|// For smaller lists, avoid the overhead of creating a set. Threshold
comment|// determined empirically using UtilTest.testIsDistinctBenchmark.
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|E
name|e
init|=
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|E
name|e1
init|=
name|list
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|Objects
operator|.
name|equals
argument_list|(
name|e
argument_list|,
name|e1
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|// we use HashMap here, because it is more efficient than HashSet.
specifier|final
name|Map
argument_list|<
name|E
argument_list|,
name|Object
argument_list|>
name|set
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|size
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|list
control|)
block|{
if|if
condition|(
name|set
operator|.
name|put
argument_list|(
name|e
argument_list|,
literal|""
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
name|set
operator|.
name|size
argument_list|()
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/** Converts a list into a list with unique elements.    *    *<p>The order is preserved; the second and subsequent occurrences are    * removed.    *    *<p>If the list is already unique it is returned unchanged. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|distinctList
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
comment|// If the list is small, check for duplicates using pairwise comparison.
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|<
name|QUICK_DISTINCT
operator|&&
name|isDistinct
argument_list|(
name|list
argument_list|)
condition|)
block|{
return|return
name|list
return|;
block|}
comment|// Lists that have all the same element are common. Avoiding creating a set.
if|if
condition|(
name|allSameElement
argument_list|(
name|list
argument_list|)
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|list
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns whether all of the elements of a list are equal.    * The list is assumed to be non-empty. */
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|allSameElement
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
init|=
name|list
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|final
name|E
name|first
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|Objects
operator|.
name|equals
argument_list|(
name|first
argument_list|,
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** Converts an iterable into a list with unique elements.    *    *<p>The order is preserved; the second and subsequent occurrences are    * removed.    *    *<p>If {@code iterable} is a unique list it is returned unchanged. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|distinctList
parameter_list|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|keys
parameter_list|)
block|{
if|if
condition|(
name|keys
operator|instanceof
name|Set
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|keys
argument_list|)
return|;
block|}
if|if
condition|(
name|keys
operator|instanceof
name|List
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|list
init|=
operator|(
name|List
operator|)
name|keys
decl_stmt|;
if|if
condition|(
name|isDistinct
argument_list|(
name|list
argument_list|)
condition|)
block|{
return|return
name|list
return|;
block|}
block|}
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|Sets
operator|.
name|newLinkedHashSet
argument_list|(
name|keys
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns whether two collections have any elements in common. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|intersects
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|c0
parameter_list|,
name|Collection
argument_list|<
name|E
argument_list|>
name|c1
parameter_list|)
block|{
for|for
control|(
name|E
name|e
range|:
name|c1
control|)
block|{
if|if
condition|(
name|c0
operator|.
name|contains
argument_list|(
name|e
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Looks for a string within a list of strings, using a given    * case-sensitivity policy, and returns the position at which the first match    * is found, or -1 if there are no matches. */
specifier|public
specifier|static
name|int
name|findMatch
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|strings
parameter_list|,
name|String
name|seek
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|)
block|{
if|if
condition|(
name|caseSensitive
condition|)
block|{
return|return
name|strings
operator|.
name|indexOf
argument_list|(
name|seek
argument_list|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strings
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|s
init|=
name|strings
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|equalsIgnoreCase
argument_list|(
name|seek
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/** Returns whether a name matches another according to a given    * case-sensitivity policy. */
specifier|public
specifier|static
name|boolean
name|matches
parameter_list|(
name|boolean
name|caseSensitive
parameter_list|,
name|String
name|s0
parameter_list|,
name|String
name|s1
parameter_list|)
block|{
return|return
name|caseSensitive
condition|?
name|s1
operator|.
name|equals
argument_list|(
name|s0
argument_list|)
else|:
name|s1
operator|.
name|equalsIgnoreCase
argument_list|(
name|s0
argument_list|)
return|;
block|}
comment|/** Returns whether one list is a prefix of another. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|startsWith
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list0
parameter_list|,
name|List
argument_list|<
name|E
argument_list|>
name|list1
parameter_list|)
block|{
if|if
condition|(
name|list0
operator|==
name|list1
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|final
name|int
name|size
init|=
name|list1
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|list0
operator|.
name|size
argument_list|()
operator|<
name|size
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Objects
operator|.
name|equals
argument_list|(
name|list0
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|list1
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** Converts ["ab", "c"] to "ab"."c". */
specifier|public
specifier|static
name|String
name|listToString
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|list
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|list
control|)
block|{
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|s
operator|.
name|replace
argument_list|(
literal|"\""
argument_list|,
literal|"\"\""
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|stringToList
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|String
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|s
operator|.
name|charAt
argument_list|(
operator|++
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
break|break;
block|}
operator|++
name|i
expr_stmt|;
name|c
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
block|}
name|b
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|add
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|b
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>=
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Converts a number into human-readable form, with 3 digits and a "K", "M"    * or "G" multiplier for thousands, millions or billions.    *    *<p>Examples: -2, 0, 1, 999, 1.00K, 1.99K, 3.45M, 4.56B.</p>    */
specifier|public
specifier|static
name|String
name|human
parameter_list|(
name|double
name|d
parameter_list|)
block|{
if|if
condition|(
name|d
operator|==
literal|0d
condition|)
block|{
return|return
literal|"0"
return|;
block|}
if|if
condition|(
name|d
operator|<
literal|0d
condition|)
block|{
return|return
literal|"-"
operator|+
name|human
argument_list|(
operator|-
name|d
argument_list|)
return|;
block|}
specifier|final
name|int
name|digitCount
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|Math
operator|.
name|log10
argument_list|(
name|d
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|digitCount
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
return|return
name|Integer
operator|.
name|toString
argument_list|(
operator|(
name|int
operator|)
name|d
argument_list|)
return|;
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
return|return
name|digits3
argument_list|(
name|Math
operator|.
name|round
argument_list|(
name|d
operator|/
literal|10D
argument_list|)
argument_list|,
name|digitCount
operator|%
literal|3
argument_list|)
operator|+
literal|"K"
return|;
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
return|return
name|digits3
argument_list|(
name|Math
operator|.
name|round
argument_list|(
name|d
operator|/
literal|10000D
argument_list|)
argument_list|,
name|digitCount
operator|%
literal|3
argument_list|)
operator|+
literal|"M"
return|;
case|case
literal|9
case|:
case|case
literal|10
case|:
case|case
literal|11
case|:
return|return
name|digits3
argument_list|(
name|Math
operator|.
name|round
argument_list|(
name|d
operator|/
literal|10000000D
argument_list|)
argument_list|,
name|digitCount
operator|%
literal|3
argument_list|)
operator|+
literal|"G"
return|;
default|default:
return|return
name|Double
operator|.
name|toString
argument_list|(
name|d
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|String
name|digits3
parameter_list|(
name|long
name|x
parameter_list|,
name|int
name|z
parameter_list|)
block|{
specifier|final
name|String
name|s
init|=
name|Long
operator|.
name|toString
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|z
condition|)
block|{
case|case
literal|0
case|:
return|return
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|+
literal|"."
operator|+
name|s
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
operator|+
literal|"."
operator|+
name|s
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
return|;
default|default:
return|return
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
return|;
block|}
block|}
comment|/** Returns a map that is a view onto a collection of values, using the    * provided function to convert a value to a key.    *    *<p>Unlike    * {@link com.google.common.collect.Maps#uniqueIndex(Iterable, com.google.common.base.Function)},    * returns a view whose contents change as the collection of values changes.    *    * @param values Collection of values    * @param function Function to map value to key    * @param<K> Key type    * @param<V> Value type    * @return Map that is a view onto the values    */
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asIndexMapJ
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|,
specifier|final
name|Function
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|function
parameter_list|)
block|{
specifier|final
name|Collection
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
init|=
name|Collections2
operator|.
name|transform
argument_list|(
name|values
argument_list|,
name|v
lambda|->
name|Pair
operator|.
name|of
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|v
argument_list|)
argument_list|,
name|v
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
init|=
operator|new
name|AbstractSet
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|entries
operator|.
name|iterator
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|entries
operator|.
name|size
argument_list|()
return|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"override.return.invalid"
argument_list|)
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
name|entrySet
return|;
block|}
block|}
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"Guava"
argument_list|)
annotation|@
name|Deprecated
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asIndexMap
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|,
specifier|final
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
argument_list|<
name|V
argument_list|,
name|K
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|asIndexMapJ
argument_list|(
name|values
argument_list|,
name|function
operator|::
name|apply
argument_list|)
return|;
block|}
comment|/**    * Prints the given code with line numbering.    */
specifier|public
specifier|static
name|void
name|debugCode
parameter_list|(
name|PrintStream
name|out
parameter_list|,
name|String
name|code
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|StringReader
name|sr
init|=
operator|new
name|StringReader
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|BufferedReader
name|br
init|=
operator|new
name|BufferedReader
argument_list|(
name|sr
argument_list|)
decl_stmt|;
try|try
block|{
name|String
name|line
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
operator|(
name|line
operator|=
name|br
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|"/*"
argument_list|)
expr_stmt|;
name|String
name|number
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|number
operator|.
name|length
argument_list|()
operator|<
literal|4
condition|)
block|{
name|Spaces
operator|.
name|append
argument_list|(
name|out
argument_list|,
literal|4
operator|-
name|number
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|print
argument_list|(
name|number
argument_list|)
expr_stmt|;
name|out
operator|.
name|print
argument_list|(
literal|" */ "
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// not possible
block|}
block|}
comment|/** Returns a copy of a list of lists, making the component lists immutable if    * they are not already. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|immutableCopy
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|>
name|lists
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|list
range|:
name|lists
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|list
operator|instanceof
name|ImmutableList
operator|)
condition|)
block|{
operator|++
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|// Lists are already immutable. Furthermore, if the outer list is
comment|// immutable we will just return "lists" unchanged.
comment|//noinspection unchecked
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
operator|(
name|Iterable
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
operator|)
name|lists
argument_list|)
return|;
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterable
argument_list|<
name|E
argument_list|>
name|list
range|:
name|lists
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Creates a {@link PrintWriter} to a given output stream using UTF-8    * character set.    *    *<p>Does not use the default character set. */
specifier|public
specifier|static
name|PrintWriter
name|printWriter
parameter_list|(
name|OutputStream
name|out
parameter_list|)
block|{
return|return
operator|new
name|PrintWriter
argument_list|(
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|out
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link PrintWriter} to a given file using UTF-8    * character set.    *    *<p>Does not use the default character set. */
specifier|public
specifier|static
name|PrintWriter
name|printWriter
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
return|return
name|printWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link BufferedReader} to a given input stream using UTF-8    * character set.    *    *<p>Does not use the default character set. */
specifier|public
specifier|static
name|BufferedReader
name|reader
parameter_list|(
name|InputStream
name|in
parameter_list|)
block|{
return|return
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|in
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link BufferedReader} to read a given file using UTF-8    * character set.    *    *<p>Does not use the default character set. */
specifier|public
specifier|static
name|BufferedReader
name|reader
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
return|return
name|reader
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|)
return|;
block|}
comment|/** Given an {@link Appendable}, performs an action that requires a    * {@link StringBuilder}. Casts the Appendable if possible. */
specifier|public
specifier|static
name|void
name|asStringBuilder
parameter_list|(
name|Appendable
name|appendable
parameter_list|,
name|Consumer
argument_list|<
name|StringBuilder
argument_list|>
name|consumer
parameter_list|)
block|{
if|if
condition|(
name|appendable
operator|instanceof
name|StringBuilder
condition|)
block|{
name|consumer
operator|.
name|accept
argument_list|(
operator|(
name|StringBuilder
operator|)
name|appendable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|consumer
operator|.
name|accept
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|appendable
operator|.
name|append
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Creates a {@link Calendar} in the UTC time zone and root locale.    * Does not use the time zone or locale. */
specifier|public
specifier|static
name|Calendar
name|calendar
parameter_list|()
block|{
return|return
name|Calendar
operator|.
name|getInstance
argument_list|(
name|DateTimeUtils
operator|.
name|UTC_ZONE
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
return|;
block|}
comment|/** Creates a {@link Calendar} in the UTC time zone and root locale    * with a given time. */
specifier|public
specifier|static
name|Calendar
name|calendar
parameter_list|(
name|long
name|millis
parameter_list|)
block|{
name|Calendar
name|calendar
init|=
name|calendar
argument_list|()
decl_stmt|;
name|calendar
operator|.
name|setTimeInMillis
argument_list|(
name|millis
argument_list|)
expr_stmt|;
return|return
name|calendar
return|;
block|}
comment|/**    * Returns a {@code Collector} that accumulates the input elements into a    * Guava {@link ImmutableList} via a {@link ImmutableList.Builder}.    *    *<p>It will be obsolete when we move to {@link Bug#upgrade Guava 28.0-jre}.    * Guava 21.0 introduced {@code ImmutableList.toImmutableList()}, but it had    * a {@link com.google.common.annotations.Beta} tag until 28.0-jre.    *    *<p>In {@link Bug#upgrade Guava 21.0}, change this method to call    * {@code ImmutableList.toImmutableList()}, ignoring the {@code @Beta} tag.    *    * @param<T> Type of the input elements    *    * @return a {@code Collector} that collects all the input elements into an    * {@link ImmutableList}, in encounter order    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collector
argument_list|<
name|T
argument_list|,
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|T
argument_list|>
argument_list|,
name|ImmutableList
argument_list|<
name|T
argument_list|>
argument_list|>
name|toImmutableList
parameter_list|()
block|{
return|return
name|Collector
operator|.
name|of
argument_list|(
name|ImmutableList
operator|::
name|builder
argument_list|,
name|ImmutableList
operator|.
name|Builder
operator|::
name|add
argument_list|,
name|Util
operator|::
name|combine
argument_list|,
name|ImmutableList
operator|.
name|Builder
operator|::
name|build
argument_list|)
return|;
block|}
comment|/** Combines a second immutable list builder into a first. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
name|combine
parameter_list|(
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
name|b0
parameter_list|,
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|E
argument_list|>
name|b1
parameter_list|)
block|{
name|b0
operator|.
name|addAll
argument_list|(
name|b1
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|b0
return|;
block|}
comment|/** Combines a second array list into a first. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ArrayList
argument_list|<
name|E
argument_list|>
name|combine
parameter_list|(
name|ArrayList
argument_list|<
name|E
argument_list|>
name|list0
parameter_list|,
name|ArrayList
argument_list|<
name|E
argument_list|>
name|list1
parameter_list|)
block|{
name|list0
operator|.
name|addAll
argument_list|(
name|list1
argument_list|)
expr_stmt|;
return|return
name|list0
return|;
block|}
comment|/** Returns an operator that applies {@code op1} and then {@code op2}.    *    *<p>As {@link Function#andThen(Function)} but for {@link UnaryOperator}. */
specifier|public
specifier|static
parameter_list|<
name|X
parameter_list|>
name|UnaryOperator
argument_list|<
name|X
argument_list|>
name|andThen
parameter_list|(
name|UnaryOperator
argument_list|<
name|X
argument_list|>
name|op1
parameter_list|,
name|UnaryOperator
argument_list|<
name|X
argument_list|>
name|op2
parameter_list|)
block|{
return|return
name|op1
operator|.
name|andThen
argument_list|(
name|op2
argument_list|)
operator|::
name|apply
return|;
block|}
comment|/** Transforms a list, applying a function to each element. */
specifier|public
specifier|static
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|transform
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|F
argument_list|>
name|list
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
if|if
condition|(
name|list
operator|instanceof
name|RandomAccess
condition|)
block|{
return|return
operator|new
name|RandomAccessTransformingList
argument_list|<>
argument_list|(
name|list
argument_list|,
name|function
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|TransformingList
argument_list|<>
argument_list|(
name|list
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
comment|/** Transforms a list, applying a function to each element, also passing in    * the element's index in the list. */
specifier|public
specifier|static
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|transformIndexed
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|F
argument_list|>
name|list
parameter_list|,
name|BiFunction
argument_list|<
name|?
super|super
name|F
argument_list|,
name|Integer
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
if|if
condition|(
name|list
operator|instanceof
name|RandomAccess
condition|)
block|{
return|return
operator|new
name|RandomAccessTransformingIndexedList
argument_list|<>
argument_list|(
name|list
argument_list|,
name|function
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|TransformingIndexedList
argument_list|<>
argument_list|(
name|list
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
comment|/** Transforms an iterable, applying a function to each element. */
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.27"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
specifier|static
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|transform
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|F
argument_list|>
name|iterable
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
comment|// FluentIterable provides toString
return|return
operator|new
name|FluentIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Util
operator|.
name|transform
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Transforms an iterator. */
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.27"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
specifier|static
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|transform
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|F
argument_list|>
name|iterator
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|new
name|TransformingIterator
argument_list|<>
argument_list|(
name|iterator
argument_list|,
name|function
argument_list|)
return|;
block|}
comment|/** Filters an iterable. */
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.27"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Iterable
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
comment|// FluentIterable provides toString
return|return
operator|new
name|FluentIterable
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Util
operator|.
name|filter
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Filters an iterator. */
annotation|@
name|API
argument_list|(
name|since
operator|=
literal|"1.27"
argument_list|,
name|status
operator|=
name|API
operator|.
name|Status
operator|.
name|EXPERIMENTAL
argument_list|)
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Iterator
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|iterator
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
operator|new
name|FilteringIterator
argument_list|<>
argument_list|(
name|iterator
argument_list|,
name|predicate
argument_list|)
return|;
block|}
comment|/** Returns a list with any elements for which the predicate is true moved to    * the head of the list. The algorithm does not modify the list, is stable,    * and is idempotent. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|moveToHead
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|terms
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
if|if
condition|(
name|alreadyAtFront
argument_list|(
name|terms
argument_list|,
name|predicate
argument_list|)
condition|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|List
argument_list|<
name|E
argument_list|>
operator|)
name|terms
return|;
block|}
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|newTerms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|terms
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|term
range|:
name|terms
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|term
argument_list|)
condition|)
block|{
name|newTerms
operator|.
name|add
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|E
name|term
range|:
name|terms
control|)
block|{
if|if
condition|(
operator|!
name|predicate
operator|.
name|test
argument_list|(
name|term
argument_list|)
condition|)
block|{
name|newTerms
operator|.
name|add
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newTerms
return|;
block|}
comment|/** Returns whether of the elements of a list for which predicate is true    * occur before all elements where the predicate is false. (Returns true in    * corner cases such as empty list, all true, or all false. */
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|alreadyAtFront
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|list
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|E
argument_list|>
name|predicate
parameter_list|)
block|{
name|boolean
name|prev
init|=
literal|true
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|list
control|)
block|{
specifier|final
name|boolean
name|pass
init|=
name|predicate
operator|.
name|test
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|pass
operator|&&
operator|!
name|prev
condition|)
block|{
return|return
literal|false
return|;
block|}
name|prev
operator|=
name|pass
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Returns a view of a list, picking the elements of a list with the given    * set of ordinals. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|select
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|ordinals
parameter_list|)
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|ordinals
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|ordinals
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Returns a map which ignores any write operation. */
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|blackholeMap
parameter_list|()
block|{
return|return
name|BlackholeMap
operator|.
name|of
argument_list|()
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Exception used to interrupt a tree walk of any kind.    */
specifier|public
specifier|static
class|class
name|FoundOne
extends|extends
name|ControlFlowException
block|{
specifier|private
specifier|final
annotation|@
name|Nullable
name|Object
name|node
decl_stmt|;
comment|/** Singleton instance. Can be used if you don't care about node. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ThrowableInstanceNeverThrown"
argument_list|)
specifier|public
specifier|static
specifier|final
name|FoundOne
name|NULL
init|=
operator|new
name|FoundOne
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|public
name|FoundOne
parameter_list|(
annotation|@
name|Nullable
name|Object
name|node
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
block|}
annotation|@
name|Pure
specifier|public
annotation|@
name|Nullable
name|Object
name|getNode
parameter_list|()
block|{
return|return
name|node
return|;
block|}
block|}
comment|/**    * Visitor which looks for an OVER clause inside a tree of    * {@link SqlNode} objects.    */
specifier|public
specifier|static
class|class
name|OverFinder
extends|extends
name|SqlBasicVisitor
argument_list|<
name|Void
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|OverFinder
name|INSTANCE
init|=
operator|new
name|Util
operator|.
name|OverFinder
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|OVER
condition|)
block|{
throw|throw
name|FoundOne
operator|.
name|NULL
throw|;
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
comment|/** List that returns the same number of elements as a backing list,    * applying a transformation function to each one.    *    * @param<F> Element type of backing list    * @param<T> Element type of this list    */
specifier|private
specifier|static
class|class
name|TransformingList
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|T
argument_list|>
block|{
specifier|private
specifier|final
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|F
argument_list|>
name|list
decl_stmt|;
name|TransformingList
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|F
argument_list|>
name|list
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|this
operator|.
name|function
operator|=
name|function
expr_stmt|;
name|this
operator|.
name|list
operator|=
name|list
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|get
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|list
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|listIterator
argument_list|()
return|;
block|}
block|}
comment|/** Extension to {@link TransformingList} that implements    * {@link RandomAccess}.    *    * @param<F> Element type of backing list    * @param<T> Element type of this list    */
specifier|private
specifier|static
class|class
name|RandomAccessTransformingList
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
extends|extends
name|TransformingList
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
implements|implements
name|RandomAccess
block|{
name|RandomAccessTransformingList
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|F
argument_list|>
name|list
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|super
argument_list|(
name|list
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** List that returns the same number of elements as a backing list,    * applying a transformation function to each one.    *    * @param<F> Element type of backing list    * @param<T> Element type of this list    */
specifier|private
specifier|static
class|class
name|TransformingIndexedList
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|T
argument_list|>
block|{
specifier|private
specifier|final
name|BiFunction
argument_list|<
name|?
super|super
name|F
argument_list|,
name|Integer
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|F
argument_list|>
name|list
decl_stmt|;
name|TransformingIndexedList
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|F
argument_list|>
name|list
parameter_list|,
name|BiFunction
argument_list|<
name|?
super|super
name|F
argument_list|,
name|Integer
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|this
operator|.
name|function
operator|=
name|function
expr_stmt|;
name|this
operator|.
name|list
operator|=
name|list
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|get
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|list
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|listIterator
argument_list|()
return|;
block|}
block|}
comment|/** Extension to {@link TransformingIndexedList} that implements    * {@link RandomAccess}.    *    * @param<F> Element type of backing list    * @param<T> Element type of this list    */
specifier|private
specifier|static
class|class
name|RandomAccessTransformingIndexedList
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
extends|extends
name|TransformingIndexedList
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
implements|implements
name|RandomAccess
block|{
name|RandomAccessTransformingIndexedList
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|F
argument_list|>
name|list
parameter_list|,
name|BiFunction
argument_list|<
name|?
super|super
name|F
argument_list|,
name|Integer
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|super
argument_list|(
name|list
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Iterator that applies a predicate to each element.    *    * @param<T> Element type */
specifier|private
specifier|static
class|class
name|FilteringIterator
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Iterator
argument_list|<
name|T
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Object
name|DUMMY
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
decl_stmt|;
specifier|private
specifier|final
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
decl_stmt|;
name|T
name|current
decl_stmt|;
name|FilteringIterator
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterator
parameter_list|,
name|Predicate
argument_list|<
name|?
super|super
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|iterator
operator|=
name|iterator
expr_stmt|;
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"method.invocation.invalid"
argument_list|)
name|T
name|current
init|=
name|moveNext
argument_list|()
decl_stmt|;
name|this
operator|.
name|current
operator|=
name|current
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|current
operator|!=
name|DUMMY
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
specifier|final
name|T
name|t
init|=
name|this
operator|.
name|current
decl_stmt|;
name|current
operator|=
name|moveNext
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
specifier|protected
name|T
name|moveNext
parameter_list|()
block|{
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|t
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|t
argument_list|)
condition|)
block|{
return|return
name|t
return|;
block|}
block|}
return|return
operator|(
name|T
operator|)
name|DUMMY
return|;
block|}
block|}
comment|/**    * An {@link java.util.Iterator} that transforms its elements on-the-fly.    *    * @param<F> The element type of the delegate iterator    * @param<T> The element type of this iterator    */
specifier|private
specifier|static
class|class
name|TransformingIterator
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
implements|implements
name|Iterator
argument_list|<
name|T
argument_list|>
block|{
specifier|private
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|F
argument_list|>
name|delegate
decl_stmt|;
specifier|private
specifier|final
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
decl_stmt|;
name|TransformingIterator
parameter_list|(
name|Iterator
argument_list|<
name|?
extends|extends
name|F
argument_list|>
name|delegate
parameter_list|,
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
argument_list|<
name|?
super|super
name|F
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
name|this
operator|.
name|function
operator|=
name|function
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|T
name|next
parameter_list|()
block|{
return|return
name|function
operator|.
name|apply
argument_list|(
name|delegate
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|delegate
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

