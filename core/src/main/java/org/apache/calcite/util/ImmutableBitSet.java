begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Linq4j
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|LongBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_comment
comment|/**  * An immutable list of bits.  */
end_comment

begin_class
specifier|public
class|class
name|ImmutableBitSet
implements|implements
name|Iterable
argument_list|<
name|Integer
argument_list|>
implements|,
name|Serializable
implements|,
name|Comparable
argument_list|<
name|ImmutableBitSet
argument_list|>
block|{
comment|/** Compares bit sets topologically, so that enclosing bit sets come first,    * using natural ordering to break ties. */
specifier|public
specifier|static
specifier|final
name|Comparator
argument_list|<
name|ImmutableBitSet
argument_list|>
name|COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|ImmutableBitSet
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|ImmutableBitSet
name|o1
parameter_list|,
name|ImmutableBitSet
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|.
name|equals
argument_list|(
name|o2
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|o1
operator|.
name|contains
argument_list|(
name|o2
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|o2
operator|.
name|contains
argument_list|(
name|o1
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
name|o1
operator|.
name|compareTo
argument_list|(
name|o2
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Ordering
argument_list|<
name|ImmutableBitSet
argument_list|>
name|ORDERING
init|=
name|Ordering
operator|.
name|from
argument_list|(
name|COMPARATOR
argument_list|)
decl_stmt|;
comment|// BitSets are packed into arrays of "words."  Currently a word is
comment|// a long, which consists of 64 bits, requiring 6 address bits.
comment|// The choice of word size is determined purely by performance concerns.
specifier|private
specifier|static
specifier|final
name|int
name|ADDRESS_BITS_PER_WORD
init|=
literal|6
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|BITS_PER_WORD
init|=
literal|1
operator|<<
name|ADDRESS_BITS_PER_WORD
decl_stmt|;
comment|/* Used to shift left or right for a partial word mask */
specifier|private
specifier|static
specifier|final
name|long
name|WORD_MASK
init|=
literal|0xffffffffffffffffL
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
index|[]
name|EMPTY_LONGS
init|=
operator|new
name|long
index|[
literal|0
index|]
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ImmutableBitSet
name|EMPTY
init|=
operator|new
name|ImmutableBitSet
argument_list|(
name|EMPTY_LONGS
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Function
argument_list|<
name|?
super|super
name|BitSet
argument_list|,
name|ImmutableBitSet
argument_list|>
name|FROM_BIT_SET
init|=
operator|new
name|Function
argument_list|<
name|BitSet
argument_list|,
name|ImmutableBitSet
argument_list|>
argument_list|()
block|{
specifier|public
name|ImmutableBitSet
name|apply
parameter_list|(
name|BitSet
name|input
parameter_list|)
block|{
return|return
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|BitSets
operator|.
name|toIter
argument_list|(
name|input
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|final
name|long
index|[]
name|words
decl_stmt|;
comment|/** Private constructor. Does not copy the array. */
specifier|private
name|ImmutableBitSet
parameter_list|(
name|long
index|[]
name|words
parameter_list|)
block|{
name|this
operator|.
name|words
operator|=
name|words
expr_stmt|;
assert|assert
name|words
operator|.
name|length
operator|==
literal|0
condition|?
name|words
operator|==
name|EMPTY_LONGS
else|:
name|words
index|[
name|words
operator|.
name|length
operator|-
literal|1
index|]
operator|!=
literal|0L
assert|;
block|}
comment|/** Creates an ImmutableBitSet with no bits. */
specifier|public
specifier|static
name|ImmutableBitSet
name|of
parameter_list|()
block|{
return|return
name|EMPTY
return|;
block|}
specifier|public
specifier|static
name|ImmutableBitSet
name|of
parameter_list|(
name|int
modifier|...
name|bits
parameter_list|)
block|{
name|int
name|max
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|bit
range|:
name|bits
control|)
block|{
name|max
operator|=
name|Math
operator|.
name|max
argument_list|(
name|bit
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|EMPTY
return|;
block|}
name|long
index|[]
name|words
init|=
operator|new
name|long
index|[
name|wordIndex
argument_list|(
name|max
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|bit
range|:
name|bits
control|)
block|{
name|int
name|wordIndex
init|=
name|wordIndex
argument_list|(
name|bit
argument_list|)
decl_stmt|;
name|words
index|[
name|wordIndex
index|]
operator||=
literal|1L
operator|<<
name|bit
expr_stmt|;
block|}
return|return
operator|new
name|ImmutableBitSet
argument_list|(
name|words
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|ImmutableBitSet
name|of
parameter_list|(
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|bits
parameter_list|)
block|{
if|if
condition|(
name|bits
operator|instanceof
name|ImmutableBitSet
condition|)
block|{
return|return
operator|(
name|ImmutableBitSet
operator|)
name|bits
return|;
block|}
name|int
name|max
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|bit
range|:
name|bits
control|)
block|{
name|max
operator|=
name|Math
operator|.
name|max
argument_list|(
name|bit
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|EMPTY
return|;
block|}
name|long
index|[]
name|words
init|=
operator|new
name|long
index|[
name|wordIndex
argument_list|(
name|max
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|bit
range|:
name|bits
control|)
block|{
name|int
name|wordIndex
init|=
name|wordIndex
argument_list|(
name|bit
argument_list|)
decl_stmt|;
name|words
index|[
name|wordIndex
index|]
operator||=
literal|1L
operator|<<
name|bit
expr_stmt|;
block|}
return|return
operator|new
name|ImmutableBitSet
argument_list|(
name|words
argument_list|)
return|;
block|}
comment|/**    * Creates an ImmutableBitSet with given bits set.    *    *<p>For example,<code>of(ImmutableIntList.of(0, 3))</code> returns a bit    * set with bits {0, 3} set.    *    * @param bits Collection of bits to set    * @return Bit set    */
specifier|public
specifier|static
name|ImmutableBitSet
name|of
parameter_list|(
name|ImmutableIntList
name|bits
parameter_list|)
block|{
return|return
name|builder
argument_list|()
operator|.
name|addAll
argument_list|(
name|bits
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Returns a new immutable bit set containing all the bits in the given long    * array.    *    *<p>More precisely,    *    *<blockquote>{@code ImmutableBitSet.valueOf(longs).get(n)    *   == ((longs[n/64]& (1L<<(n%64))) != 0)}</blockquote>    *    *<p>for all {@code n< 64 * longs.length}.    *    *<p>This method is equivalent to    * {@code ImmutableBitSet.valueOf(LongBuffer.wrap(longs))}.    *    * @param longs a long array containing a little-endian representation    *        of a sequence of bits to be used as the initial bits of the    *        new bit set    * @return a {@code ImmutableBitSet} containing all the bits in the long    *         array    */
specifier|public
specifier|static
name|ImmutableBitSet
name|valueOf
parameter_list|(
name|long
modifier|...
name|longs
parameter_list|)
block|{
name|int
name|n
init|=
name|longs
operator|.
name|length
decl_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
operator|&&
name|longs
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
operator|--
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY
return|;
block|}
return|return
operator|new
name|ImmutableBitSet
argument_list|(
name|Arrays
operator|.
name|copyOf
argument_list|(
name|longs
argument_list|,
name|n
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a new immutable bit set containing all the bits in the given long    * buffer.    */
specifier|public
specifier|static
name|ImmutableBitSet
name|valueOf
parameter_list|(
name|LongBuffer
name|longs
parameter_list|)
block|{
name|longs
operator|=
name|longs
operator|.
name|slice
argument_list|()
expr_stmt|;
name|int
name|n
init|=
name|longs
operator|.
name|remaining
argument_list|()
decl_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
operator|&&
name|longs
operator|.
name|get
argument_list|(
name|n
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|--
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY
return|;
block|}
name|long
index|[]
name|words
init|=
operator|new
name|long
index|[
name|n
index|]
decl_stmt|;
name|longs
operator|.
name|get
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmutableBitSet
argument_list|(
name|words
argument_list|)
return|;
block|}
comment|/**    * Creates an ImmutableBitSet with bits from {@code fromIndex} (inclusive) to    * specified {@code toIndex} (exclusive) set to {@code true}.    *    *<p>For example, {@code range(0, 3)} returns a bit set with bits    * {0, 1, 2} set.    *    * @param fromIndex Index of the first bit to be set.    * @param toIndex   Index after the last bit to be set.    * @return Bit set    */
specifier|public
specifier|static
name|ImmutableBitSet
name|range
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
if|if
condition|(
name|fromIndex
operator|>
name|toIndex
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
if|if
condition|(
name|toIndex
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
if|if
condition|(
name|fromIndex
operator|==
name|toIndex
condition|)
block|{
return|return
name|EMPTY
return|;
block|}
name|int
name|startWordIndex
init|=
name|wordIndex
argument_list|(
name|fromIndex
argument_list|)
decl_stmt|;
name|int
name|endWordIndex
init|=
name|wordIndex
argument_list|(
name|toIndex
operator|-
literal|1
argument_list|)
decl_stmt|;
name|long
index|[]
name|words
init|=
operator|new
name|long
index|[
name|endWordIndex
operator|+
literal|1
index|]
decl_stmt|;
name|long
name|firstWordMask
init|=
name|WORD_MASK
operator|<<
name|fromIndex
decl_stmt|;
name|long
name|lastWordMask
init|=
name|WORD_MASK
operator|>>>
operator|-
name|toIndex
decl_stmt|;
if|if
condition|(
name|startWordIndex
operator|==
name|endWordIndex
condition|)
block|{
comment|// One word
name|words
index|[
name|startWordIndex
index|]
operator||=
name|firstWordMask
operator|&
name|lastWordMask
expr_stmt|;
block|}
else|else
block|{
comment|// First word, middle words, last word
name|words
index|[
name|startWordIndex
index|]
operator||=
name|firstWordMask
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|startWordIndex
operator|+
literal|1
init|;
name|i
operator|<
name|endWordIndex
condition|;
name|i
operator|++
control|)
block|{
name|words
index|[
name|i
index|]
operator|=
name|WORD_MASK
expr_stmt|;
block|}
name|words
index|[
name|endWordIndex
index|]
operator||=
name|lastWordMask
expr_stmt|;
block|}
return|return
operator|new
name|ImmutableBitSet
argument_list|(
name|words
argument_list|)
return|;
block|}
comment|/** Creates an ImmutableBitSet with bits between 0 and {@code toIndex} set. */
specifier|public
specifier|static
name|ImmutableBitSet
name|range
parameter_list|(
name|int
name|toIndex
parameter_list|)
block|{
return|return
name|range
argument_list|(
literal|0
argument_list|,
name|toIndex
argument_list|)
return|;
block|}
comment|/**    * Given a bit index, return word index containing it.    */
specifier|private
specifier|static
name|int
name|wordIndex
parameter_list|(
name|int
name|bitIndex
parameter_list|)
block|{
return|return
name|bitIndex
operator|>>
name|ADDRESS_BITS_PER_WORD
return|;
block|}
comment|/** Computes the power set (set of all sets) of this bit set. */
specifier|public
name|Iterable
argument_list|<
name|ImmutableBitSet
argument_list|>
name|powerSet
parameter_list|()
block|{
name|List
argument_list|<
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
argument_list|>
name|singletons
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|bit
range|:
name|this
control|)
block|{
name|singletons
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|()
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|bit
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Iterables
operator|.
name|transform
argument_list|(
name|Linq4j
operator|.
name|product
argument_list|(
name|singletons
argument_list|)
argument_list|,
operator|new
name|Function
argument_list|<
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
argument_list|,
name|ImmutableBitSet
argument_list|>
argument_list|()
block|{
specifier|public
name|ImmutableBitSet
name|apply
parameter_list|(
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|ImmutableBitSet
operator|.
name|union
argument_list|(
name|input
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Returns the value of the bit with the specified index. The value    * is {@code true} if the bit with the index {@code bitIndex}    * is currently set in this {@code ImmutableBitSet}; otherwise, the result    * is {@code false}.    *    * @param  bitIndex   the bit index    * @return the value of the bit with the specified index    * @throws IndexOutOfBoundsException if the specified index is negative    */
specifier|public
name|boolean
name|get
parameter_list|(
name|int
name|bitIndex
parameter_list|)
block|{
if|if
condition|(
name|bitIndex
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"bitIndex< 0: "
operator|+
name|bitIndex
argument_list|)
throw|;
block|}
name|int
name|wordIndex
init|=
name|wordIndex
argument_list|(
name|bitIndex
argument_list|)
decl_stmt|;
return|return
operator|(
name|wordIndex
operator|<
name|words
operator|.
name|length
operator|)
operator|&&
operator|(
operator|(
name|words
index|[
name|wordIndex
index|]
operator|&
operator|(
literal|1L
operator|<<
name|bitIndex
operator|)
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
comment|/**    * Returns a string representation of this bit set. For every index    * for which this {@code BitSet} contains a bit in the set    * state, the decimal representation of that index is included in    * the result. Such indices are listed in order from lowest to    * highest, separated by ",&nbsp;" (a comma and a space) and    * surrounded by braces, resulting in the usual mathematical    * notation for a set of integers.    *    *<p>Example:    *<pre>    * BitSet drPepper = new BitSet();</pre>    * Now {@code drPepper.toString()} returns "{@code {}}".    *<pre>    * drPepper.set(2);</pre>    * Now {@code drPepper.toString()} returns "{@code {2}}".    *<pre>    * drPepper.set(4);    * drPepper.set(10);</pre>    * Now {@code drPepper.toString()} returns "{@code {2, 4, 10}}".    *    * @return a string representation of this bit set    */
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|int
name|numBits
init|=
name|words
operator|.
name|length
operator|*
name|BITS_PER_WORD
decl_stmt|;
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|(
literal|6
operator|*
name|numBits
operator|+
literal|2
argument_list|)
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
control|)
block|{
name|int
name|endOfRun
init|=
name|nextClearBit
argument_list|(
name|i
argument_list|)
decl_stmt|;
do|do
block|{
name|b
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|endOfRun
condition|)
do|;
block|}
block|}
name|b
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns true if the specified {@code ImmutableBitSet} has any bits set to    * {@code true} that are also set to {@code true} in this    * {@code ImmutableBitSet}.    *    * @param  set {@code ImmutableBitSet} to intersect with    * @return boolean indicating whether this {@code ImmutableBitSet} intersects    *         the specified {@code ImmutableBitSet}    */
specifier|public
name|boolean
name|intersects
parameter_list|(
name|ImmutableBitSet
name|set
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|Math
operator|.
name|min
argument_list|(
name|words
operator|.
name|length
argument_list|,
name|set
operator|.
name|words
operator|.
name|length
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|words
index|[
name|i
index|]
operator|&
name|set
operator|.
name|words
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Returns the number of bits set to {@code true} in this    * {@code ImmutableBitSet}. */
specifier|public
name|int
name|cardinality
parameter_list|()
block|{
return|return
name|countBits
argument_list|(
name|words
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|countBits
parameter_list|(
name|long
index|[]
name|words
parameter_list|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|long
name|word
range|:
name|words
control|)
block|{
name|sum
operator|+=
name|Long
operator|.
name|bitCount
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
comment|/**    * Returns the hash code value for this bit set. The hash code    * depends only on which bits are set within this {@code ImmutableBitSet}.    *    *<p>The hash code is defined using the same calculation as    * {@link java.util.BitSet#hashCode()}.    *    * @return the hash code value for this bit set    */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|long
name|h
init|=
literal|1234
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|words
operator|.
name|length
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|h
operator|^=
name|words
index|[
name|i
index|]
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
operator|(
operator|(
name|h
operator|>>
literal|32
operator|)
operator|^
name|h
operator|)
return|;
block|}
comment|/**    * Returns the number of bits of space actually in use by this    * {@code ImmutableBitSet} to represent bit values.    * The maximum element in the set is the size - 1st element.    *    * @return the number of bits currently in this bit set    */
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|words
operator|.
name|length
operator|*
name|BITS_PER_WORD
return|;
block|}
comment|/**    * Compares this object against the specified object.    * The result is {@code true} if and only if the argument is    * not {@code null} and is a {@code ImmutableBitSet} object that has    * exactly the same set of bits set to {@code true} as this bit    * set.    *    * @param  obj the object to compare with    * @return {@code true} if the objects are the same;    *         {@code false} otherwise    * @see    #size()    */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|ImmutableBitSet
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ImmutableBitSet
name|set
init|=
operator|(
name|ImmutableBitSet
operator|)
name|obj
decl_stmt|;
return|return
name|Arrays
operator|.
name|equals
argument_list|(
name|words
argument_list|,
name|set
operator|.
name|words
argument_list|)
return|;
block|}
comment|/** Compares this ImmutableBitSet with another, using a lexicographic    * ordering.    *    *<p>Bit sets {@code (), (0), (0, 1), (0, 1, 3), (1), (2, 3)} are in sorted    * order.</p>    */
specifier|public
name|int
name|compareTo
parameter_list|(
name|ImmutableBitSet
name|o
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|n0
init|=
name|nextSetBit
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|n1
init|=
name|o
operator|.
name|nextSetBit
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|Utilities
operator|.
name|compare
argument_list|(
name|n0
argument_list|,
name|n1
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
operator|||
name|n0
operator|<
literal|0
condition|)
block|{
return|return
name|c
return|;
block|}
name|i
operator|=
name|n0
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/**    * Returns the index of the first bit that is set to {@code true}    * that occurs on or after the specified starting index. If no such    * bit exists then {@code -1} is returned.    *    *<p>Based upon {@link BitSet#nextSetBit}.    *    * @param  fromIndex the index to start checking from (inclusive)    * @return the index of the next set bit, or {@code -1} if there    *         is no such bit    * @throws IndexOutOfBoundsException if the specified index is negative    */
specifier|public
name|int
name|nextSetBit
parameter_list|(
name|int
name|fromIndex
parameter_list|)
block|{
if|if
condition|(
name|fromIndex
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"fromIndex< 0: "
operator|+
name|fromIndex
argument_list|)
throw|;
block|}
name|int
name|u
init|=
name|wordIndex
argument_list|(
name|fromIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|>=
name|words
operator|.
name|length
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|long
name|word
init|=
name|words
index|[
name|u
index|]
operator|&
operator|(
name|WORD_MASK
operator|<<
name|fromIndex
operator|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|word
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|u
operator|*
name|BITS_PER_WORD
operator|)
operator|+
name|Long
operator|.
name|numberOfTrailingZeros
argument_list|(
name|word
argument_list|)
return|;
block|}
if|if
condition|(
operator|++
name|u
operator|==
name|words
operator|.
name|length
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|word
operator|=
name|words
index|[
name|u
index|]
expr_stmt|;
block|}
block|}
comment|/**    * Returns the index of the first bit that is set to {@code false}    * that occurs on or after the specified starting index.    *    * @param  fromIndex the index to start checking from (inclusive)    * @return the index of the next clear bit    * @throws IndexOutOfBoundsException if the specified index is negative    */
specifier|public
name|int
name|nextClearBit
parameter_list|(
name|int
name|fromIndex
parameter_list|)
block|{
if|if
condition|(
name|fromIndex
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"fromIndex< 0: "
operator|+
name|fromIndex
argument_list|)
throw|;
block|}
name|int
name|u
init|=
name|wordIndex
argument_list|(
name|fromIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|>=
name|words
operator|.
name|length
condition|)
block|{
return|return
name|fromIndex
return|;
block|}
name|long
name|word
init|=
operator|~
name|words
index|[
name|u
index|]
operator|&
operator|(
name|WORD_MASK
operator|<<
name|fromIndex
operator|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|word
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|u
operator|*
name|BITS_PER_WORD
operator|)
operator|+
name|Long
operator|.
name|numberOfTrailingZeros
argument_list|(
name|word
argument_list|)
return|;
block|}
if|if
condition|(
operator|++
name|u
operator|==
name|words
operator|.
name|length
condition|)
block|{
return|return
name|words
operator|.
name|length
operator|*
name|BITS_PER_WORD
return|;
block|}
name|word
operator|=
operator|~
name|words
index|[
name|u
index|]
expr_stmt|;
block|}
block|}
comment|/**    * Returns the index of the nearest bit that is set to {@code false}    * that occurs on or before the specified starting index.    * If no such bit exists, or if {@code -1} is given as the    * starting index, then {@code -1} is returned.    *    * @param  fromIndex the index to start checking from (inclusive)    * @return the index of the previous clear bit, or {@code -1} if there    *         is no such bit    * @throws IndexOutOfBoundsException if the specified index is less    *         than {@code -1}    */
specifier|public
name|int
name|previousClearBit
parameter_list|(
name|int
name|fromIndex
parameter_list|)
block|{
if|if
condition|(
name|fromIndex
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fromIndex
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"fromIndex< -1: "
operator|+
name|fromIndex
argument_list|)
throw|;
block|}
name|int
name|u
init|=
name|wordIndex
argument_list|(
name|fromIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|>=
name|words
operator|.
name|length
condition|)
block|{
return|return
name|fromIndex
return|;
block|}
name|long
name|word
init|=
operator|~
name|words
index|[
name|u
index|]
operator|&
operator|(
name|WORD_MASK
operator|>>>
operator|-
operator|(
name|fromIndex
operator|+
literal|1
operator|)
operator|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|word
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|u
operator|+
literal|1
operator|)
operator|*
name|BITS_PER_WORD
operator|-
literal|1
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|word
argument_list|)
return|;
block|}
if|if
condition|(
name|u
operator|--
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|word
operator|=
operator|~
name|words
index|[
name|u
index|]
expr_stmt|;
block|}
block|}
specifier|public
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
name|int
name|i
init|=
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|i
operator|>=
literal|0
return|;
block|}
specifier|public
name|Integer
name|next
parameter_list|()
block|{
name|int
name|prev
init|=
name|i
decl_stmt|;
name|i
operator|=
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|prev
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
comment|/** Converts this bit set to a list. */
specifier|public
name|IntList
name|toList
parameter_list|()
block|{
specifier|final
name|IntList
name|list
init|=
operator|new
name|IntList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/** Creates a view onto this bit set as a list of integers.    *    *<p>The {@code cardinality} and {@code get} methods are both O(n), but    * the iterator is efficient. The list is memory efficient, and the CPU cost    * breaks even (versus {@link #toList}) if you intend to scan it only once. */
specifier|public
name|List
argument_list|<
name|Integer
argument_list|>
name|asList
parameter_list|()
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|nth
argument_list|(
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|cardinality
argument_list|()
return|;
block|}
annotation|@
name|Nonnull
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|ImmutableBitSet
operator|.
name|this
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Converts this bit set to an array.    *    *<p>Each entry of the array is the ordinal of a set bit. The array is    * sorted.    *    * @return Array of set bits    */
specifier|public
name|int
index|[]
name|toArray
parameter_list|()
block|{
specifier|final
name|int
index|[]
name|integers
init|=
operator|new
name|int
index|[
name|cardinality
argument_list|()
index|]
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
control|)
block|{
name|integers
index|[
name|j
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
return|return
name|integers
return|;
block|}
comment|/**    * Converts this bit set to an array of little-endian words.    */
specifier|public
name|long
index|[]
name|toLongArray
parameter_list|()
block|{
return|return
name|words
operator|.
name|length
operator|==
literal|0
condition|?
name|words
else|:
name|words
operator|.
name|clone
argument_list|()
return|;
block|}
comment|/** Returns the union of this bit set with another. */
specifier|public
name|ImmutableBitSet
name|union
parameter_list|(
name|ImmutableBitSet
name|other
parameter_list|)
block|{
return|return
name|builder
argument_list|(
name|this
argument_list|)
operator|.
name|addAll
argument_list|(
name|other
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns the union of a number of bit sets. */
specifier|public
specifier|static
name|ImmutableBitSet
name|union
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ImmutableBitSet
argument_list|>
name|sets
parameter_list|)
block|{
specifier|final
name|Builder
name|builder
init|=
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|ImmutableBitSet
name|set
range|:
name|sets
control|)
block|{
name|builder
operator|.
name|addAll
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns a bit set with all the bits in this set that are not in    * another.    *    *  @see BitSet#andNot(java.util.BitSet) */
specifier|public
name|ImmutableBitSet
name|except
parameter_list|(
name|ImmutableBitSet
name|that
parameter_list|)
block|{
specifier|final
name|Builder
name|builder
init|=
name|builder
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|builder
operator|.
name|removeAll
argument_list|(
name|that
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|build
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/** Returns a bit set with all the bits set in both this set and in    *  another.    *    *  @see BitSet#and */
specifier|public
name|ImmutableBitSet
name|intersect
parameter_list|(
name|ImmutableBitSet
name|that
parameter_list|)
block|{
specifier|final
name|Builder
name|builder
init|=
name|builder
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|builder
operator|.
name|intersect
argument_list|(
name|that
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|build
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Returns true if all bits set in the second parameter are also set in the    * first. In other words, whether x is a super-set of y.    *    * @param set1 Bitmap to be checked    *    * @return Whether all bits in set1 are set in set0    */
specifier|public
name|boolean
name|contains
parameter_list|(
name|ImmutableBitSet
name|set1
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|set1
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|set1
operator|.
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * The ordinal of a given bit, or -1 if it is not set.    */
specifier|public
name|int
name|indexOf
parameter_list|(
name|int
name|bit
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|,
name|k
init|=
literal|0
init|;
condition|;
name|i
operator|=
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|,
operator|++
name|k
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|i
operator|==
name|bit
condition|)
block|{
return|return
name|k
return|;
block|}
block|}
block|}
comment|/** Computes the closure of a map from integers to bits.    *    *<p>The input must have an entry for each position.    *    *<p>Does not modify the input map or its bit sets. */
specifier|public
specifier|static
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|ImmutableBitSet
argument_list|>
name|closure
parameter_list|(
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|ImmutableBitSet
argument_list|>
name|equivalence
parameter_list|)
block|{
specifier|final
name|Closure
name|closure
init|=
operator|new
name|Closure
argument_list|(
name|equivalence
argument_list|)
decl_stmt|;
return|return
name|closure
operator|.
name|closure
return|;
block|}
comment|/**    * Returns the "logical size" of this {@code ImmutableBitSet}: the index of    * the highest set bit in the {@code ImmutableBitSet} plus one. Returns zero    * if the {@code ImmutableBitSet} contains no set bits.    *    * @return the logical size of this {@code ImmutableBitSet}    */
specifier|public
name|int
name|length
parameter_list|()
block|{
if|if
condition|(
name|words
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|BITS_PER_WORD
operator|*
operator|(
name|words
operator|.
name|length
operator|-
literal|1
operator|)
operator|+
operator|(
name|BITS_PER_WORD
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|words
index|[
name|words
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
operator|)
return|;
block|}
comment|/**    * Returns true if this {@code ImmutableBitSet} contains no bits that are set    * to {@code true}.    */
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|words
operator|.
name|length
operator|==
literal|0
return|;
block|}
specifier|public
specifier|static
name|Builder
name|builder
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|Builder
name|builder
parameter_list|(
name|ImmutableBitSet
name|bitSet
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|(
name|bitSet
argument_list|)
return|;
block|}
comment|/** Returns the {@code n}th set bit.    *    * @throws java.lang.IndexOutOfBoundsException if n is less than 0 or greater    * than the number of bits set */
specifier|public
name|int
name|nth
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|int
name|start
init|=
literal|0
decl_stmt|;
for|for
control|(
name|long
name|word
range|:
name|words
control|)
block|{
specifier|final
name|int
name|bitCount
init|=
name|Long
operator|.
name|bitCount
argument_list|(
name|word
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
name|bitCount
condition|)
block|{
while|while
condition|(
name|word
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|word
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
name|start
return|;
block|}
operator|--
name|n
expr_stmt|;
block|}
name|word
operator|>>=
literal|1
expr_stmt|;
operator|++
name|start
expr_stmt|;
block|}
block|}
name|start
operator|+=
literal|64
expr_stmt|;
name|n
operator|-=
name|bitCount
expr_stmt|;
block|}
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"index out of range: "
operator|+
name|n
argument_list|)
throw|;
block|}
comment|/** Returns a bit set the same as this but with a given bit set. */
specifier|public
name|ImmutableBitSet
name|set
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|union
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns a bit set the same as this but with a given bit set if condition    * is true. */
specifier|public
name|ImmutableBitSet
name|setIf
parameter_list|(
name|int
name|bit
parameter_list|,
name|boolean
name|condition
parameter_list|)
block|{
return|return
name|condition
condition|?
name|set
argument_list|(
name|bit
argument_list|)
else|:
name|this
return|;
block|}
comment|/** Returns a bit set the same as this but with a given bit cleared. */
specifier|public
name|ImmutableBitSet
name|clear
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|except
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns a bit set the same as this but with a given bit cleared if    * condition is true. */
specifier|public
name|ImmutableBitSet
name|clearIf
parameter_list|(
name|int
name|i
parameter_list|,
name|boolean
name|condition
parameter_list|)
block|{
return|return
name|condition
condition|?
name|except
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|i
argument_list|)
argument_list|)
else|:
name|this
return|;
block|}
comment|/** Returns a {@link BitSet} that has the same contents as this    * {@code ImmutableBitSet}. */
specifier|public
name|BitSet
name|toBitSet
parameter_list|()
block|{
return|return
name|BitSets
operator|.
name|of
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/** Permutes a bit set according to a given mapping. */
specifier|public
name|ImmutableBitSet
name|permute
parameter_list|(
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
parameter_list|)
block|{
specifier|final
name|Builder
name|builder
init|=
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
control|)
block|{
name|builder
operator|.
name|set
argument_list|(
name|map
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Permutes a collection of bit sets according to a given mapping. */
specifier|public
specifier|static
name|Iterable
argument_list|<
name|ImmutableBitSet
argument_list|>
name|permute
parameter_list|(
name|Iterable
argument_list|<
name|ImmutableBitSet
argument_list|>
name|bitSets
parameter_list|,
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|transform
argument_list|(
name|bitSets
argument_list|,
operator|new
name|Function
argument_list|<
name|ImmutableBitSet
argument_list|,
name|ImmutableBitSet
argument_list|>
argument_list|()
block|{
specifier|public
name|ImmutableBitSet
name|apply
parameter_list|(
name|ImmutableBitSet
name|bitSet
parameter_list|)
block|{
return|return
name|bitSet
operator|.
name|permute
argument_list|(
name|map
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Setup equivalence Sets for each position. If i& j are equivalent then    * they will have the same equivalence Set. The algorithm computes the    * closure relation at each position for the position wrt to positions    * greater than it. Once a closure is computed for a position, the closure    * Set is set on all its descendants. So the closure computation bubbles up    * from lower positions and the final equivalence Set is propagated down    * from the lowest element in the Set.    */
specifier|private
specifier|static
class|class
name|Closure
block|{
specifier|private
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|ImmutableBitSet
argument_list|>
name|equivalence
decl_stmt|;
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|ImmutableBitSet
argument_list|>
name|closure
init|=
name|Maps
operator|.
name|newTreeMap
argument_list|()
decl_stmt|;
specifier|public
name|Closure
parameter_list|(
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|ImmutableBitSet
argument_list|>
name|equivalence
parameter_list|)
block|{
name|this
operator|.
name|equivalence
operator|=
name|equivalence
expr_stmt|;
specifier|final
name|ImmutableIntList
name|keys
init|=
name|ImmutableIntList
operator|.
name|copyOf
argument_list|(
name|equivalence
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|pos
range|:
name|keys
control|)
block|{
name|computeClosure
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|ImmutableBitSet
name|computeClosure
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|ImmutableBitSet
name|o
init|=
name|closure
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
return|return
name|o
return|;
block|}
specifier|final
name|ImmutableBitSet
name|b
init|=
name|equivalence
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|o
operator|=
name|b
expr_stmt|;
name|int
name|i
init|=
name|b
operator|.
name|nextSetBit
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|b
operator|.
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
control|)
block|{
name|o
operator|=
name|o
operator|.
name|union
argument_list|(
name|computeClosure
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|closure
operator|.
name|put
argument_list|(
name|pos
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|i
operator|=
name|o
operator|.
name|nextSetBit
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|b
operator|.
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
control|)
block|{
name|closure
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
block|}
comment|/** Builder. */
specifier|public
specifier|static
class|class
name|Builder
block|{
specifier|private
name|long
index|[]
name|words
decl_stmt|;
specifier|public
name|Builder
parameter_list|(
name|ImmutableBitSet
name|bitSet
parameter_list|)
block|{
name|words
operator|=
name|bitSet
operator|.
name|words
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
specifier|public
name|Builder
parameter_list|()
block|{
name|words
operator|=
name|EMPTY_LONGS
expr_stmt|;
block|}
comment|/** Builds an ImmutableBitSet from the contents of this Builder.      *      *<p>After calling this method, the Builder cannot be used again. */
specifier|public
name|ImmutableBitSet
name|build
parameter_list|()
block|{
if|if
condition|(
name|words
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY
return|;
block|}
name|long
index|[]
name|words
init|=
name|this
operator|.
name|words
decl_stmt|;
name|this
operator|.
name|words
operator|=
literal|null
expr_stmt|;
comment|// prevent re-use of builder
return|return
operator|new
name|ImmutableBitSet
argument_list|(
name|words
argument_list|)
return|;
block|}
comment|/** Builds an ImmutableBitSet from the contents of this Builder, using      * an existing ImmutableBitSet if it happens to have the same contents.      *      *<p>Supplying the existing bit set if useful for set operations,      * where there is a significant chance that the original bit set is      * unchanged. We save memory because we use the same copy. For example:      *      *<blockquote><pre>      * ImmutableBitSet primeNumbers;      * ImmutableBitSet hundreds = ImmutableBitSet.of(100, 200, 300);      * return primeNumbers.except(hundreds);</pre></blockquote>      *      *<p>After calling this method, the Builder cannot be used again. */
specifier|public
name|ImmutableBitSet
name|build
parameter_list|(
name|ImmutableBitSet
name|bitSet
parameter_list|)
block|{
if|if
condition|(
name|wouldEqual
argument_list|(
name|bitSet
argument_list|)
condition|)
block|{
return|return
name|bitSet
return|;
block|}
return|return
name|build
argument_list|()
return|;
block|}
specifier|public
name|Builder
name|set
parameter_list|(
name|int
name|bit
parameter_list|)
block|{
if|if
condition|(
name|words
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"can only use builder once"
argument_list|)
throw|;
block|}
name|int
name|wordIndex
init|=
name|wordIndex
argument_list|(
name|bit
argument_list|)
decl_stmt|;
if|if
condition|(
name|wordIndex
operator|>=
name|words
operator|.
name|length
condition|)
block|{
name|words
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|words
argument_list|,
name|wordIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|words
index|[
name|wordIndex
index|]
operator||=
literal|1L
operator|<<
name|bit
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|private
name|void
name|trim
parameter_list|(
name|int
name|wordCount
parameter_list|)
block|{
while|while
condition|(
name|wordCount
operator|>
literal|0
operator|&&
name|words
index|[
name|wordCount
operator|-
literal|1
index|]
operator|==
literal|0L
condition|)
block|{
operator|--
name|wordCount
expr_stmt|;
block|}
if|if
condition|(
name|wordCount
operator|==
name|words
operator|.
name|length
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|wordCount
operator|==
literal|0
condition|)
block|{
name|words
operator|=
name|EMPTY_LONGS
expr_stmt|;
block|}
else|else
block|{
name|words
operator|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|words
argument_list|,
literal|0
argument_list|,
name|wordCount
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|Builder
name|clear
parameter_list|(
name|int
name|bit
parameter_list|)
block|{
name|int
name|wordIndex
init|=
name|wordIndex
argument_list|(
name|bit
argument_list|)
decl_stmt|;
if|if
condition|(
name|wordIndex
operator|<
name|words
operator|.
name|length
condition|)
block|{
name|words
index|[
name|wordIndex
index|]
operator|&=
operator|~
operator|(
literal|1L
operator|<<
name|bit
operator|)
expr_stmt|;
name|trim
argument_list|(
name|words
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Returns whether the bit set that would be created by this Builder would      * equal a given bit set. */
specifier|public
name|boolean
name|wouldEqual
parameter_list|(
name|ImmutableBitSet
name|bitSet
parameter_list|)
block|{
if|if
condition|(
name|words
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"can only use builder once"
argument_list|)
throw|;
block|}
return|return
name|Arrays
operator|.
name|equals
argument_list|(
name|words
argument_list|,
name|bitSet
operator|.
name|words
argument_list|)
return|;
block|}
comment|/** Returns the number of set bits. */
specifier|public
name|int
name|cardinality
parameter_list|()
block|{
if|if
condition|(
name|words
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"can only use builder once"
argument_list|)
throw|;
block|}
return|return
name|countBits
argument_list|(
name|words
argument_list|)
return|;
block|}
comment|/** Sets all bits in a given bit set. */
specifier|public
name|Builder
name|addAll
parameter_list|(
name|ImmutableBitSet
name|bitSet
parameter_list|)
block|{
for|for
control|(
name|Integer
name|bit
range|:
name|bitSet
control|)
block|{
name|set
argument_list|(
name|bit
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Sets all bits in a given list of bits. */
specifier|public
name|Builder
name|addAll
parameter_list|(
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|integers
parameter_list|)
block|{
for|for
control|(
name|Integer
name|integer
range|:
name|integers
control|)
block|{
name|set
argument_list|(
name|integer
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Sets all bits in a given list of {@code int}s. */
specifier|public
name|Builder
name|addAll
parameter_list|(
name|ImmutableIntList
name|integers
parameter_list|)
block|{
comment|//noinspection ForLoopReplaceableByForEach
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|integers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|set
argument_list|(
name|integers
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Clears all bits in a given bit set. */
specifier|public
name|Builder
name|removeAll
parameter_list|(
name|ImmutableBitSet
name|bitSet
parameter_list|)
block|{
for|for
control|(
name|Integer
name|bit
range|:
name|bitSet
control|)
block|{
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Sets a range of bits, from {@code from} to {@code to} - 1. */
specifier|public
name|Builder
name|set
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
if|if
condition|(
name|fromIndex
operator|>
name|toIndex
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
if|if
condition|(
name|toIndex
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
if|if
condition|(
name|fromIndex
operator|<
name|toIndex
condition|)
block|{
comment|// Increase capacity if necessary
name|int
name|startWordIndex
init|=
name|wordIndex
argument_list|(
name|fromIndex
argument_list|)
decl_stmt|;
name|int
name|endWordIndex
init|=
name|wordIndex
argument_list|(
name|toIndex
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|endWordIndex
operator|>=
name|words
operator|.
name|length
condition|)
block|{
name|words
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|words
argument_list|,
name|endWordIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|long
name|firstWordMask
init|=
name|WORD_MASK
operator|<<
name|fromIndex
decl_stmt|;
name|long
name|lastWordMask
init|=
name|WORD_MASK
operator|>>>
operator|-
name|toIndex
decl_stmt|;
if|if
condition|(
name|startWordIndex
operator|==
name|endWordIndex
condition|)
block|{
comment|// One word
name|words
index|[
name|startWordIndex
index|]
operator||=
name|firstWordMask
operator|&
name|lastWordMask
expr_stmt|;
block|}
else|else
block|{
comment|// First word, middle words, last word
name|words
index|[
name|startWordIndex
index|]
operator||=
name|firstWordMask
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|startWordIndex
operator|+
literal|1
init|;
name|i
operator|<
name|endWordIndex
condition|;
name|i
operator|++
control|)
block|{
name|words
index|[
name|i
index|]
operator|=
name|WORD_MASK
expr_stmt|;
block|}
name|words
index|[
name|endWordIndex
index|]
operator||=
name|lastWordMask
expr_stmt|;
block|}
block|}
return|return
name|this
return|;
block|}
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|words
operator|.
name|length
operator|==
literal|0
return|;
block|}
specifier|public
name|void
name|intersect
parameter_list|(
name|ImmutableBitSet
name|that
parameter_list|)
block|{
name|int
name|x
init|=
name|Math
operator|.
name|min
argument_list|(
name|words
operator|.
name|length
argument_list|,
name|that
operator|.
name|words
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|x
condition|;
name|i
operator|++
control|)
block|{
name|words
index|[
name|i
index|]
operator|&=
name|that
operator|.
name|words
index|[
name|i
index|]
expr_stmt|;
block|}
name|trim
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End ImmutableBitSet.java
end_comment

end_unit

