begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|BitSets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|IntList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Permutation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Utility functions related to mappings.  *  * @see MappingType  * @see Mapping  * @see org.apache.calcite.util.Permutation  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|Mappings
block|{
comment|//~ Constructors -----------------------------------------------------------
specifier|private
name|Mappings
parameter_list|()
block|{
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Creates a mapping with required properties.    */
specifier|public
specifier|static
name|Mapping
name|create
parameter_list|(
name|MappingType
name|mappingType
parameter_list|,
name|int
name|sourceCount
parameter_list|,
name|int
name|targetCount
parameter_list|)
block|{
switch|switch
condition|(
name|mappingType
condition|)
block|{
case|case
name|BIJECTION
case|:
assert|assert
name|sourceCount
operator|==
name|targetCount
assert|;
return|return
operator|new
name|Permutation
argument_list|(
name|sourceCount
argument_list|)
return|;
case|case
name|INVERSE_SURJECTION
case|:
assert|assert
name|sourceCount
operator|>=
name|targetCount
assert|;
return|return
operator|new
name|SurjectionWithInverse
argument_list|(
name|sourceCount
argument_list|,
name|targetCount
argument_list|)
return|;
case|case
name|PARTIAL_SURJECTION
case|:
case|case
name|SURJECTION
case|:
return|return
operator|new
name|Mappings
operator|.
name|PartialMapping
argument_list|(
name|sourceCount
argument_list|,
name|targetCount
argument_list|,
name|mappingType
argument_list|)
return|;
case|case
name|PARTIAL_FUNCTION
case|:
case|case
name|FUNCTION
case|:
return|return
operator|new
name|PartialFunctionImpl
argument_list|(
name|sourceCount
argument_list|,
name|targetCount
argument_list|,
name|mappingType
argument_list|)
return|;
case|case
name|INVERSE_FUNCTION
case|:
case|case
name|INVERSE_PARTIAL_FUNCTION
case|:
return|return
operator|new
name|InverseMapping
argument_list|(
name|create
argument_list|(
name|mappingType
operator|.
name|inverse
argument_list|()
argument_list|,
name|targetCount
argument_list|,
name|sourceCount
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|"no known implementation for mapping type "
operator|+
name|mappingType
argument_list|)
throw|;
block|}
block|}
comment|/**    * Creates the identity mapping.    *    *<p>For example, {@code createIdentity(2)} returns the mapping    * {0:0, 1:1, 2:2}.    *    * @param fieldCount Number of sources/targets    * @return Identity mapping    */
specifier|public
specifier|static
name|IdentityMapping
name|createIdentity
parameter_list|(
name|int
name|fieldCount
parameter_list|)
block|{
return|return
operator|new
name|Mappings
operator|.
name|IdentityMapping
argument_list|(
name|fieldCount
argument_list|)
return|;
block|}
comment|/**    * Converts a mapping to its inverse.    */
specifier|public
specifier|static
name|Mapping
name|invert
parameter_list|(
name|Mapping
name|mapping
parameter_list|)
block|{
if|if
condition|(
name|mapping
operator|instanceof
name|InverseMapping
condition|)
block|{
return|return
operator|(
operator|(
name|InverseMapping
operator|)
name|mapping
operator|)
operator|.
name|parent
return|;
block|}
return|return
operator|new
name|InverseMapping
argument_list|(
name|mapping
argument_list|)
return|;
block|}
comment|/**    * Divides one mapping by another.    *    *<p>{@code divide(A, B)} returns a mapping C such that B . C (the mapping    * B followed by the mapping C) is equivalent to A.    *    * @param mapping1 First mapping    * @param mapping2 Second mapping    * @return Mapping mapping3 such that mapping1 = mapping2 . mapping3    */
specifier|public
specifier|static
name|Mapping
name|divide
parameter_list|(
name|Mapping
name|mapping1
parameter_list|,
name|Mapping
name|mapping2
parameter_list|)
block|{
if|if
condition|(
name|mapping1
operator|.
name|getSourceCount
argument_list|()
operator|!=
name|mapping2
operator|.
name|getSourceCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|Mapping
name|remaining
init|=
name|create
argument_list|(
name|MappingType
operator|.
name|INVERSE_SURJECTION
argument_list|,
name|mapping2
operator|.
name|getTargetCount
argument_list|()
argument_list|,
name|mapping1
operator|.
name|getTargetCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|target
init|=
literal|0
init|;
name|target
operator|<
name|mapping1
operator|.
name|getTargetCount
argument_list|()
condition|;
operator|++
name|target
control|)
block|{
name|int
name|source
init|=
name|mapping1
operator|.
name|getSourceOpt
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|>=
literal|0
condition|)
block|{
name|int
name|x
init|=
name|mapping2
operator|.
name|getTarget
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|remaining
operator|.
name|set
argument_list|(
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|remaining
return|;
block|}
comment|/**    * Multiplies one mapping by another.    *    *<p>{@code divide(A, B)} returns a mapping C such that B . C (the mapping    * B followed by the mapping C) is equivalent to A.    *    * @param mapping1 First mapping    * @param mapping2 Second mapping    * @return Mapping mapping3 such that mapping1 = mapping2 . mapping3    */
specifier|public
specifier|static
name|Mapping
name|multiply
parameter_list|(
name|Mapping
name|mapping1
parameter_list|,
name|Mapping
name|mapping2
parameter_list|)
block|{
if|if
condition|(
name|mapping1
operator|.
name|getTargetCount
argument_list|()
operator|!=
name|mapping2
operator|.
name|getSourceCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|Mapping
name|product
init|=
name|create
argument_list|(
name|MappingType
operator|.
name|INVERSE_SURJECTION
argument_list|,
name|mapping1
operator|.
name|getSourceCount
argument_list|()
argument_list|,
name|mapping2
operator|.
name|getTargetCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|source
init|=
literal|0
init|;
name|source
operator|<
name|mapping1
operator|.
name|getSourceCount
argument_list|()
condition|;
operator|++
name|source
control|)
block|{
name|int
name|x
init|=
name|mapping1
operator|.
name|getTargetOpt
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|>=
literal|0
condition|)
block|{
name|int
name|target
init|=
name|mapping2
operator|.
name|getTarget
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|product
operator|.
name|set
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|product
return|;
block|}
comment|/**    * Applies a mapping to a BitSet.    *    *<p>If the mapping does not affect the bit set, returns the original.    * Never changes the original.    *    * @param mapping Mapping    * @param bitSet  Bit set    * @return Bit set with mapping applied    */
specifier|public
specifier|static
name|BitSet
name|apply
parameter_list|(
name|Mapping
name|mapping
parameter_list|,
name|BitSet
name|bitSet
parameter_list|)
block|{
specifier|final
name|BitSet
name|newBitSet
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|source
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|bitSet
argument_list|)
control|)
block|{
specifier|final
name|int
name|target
init|=
name|mapping
operator|.
name|getTarget
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|newBitSet
operator|.
name|set
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newBitSet
operator|.
name|equals
argument_list|(
name|bitSet
argument_list|)
condition|)
block|{
return|return
name|bitSet
return|;
block|}
return|return
name|newBitSet
return|;
block|}
comment|/**    * Applies a mapping to an {@code ImmutableBitSet}.    *    *<p>If the mapping does not affect the bit set, returns the original.    * Never changes the original.    *    * @param mapping Mapping    * @param bitSet  Bit set    * @return Bit set with mapping applied    */
specifier|public
specifier|static
name|ImmutableBitSet
name|apply
parameter_list|(
name|Mapping
name|mapping
parameter_list|,
name|ImmutableBitSet
name|bitSet
parameter_list|)
block|{
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|builder
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|source
range|:
name|bitSet
control|)
block|{
specifier|final
name|int
name|target
init|=
name|mapping
operator|.
name|getTarget
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|builder
operator|.
name|set
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|(
name|bitSet
argument_list|)
return|;
block|}
comment|/**    * Applies a mapping to a list.    *    * @param mapping Mapping    * @param list    List    * @param<T>     Element type    * @return List with elements permuted according to mapping    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|apply
parameter_list|(
specifier|final
name|Mapping
name|mapping
parameter_list|,
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
if|if
condition|(
name|mapping
operator|.
name|getSourceCount
argument_list|()
operator|!=
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// REVIEW: too strict?
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"mapping source count "
operator|+
name|mapping
operator|.
name|getSourceCount
argument_list|()
operator|+
literal|" does not match list size "
operator|+
name|list
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
specifier|final
name|int
name|targetCount
init|=
name|mapping
operator|.
name|getTargetCount
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list2
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|(
name|targetCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|target
init|=
literal|0
init|;
name|target
operator|<
name|targetCount
condition|;
operator|++
name|target
control|)
block|{
specifier|final
name|int
name|source
init|=
name|mapping
operator|.
name|getSource
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|list2
operator|.
name|add
argument_list|(
name|list
operator|.
name|get
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list2
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|apply2
parameter_list|(
specifier|final
name|Mapping
name|mapping
parameter_list|,
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|list
parameter_list|)
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|Integer
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
specifier|final
name|int
name|source
init|=
name|list
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|mapping
operator|.
name|getTarget
argument_list|(
name|source
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|list
operator|.
name|size
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Creates a view of a list, permuting according to a mapping.    *    * @param mapping Mapping    * @param list    List    * @param<T>     Element type    * @return Permuted view of list    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|apply3
parameter_list|(
specifier|final
name|Mapping
name|mapping
parameter_list|,
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|T
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|mapping
operator|.
name|getSource
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|mapping
operator|.
name|getTargetCount
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Creates a view of a list, permuting according to a target mapping.    *    * @param mapping Mapping    * @param list    List    * @param<T>     Element type    * @return Permuted view of list    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|permute
parameter_list|(
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
specifier|final
name|TargetMapping
name|mapping
parameter_list|)
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
specifier|public
name|T
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|mapping
operator|.
name|getTarget
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|mapping
operator|.
name|getSourceCount
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a mapping as a list such that {@code list.get(source)} is    * {@code mapping.getTarget(source)} and {@code list.size()} is    * {@code mapping.getSourceCount()}.    *    *<p>Converse of {@link #target(List, int)}</p>    */
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|asList
parameter_list|(
specifier|final
name|TargetMapping
name|mapping
parameter_list|)
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|Integer
name|get
parameter_list|(
name|int
name|source
parameter_list|)
block|{
name|int
name|target
init|=
name|mapping
operator|.
name|getTargetOpt
argument_list|(
name|source
argument_list|)
decl_stmt|;
return|return
name|target
operator|<
literal|0
condition|?
literal|null
else|:
name|target
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|mapping
operator|.
name|getSourceCount
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Converts a {@link Map} of integers to a {@link TargetMapping}.    */
specifier|public
specifier|static
name|TargetMapping
name|target
parameter_list|(
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
parameter_list|,
name|int
name|sourceCount
parameter_list|,
name|int
name|targetCount
parameter_list|)
block|{
specifier|final
name|PartialFunctionImpl
name|mapping
init|=
operator|new
name|PartialFunctionImpl
argument_list|(
name|sourceCount
argument_list|,
name|targetCount
argument_list|,
name|MappingType
operator|.
name|FUNCTION
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|mapping
return|;
block|}
specifier|public
specifier|static
name|TargetMapping
name|target
parameter_list|(
name|Function
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|function
parameter_list|,
name|int
name|sourceCount
parameter_list|,
name|int
name|targetCount
parameter_list|)
block|{
specifier|final
name|PartialFunctionImpl
name|mapping
init|=
operator|new
name|PartialFunctionImpl
argument_list|(
name|sourceCount
argument_list|,
name|targetCount
argument_list|,
name|MappingType
operator|.
name|FUNCTION
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|source
init|=
literal|0
init|;
name|source
operator|<
name|sourceCount
condition|;
name|source
operator|++
control|)
block|{
name|Integer
name|target
init|=
name|function
operator|.
name|apply
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|!=
literal|null
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|mapping
return|;
block|}
specifier|public
specifier|static
name|Mapping
name|target
parameter_list|(
name|Iterable
argument_list|<
name|IntPair
argument_list|>
name|pairs
parameter_list|,
name|int
name|sourceCount
parameter_list|,
name|int
name|targetCount
parameter_list|)
block|{
specifier|final
name|PartialFunctionImpl
name|mapping
init|=
operator|new
name|PartialFunctionImpl
argument_list|(
name|sourceCount
argument_list|,
name|targetCount
argument_list|,
name|MappingType
operator|.
name|FUNCTION
argument_list|)
decl_stmt|;
for|for
control|(
name|IntPair
name|pair
range|:
name|pairs
control|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|pair
operator|.
name|source
argument_list|,
name|pair
operator|.
name|target
argument_list|)
expr_stmt|;
block|}
return|return
name|mapping
return|;
block|}
specifier|public
specifier|static
name|Mapping
name|source
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|targets
parameter_list|,
name|int
name|targetCount
parameter_list|)
block|{
specifier|final
name|int
name|sourceCount
init|=
name|targets
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|PartialFunctionImpl
name|mapping
init|=
operator|new
name|PartialFunctionImpl
argument_list|(
name|sourceCount
argument_list|,
name|targetCount
argument_list|,
name|MappingType
operator|.
name|FUNCTION
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|source
init|=
literal|0
init|;
name|source
operator|<
name|sourceCount
condition|;
name|source
operator|++
control|)
block|{
name|int
name|target
init|=
name|targets
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|mapping
operator|.
name|set
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
return|return
name|mapping
return|;
block|}
specifier|public
specifier|static
name|Mapping
name|target
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|sources
parameter_list|,
name|int
name|sourceCount
parameter_list|)
block|{
specifier|final
name|int
name|targetCount
init|=
name|sources
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|PartialFunctionImpl
name|mapping
init|=
operator|new
name|PartialFunctionImpl
argument_list|(
name|sourceCount
argument_list|,
name|targetCount
argument_list|,
name|MappingType
operator|.
name|FUNCTION
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|target
init|=
literal|0
init|;
name|target
operator|<
name|targetCount
condition|;
name|target
operator|++
control|)
block|{
name|int
name|source
init|=
name|sources
operator|.
name|get
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|mapping
operator|.
name|set
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
return|return
name|mapping
return|;
block|}
comment|/** Creates a bijection.    *    *<p>Throws if sources and targets are not one to one.</p> */
specifier|public
specifier|static
name|Mapping
name|bijection
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|targets
parameter_list|)
block|{
return|return
operator|new
name|Permutation
argument_list|(
name|IntList
operator|.
name|toArray
argument_list|(
name|targets
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns whether a mapping is the identity.    */
specifier|public
specifier|static
name|boolean
name|isIdentity
parameter_list|(
name|TargetMapping
name|mapping
parameter_list|)
block|{
if|if
condition|(
name|mapping
operator|.
name|getSourceCount
argument_list|()
operator|!=
name|mapping
operator|.
name|getTargetCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mapping
operator|.
name|getSourceCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mapping
operator|.
name|getTargetOpt
argument_list|(
name|i
argument_list|)
operator|!=
name|i
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Creates a mapping that consists of a set of contiguous ranges.    *    *<p>For example,</p>    *    *<pre>createShiftMapping(60,    *     100, 0, 3,    *     200, 50, 5);    *</pre>    *    *<p>creates</p>    *    *<table>    *<caption>Example mapping</caption>    *<tr><th>Source</th><th>Target</th></tr>    *<tr><td>0</td><td>100</td></tr>    *<tr><td>1</td><td>101</td></tr>    *<tr><td>2</td><td>102</td></tr>    *<tr><td>3</td><td>-1</td></tr>    *<tr><td>...</td><td>-1</td></tr>    *<tr><td>50</td><td>200</td></tr>    *<tr><td>51</td><td>201</td></tr>    *<tr><td>52</td><td>202</td></tr>    *<tr><td>53</td><td>203</td></tr>    *<tr><td>54</td><td>204</td></tr>    *<tr><td>55</td><td>-1</td></tr>    *<tr><td>...</td><td>-1</td></tr>    *<tr><td>59</td><td>-1</td></tr>    *</table>    *    * @param sourceCount Maximum value of {@code source}    * @param ints        Collection of ranges, each    *                    {@code (target, source, count)}    * @return Mapping that maps from source ranges to target ranges    */
specifier|public
specifier|static
name|TargetMapping
name|createShiftMapping
parameter_list|(
name|int
name|sourceCount
parameter_list|,
name|int
modifier|...
name|ints
parameter_list|)
block|{
name|int
name|targetCount
init|=
literal|0
decl_stmt|;
assert|assert
name|ints
operator|.
name|length
operator|%
literal|3
operator|==
literal|0
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ints
operator|.
name|length
condition|;
name|i
operator|+=
literal|3
control|)
block|{
specifier|final
name|int
name|target
init|=
name|ints
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|int
name|length
init|=
name|ints
index|[
name|i
operator|+
literal|2
index|]
decl_stmt|;
specifier|final
name|int
name|top
init|=
name|target
operator|+
name|length
decl_stmt|;
name|targetCount
operator|=
name|Math
operator|.
name|max
argument_list|(
name|targetCount
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
specifier|final
name|TargetMapping
name|mapping
init|=
name|create
argument_list|(
name|MappingType
operator|.
name|INVERSE_SURJECTION
argument_list|,
name|sourceCount
argument_list|,
comment|// aCount + bCount + cCount,
name|targetCount
argument_list|)
decl_stmt|;
comment|// cCount + bCount
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ints
operator|.
name|length
condition|;
name|i
operator|+=
literal|3
control|)
block|{
specifier|final
name|int
name|target
init|=
name|ints
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|int
name|source
init|=
name|ints
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
specifier|final
name|int
name|length
init|=
name|ints
index|[
name|i
operator|+
literal|2
index|]
decl_stmt|;
assert|assert
name|source
operator|+
name|length
operator|<=
name|sourceCount
assert|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
block|{
assert|assert
name|mapping
operator|.
name|getTargetOpt
argument_list|(
name|source
operator|+
name|j
argument_list|)
operator|==
operator|-
literal|1
assert|;
name|mapping
operator|.
name|set
argument_list|(
name|source
operator|+
name|j
argument_list|,
name|target
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|mapping
return|;
block|}
comment|/**    * Creates a mapping by appending two mappings.    *    *<p>Sources and targets of the second mapping are shifted to the right.</p>    *    *<p>For example,<pre>append({0:0, 1:1}, {0:0, 1:1, 2:2})</pre> yields    *<pre>{0:0, 1:1, 2:2, 3:3, 4:4}</pre>.    *    * @see #merge    */
specifier|public
specifier|static
name|TargetMapping
name|append
parameter_list|(
name|TargetMapping
name|mapping0
parameter_list|,
name|TargetMapping
name|mapping1
parameter_list|)
block|{
specifier|final
name|int
name|s0
init|=
name|mapping0
operator|.
name|getSourceCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|s1
init|=
name|mapping1
operator|.
name|getSourceCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|t0
init|=
name|mapping0
operator|.
name|getTargetCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|t1
init|=
name|mapping1
operator|.
name|getTargetCount
argument_list|()
decl_stmt|;
specifier|final
name|TargetMapping
name|mapping
init|=
name|create
argument_list|(
name|MappingType
operator|.
name|INVERSE_SURJECTION
argument_list|,
name|s0
operator|+
name|s1
argument_list|,
name|t0
operator|+
name|t1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|s0
condition|;
name|s
operator|++
control|)
block|{
name|int
name|t
init|=
name|mapping0
operator|.
name|getTargetOpt
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|s1
condition|;
name|s
operator|++
control|)
block|{
name|int
name|t
init|=
name|mapping1
operator|.
name|getTargetOpt
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|s0
operator|+
name|s
argument_list|,
name|t0
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|mapping
return|;
block|}
comment|/**    * Creates a mapping by merging two mappings. There must be no clashes.    *    *<p>Unlike {@link #append}, sources and targets are not shifted.    *    *<p>For example,<code>merge({0:0, 1:1}, {2:2, 3:3, 4:4})</code> yields    *<code>{0:0, 1:1, 2:2, 3:3, 4:4}</code>.    *<code>merge({0:0, 1:1}, {1:2, 2:3})</code> throws, because there are    * two entries with source=1.    */
specifier|public
specifier|static
name|TargetMapping
name|merge
parameter_list|(
name|TargetMapping
name|mapping0
parameter_list|,
name|TargetMapping
name|mapping1
parameter_list|)
block|{
specifier|final
name|int
name|s0
init|=
name|mapping0
operator|.
name|getSourceCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|s1
init|=
name|mapping1
operator|.
name|getSourceCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|sMin
init|=
name|Math
operator|.
name|min
argument_list|(
name|s0
argument_list|,
name|s1
argument_list|)
decl_stmt|;
specifier|final
name|int
name|sMax
init|=
name|Math
operator|.
name|max
argument_list|(
name|s0
argument_list|,
name|s1
argument_list|)
decl_stmt|;
specifier|final
name|int
name|t0
init|=
name|mapping0
operator|.
name|getTargetCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|t1
init|=
name|mapping1
operator|.
name|getTargetCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|tMax
init|=
name|Math
operator|.
name|max
argument_list|(
name|t0
argument_list|,
name|t1
argument_list|)
decl_stmt|;
specifier|final
name|TargetMapping
name|mapping
init|=
name|create
argument_list|(
name|MappingType
operator|.
name|INVERSE_SURJECTION
argument_list|,
name|sMax
argument_list|,
name|tMax
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|sMin
condition|;
name|s
operator|++
control|)
block|{
name|int
name|t
init|=
name|mapping0
operator|.
name|getTargetOpt
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
assert|assert
name|mapping1
operator|.
name|getTargetOpt
argument_list|(
name|s
argument_list|)
operator|<
literal|0
assert|;
block|}
else|else
block|{
name|t
operator|=
name|mapping1
operator|.
name|getTargetOpt
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|int
name|s
init|=
name|sMin
init|;
name|s
operator|<
name|sMax
condition|;
name|s
operator|++
control|)
block|{
name|int
name|t
init|=
name|s
operator|<
name|s0
condition|?
name|mapping0
operator|.
name|getTargetOpt
argument_list|(
name|s
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
assert|assert
name|s
operator|>=
name|s1
operator|||
name|mapping1
operator|.
name|getTargetOpt
argument_list|(
name|s
argument_list|)
operator|<
literal|0
assert|;
block|}
else|else
block|{
name|t
operator|=
name|s
operator|<
name|s1
condition|?
name|mapping1
operator|.
name|getTargetOpt
argument_list|(
name|s
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|mapping
return|;
block|}
comment|/**    * Returns a mapping that shifts a given mapping's source by a given    * offset, incrementing the number of sources by the minimum possible.    *    * @param mapping     Input mapping    * @param offset      Offset to be applied to each source    * @return Shifted mapping    */
specifier|public
specifier|static
name|TargetMapping
name|offsetSource
parameter_list|(
specifier|final
name|TargetMapping
name|mapping
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
return|return
name|offsetSource
argument_list|(
name|mapping
argument_list|,
name|offset
argument_list|,
name|mapping
operator|.
name|getSourceCount
argument_list|()
operator|+
name|offset
argument_list|)
return|;
block|}
comment|/**    * Returns a mapping that shifts a given mapping's source by a given    * offset.    *    *<p>For example, given {@code mapping} with sourceCount=2, targetCount=8,    * and (source, target) entries {[0: 5], [1: 7]}, offsetSource(mapping, 3)    * returns a mapping with sourceCount=5, targetCount=8,    * and (source, target) entries {[3: 5], [4: 7]}.    *    * @param mapping     Input mapping    * @param offset      Offset to be applied to each source    * @param sourceCount New source count; must be at least {@code mapping}'s    *                    source count plus {@code offset}    * @return Shifted mapping    */
specifier|public
specifier|static
name|TargetMapping
name|offsetSource
parameter_list|(
specifier|final
name|TargetMapping
name|mapping
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|sourceCount
parameter_list|)
block|{
if|if
condition|(
name|sourceCount
operator|<
name|mapping
operator|.
name|getSourceCount
argument_list|()
operator|+
name|offset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"new source count too low"
argument_list|)
throw|;
block|}
return|return
name|target
argument_list|(
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|Integer
name|apply
parameter_list|(
name|Integer
name|source
parameter_list|)
block|{
name|int
name|source2
init|=
name|source
operator|-
name|offset
decl_stmt|;
return|return
name|source2
operator|<
literal|0
operator|||
name|source2
operator|>=
name|mapping
operator|.
name|getSourceCount
argument_list|()
condition|?
literal|null
else|:
name|mapping
operator|.
name|getTargetOpt
argument_list|(
name|source2
argument_list|)
return|;
block|}
block|}
argument_list|,
name|sourceCount
argument_list|,
name|mapping
operator|.
name|getTargetCount
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a mapping that shifts a given mapping's target by a given    * offset, incrementing the number of targets by the minimum possible.    *    * @param mapping     Input mapping    * @param offset      Offset to be applied to each target    * @return Shifted mapping    */
specifier|public
specifier|static
name|TargetMapping
name|offsetTarget
parameter_list|(
specifier|final
name|TargetMapping
name|mapping
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
return|return
name|offsetTarget
argument_list|(
name|mapping
argument_list|,
name|offset
argument_list|,
name|mapping
operator|.
name|getTargetCount
argument_list|()
operator|+
name|offset
argument_list|)
return|;
block|}
comment|/**    * Returns a mapping that shifts a given mapping's target by a given    * offset.    *    *<p>For example, given {@code mapping} with sourceCount=2, targetCount=8,    * and (source, target) entries {[0: 5], [1: 7]}, offsetTarget(mapping, 3)    * returns a mapping with sourceCount=2, targetCount=11,    * and (source, target) entries {[0: 8], [1: 10]}.    *    * @param mapping     Input mapping    * @param offset      Offset to be applied to each target    * @param targetCount New target count; must be at least {@code mapping}'s    *                    target count plus {@code offset}    * @return Shifted mapping    */
specifier|public
specifier|static
name|TargetMapping
name|offsetTarget
parameter_list|(
specifier|final
name|TargetMapping
name|mapping
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|targetCount
parameter_list|)
block|{
if|if
condition|(
name|targetCount
operator|<
name|mapping
operator|.
name|getTargetCount
argument_list|()
operator|+
name|offset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"new target count too low"
argument_list|)
throw|;
block|}
return|return
name|target
argument_list|(
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|Integer
name|apply
parameter_list|(
name|Integer
name|source
parameter_list|)
block|{
name|int
name|target
init|=
name|mapping
operator|.
name|getTargetOpt
argument_list|(
name|source
argument_list|)
decl_stmt|;
return|return
name|target
operator|<
literal|0
condition|?
literal|null
else|:
name|target
operator|+
name|offset
return|;
block|}
block|}
argument_list|,
name|mapping
operator|.
name|getSourceCount
argument_list|()
argument_list|,
name|targetCount
argument_list|)
return|;
block|}
comment|/**    * Returns a mapping that shifts a given mapping's source and target by a    * given offset.    *    *<p>For example, given {@code mapping} with sourceCount=2, targetCount=8,    * and (source, target) entries {[0: 5], [1: 7]}, offsetSource(mapping, 3)    * returns a mapping with sourceCount=5, targetCount=8,    * and (source, target) entries {[3: 8], [4: 10]}.    *    * @param mapping     Input mapping    * @param offset      Offset to be applied to each source    * @param sourceCount New source count; must be at least {@code mapping}'s    *                    source count plus {@code offset}    * @return Shifted mapping    */
specifier|public
specifier|static
name|TargetMapping
name|offset
parameter_list|(
specifier|final
name|TargetMapping
name|mapping
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|sourceCount
parameter_list|)
block|{
if|if
condition|(
name|sourceCount
operator|<
name|mapping
operator|.
name|getSourceCount
argument_list|()
operator|+
name|offset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"new source count too low"
argument_list|)
throw|;
block|}
return|return
name|target
argument_list|(
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|Integer
name|apply
parameter_list|(
name|Integer
name|source
parameter_list|)
block|{
specifier|final
name|int
name|source2
init|=
name|source
operator|-
name|offset
decl_stmt|;
if|if
condition|(
name|source2
operator|<
literal|0
operator|||
name|source2
operator|>=
name|mapping
operator|.
name|getSourceCount
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|target
init|=
name|mapping
operator|.
name|getTargetOpt
argument_list|(
name|source2
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|target
operator|+
name|offset
return|;
block|}
block|}
argument_list|,
name|sourceCount
argument_list|,
name|mapping
operator|.
name|getTargetCount
argument_list|()
operator|+
name|offset
argument_list|)
return|;
block|}
comment|/** Returns whether a list of integers is the identity mapping    * [0, ..., n - 1]. */
specifier|public
specifier|static
name|boolean
name|isIdentity
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|list
parameter_list|,
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|!=
name|count
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Integer
name|o
init|=
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|o
operator|!=
name|i
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** Inverts an {@link java.lang.Iterable} over    * {@link org.apache.calcite.util.mapping.IntPair}s. */
specifier|public
specifier|static
name|Iterable
argument_list|<
name|IntPair
argument_list|>
name|invert
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|IntPair
argument_list|>
name|pairs
parameter_list|)
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|IntPair
argument_list|>
argument_list|()
block|{
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|invert
argument_list|(
name|pairs
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Inverts an {@link java.util.Iterator} over    * {@link org.apache.calcite.util.mapping.IntPair}s. */
specifier|public
specifier|static
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|invert
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|pairs
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|IntPair
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|pairs
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|IntPair
name|next
parameter_list|()
block|{
specifier|final
name|IntPair
name|pair
init|=
name|pairs
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
name|IntPair
operator|.
name|of
argument_list|(
name|pair
operator|.
name|target
argument_list|,
name|pair
operator|.
name|source
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"remove"
argument_list|)
throw|;
block|}
block|}
return|;
block|}
comment|/** Applies a mapping to an optional integer, returning an optional    * result. */
specifier|public
specifier|static
name|int
name|apply
parameter_list|(
name|TargetMapping
name|mapping
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|i
operator|<
literal|0
condition|?
name|i
else|:
name|mapping
operator|.
name|getTarget
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|//~ Inner Interfaces -------------------------------------------------------
comment|/**    * Core interface of all mappings.    */
specifier|public
interface|interface
name|CoreMapping
extends|extends
name|Iterable
argument_list|<
name|IntPair
argument_list|>
block|{
comment|/**      * Returns the mapping type.      *      * @return Mapping type      */
name|MappingType
name|getMappingType
parameter_list|()
function_decl|;
comment|/**      * Returns the number of elements in the mapping.      */
name|int
name|size
parameter_list|()
function_decl|;
block|}
comment|/**    * Mapping where every source has a target. But:    *    *<ul>    *<li>A target may not have a source.    *<li>May not be finite.    *</ul>    */
specifier|public
interface|interface
name|FunctionMapping
extends|extends
name|CoreMapping
block|{
comment|/**      * Returns the target that a source maps to, or -1 if it is not mapped.      */
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
function_decl|;
comment|/**      * Returns the target that a source maps to.      *      * @param source source      * @return target      * @throws NoElementException if source is not mapped      */
name|int
name|getTarget
parameter_list|(
name|int
name|source
parameter_list|)
function_decl|;
name|MappingType
name|getMappingType
parameter_list|()
function_decl|;
name|int
name|getSourceCount
parameter_list|()
function_decl|;
block|}
comment|/**    * Mapping suitable for sourcing columns.    *    *<p>Properties:    *    *<ul>    *<li>It has a finite number of sources and targets    *<li>Each target has exactly one source    *<li>Each source has at most one target    *</ul>    *    *<p>TODO: figure out which interfaces this should extend    */
specifier|public
interface|interface
name|SourceMapping
extends|extends
name|CoreMapping
block|{
name|int
name|getSourceCount
parameter_list|()
function_decl|;
name|int
name|getSource
parameter_list|(
name|int
name|target
parameter_list|)
function_decl|;
name|int
name|getSourceOpt
parameter_list|(
name|int
name|target
parameter_list|)
function_decl|;
name|int
name|getTargetCount
parameter_list|()
function_decl|;
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
function_decl|;
name|MappingType
name|getMappingType
parameter_list|()
function_decl|;
name|boolean
name|isIdentity
parameter_list|()
function_decl|;
name|Mapping
name|inverse
parameter_list|()
function_decl|;
block|}
comment|/**    * Mapping suitable for mapping columns to a target.    *    *<p>Properties:    *    *<ul>    *<li>It has a finite number of sources and targets    *<li>Each target has at most one source    *<li>Each source has exactly one target    *</ul>    *    *<p>TODO: figure out which interfaces this should extend    */
specifier|public
interface|interface
name|TargetMapping
extends|extends
name|FunctionMapping
block|{
name|int
name|getSourceCount
parameter_list|()
function_decl|;
name|int
name|getSourceOpt
parameter_list|(
name|int
name|target
parameter_list|)
function_decl|;
name|int
name|getTargetCount
parameter_list|()
function_decl|;
name|int
name|getTarget
parameter_list|(
name|int
name|target
parameter_list|)
function_decl|;
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
function_decl|;
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
function_decl|;
name|Mapping
name|inverse
parameter_list|()
function_decl|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/** Abstract implementation of {@link Mapping}. */
specifier|public
specifier|abstract
specifier|static
class|class
name|AbstractMapping
implements|implements
name|Mapping
block|{
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|int
name|getTarget
parameter_list|(
name|int
name|source
parameter_list|)
block|{
name|int
name|target
init|=
name|getTargetOpt
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|NoElementException
argument_list|(
literal|"source #"
operator|+
name|source
operator|+
literal|" has no target in mapping "
operator|+
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|target
return|;
block|}
specifier|public
name|int
name|getSourceOpt
parameter_list|(
name|int
name|target
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|int
name|getSource
parameter_list|(
name|int
name|target
parameter_list|)
block|{
name|int
name|source
init|=
name|getSourceOpt
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|NoElementException
argument_list|(
literal|"target #"
operator|+
name|target
operator|+
literal|" has no source in mapping "
operator|+
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|source
return|;
block|}
specifier|public
name|int
name|getSourceCount
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|int
name|getTargetCount
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|boolean
name|isIdentity
parameter_list|()
block|{
name|int
name|sourceCount
init|=
name|getSourceCount
argument_list|()
decl_stmt|;
name|int
name|targetCount
init|=
name|getTargetCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|sourceCount
operator|!=
name|targetCount
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sourceCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|getSource
argument_list|(
name|i
argument_list|)
operator|!=
name|i
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns a string representation of this mapping.      *      *<p>For example, the mapping      *      *<table border="1">      *<caption>Example</caption>      *<tr>      *<th>source</th>      *<td>0</td>      *<td>1</td>      *<td>2</td>      *</tr>      *<tr>      *<th>target</th>      *<td>-1</td>      *<td>3</td>      *<td>2</td>      *</tr>      *</table>      *      *<table border="1">      *<caption>Example</caption>      *<tr>      *<th>target</th>      *<td>0</td>      *<td>1</td>      *<td>2</td>      *<td>3</td>      *</tr>      *<tr>      *<th>source</th>      *<td>-1</td>      *<td>-1</td>      *<td>2</td>      *<td>1</td>      *</tr>      *</table>      *      * is represented by the string "[1:3, 2:2]".      *      *<p>This method relies upon the optional method {@link #iterator()}.      */
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"[size="
argument_list|)
operator|.
name|append
argument_list|(
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", sourceCount="
argument_list|)
operator|.
name|append
argument_list|(
name|getSourceCount
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", targetCount="
argument_list|)
operator|.
name|append
argument_list|(
name|getTargetCount
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", elements=["
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|IntPair
name|pair
range|:
name|this
control|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|pair
operator|.
name|source
argument_list|)
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
operator|.
name|append
argument_list|(
name|pair
operator|.
name|target
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"]]"
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Abstract implementation of mapping where both source and target    * domains are finite. */
specifier|public
specifier|abstract
specifier|static
class|class
name|FiniteAbstractMapping
extends|extends
name|AbstractMapping
block|{
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|FunctionMappingIter
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// not very efficient
return|return
name|toString
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
comment|// not very efficient
return|return
operator|(
name|obj
operator|instanceof
name|Mapping
operator|)
operator|&&
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|obj
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Iterator that yields the (source, target) values in a    * {@link FunctionMapping}. */
specifier|static
class|class
name|FunctionMappingIter
implements|implements
name|Iterator
argument_list|<
name|IntPair
argument_list|>
block|{
specifier|private
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|FunctionMapping
name|mapping
decl_stmt|;
name|FunctionMappingIter
parameter_list|(
name|FunctionMapping
name|mapping
parameter_list|)
block|{
name|this
operator|.
name|mapping
operator|=
name|mapping
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|(
name|i
operator|<
name|mapping
operator|.
name|getSourceCount
argument_list|()
operator|)
operator|||
operator|(
name|mapping
operator|.
name|getSourceCount
argument_list|()
operator|==
operator|-
literal|1
operator|)
return|;
block|}
specifier|public
name|IntPair
name|next
parameter_list|()
block|{
name|int
name|x
init|=
name|i
operator|++
decl_stmt|;
return|return
operator|new
name|IntPair
argument_list|(
name|x
argument_list|,
name|mapping
operator|.
name|getTarget
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Thrown when a mapping is expected to return one element but returns    * several.    */
specifier|public
specifier|static
class|class
name|TooManyElementsException
extends|extends
name|RuntimeException
block|{   }
comment|/**    * Thrown when a mapping is expected to return one element but returns none.    */
specifier|public
specifier|static
class|class
name|NoElementException
extends|extends
name|RuntimeException
block|{
comment|/**      * Creates a NoElementException.      *      * @param message Message      */
specifier|public
name|NoElementException
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A mapping where a source has at most one target, and every target has at    * most one source.    */
specifier|public
specifier|static
class|class
name|PartialMapping
extends|extends
name|FiniteAbstractMapping
implements|implements
name|Mapping
implements|,
name|FunctionMapping
implements|,
name|TargetMapping
block|{
specifier|protected
specifier|final
name|int
index|[]
name|sources
decl_stmt|;
specifier|protected
specifier|final
name|int
index|[]
name|targets
decl_stmt|;
specifier|private
specifier|final
name|MappingType
name|mappingType
decl_stmt|;
comment|/**      * Creates a partial mapping.      *      *<p>Initially, no element is mapped to any other:      *      *<table border="1">      *<caption>Example</caption>      *<tr>      *<th>source</th>      *<td>0</td>      *<td>1</td>      *<td>2</td>      *</tr>      *<tr>      *<th>target</th>      *<td>-1</td>      *<td>-1</td>      *<td>-1</td>      *</tr>      *</table>      *      *<table border="1">      *<caption>Example</caption>      *<tr>      *<th>target</th>      *<td>0</td>      *<td>1</td>      *<td>2</td>      *<td>3</td>      *</tr>      *<tr>      *<th>source</th>      *<td>-1</td>      *<td>-1</td>      *<td>-1</td>      *<td>-1</td>      *</tr>      *</table>      *      * @param sourceCount Number of source elements      * @param targetCount Number of target elements      * @param mappingType Mapping type; must not allow multiple sources per      *                    target or multiple targets per source      */
specifier|public
name|PartialMapping
parameter_list|(
name|int
name|sourceCount
parameter_list|,
name|int
name|targetCount
parameter_list|,
name|MappingType
name|mappingType
parameter_list|)
block|{
name|this
operator|.
name|mappingType
operator|=
name|mappingType
expr_stmt|;
assert|assert
name|mappingType
operator|.
name|isSingleSource
argument_list|()
operator|:
name|mappingType
assert|;
assert|assert
name|mappingType
operator|.
name|isSingleTarget
argument_list|()
operator|:
name|mappingType
assert|;
name|this
operator|.
name|sources
operator|=
operator|new
name|int
index|[
name|targetCount
index|]
expr_stmt|;
name|this
operator|.
name|targets
operator|=
operator|new
name|int
index|[
name|sourceCount
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|sources
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|targets
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a partial mapping from a list. For example,<code>      * PartialMapping({1, 2, 4}, 6)</code> creates the mapping      *      *<table border="1">      *<caption>Example</caption>      *<tr>      *<th>source</th>      *<td>0</td>      *<td>1</td>      *<td>2</td>      *<td>3</td>      *<td>4</td>      *<td>5</td>      *</tr>      *<tr>      *<th>target</th>      *<td>-1</td>      *<td>0</td>      *<td>1</td>      *<td>-1</td>      *<td>2</td>      *<td>-1</td>      *</tr>      *</table>      *      * @param sourceList  List whose i'th element is the source of target #i      * @param sourceCount Number of elements in the source domain      * @param mappingType Mapping type, must be      *   {@link org.apache.calcite.util.mapping.MappingType#PARTIAL_SURJECTION}      *   or stronger.      */
specifier|public
name|PartialMapping
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|sourceList
parameter_list|,
name|int
name|sourceCount
parameter_list|,
name|MappingType
name|mappingType
parameter_list|)
block|{
name|this
operator|.
name|mappingType
operator|=
name|mappingType
expr_stmt|;
assert|assert
name|mappingType
operator|.
name|isSingleSource
argument_list|()
assert|;
assert|assert
name|mappingType
operator|.
name|isSingleTarget
argument_list|()
assert|;
name|int
name|targetCount
init|=
name|sourceList
operator|.
name|size
argument_list|()
decl_stmt|;
name|this
operator|.
name|targets
operator|=
operator|new
name|int
index|[
name|sourceCount
index|]
expr_stmt|;
name|this
operator|.
name|sources
operator|=
operator|new
name|int
index|[
name|targetCount
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|sources
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sourceList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|source
init|=
name|sourceList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|sources
index|[
name|i
index|]
operator|=
name|source
expr_stmt|;
if|if
condition|(
name|source
operator|>=
literal|0
condition|)
block|{
name|targets
index|[
name|source
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|!
name|this
operator|.
name|mappingType
operator|.
name|isMandatorySource
argument_list|()
assert|;
block|}
block|}
block|}
specifier|private
name|PartialMapping
parameter_list|(
name|int
index|[]
name|sources
parameter_list|,
name|int
index|[]
name|targets
parameter_list|,
name|MappingType
name|mappingType
parameter_list|)
block|{
name|this
operator|.
name|sources
operator|=
name|sources
expr_stmt|;
name|this
operator|.
name|targets
operator|=
name|targets
expr_stmt|;
name|this
operator|.
name|mappingType
operator|=
name|mappingType
expr_stmt|;
block|}
specifier|public
name|MappingType
name|getMappingType
parameter_list|()
block|{
return|return
name|mappingType
return|;
block|}
specifier|public
name|int
name|getSourceCount
parameter_list|()
block|{
return|return
name|targets
operator|.
name|length
return|;
block|}
specifier|public
name|int
name|getTargetCount
parameter_list|()
block|{
return|return
name|sources
operator|.
name|length
return|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|sources
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|targets
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
name|int
index|[]
name|a
init|=
name|sources
operator|.
name|length
operator|<
name|targets
operator|.
name|length
condition|?
name|sources
else|:
name|targets
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|a
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
operator|++
name|size
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
specifier|public
name|Mapping
name|inverse
parameter_list|()
block|{
return|return
operator|new
name|PartialMapping
argument_list|(
name|targets
operator|.
name|clone
argument_list|()
argument_list|,
name|sources
operator|.
name|clone
argument_list|()
argument_list|,
name|mappingType
operator|.
name|inverse
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|MappingItr
argument_list|()
return|;
block|}
specifier|protected
name|boolean
name|isValid
parameter_list|()
block|{
name|assertPartialValid
argument_list|(
name|this
operator|.
name|sources
argument_list|,
name|this
operator|.
name|targets
argument_list|)
expr_stmt|;
name|assertPartialValid
argument_list|(
name|this
operator|.
name|targets
argument_list|,
name|this
operator|.
name|sources
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|void
name|assertPartialValid
parameter_list|(
name|int
index|[]
name|sources
parameter_list|,
name|int
index|[]
name|targets
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sources
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|source
init|=
name|sources
index|[
name|i
index|]
decl_stmt|;
assert|assert
name|source
operator|>=
operator|-
literal|1
assert|;
assert|assert
name|source
operator|<
name|targets
operator|.
name|length
assert|;
assert|assert
operator|(
name|source
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|targets
index|[
name|source
index|]
operator|==
name|i
operator|)
assert|;
block|}
block|}
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
assert|assert
name|isValid
argument_list|()
assert|;
specifier|final
name|int
name|prevTarget
init|=
name|targets
index|[
name|source
index|]
decl_stmt|;
name|targets
index|[
name|source
index|]
operator|=
name|target
expr_stmt|;
specifier|final
name|int
name|prevSource
init|=
name|sources
index|[
name|target
index|]
decl_stmt|;
name|sources
index|[
name|target
index|]
operator|=
name|source
expr_stmt|;
if|if
condition|(
name|prevTarget
operator|!=
operator|-
literal|1
condition|)
block|{
name|sources
index|[
name|prevTarget
index|]
operator|=
name|prevSource
expr_stmt|;
block|}
if|if
condition|(
name|prevSource
operator|!=
operator|-
literal|1
condition|)
block|{
name|targets
index|[
name|prevSource
index|]
operator|=
name|prevTarget
expr_stmt|;
block|}
assert|assert
name|isValid
argument_list|()
assert|;
block|}
specifier|public
name|int
name|getSourceOpt
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|sources
index|[
name|target
index|]
return|;
block|}
specifier|public
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
block|{
return|return
name|targets
index|[
name|source
index|]
return|;
block|}
specifier|public
name|boolean
name|isIdentity
parameter_list|()
block|{
if|if
condition|(
name|sources
operator|.
name|length
operator|!=
name|targets
operator|.
name|length
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sources
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|source
init|=
name|sources
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|source
operator|!=
name|i
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** Mapping iterator. */
specifier|private
class|class
name|MappingItr
implements|implements
name|Iterator
argument_list|<
name|IntPair
argument_list|>
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|MappingItr
parameter_list|()
block|{
name|advance
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|i
operator|<
name|targets
operator|.
name|length
return|;
block|}
specifier|private
name|void
name|advance
parameter_list|()
block|{
do|do
block|{
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|targets
operator|.
name|length
operator|&&
name|targets
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
do|;
block|}
specifier|public
name|IntPair
name|next
parameter_list|()
block|{
specifier|final
name|IntPair
name|pair
init|=
operator|new
name|IntPair
argument_list|(
name|i
argument_list|,
name|targets
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|pair
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
block|}
comment|/**    * A surjection with inverse has precisely one source for each target.    * (Whereas a general surjection has at least one source for each target.)    * Every source has at most one target.    *    *<p>If you call {@link #set} on a target, the target's previous source    * will be lost.    */
specifier|static
class|class
name|SurjectionWithInverse
extends|extends
name|PartialMapping
block|{
name|SurjectionWithInverse
parameter_list|(
name|int
name|sourceCount
parameter_list|,
name|int
name|targetCount
parameter_list|)
block|{
name|super
argument_list|(
name|sourceCount
argument_list|,
name|targetCount
argument_list|,
name|MappingType
operator|.
name|INVERSE_SURJECTION
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a mapping between a source and a target.      *      *<p>It is an error to map a target to a source which already has a      * target.      *      *<p>If you map a source to a target which already has a source, the      * old source becomes an orphan.      *      * @param source source      * @param target target      */
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
assert|assert
name|isValid
argument_list|()
assert|;
specifier|final
name|int
name|prevTarget
init|=
name|targets
index|[
name|source
index|]
decl_stmt|;
if|if
condition|(
name|prevTarget
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"source #"
operator|+
name|source
operator|+
literal|" is already mapped to target #"
operator|+
name|target
argument_list|)
throw|;
block|}
name|targets
index|[
name|source
index|]
operator|=
name|target
expr_stmt|;
name|sources
index|[
name|target
index|]
operator|=
name|source
expr_stmt|;
block|}
specifier|public
name|int
name|getSource
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|sources
index|[
name|target
index|]
return|;
block|}
block|}
comment|/** The identity mapping, of a given size, or infinite. */
specifier|public
specifier|static
class|class
name|IdentityMapping
extends|extends
name|AbstractMapping
implements|implements
name|FunctionMapping
implements|,
name|TargetMapping
implements|,
name|SourceMapping
block|{
specifier|private
specifier|final
name|int
name|size
decl_stmt|;
comment|/**      * Creates an identity mapping.      *      * @param size Size, or -1 if infinite.      */
specifier|public
name|IdentityMapping
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Mapping is read-only"
argument_list|)
throw|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
specifier|public
name|Mapping
name|inverse
parameter_list|()
block|{
return|return
name|this
return|;
block|}
specifier|public
name|boolean
name|isIdentity
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|MappingType
name|getMappingType
parameter_list|()
block|{
return|return
name|MappingType
operator|.
name|BIJECTION
return|;
block|}
specifier|public
name|int
name|getSourceCount
parameter_list|()
block|{
return|return
name|size
return|;
block|}
specifier|public
name|int
name|getTargetCount
parameter_list|()
block|{
return|return
name|size
return|;
block|}
specifier|public
name|int
name|getTarget
parameter_list|(
name|int
name|source
parameter_list|)
block|{
return|return
name|source
return|;
block|}
specifier|public
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
block|{
return|return
name|source
return|;
block|}
specifier|public
name|int
name|getSource
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|target
return|;
block|}
specifier|public
name|int
name|getSourceOpt
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|target
return|;
block|}
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|IntPair
argument_list|>
argument_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|(
name|size
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|<
name|size
operator|)
return|;
block|}
specifier|public
name|IntPair
name|next
parameter_list|()
block|{
name|int
name|x
init|=
name|i
operator|++
decl_stmt|;
return|return
operator|new
name|IntPair
argument_list|(
name|x
argument_list|,
name|x
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
block|}
comment|/** Source mapping that returns the same result as a parent    * {@link SourceMapping} except for specific overriding elements. */
specifier|public
specifier|static
class|class
name|OverridingSourceMapping
extends|extends
name|AbstractMapping
implements|implements
name|SourceMapping
block|{
specifier|private
specifier|final
name|SourceMapping
name|parent
decl_stmt|;
specifier|private
specifier|final
name|int
name|source
decl_stmt|;
specifier|private
specifier|final
name|int
name|target
decl_stmt|;
specifier|public
name|OverridingSourceMapping
parameter_list|(
name|SourceMapping
name|parent
parameter_list|,
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Mapping is read-only"
argument_list|)
throw|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|parent
operator|.
name|getSourceOpt
argument_list|(
name|target
argument_list|)
operator|>=
literal|0
condition|?
name|parent
operator|.
name|size
argument_list|()
else|:
name|parent
operator|.
name|size
argument_list|()
operator|+
literal|1
return|;
block|}
specifier|public
name|Mapping
name|inverse
parameter_list|()
block|{
return|return
operator|new
name|OverridingTargetMapping
argument_list|(
operator|(
name|TargetMapping
operator|)
name|parent
operator|.
name|inverse
argument_list|()
argument_list|,
name|target
argument_list|,
name|source
argument_list|)
return|;
block|}
specifier|public
name|MappingType
name|getMappingType
parameter_list|()
block|{
comment|// FIXME: Mapping type might be weaker than parent.
return|return
name|parent
operator|.
name|getMappingType
argument_list|()
return|;
block|}
specifier|public
name|int
name|getSource
parameter_list|(
name|int
name|target
parameter_list|)
block|{
if|if
condition|(
name|target
operator|==
name|this
operator|.
name|target
condition|)
block|{
return|return
name|this
operator|.
name|source
return|;
block|}
else|else
block|{
return|return
name|parent
operator|.
name|getSource
argument_list|(
name|target
argument_list|)
return|;
block|}
block|}
specifier|public
name|boolean
name|isIdentity
parameter_list|()
block|{
comment|// FIXME: It's possible that parent was not the identity but that
comment|// this overriding fixed it.
return|return
operator|(
name|source
operator|==
name|target
operator|)
operator|&&
name|parent
operator|.
name|isIdentity
argument_list|()
return|;
block|}
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|this
argument_list|)
throw|;
block|}
block|}
comment|/** Target mapping that returns the same result as a parent    * {@link TargetMapping} except for specific overriding elements. */
specifier|public
specifier|static
class|class
name|OverridingTargetMapping
extends|extends
name|AbstractMapping
implements|implements
name|TargetMapping
block|{
specifier|private
specifier|final
name|TargetMapping
name|parent
decl_stmt|;
specifier|private
specifier|final
name|int
name|target
decl_stmt|;
specifier|private
specifier|final
name|int
name|source
decl_stmt|;
specifier|public
name|OverridingTargetMapping
parameter_list|(
name|TargetMapping
name|parent
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|source
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Mapping is read-only"
argument_list|)
throw|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|parent
operator|.
name|getTargetOpt
argument_list|(
name|source
argument_list|)
operator|>=
literal|0
condition|?
name|parent
operator|.
name|size
argument_list|()
else|:
name|parent
operator|.
name|size
argument_list|()
operator|+
literal|1
return|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|parent
operator|.
name|set
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Mapping
name|inverse
parameter_list|()
block|{
return|return
operator|new
name|OverridingSourceMapping
argument_list|(
name|parent
operator|.
name|inverse
argument_list|()
argument_list|,
name|source
argument_list|,
name|target
argument_list|)
return|;
block|}
specifier|public
name|MappingType
name|getMappingType
parameter_list|()
block|{
comment|// FIXME: Mapping type might be weaker than parent.
return|return
name|parent
operator|.
name|getMappingType
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isIdentity
parameter_list|()
block|{
comment|// FIXME: Possible that parent is not identity but this overriding
comment|// fixes it.
return|return
operator|(
name|source
operator|==
name|target
operator|)
operator|&&
operator|(
operator|(
name|Mapping
operator|)
name|parent
operator|)
operator|.
name|isIdentity
argument_list|()
return|;
block|}
specifier|public
name|int
name|getTarget
parameter_list|(
name|int
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|==
name|this
operator|.
name|source
condition|)
block|{
return|return
name|this
operator|.
name|target
return|;
block|}
else|else
block|{
return|return
name|parent
operator|.
name|getTarget
argument_list|(
name|source
argument_list|)
return|;
block|}
block|}
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|this
argument_list|)
throw|;
block|}
block|}
comment|/**    * Implementation of {@link Mapping} where a source can have at most one    * target, and a target can have any number of sources. The source count    * must be finite, but the target count may be infinite.    *    *<p>The implementation uses an array for the forward-mapping, but does not    * store the backward mapping.    */
specifier|private
specifier|static
class|class
name|PartialFunctionImpl
extends|extends
name|AbstractMapping
implements|implements
name|TargetMapping
block|{
specifier|private
specifier|final
name|int
name|sourceCount
decl_stmt|;
specifier|private
specifier|final
name|int
name|targetCount
decl_stmt|;
specifier|private
specifier|final
name|MappingType
name|mappingType
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|targets
decl_stmt|;
specifier|public
name|PartialFunctionImpl
parameter_list|(
name|int
name|sourceCount
parameter_list|,
name|int
name|targetCount
parameter_list|,
name|MappingType
name|mappingType
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
if|if
condition|(
name|sourceCount
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Sources must be finite"
argument_list|)
throw|;
block|}
name|this
operator|.
name|sourceCount
operator|=
name|sourceCount
expr_stmt|;
name|this
operator|.
name|targetCount
operator|=
name|targetCount
expr_stmt|;
name|this
operator|.
name|mappingType
operator|=
name|mappingType
expr_stmt|;
if|if
condition|(
operator|!
name|mappingType
operator|.
name|isSingleTarget
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must have at most one target"
argument_list|)
throw|;
block|}
name|this
operator|.
name|targets
operator|=
operator|new
name|int
index|[
name|sourceCount
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|targets
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|getSourceCount
parameter_list|()
block|{
return|return
name|sourceCount
return|;
block|}
specifier|public
name|int
name|getTargetCount
parameter_list|()
block|{
return|return
name|targetCount
return|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|targets
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|targets
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
operator|++
name|size
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|IntPair
argument_list|>
argument_list|()
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
block|{
name|advance
parameter_list|()
constructor_decl|;
block|}
specifier|private
name|void
name|advance
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|sourceCount
condition|)
block|{
break|break;
comment|// end
block|}
if|if
condition|(
name|targets
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
break|break;
comment|// found one
block|}
block|}
block|}
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|i
operator|<
name|sourceCount
return|;
block|}
specifier|public
name|IntPair
name|next
parameter_list|()
block|{
specifier|final
name|IntPair
name|pair
init|=
operator|new
name|IntPair
argument_list|(
name|i
argument_list|,
name|targets
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|pair
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
specifier|public
name|MappingType
name|getMappingType
parameter_list|()
block|{
return|return
name|mappingType
return|;
block|}
specifier|public
name|Mapping
name|inverse
parameter_list|()
block|{
return|return
name|target
argument_list|(
name|invert
argument_list|(
name|this
argument_list|)
argument_list|,
name|targetCount
argument_list|,
name|sourceCount
argument_list|)
return|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
if|if
condition|(
operator|(
name|target
operator|<
literal|0
operator|)
operator|&&
name|mappingType
operator|.
name|isMandatorySource
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Target is required"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|target
operator|>=
name|targetCount
operator|)
operator|&&
operator|(
name|targetCount
operator|>=
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Target must be less than target count, "
operator|+
name|targetCount
argument_list|)
throw|;
block|}
name|targets
index|[
name|source
index|]
operator|=
name|target
expr_stmt|;
block|}
specifier|public
name|void
name|setAll
parameter_list|(
name|Mapping
name|mapping
parameter_list|)
block|{
for|for
control|(
name|IntPair
name|pair
range|:
name|mapping
control|)
block|{
name|set
argument_list|(
name|pair
operator|.
name|source
argument_list|,
name|pair
operator|.
name|target
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
block|{
return|return
name|targets
index|[
name|source
index|]
return|;
block|}
block|}
comment|/**    * Decorator which converts any {@link Mapping} into the inverse of itself.    *    *<p>If the mapping does not have an inverse -- for example, if a given    * source can have more than one target -- then the corresponding method    * call of the underlying mapping will raise a runtime exception.    */
specifier|private
specifier|static
class|class
name|InverseMapping
implements|implements
name|Mapping
block|{
specifier|private
specifier|final
name|Mapping
name|parent
decl_stmt|;
name|InverseMapping
parameter_list|(
name|Mapping
name|parent
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
block|}
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|parentIter
init|=
name|parent
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|IntPair
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|parentIter
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|IntPair
name|next
parameter_list|()
block|{
name|IntPair
name|parentPair
init|=
name|parentIter
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|new
name|IntPair
argument_list|(
name|parentPair
operator|.
name|target
argument_list|,
name|parentPair
operator|.
name|source
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|parentIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|parent
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|parent
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|int
name|getSourceCount
parameter_list|()
block|{
return|return
name|parent
operator|.
name|getTargetCount
argument_list|()
return|;
block|}
specifier|public
name|int
name|getTargetCount
parameter_list|()
block|{
return|return
name|parent
operator|.
name|getSourceCount
argument_list|()
return|;
block|}
specifier|public
name|MappingType
name|getMappingType
parameter_list|()
block|{
return|return
name|parent
operator|.
name|getMappingType
argument_list|()
operator|.
name|inverse
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isIdentity
parameter_list|()
block|{
return|return
name|parent
operator|.
name|isIdentity
argument_list|()
return|;
block|}
specifier|public
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
block|{
return|return
name|parent
operator|.
name|getSourceOpt
argument_list|(
name|source
argument_list|)
return|;
block|}
specifier|public
name|int
name|getTarget
parameter_list|(
name|int
name|source
parameter_list|)
block|{
return|return
name|parent
operator|.
name|getSource
argument_list|(
name|source
argument_list|)
return|;
block|}
specifier|public
name|int
name|getSource
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|parent
operator|.
name|getTarget
argument_list|(
name|target
argument_list|)
return|;
block|}
specifier|public
name|int
name|getSourceOpt
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|parent
operator|.
name|getTargetOpt
argument_list|(
name|target
argument_list|)
return|;
block|}
specifier|public
name|Mapping
name|inverse
parameter_list|()
block|{
return|return
name|parent
return|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|parent
operator|.
name|set
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End Mappings.java
end_comment

end_unit

