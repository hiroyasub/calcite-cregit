begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSortedMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSortedSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|TreeMultimap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_comment
comment|/** Set of elements organized into equivalence classes.  *  *<p>Elements are equivalent by the rules of a mathematical equivalence  * relation:  *  *<dl>  *<dt>Reflexive  *<dd>Every element {@code e} is equivalent to itself  *<dt>Symmetric  *<dd>If {@code e} is equivalent to {@code f},  *     then {@code f} is equivalent to {@code e}  *<dt>Transitive  *<dd>If {@code e} is equivalent to {@code f},  *     and {@code f} is equivalent to {@code g},  *     then {@code e} is equivalent to {@code g}  *</dl>  *  *<p>For any given pair of elements, answers in O(log N) (two hash-table  * lookups) whether they are equivalent to each other.  *  * @param<E> Element type  */
end_comment

begin_class
specifier|public
class|class
name|EquivalenceSet
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|<
name|E
parameter_list|>
parameter_list|>
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|E
argument_list|,
name|E
argument_list|>
name|parents
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Adds an element, and returns the element (which is its own parent).    * If already present, returns the element's parent. */
specifier|public
name|E
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
specifier|final
name|E
name|parent
init|=
name|parents
operator|.
name|get
argument_list|(
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|e
argument_list|,
literal|"e"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
comment|// Element is new. Add it to the map, as its own parent.
name|parents
operator|.
name|put
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
else|else
block|{
return|return
name|parent
return|;
block|}
block|}
comment|/** Marks two elements as equivalent.    * They may or may not be registered, and they may or may not be equal. */
specifier|public
name|E
name|equiv
parameter_list|(
name|E
name|e
parameter_list|,
name|E
name|f
parameter_list|)
block|{
specifier|final
name|E
name|eParent
init|=
name|add
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|eParent
operator|.
name|equals
argument_list|(
name|e
argument_list|)
condition|)
block|{
assert|assert
name|Objects
operator|.
name|equals
argument_list|(
name|parents
operator|.
name|get
argument_list|(
name|eParent
argument_list|)
argument_list|,
name|eParent
argument_list|)
assert|;
specifier|final
name|E
name|root
init|=
name|equiv
argument_list|(
name|eParent
argument_list|,
name|f
argument_list|)
decl_stmt|;
name|parents
operator|.
name|put
argument_list|(
name|e
argument_list|,
name|root
argument_list|)
expr_stmt|;
return|return
name|root
return|;
block|}
specifier|final
name|E
name|fParent
init|=
name|add
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fParent
operator|.
name|equals
argument_list|(
name|f
argument_list|)
condition|)
block|{
assert|assert
name|Objects
operator|.
name|equals
argument_list|(
name|parents
operator|.
name|get
argument_list|(
name|fParent
argument_list|)
argument_list|,
name|fParent
argument_list|)
assert|;
specifier|final
name|E
name|root
init|=
name|equiv
argument_list|(
name|e
argument_list|,
name|fParent
argument_list|)
decl_stmt|;
name|parents
operator|.
name|put
argument_list|(
name|f
argument_list|,
name|root
argument_list|)
expr_stmt|;
return|return
name|root
return|;
block|}
specifier|final
name|int
name|c
init|=
name|e
operator|.
name|compareTo
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
return|return
name|e
return|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
comment|// e is a better (lower) parent of f
name|parents
operator|.
name|put
argument_list|(
name|f
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
else|else
block|{
comment|// f is a better (lower) parent of e
name|parents
operator|.
name|put
argument_list|(
name|e
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
block|}
comment|/** Returns whether two elements are in the same equivalence class.    * Returns false if either or both of the elements are not registered. */
specifier|public
name|boolean
name|areEquivalent
parameter_list|(
name|E
name|e
parameter_list|,
name|E
name|f
parameter_list|)
block|{
specifier|final
name|E
name|eParent
init|=
name|parents
operator|.
name|get
argument_list|(
name|e
argument_list|)
decl_stmt|;
specifier|final
name|E
name|fParent
init|=
name|parents
operator|.
name|get
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|eParent
argument_list|,
name|fParent
argument_list|)
return|;
block|}
comment|/** Returns a map of the canonical element in each equivalence class to the    * set of elements in that class. The keys are sorted in natural order, as    * are the elements within each key. */
specifier|public
name|NavigableMap
argument_list|<
name|E
argument_list|,
name|SortedSet
argument_list|<
name|E
argument_list|>
argument_list|>
name|map
parameter_list|()
block|{
specifier|final
name|TreeMultimap
argument_list|<
name|E
argument_list|,
name|E
argument_list|>
name|multimap
init|=
name|TreeMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|E
argument_list|,
name|E
argument_list|>
name|entry
range|:
name|parents
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|multimap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Create an immutable copy. Keys and values remain in sorted order.
specifier|final
name|ImmutableSortedMap
operator|.
name|Builder
argument_list|<
name|E
argument_list|,
name|SortedSet
argument_list|<
name|E
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableSortedMap
operator|.
name|naturalOrder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|E
argument_list|,
name|Collection
argument_list|<
name|E
argument_list|>
argument_list|>
name|entry
range|:
name|multimap
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|ImmutableSortedSet
operator|.
name|copyOf
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Removes all elements in this equivalence set. */
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|parents
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/** Returns the number of elements in this equivalence set. */
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|parents
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** Returns the number of equivalence classes in this equivalence set. */
specifier|public
name|int
name|classCount
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|parents
operator|.
name|values
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
block|}
end_class

end_unit

