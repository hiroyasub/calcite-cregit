begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to the Apache Software Foundation (ASF) under one or more // contributor license agreements.  See the NOTICE file distributed with // this work for additional information regarding copyright ownership. // The ASF licenses this file to you under the Apache License, Version 2.0 // (the "License"); you may not use this file except in compliance with // the License.  You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|sql2rel
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|metadata
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|parser
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|validate
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|trace
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util14
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function1
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|ModifiableTable
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|TranslatableTable
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|prepare
operator|.
name|Prepare
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|prepare
operator|.
name|RelOptTableImpl
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|util
operator|.
name|BitSets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlUtil
operator|.
name|stripAs
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Static
operator|.
name|RESOURCE
import|;
end_import

begin_comment
comment|/**  * Converts a SQL parse tree (consisting of {@link org.eigenbase.sql.SqlNode}  * objects) into a relational algebra expression (consisting of  * {@link org.eigenbase.rel.RelNode} objects).  *  *<p>The public entry points are: {@link #convertQuery},  * {@link #convertExpression(SqlNode)}.  */
end_comment

begin_class
specifier|public
class|class
name|SqlToRelConverter
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|protected
specifier|static
specifier|final
name|Logger
name|SQL2REL_LOGGER
init|=
name|EigenbaseTrace
operator|.
name|getSqlToRelTracer
argument_list|()
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|protected
specifier|final
name|SqlValidator
name|validator
decl_stmt|;
specifier|protected
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|protected
specifier|final
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
decl_stmt|;
specifier|protected
specifier|final
name|RelOptCluster
name|cluster
decl_stmt|;
specifier|private
name|DefaultValueFactory
name|defaultValueFactory
decl_stmt|;
specifier|private
name|SubqueryConverter
name|subqueryConverter
decl_stmt|;
specifier|protected
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|leaves
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|SqlDynamicParam
argument_list|>
name|dynamicParamSqlNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|SqlDynamicParam
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|SqlOperatorTable
name|opTab
decl_stmt|;
specifier|private
name|boolean
name|shouldConvertTableAccess
decl_stmt|;
specifier|protected
specifier|final
name|RelDataTypeFactory
name|typeFactory
decl_stmt|;
specifier|private
specifier|final
name|SqlNodeToRexConverter
name|exprConverter
decl_stmt|;
specifier|private
name|boolean
name|decorrelationEnabled
decl_stmt|;
specifier|private
name|boolean
name|trimUnusedFields
decl_stmt|;
specifier|private
name|boolean
name|shouldCreateValuesRel
decl_stmt|;
specifier|private
name|boolean
name|isExplain
decl_stmt|;
specifier|private
name|int
name|nDynamicParamsInExplain
decl_stmt|;
comment|/**    * Fields used in name resolution for correlated subqueries.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|DeferredLookup
argument_list|>
name|mapCorrelToDeferred
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|DeferredLookup
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|int
name|nextCorrel
init|=
literal|0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CORREL_PREFIX
init|=
literal|"$cor"
decl_stmt|;
comment|/**    * Fields used in decorrelation.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|mapCorrelToRefRel
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|CorrelatorRel
argument_list|>
name|mapCorVarToCorRel
init|=
operator|new
name|TreeMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|CorrelatorRel
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|SortedSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
argument_list|>
name|mapRefRelToCorVar
init|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|SortedSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|RexFieldAccess
argument_list|,
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
name|mapFieldAccessToCorVar
init|=
operator|new
name|HashMap
argument_list|<
name|RexFieldAccess
argument_list|,
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Stack of names of datasets requested by the<code>    * TABLE(SAMPLE(&lt;datasetName&gt;,&lt;query&gt;))</code> construct.    */
specifier|private
specifier|final
name|Stack
argument_list|<
name|String
argument_list|>
name|datasetStack
init|=
operator|new
name|Stack
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Mapping of non-correlated subqueries that have been converted to their    * equivalent constants. Used to avoid re-evaluating the subquery if it's    * already been evaluated.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|RexNode
argument_list|>
name|mapConvertedNonCorrSubqs
init|=
operator|new
name|HashMap
argument_list|<
name|SqlNode
argument_list|,
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
specifier|final
name|RelOptTable
operator|.
name|ViewExpander
name|viewExpander
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a converter.    *    * @param viewExpander    Preparing statement    * @param validator       Validator    * @param catalogReader   Schema    * @param planner         Planner    * @param rexBuilder      Rex builder    * @param convertletTable Expression converter    */
specifier|public
name|SqlToRelConverter
parameter_list|(
name|RelOptTable
operator|.
name|ViewExpander
name|viewExpander
parameter_list|,
name|SqlValidator
name|validator
parameter_list|,
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
parameter_list|,
name|RelOptPlanner
name|planner
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|SqlRexConvertletTable
name|convertletTable
parameter_list|)
block|{
name|this
operator|.
name|viewExpander
operator|=
name|viewExpander
expr_stmt|;
name|this
operator|.
name|opTab
operator|=
operator|(
name|validator
operator|==
literal|null
operator|)
condition|?
name|SqlStdOperatorTable
operator|.
name|instance
argument_list|()
else|:
name|validator
operator|.
name|getOperatorTable
argument_list|()
expr_stmt|;
name|this
operator|.
name|validator
operator|=
name|validator
expr_stmt|;
name|this
operator|.
name|catalogReader
operator|=
name|catalogReader
expr_stmt|;
name|this
operator|.
name|defaultValueFactory
operator|=
operator|new
name|NullDefaultValueFactory
argument_list|()
expr_stmt|;
name|this
operator|.
name|subqueryConverter
operator|=
operator|new
name|NoOpSubqueryConverter
argument_list|()
expr_stmt|;
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
name|this
operator|.
name|typeFactory
operator|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
expr_stmt|;
name|RelOptQuery
name|query
init|=
operator|new
name|RelOptQuery
argument_list|(
name|planner
argument_list|)
decl_stmt|;
name|this
operator|.
name|cluster
operator|=
name|query
operator|.
name|createCluster
argument_list|(
name|typeFactory
argument_list|,
name|rexBuilder
argument_list|)
expr_stmt|;
name|this
operator|.
name|shouldConvertTableAccess
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|exprConverter
operator|=
operator|new
name|SqlNodeToRexConverterImpl
argument_list|(
name|convertletTable
argument_list|)
expr_stmt|;
name|decorrelationEnabled
operator|=
literal|true
expr_stmt|;
name|trimUnusedFields
operator|=
literal|false
expr_stmt|;
name|shouldCreateValuesRel
operator|=
literal|true
expr_stmt|;
name|isExplain
operator|=
literal|false
expr_stmt|;
name|nDynamicParamsInExplain
operator|=
literal|0
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * @return the RelOptCluster in use.    */
specifier|public
name|RelOptCluster
name|getCluster
parameter_list|()
block|{
return|return
name|cluster
return|;
block|}
comment|/**    * Returns the row-expression builder.    */
specifier|public
name|RexBuilder
name|getRexBuilder
parameter_list|()
block|{
return|return
name|rexBuilder
return|;
block|}
comment|/**    * Returns the number of dynamic parameters encountered during translation;    * this must only be called after {@link #convertQuery}.    *    * @return number of dynamic parameters    */
specifier|public
name|int
name|getDynamicParamCount
parameter_list|()
block|{
return|return
name|dynamicParamSqlNodes
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Returns the type inferred for a dynamic parameter.    *    * @param index 0-based index of dynamic parameter    * @return inferred type, never null    */
specifier|public
name|RelDataType
name|getDynamicParamType
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|SqlNode
name|sqlNode
init|=
name|dynamicParamSqlNodes
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|sqlNode
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|"dynamic param type inference"
argument_list|)
throw|;
block|}
return|return
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|sqlNode
argument_list|)
return|;
block|}
comment|/**    * Returns the current count of the number of dynamic parameters in an    * EXPLAIN PLAN statement.    *    * @param increment if true, increment the count    * @return the current count before the optional increment    */
specifier|public
name|int
name|getDynamicParamCountInExplain
parameter_list|(
name|boolean
name|increment
parameter_list|)
block|{
name|int
name|retVal
init|=
name|nDynamicParamsInExplain
decl_stmt|;
if|if
condition|(
name|increment
condition|)
block|{
operator|++
name|nDynamicParamsInExplain
expr_stmt|;
block|}
return|return
name|retVal
return|;
block|}
comment|/**    * @return mapping of non-correlated subqueries that have been converted to    * the constants that they evaluate to    */
specifier|public
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|RexNode
argument_list|>
name|getMapConvertedNonCorrSubqs
parameter_list|()
block|{
return|return
name|mapConvertedNonCorrSubqs
return|;
block|}
comment|/**    * Adds to the current map of non-correlated converted subqueries the    * elements from another map that contains non-correlated subqueries that    * have been converted by another SqlToRelConverter.    *    * @param alreadyConvertedNonCorrSubqs the other map    */
specifier|public
name|void
name|addConvertedNonCorrSubqs
parameter_list|(
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|RexNode
argument_list|>
name|alreadyConvertedNonCorrSubqs
parameter_list|)
block|{
name|mapConvertedNonCorrSubqs
operator|.
name|putAll
argument_list|(
name|alreadyConvertedNonCorrSubqs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set a new DefaultValueFactory. To have any effect, this must be called    * before any convert method.    *    * @param factory new DefaultValueFactory    */
specifier|public
name|void
name|setDefaultValueFactory
parameter_list|(
name|DefaultValueFactory
name|factory
parameter_list|)
block|{
name|defaultValueFactory
operator|=
name|factory
expr_stmt|;
block|}
comment|/**    * Sets a new SubqueryConverter. To have any effect, this must be called    * before any convert method.    *    * @param converter new SubqueryConverter    */
specifier|public
name|void
name|setSubqueryConverter
parameter_list|(
name|SubqueryConverter
name|converter
parameter_list|)
block|{
name|subqueryConverter
operator|=
name|converter
expr_stmt|;
block|}
comment|/**    * Indicates that the current statement is part of an EXPLAIN PLAN statement    *    * @param nDynamicParams number of dynamic parameters in the statement    */
specifier|public
name|void
name|setIsExplain
parameter_list|(
name|int
name|nDynamicParams
parameter_list|)
block|{
name|isExplain
operator|=
literal|true
expr_stmt|;
name|nDynamicParamsInExplain
operator|=
name|nDynamicParams
expr_stmt|;
block|}
comment|/**    * Controls whether table access references are converted to physical rels    * immediately. The optimizer doesn't like leaf rels to have    * {@link Convention#NONE}. However, if we are doing further conversion    * passes (e.g. {@link RelStructuredTypeFlattener}), then we may need to    * defer conversion. To have any effect, this must be called before any    * convert method.    *    * @param enabled true for immediate conversion (the default); false to    *                generate logical TableAccessRel instances    */
specifier|public
name|void
name|enableTableAccessConversion
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|shouldConvertTableAccess
operator|=
name|enabled
expr_stmt|;
block|}
comment|/**    * Controls whether instances of {@link ValuesRel} are generated. These may    * not be supported by all physical implementations. To have any effect,    * this must be called before any convert method.    *    * @param enabled true to allow ValuesRel to be generated (the default);    *                false to force substitution of ProjectRel+OneRowRel instead    */
specifier|public
name|void
name|enableValuesRelCreation
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|shouldCreateValuesRel
operator|=
name|enabled
expr_stmt|;
block|}
specifier|private
name|void
name|checkConvertedType
parameter_list|(
name|SqlNode
name|query
parameter_list|,
name|RelNode
name|result
parameter_list|)
block|{
if|if
condition|(
operator|!
name|query
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|DML
argument_list|)
condition|)
block|{
comment|// Verify that conversion from SQL to relational algebra did
comment|// not perturb any type information.  (We can't do this if the
comment|// SQL statement is something like an INSERT which has no
comment|// validator type information associated with its result,
comment|// hence the namespace check above.)
name|RelDataType
name|convertedRowType
init|=
name|result
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|checkConvertedRowType
argument_list|(
name|query
argument_list|,
name|convertedRowType
argument_list|)
condition|)
block|{
name|RelDataType
name|validatedRowType
init|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|validatedRowType
operator|=
name|uniquifyFields
argument_list|(
name|validatedRowType
argument_list|)
expr_stmt|;
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Conversion to relational algebra failed to preserve "
operator|+
literal|"datatypes:\n"
operator|+
literal|"validated type:\n"
operator|+
name|validatedRowType
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\nconverted type:\n"
operator|+
name|convertedRowType
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\nrel:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|result
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
name|RelNode
name|flattenTypes
parameter_list|(
name|RelNode
name|rootRel
parameter_list|,
name|boolean
name|restructure
parameter_list|)
block|{
name|RelStructuredTypeFlattener
name|typeFlattener
init|=
operator|new
name|RelStructuredTypeFlattener
argument_list|(
name|rexBuilder
argument_list|,
name|createToRelContext
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|newRootRel
init|=
name|typeFlattener
operator|.
name|rewrite
argument_list|(
name|rootRel
argument_list|,
name|restructure
argument_list|)
decl_stmt|;
comment|// There are three maps constructed during convertQuery which need to to
comment|// be maintained for use in decorrelation. 1. mapRefRelToCorVar: - map a
comment|// rel node to the coorrelated variables it references 2.
comment|// mapCorVarToCorRel: - map a correlated variable to the correlatorRel
comment|// providing it 3. mapFieldAccessToCorVar: - map a rex field access to
comment|// the cor var it represents. because typeFlattener does not clone or
comment|// modify a correlated field access this map does not need to be
comment|// updated.
name|typeFlattener
operator|.
name|updateRelInMap
argument_list|(
name|mapRefRelToCorVar
argument_list|)
expr_stmt|;
name|typeFlattener
operator|.
name|updateRelInMap
argument_list|(
name|mapCorVarToCorRel
argument_list|)
expr_stmt|;
return|return
name|newRootRel
return|;
block|}
comment|/**    * If subquery is correlated and decorrelation is enabled, performs    * decorrelation.    *    * @param query   Query    * @param rootRel Root relational expression    * @return New root relational expression after decorrelation    */
specifier|public
name|RelNode
name|decorrelate
parameter_list|(
name|SqlNode
name|query
parameter_list|,
name|RelNode
name|rootRel
parameter_list|)
block|{
name|RelNode
name|result
init|=
name|rootRel
decl_stmt|;
if|if
condition|(
name|enableDecorrelation
argument_list|()
operator|&&
name|hasCorrelation
argument_list|()
condition|)
block|{
name|result
operator|=
name|decorrelateQuery
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|checkConvertedType
argument_list|(
name|query
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Walks over a tree of relational expressions, replacing each    * {@link RelNode} with a 'slimmed down' relational expression that projects    * only the fields required by its consumer.    *    *<p>This may make things easier for the optimizer, by removing crud that    * would expand the search space, but is difficult for the optimizer itself    * to do it, because optimizer rules must preserve the number and type of    * fields. Hence, this transform that operates on the entire tree, similar    * to the {@link RelStructuredTypeFlattener type-flattening transform}.    *    *<p>Currently this functionality is disabled in farrago/luciddb; the    * default implementation of this method does nothing.    *    * @param rootRel Relational expression that is at the root of the tree    * @return Trimmed relational expression    */
specifier|public
name|RelNode
name|trimUnusedFields
parameter_list|(
name|RelNode
name|rootRel
parameter_list|)
block|{
comment|// Trim fields that are not used by their consumer.
if|if
condition|(
name|isTrimUnusedFields
argument_list|()
condition|)
block|{
specifier|final
name|RelFieldTrimmer
name|trimmer
init|=
name|newFieldTrimmer
argument_list|()
decl_stmt|;
name|rootRel
operator|=
name|trimmer
operator|.
name|trim
argument_list|(
name|rootRel
argument_list|)
expr_stmt|;
name|boolean
name|dumpPlan
init|=
name|SQL2REL_LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
decl_stmt|;
if|if
condition|(
name|dumpPlan
condition|)
block|{
name|SQL2REL_LOGGER
operator|.
name|fine
argument_list|(
name|RelOptUtil
operator|.
name|dumpPlan
argument_list|(
literal|"Plan after trimming unused fields"
argument_list|,
name|rootRel
argument_list|,
literal|false
argument_list|,
name|SqlExplainLevel
operator|.
name|EXPPLAN_ATTRIBUTES
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rootRel
return|;
block|}
comment|/**    * Creates a RelFieldTrimmer.    *    * @return Field trimmer    */
specifier|protected
name|RelFieldTrimmer
name|newFieldTrimmer
parameter_list|()
block|{
return|return
operator|new
name|RelFieldTrimmer
argument_list|(
name|validator
argument_list|)
return|;
block|}
comment|/**    * Converts an unvalidated query's parse tree into a relational expression.    *    * @param query           Query to convert    * @param needsValidation Whether to validate the query before converting;    *<code>false</code> if the query has already been    *                        validated.    * @param top             Whether the query is top-level, say if its result    *                        will become a JDBC result set;<code>false</code> if    *                        the query will be part of a view.    */
specifier|public
name|RelNode
name|convertQuery
parameter_list|(
name|SqlNode
name|query
parameter_list|,
specifier|final
name|boolean
name|needsValidation
parameter_list|,
specifier|final
name|boolean
name|top
parameter_list|)
block|{
if|if
condition|(
name|needsValidation
condition|)
block|{
name|query
operator|=
name|validator
operator|.
name|validate
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|result
init|=
name|convertQueryRecursive
argument_list|(
name|query
argument_list|,
name|top
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|checkConvertedType
argument_list|(
name|query
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|boolean
name|dumpPlan
init|=
name|SQL2REL_LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
decl_stmt|;
if|if
condition|(
name|dumpPlan
condition|)
block|{
name|SQL2REL_LOGGER
operator|.
name|fine
argument_list|(
name|RelOptUtil
operator|.
name|dumpPlan
argument_list|(
literal|"Plan after converting SqlNode to RelNode"
argument_list|,
name|result
argument_list|,
literal|false
argument_list|,
name|SqlExplainLevel
operator|.
name|EXPPLAN_ATTRIBUTES
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|protected
name|boolean
name|checkConvertedRowType
parameter_list|(
name|SqlNode
name|query
parameter_list|,
name|RelDataType
name|convertedRowType
parameter_list|)
block|{
name|RelDataType
name|validatedRowType
init|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|validatedRowType
operator|=
name|uniquifyFields
argument_list|(
name|validatedRowType
argument_list|)
expr_stmt|;
return|return
name|RelOptUtil
operator|.
name|equal
argument_list|(
literal|"validated row type"
argument_list|,
name|validatedRowType
argument_list|,
literal|"converted row type"
argument_list|,
name|convertedRowType
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|protected
name|RelDataType
name|uniquifyFields
parameter_list|(
name|RelDataType
name|rowType
parameter_list|)
block|{
return|return
name|validator
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createStructType
argument_list|(
name|RelOptUtil
operator|.
name|getFieldTypeList
argument_list|(
name|rowType
argument_list|)
argument_list|,
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Converts a SELECT statement's parse tree into a relational expression.    */
specifier|public
name|RelNode
name|convertSelect
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
specifier|final
name|SqlValidatorScope
name|selectScope
init|=
name|validator
operator|.
name|getWhereScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
specifier|final
name|Blackboard
name|bb
init|=
name|createBlackboard
argument_list|(
name|selectScope
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|convertSelectImpl
argument_list|(
name|bb
argument_list|,
name|select
argument_list|)
expr_stmt|;
return|return
name|bb
operator|.
name|root
return|;
block|}
comment|/**    * Factory method for creating translation workspace.    */
specifier|protected
name|Blackboard
name|createBlackboard
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|nameToNodeMap
parameter_list|)
block|{
return|return
operator|new
name|Blackboard
argument_list|(
name|scope
argument_list|,
name|nameToNodeMap
argument_list|)
return|;
block|}
comment|/**    * Implementation of {@link #convertSelect(SqlSelect)}; derived class may    * override.    */
specifier|protected
name|void
name|convertSelectImpl
parameter_list|(
specifier|final
name|Blackboard
name|bb
parameter_list|,
name|SqlSelect
name|select
parameter_list|)
block|{
name|convertFrom
argument_list|(
name|bb
argument_list|,
name|select
operator|.
name|getFrom
argument_list|()
argument_list|)
expr_stmt|;
name|convertWhere
argument_list|(
name|bb
argument_list|,
name|select
operator|.
name|getWhere
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderExprList
init|=
operator|new
name|ArrayList
argument_list|<
name|SqlNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|collationList
init|=
operator|new
name|ArrayList
argument_list|<
name|RelFieldCollation
argument_list|>
argument_list|()
decl_stmt|;
name|gatherOrderExprs
argument_list|(
name|bb
argument_list|,
name|select
argument_list|,
name|select
operator|.
name|getOrderList
argument_list|()
argument_list|,
name|orderExprList
argument_list|,
name|collationList
argument_list|)
expr_stmt|;
specifier|final
name|RelCollation
name|collation
init|=
name|cluster
operator|.
name|traitSetOf
argument_list|()
operator|.
name|canonize
argument_list|(
name|RelCollationImpl
operator|.
name|of
argument_list|(
name|collationList
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|validator
operator|.
name|isAggregate
argument_list|(
name|select
argument_list|)
condition|)
block|{
name|convertAgg
argument_list|(
name|bb
argument_list|,
name|select
argument_list|,
name|orderExprList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|convertSelectList
argument_list|(
name|bb
argument_list|,
name|select
argument_list|,
name|orderExprList
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|select
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
name|distinctify
argument_list|(
name|bb
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|convertOrder
argument_list|(
name|select
argument_list|,
name|bb
argument_list|,
name|collation
argument_list|,
name|orderExprList
argument_list|,
name|select
operator|.
name|getOffset
argument_list|()
argument_list|,
name|select
operator|.
name|getFetch
argument_list|()
argument_list|)
expr_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|bb
operator|.
name|root
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Having translated 'SELECT ... FROM ... [GROUP BY ...] [HAVING ...]', adds    * a relational expression to make the results unique.    *    *<p>If the SELECT clause contains duplicate expressions, adds {@link    * ProjectRel}s so that we are grouping on the minimal set of keys. The    * performance gain isn't huge, but it is difficult to detect these    * duplicate expressions later.    *    * @param bb               Blackboard    * @param checkForDupExprs Check for duplicate expressions    */
specifier|private
name|void
name|distinctify
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|boolean
name|checkForDupExprs
parameter_list|)
block|{
comment|// Look for duplicate expressions in the project.
comment|// Say we have 'select x, y, x, z'.
comment|// Then dups will be {[2, 0]}
comment|// and oldToNew will be {[0, 0], [1, 1], [2, 0], [3, 2]}
name|RelNode
name|rel
init|=
name|bb
operator|.
name|root
decl_stmt|;
if|if
condition|(
name|checkForDupExprs
operator|&&
operator|(
name|rel
operator|instanceof
name|ProjectRel
operator|)
condition|)
block|{
name|ProjectRel
name|project
init|=
operator|(
name|ProjectRel
operator|)
name|rel
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|projectExprs
init|=
name|project
operator|.
name|getProjects
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|origins
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|dupCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projectExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
init|=
name|findExpr
argument_list|(
name|projectExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|projectExprs
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|>=
literal|0
condition|)
block|{
name|origins
operator|.
name|add
argument_list|(
name|x
argument_list|)
expr_stmt|;
operator|++
name|dupCount
expr_stmt|;
block|}
else|else
block|{
name|origins
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dupCount
operator|==
literal|0
condition|)
block|{
name|distinctify
argument_list|(
name|bb
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|squished
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|newProjects
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|origins
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
name|i
condition|)
block|{
name|squished
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|newProjects
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|newProjects
operator|.
name|add
argument_list|(
name|RexInputRef
operator|.
name|of2
argument_list|(
name|i
argument_list|,
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|rel
operator|=
operator|new
name|ProjectRel
argument_list|(
name|cluster
argument_list|,
name|rel
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|newProjects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|newProjects
argument_list|)
argument_list|,
name|ProjectRel
operator|.
name|Flags
operator|.
name|BOXED
argument_list|)
expr_stmt|;
name|bb
operator|.
name|root
operator|=
name|rel
expr_stmt|;
name|distinctify
argument_list|(
name|bb
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|rel
operator|=
name|bb
operator|.
name|root
expr_stmt|;
comment|// Create the expressions to reverse the mapping.
comment|// Project($0, $1, $0, $2).
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|undoProjects
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|origin
init|=
name|origins
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|undoProjects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
operator|(
name|RexNode
operator|)
operator|new
name|RexInputRef
argument_list|(
name|squished
operator|.
name|get
argument_list|(
name|origin
argument_list|)
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rel
operator|=
operator|new
name|ProjectRel
argument_list|(
name|cluster
argument_list|,
name|rel
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|undoProjects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|undoProjects
argument_list|)
argument_list|,
name|ProjectRel
operator|.
name|Flags
operator|.
name|BOXED
argument_list|)
expr_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|rel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Usual case: all of the expressions in the SELECT clause are
comment|// different.
name|rel
operator|=
name|createAggregate
argument_list|(
name|bb
argument_list|,
name|BitSets
operator|.
name|range
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|,
name|ImmutableList
operator|.
expr|<
name|AggregateCall
operator|>
name|of
argument_list|()
argument_list|)
expr_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|rel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
name|findExpr
parameter_list|(
name|RexNode
name|seek
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|int
name|count
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|seek
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Converts a query's ORDER BY clause, if any.    *    * @param select        Query    * @param bb            Blackboard    * @param collation     Collation list    * @param orderExprList Method populates this list with orderBy expressions    *                      not present in selectList    * @param offset        Expression for number of rows to discard before    *                      returning first row    * @param fetch         Expression for number of rows to fetch    */
specifier|protected
name|void
name|convertOrder
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|Blackboard
name|bb
parameter_list|,
name|RelCollation
name|collation
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderExprList
parameter_list|,
name|SqlNode
name|offset
parameter_list|,
name|SqlNode
name|fetch
parameter_list|)
block|{
if|if
condition|(
name|select
operator|.
name|getOrderList
argument_list|()
operator|==
literal|null
condition|)
block|{
assert|assert
name|collation
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|isEmpty
argument_list|()
assert|;
if|if
condition|(
name|offset
operator|==
literal|null
operator|&&
name|fetch
operator|==
literal|null
condition|)
block|{
return|return;
block|}
block|}
comment|// Create a sorter using the previously constructed collations.
name|bb
operator|.
name|setRoot
argument_list|(
operator|new
name|SortRel
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|Convention
operator|.
name|NONE
argument_list|,
name|collation
argument_list|)
argument_list|,
name|bb
operator|.
name|root
argument_list|,
name|collation
argument_list|,
name|offset
operator|==
literal|null
condition|?
literal|null
else|:
name|convertExpression
argument_list|(
name|offset
argument_list|)
argument_list|,
name|fetch
operator|==
literal|null
condition|?
literal|null
else|:
name|convertExpression
argument_list|(
name|fetch
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// If extra expressions were added to the project list for sorting,
comment|// add another project to remove them.
if|if
condition|(
name|orderExprList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|bb
operator|.
name|root
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
operator|-
name|orderExprList
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldCount
condition|;
name|i
operator|++
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|bb
operator|.
name|root
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bb
operator|.
name|setRoot
argument_list|(
operator|new
name|ProjectRel
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|RelCollationImpl
operator|.
name|PRESERVE
argument_list|)
argument_list|,
name|bb
operator|.
name|root
argument_list|,
name|exprs
argument_list|,
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createStructType
argument_list|(
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|fieldCount
argument_list|)
argument_list|)
argument_list|,
name|ProjectRelBase
operator|.
name|Flags
operator|.
name|BOXED
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns whether a given node contains a {@link SqlInOperator}.    *    * @param node a RexNode tree    */
specifier|private
specifier|static
name|boolean
name|containsInOperator
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
try|try
block|{
name|SqlVisitor
argument_list|<
name|Void
argument_list|>
name|visitor
init|=
operator|new
name|SqlBasicVisitor
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlInOperator
condition|)
block|{
throw|throw
operator|new
name|Util
operator|.
name|FoundOne
argument_list|(
name|call
argument_list|)
throw|;
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|node
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Push down all the NOT logical operators into any IN/NOT IN operators.    *    * @param sqlNode the root node from which to look for NOT operators    * @return the transformed SqlNode representation with NOT pushed down.    */
specifier|private
specifier|static
name|SqlNode
name|pushDownNotForIn
parameter_list|(
name|SqlNode
name|sqlNode
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sqlNode
operator|instanceof
name|SqlCall
operator|)
operator|&&
name|containsInOperator
argument_list|(
name|sqlNode
argument_list|)
condition|)
block|{
name|SqlCall
name|sqlCall
init|=
operator|(
name|SqlCall
operator|)
name|sqlNode
decl_stmt|;
if|if
condition|(
operator|(
name|sqlCall
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|AND
operator|)
operator|||
operator|(
name|sqlCall
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|OR
operator|)
condition|)
block|{
name|SqlNode
index|[]
name|sqlOperands
init|=
operator|(
operator|(
name|SqlBasicCall
operator|)
name|sqlCall
operator|)
operator|.
name|operands
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sqlOperands
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sqlOperands
index|[
name|i
index|]
operator|=
name|pushDownNotForIn
argument_list|(
name|sqlOperands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|sqlNode
return|;
block|}
if|else if
condition|(
name|sqlCall
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|NOT
condition|)
block|{
name|SqlNode
name|childNode
init|=
name|sqlCall
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|childNode
operator|instanceof
name|SqlCall
assert|;
name|SqlBasicCall
name|childSqlCall
init|=
operator|(
name|SqlBasicCall
operator|)
name|childNode
decl_stmt|;
if|if
condition|(
name|childSqlCall
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|AND
condition|)
block|{
name|SqlNode
index|[]
name|andOperands
init|=
name|childSqlCall
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|SqlNode
index|[]
name|orOperands
init|=
operator|new
name|SqlNode
index|[
name|andOperands
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|orOperands
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|orOperands
index|[
name|i
index|]
operator|=
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|andOperands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|orOperands
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|orOperands
index|[
name|i
index|]
operator|=
name|pushDownNotForIn
argument_list|(
name|orOperands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|SqlStdOperatorTable
operator|.
name|OR
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|orOperands
index|[
literal|0
index|]
argument_list|,
name|orOperands
index|[
literal|1
index|]
argument_list|)
return|;
block|}
if|else if
condition|(
name|childSqlCall
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|OR
condition|)
block|{
name|SqlNode
index|[]
name|orOperands
init|=
name|childSqlCall
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|SqlNode
index|[]
name|andOperands
init|=
operator|new
name|SqlNode
index|[
name|orOperands
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|andOperands
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|andOperands
index|[
name|i
index|]
operator|=
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|orOperands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|andOperands
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|andOperands
index|[
name|i
index|]
operator|=
name|pushDownNotForIn
argument_list|(
name|andOperands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|SqlStdOperatorTable
operator|.
name|AND
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|andOperands
index|[
literal|0
index|]
argument_list|,
name|andOperands
index|[
literal|1
index|]
argument_list|)
return|;
block|}
if|else if
condition|(
name|childSqlCall
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|NOT
condition|)
block|{
name|SqlNode
index|[]
name|notOperands
init|=
name|childSqlCall
operator|.
name|getOperands
argument_list|()
decl_stmt|;
assert|assert
name|notOperands
operator|.
name|length
operator|==
literal|1
assert|;
return|return
name|pushDownNotForIn
argument_list|(
name|notOperands
index|[
literal|0
index|]
argument_list|)
return|;
block|}
if|else if
condition|(
name|childSqlCall
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlInOperator
condition|)
block|{
name|SqlNode
index|[]
name|inOperands
init|=
name|childSqlCall
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|SqlInOperator
name|inOp
init|=
operator|(
name|SqlInOperator
operator|)
name|childSqlCall
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|inOp
operator|.
name|isNotIn
argument_list|()
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|IN
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|inOperands
index|[
literal|0
index|]
argument_list|,
name|inOperands
index|[
literal|1
index|]
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|NOT_IN
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|inOperands
index|[
literal|0
index|]
argument_list|,
name|inOperands
index|[
literal|1
index|]
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// childSqlCall is "leaf" node in a logical expression tree
comment|// (only considering AND, OR, NOT)
return|return
name|sqlNode
return|;
block|}
block|}
else|else
block|{
comment|// sqlNode is "leaf" node in a logical expression tree
comment|// (only considering AND, OR, NOT)
return|return
name|sqlNode
return|;
block|}
block|}
else|else
block|{
comment|// tree rooted at sqlNode does not contain inOperator
return|return
name|sqlNode
return|;
block|}
block|}
comment|/**    * Converts a WHERE clause.    *    * @param bb    Blackboard    * @param where WHERE clause, may be null    */
specifier|private
name|void
name|convertWhere
parameter_list|(
specifier|final
name|Blackboard
name|bb
parameter_list|,
specifier|final
name|SqlNode
name|where
parameter_list|)
block|{
if|if
condition|(
name|where
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|SqlNode
name|newWhere
init|=
name|pushDownNotForIn
argument_list|(
name|where
argument_list|)
decl_stmt|;
name|replaceSubqueries
argument_list|(
name|bb
argument_list|,
name|newWhere
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|convertedWhere
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|newWhere
argument_list|)
decl_stmt|;
comment|// only allocate filter if the condition is not TRUE
if|if
condition|(
operator|!
name|convertedWhere
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|RelNode
name|inputRel
init|=
name|bb
operator|.
name|root
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|correlatedVariablesBefore
init|=
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|inputRel
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|CalcRel
operator|.
name|createFilter
argument_list|(
name|bb
operator|.
name|root
argument_list|,
name|convertedWhere
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|correlatedVariables
init|=
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|bb
operator|.
name|root
argument_list|)
decl_stmt|;
name|correlatedVariables
operator|.
name|removeAll
argument_list|(
name|correlatedVariablesBefore
argument_list|)
expr_stmt|;
comment|// Associate the correlated variables with the new filter rel.
for|for
control|(
name|String
name|correl
range|:
name|correlatedVariables
control|)
block|{
name|mapCorrelToRefRel
operator|.
name|put
argument_list|(
name|correl
argument_list|,
name|bb
operator|.
name|root
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|replaceSubqueries
parameter_list|(
specifier|final
name|Blackboard
name|bb
parameter_list|,
specifier|final
name|SqlNode
name|expr
parameter_list|)
block|{
name|findSubqueries
argument_list|(
name|bb
argument_list|,
name|expr
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|bb
operator|.
name|subqueryList
control|)
block|{
name|substituteSubquery
argument_list|(
name|bb
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|substituteSubquery
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlNode
name|node
parameter_list|)
block|{
name|JoinRelType
name|joinType
init|=
name|JoinRelType
operator|.
name|INNER
decl_stmt|;
name|RexNode
index|[]
name|leftJoinKeysForIn
init|=
literal|null
decl_stmt|;
name|boolean
name|isNotIn
decl_stmt|;
name|boolean
name|subqueryNeedsOuterJoin
init|=
name|bb
operator|.
name|subqueryNeedsOuterJoin
decl_stmt|;
name|SqlBasicCall
name|call
decl_stmt|;
name|SqlNode
name|query
decl_stmt|;
specifier|final
name|RexNode
name|expr
init|=
name|bb
operator|.
name|mapSubqueryToExpr
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|!=
literal|null
condition|)
block|{
comment|// Already done.
return|return;
block|}
name|RelNode
name|converted
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CURSOR
case|:
name|convertCursor
argument_list|(
name|bb
argument_list|,
operator|(
name|SqlCall
operator|)
name|node
argument_list|)
expr_stmt|;
return|return;
case|case
name|MULTISET_QUERY_CONSTRUCTOR
case|:
case|case
name|MULTISET_VALUE_CONSTRUCTOR
case|:
name|converted
operator|=
name|convertMultisets
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|node
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
break|break;
case|case
name|IN
case|:
name|call
operator|=
operator|(
name|SqlBasicCall
operator|)
name|node
expr_stmt|;
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|isNotIn
operator|=
operator|(
operator|(
name|SqlInOperator
operator|)
name|call
operator|.
name|getOperator
argument_list|()
operator|)
operator|.
name|isNotIn
argument_list|()
expr_stmt|;
name|SqlNode
name|leftKeyNode
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|SqlNode
name|seek
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|leftKeyNode
operator|instanceof
name|SqlCall
operator|)
operator|&&
operator|(
operator|(
operator|(
name|SqlCall
operator|)
name|leftKeyNode
operator|)
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlRowOperator
operator|)
condition|)
block|{
name|SqlBasicCall
name|keyCall
init|=
operator|(
name|SqlBasicCall
operator|)
name|leftKeyNode
decl_stmt|;
name|SqlNode
index|[]
name|keyCallOperands
init|=
name|keyCall
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|int
name|rowLength
init|=
name|keyCallOperands
operator|.
name|length
decl_stmt|;
name|leftJoinKeysForIn
operator|=
operator|new
name|RexNode
index|[
name|rowLength
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowLength
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|sqlExpr
init|=
name|keyCallOperands
index|[
name|i
index|]
decl_stmt|;
name|leftJoinKeysForIn
index|[
name|i
index|]
operator|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|sqlExpr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|leftJoinKeysForIn
operator|=
operator|new
name|RexNode
index|[
literal|1
index|]
expr_stmt|;
name|leftJoinKeysForIn
index|[
literal|0
index|]
operator|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|leftKeyNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seek
operator|instanceof
name|SqlNodeList
condition|)
block|{
name|SqlNodeList
name|valueList
init|=
operator|(
name|SqlNodeList
operator|)
name|seek
decl_stmt|;
name|boolean
name|seenNull
init|=
literal|false
decl_stmt|;
comment|// check for nulls
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valueList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|sqlNode
init|=
name|valueList
operator|.
name|getList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|sqlNode
operator|instanceof
name|SqlLiteral
condition|)
block|{
name|SqlLiteral
name|lit
init|=
operator|(
name|SqlLiteral
operator|)
name|sqlNode
decl_stmt|;
if|if
condition|(
name|lit
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
name|seenNull
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|seenNull
operator|&&
operator|(
name|valueList
operator|.
name|size
argument_list|()
operator|<
name|getInSubqueryThreshold
argument_list|()
operator|)
condition|)
block|{
comment|// We're under the threshold, so convert to OR.
name|RexNode
name|expression
init|=
name|convertInToOr
argument_list|(
name|bb
argument_list|,
name|leftJoinKeysForIn
argument_list|,
name|valueList
argument_list|,
name|isNotIn
argument_list|)
decl_stmt|;
name|bb
operator|.
name|mapSubqueryToExpr
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|expression
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|// Otherwise, let convertExists translate
comment|// values list into an inline table for the
comment|// reference to Q below.
block|}
block|}
comment|// Project out the search columns from the left side
comment|//  Q1:
comment|// "select from emp where emp.deptno in (select col1 from T)"
comment|//
comment|// is converted to
comment|//
comment|// "select from
comment|//   emp inner join (select distinct col1 from T)) q
comment|//   on emp.deptno = q.col1
comment|//
comment|// Q2:
comment|// "select from emp where emp.deptno not in (Q)"
comment|//
comment|// is converted to
comment|//
comment|// "select from
comment|//   emp left outer join (select distinct col1, TRUE from T) q
comment|//   on emp.deptno = q.col1
comment|//   where emp.deptno<> null
comment|//         and q.indicator<> TRUE"
comment|//
name|converted
operator|=
name|convertExists
argument_list|(
name|seek
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|subqueryNeedsOuterJoin
operator|||
name|isNotIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|subqueryNeedsOuterJoin
operator|||
name|isNotIn
condition|)
block|{
name|joinType
operator|=
name|JoinRelType
operator|.
name|LEFT
expr_stmt|;
block|}
else|else
block|{
name|joinType
operator|=
name|JoinRelType
operator|.
name|INNER
expr_stmt|;
block|}
break|break;
case|case
name|EXISTS
case|:
comment|// "select from emp where exists (select a from T)"
comment|//
comment|// is converted to the following if the subquery is correlated:
comment|//
comment|// "select from emp left outer join (select AGG_TRUE() as indicator
comment|// from T group by corr_var) q where q.indicator is true"
comment|//
comment|// If there is no correlation, the expression is replaced with a
comment|// boolean indicating whether the subquery returned 0 or>= 1 row.
name|call
operator|=
operator|(
name|SqlBasicCall
operator|)
name|node
expr_stmt|;
name|query
operator|=
name|call
operator|.
name|getOperands
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
name|converted
operator|=
name|convertExists
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|convertNonCorrelatedSubq
argument_list|(
name|call
argument_list|,
name|bb
argument_list|,
name|converted
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return;
block|}
name|joinType
operator|=
name|JoinRelType
operator|.
name|LEFT
expr_stmt|;
break|break;
case|case
name|SCALAR_QUERY
case|:
comment|// Convert the subquery.  If it's non-correlated, convert it
comment|// to a constant expression.
name|call
operator|=
operator|(
name|SqlBasicCall
operator|)
name|node
expr_stmt|;
name|query
operator|=
name|call
operator|.
name|getOperands
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
name|converted
operator|=
name|convertExists
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|convertNonCorrelatedSubq
argument_list|(
name|call
argument_list|,
name|bb
argument_list|,
name|converted
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|converted
operator|=
name|convertToSingleValueSubq
argument_list|(
name|query
argument_list|,
name|converted
argument_list|)
expr_stmt|;
name|joinType
operator|=
name|JoinRelType
operator|.
name|LEFT
expr_stmt|;
break|break;
case|case
name|SELECT
case|:
comment|// This is used when converting multiset queries:
comment|//
comment|// select * from unnest(select multiset[deptno] from emps);
comment|//
name|converted
operator|=
name|convertExists
argument_list|(
name|node
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|joinType
operator|=
name|JoinRelType
operator|.
name|LEFT
expr_stmt|;
break|break;
default|default:
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"unexpected kind of subquery :"
operator|+
name|node
argument_list|)
throw|;
block|}
specifier|final
name|RexNode
name|expression
init|=
name|bb
operator|.
name|register
argument_list|(
name|converted
argument_list|,
name|joinType
argument_list|,
name|leftJoinKeysForIn
argument_list|)
decl_stmt|;
name|bb
operator|.
name|mapSubqueryToExpr
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|expression
argument_list|)
expr_stmt|;
block|}
comment|/**    * Determines if a subquery is non-correlated and if so, converts it to a    * constant.    *    * @param call      the call that references the subquery    * @param bb        blackboard used to convert the subquery    * @param converted RelNode tree corresponding to the subquery    * @param isExists  true if the subquery is part of an EXISTS expression    * @return if the subquery can be converted to a constant    */
specifier|private
name|boolean
name|convertNonCorrelatedSubq
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|Blackboard
name|bb
parameter_list|,
name|RelNode
name|converted
parameter_list|,
name|boolean
name|isExists
parameter_list|)
block|{
if|if
condition|(
name|subqueryConverter
operator|.
name|canConvertSubquery
argument_list|()
operator|&&
name|isSubqNonCorrelated
argument_list|(
name|converted
argument_list|,
name|bb
argument_list|)
condition|)
block|{
comment|// First check if the subquery has already been converted
comment|// because it's a nested subquery.  If so, don't re-evaluate
comment|// it again.
name|RexNode
name|constExpr
init|=
name|mapConvertedNonCorrSubqs
operator|.
name|get
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|constExpr
operator|==
literal|null
condition|)
block|{
name|constExpr
operator|=
name|subqueryConverter
operator|.
name|convertSubquery
argument_list|(
name|call
argument_list|,
name|this
argument_list|,
name|isExists
argument_list|,
name|isExplain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constExpr
operator|!=
literal|null
condition|)
block|{
name|bb
operator|.
name|mapSubqueryToExpr
operator|.
name|put
argument_list|(
name|call
argument_list|,
name|constExpr
argument_list|)
expr_stmt|;
name|mapConvertedNonCorrSubqs
operator|.
name|put
argument_list|(
name|call
argument_list|,
name|constExpr
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Converts the RelNode tree for a select statement to a select that    * produces a single value.    *    * @param query the query    * @param plan   the original RelNode tree corresponding to the statement    * @return the converted RelNode tree    */
specifier|public
name|RelNode
name|convertToSingleValueSubq
parameter_list|(
name|SqlNode
name|query
parameter_list|,
name|RelNode
name|plan
parameter_list|)
block|{
comment|// Check whether query is guaranteed to produce a single value.
if|if
condition|(
name|query
operator|instanceof
name|SqlSelect
condition|)
block|{
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|query
decl_stmt|;
name|SqlNodeList
name|selectList
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
name|SqlNodeList
name|groupList
init|=
name|select
operator|.
name|getGroup
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|selectList
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|groupList
operator|==
literal|null
operator|)
operator|||
operator|(
name|groupList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|SqlNode
name|selectExpr
init|=
name|selectList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectExpr
operator|instanceof
name|SqlCall
condition|)
block|{
name|SqlCall
name|selectExprCall
init|=
operator|(
name|SqlCall
operator|)
name|selectExpr
decl_stmt|;
if|if
condition|(
name|selectExprCall
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlAggFunction
condition|)
block|{
return|return
name|plan
return|;
block|}
block|}
block|}
block|}
comment|// If not, project SingleValueAgg
return|return
name|RelOptUtil
operator|.
name|createSingleValueAggRel
argument_list|(
name|cluster
argument_list|,
name|plan
argument_list|)
return|;
block|}
comment|/**    * Converts "x IN (1, 2, ...)" to "x=1 OR x=2 OR ...".    *    * @param leftKeys   LHS    * @param valuesList RHS    * @param isNotIn    is this a NOT IN operator    * @return converted expression    */
specifier|private
name|RexNode
name|convertInToOr
parameter_list|(
specifier|final
name|Blackboard
name|bb
parameter_list|,
specifier|final
name|RexNode
index|[]
name|leftKeys
parameter_list|,
name|SqlNodeList
name|valuesList
parameter_list|,
name|boolean
name|isNotIn
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|comparisons
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|rightVals
range|:
name|valuesList
control|)
block|{
name|RexNode
name|rexComparison
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|leftKeys
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|rexComparison
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|leftKeys
index|[
literal|0
index|]
argument_list|,
name|bb
operator|.
name|convertExpression
argument_list|(
name|rightVals
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|rightVals
operator|instanceof
name|SqlCall
assert|;
specifier|final
name|SqlBasicCall
name|call
init|=
operator|(
name|SqlBasicCall
operator|)
name|rightVals
decl_stmt|;
assert|assert
operator|(
name|call
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlRowOperator
operator|)
operator|&&
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|length
operator|==
name|leftKeys
operator|.
name|length
assert|;
name|rexComparison
operator|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|RexUtil
operator|.
name|generate
argument_list|(
name|leftKeys
operator|.
name|length
argument_list|,
operator|new
name|Function1
argument_list|<
name|Integer
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
specifier|public
name|RexNode
name|apply
parameter_list|(
name|Integer
name|i
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|leftKeys
index|[
name|i
index|]
argument_list|,
name|bb
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
index|[
name|i
index|]
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|comparisons
operator|.
name|add
argument_list|(
name|rexComparison
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|result
init|=
name|RexUtil
operator|.
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|comparisons
argument_list|,
literal|true
argument_list|)
decl_stmt|;
assert|assert
name|result
operator|!=
literal|null
assert|;
if|if
condition|(
name|isNotIn
condition|)
block|{
name|result
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Gets the list size threshold under which {@link #convertInToOr} is used.    * Lists of this size or greater will instead be converted to use a join    * against an inline table ({@link ValuesRel}) rather than a predicate. A    * threshold of 0 forces usage of an inline table in all cases; a threshold    * of Integer.MAX_VALUE forces usage of OR in all cases    *    * @return threshold, default 20    */
specifier|protected
name|int
name|getInSubqueryThreshold
parameter_list|()
block|{
return|return
literal|20
return|;
block|}
comment|/**    * Creates the condition for a join implementing an IN clause.    *    * @param bb       blackboard to use, bb.root points to the LHS    * @param leftKeys LHS of IN    * @param rightRel Relational expression on RHS    * @return join condition    */
specifier|private
name|RexNode
name|createJoinConditionForIn
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftKeys
parameter_list|,
name|RelNode
name|rightRel
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinConditions
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
comment|// right fields appear after the LHS fields.
name|int
name|rightInputOffset
init|=
name|bb
operator|.
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightTypeFields
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|leftKeys
operator|.
name|size
argument_list|()
operator|<=
name|rightTypeFields
operator|.
name|size
argument_list|()
assert|;
for|for
control|(
name|Ord
argument_list|<
name|RexNode
argument_list|>
name|key
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|leftKeys
argument_list|)
control|)
block|{
name|joinConditions
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|key
operator|.
name|e
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|rightTypeFields
operator|.
name|get
argument_list|(
name|key
operator|.
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|rightInputOffset
operator|+
name|key
operator|.
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|joinConditions
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Converts an EXISTS or IN predicate into a join. For EXISTS, the subquery    * produces an indicator variable, and the result is a relational expression    * which outer joins that indicator to the original query. After performing    * the outer join, the condition will be TRUE if the EXISTS condition holds,    * NULL otherwise.    *    *<p>FIXME jvs 1-May-2006: null semantics for IN are currently broken    *    * @param seek           A query, for example 'select * from emp' or    *                       'values (1,2,3)' or '('Foo', 34)'.    * @param isIn           Whether is an IN predicate    * @param isExists       Whether is an EXISTS predicate    * @param needsOuterJoin Whether an outer join is needed    * @return join expression    * @pre extraExpr == null || extraName != null    */
specifier|private
name|RelNode
name|convertExists
parameter_list|(
name|SqlNode
name|seek
parameter_list|,
name|boolean
name|isIn
parameter_list|,
name|boolean
name|isExists
parameter_list|,
name|boolean
name|needsOuterJoin
parameter_list|)
block|{
assert|assert
operator|!
name|isIn
operator|||
operator|!
name|isExists
assert|;
specifier|final
name|SqlValidatorScope
name|seekScope
init|=
operator|(
name|seek
operator|instanceof
name|SqlSelect
operator|)
condition|?
name|validator
operator|.
name|getSelectScope
argument_list|(
operator|(
name|SqlSelect
operator|)
name|seek
argument_list|)
else|:
literal|null
decl_stmt|;
specifier|final
name|Blackboard
name|seekBb
init|=
name|createBlackboard
argument_list|(
name|seekScope
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|RelNode
name|seekRel
init|=
name|convertQueryOrInList
argument_list|(
name|seekBb
argument_list|,
name|seek
argument_list|)
decl_stmt|;
return|return
name|RelOptUtil
operator|.
name|createExistsPlan
argument_list|(
name|cluster
argument_list|,
name|seekRel
argument_list|,
name|isIn
argument_list|,
name|isExists
argument_list|,
name|needsOuterJoin
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|convertQueryOrInList
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlNode
name|seek
parameter_list|)
block|{
comment|// NOTE: Once we start accepting single-row queries as row constructors,
comment|// there will be an ambiguity here for a case like X IN ((SELECT Y FROM
comment|// Z)).  The SQL standard resolves the ambiguity by saying that a lone
comment|// select should be interpreted as a table expression, not a row
comment|// expression.  The semantic difference is that a table expression can
comment|// return multiple rows.
if|if
condition|(
name|seek
operator|instanceof
name|SqlNodeList
condition|)
block|{
return|return
name|convertRowValues
argument_list|(
name|bb
argument_list|,
name|seek
argument_list|,
operator|(
operator|(
name|SqlNodeList
operator|)
name|seek
operator|)
operator|.
name|getList
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|convertQueryRecursive
argument_list|(
name|seek
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
specifier|private
name|RelNode
name|convertRowValues
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlNode
name|rowList
parameter_list|,
name|Collection
argument_list|<
name|SqlNode
argument_list|>
name|rows
parameter_list|,
name|boolean
name|allowLiteralsOnly
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|)
block|{
comment|// NOTE jvs 30-Apr-2006: We combine all rows consisting entirely of
comment|// literals into a single ValuesRel; this gives the optimizer a smaller
comment|// input tree.  For everything else (computed expressions, row
comment|// subqueries), we union each row in as a projection on top of a
comment|// OneRowRel.
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
decl_stmt|;
if|if
condition|(
name|targetRowType
operator|!=
literal|null
condition|)
block|{
name|rowType
operator|=
name|targetRowType
expr_stmt|;
block|}
else|else
block|{
name|rowType
operator|=
name|SqlTypeUtil
operator|.
name|promoteToRowType
argument_list|(
name|typeFactory
argument_list|,
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|rowList
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|RelNode
argument_list|>
name|unionInputs
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|rows
control|)
block|{
name|SqlBasicCall
name|call
decl_stmt|;
if|if
condition|(
name|isRowConstructor
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|call
operator|=
operator|(
name|SqlBasicCall
operator|)
name|node
expr_stmt|;
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|tuple
init|=
operator|new
name|ArrayList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|operands
control|)
block|{
name|RexLiteral
name|rexLiteral
init|=
name|convertLiteralInValuesList
argument_list|(
name|operand
argument_list|,
name|bb
argument_list|,
name|rowType
argument_list|,
name|tuple
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|rexLiteral
operator|==
literal|null
operator|)
operator|&&
name|allowLiteralsOnly
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|(
name|rexLiteral
operator|==
literal|null
operator|)
operator|||
operator|!
name|shouldCreateValuesRel
condition|)
block|{
comment|// fallback to convertRowConstructor
name|tuple
operator|=
literal|null
expr_stmt|;
break|break;
block|}
name|tuple
operator|.
name|add
argument_list|(
name|rexLiteral
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tuple
operator|!=
literal|null
condition|)
block|{
name|tupleList
operator|.
name|add
argument_list|(
name|tuple
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|RexLiteral
name|rexLiteral
init|=
name|convertLiteralInValuesList
argument_list|(
name|node
argument_list|,
name|bb
argument_list|,
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|rexLiteral
operator|!=
literal|null
operator|)
operator|&&
name|shouldCreateValuesRel
condition|)
block|{
name|tupleList
operator|.
name|add
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|rexLiteral
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rexLiteral
operator|==
literal|null
operator|)
operator|&&
name|allowLiteralsOnly
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// convert "1" to "row(1)"
name|call
operator|=
operator|(
name|SqlBasicCall
operator|)
name|SqlStdOperatorTable
operator|.
name|ROW
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|unionInputs
operator|.
name|add
argument_list|(
name|convertRowConstructor
argument_list|(
name|bb
argument_list|,
name|call
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ValuesRel
name|valuesRel
init|=
operator|new
name|ValuesRel
argument_list|(
name|cluster
argument_list|,
name|rowType
argument_list|,
name|tupleList
argument_list|)
decl_stmt|;
name|RelNode
name|resultRel
decl_stmt|;
if|if
condition|(
name|unionInputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|resultRel
operator|=
name|valuesRel
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|tupleList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|unionInputs
operator|.
name|add
argument_list|(
name|valuesRel
argument_list|)
expr_stmt|;
block|}
name|UnionRel
name|unionRel
init|=
operator|new
name|UnionRel
argument_list|(
name|cluster
argument_list|,
name|unionInputs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|resultRel
operator|=
name|unionRel
expr_stmt|;
block|}
name|leaves
operator|.
name|add
argument_list|(
name|resultRel
argument_list|)
expr_stmt|;
return|return
name|resultRel
return|;
block|}
specifier|private
name|RexLiteral
name|convertLiteralInValuesList
parameter_list|(
name|SqlNode
name|sqlNode
parameter_list|,
name|Blackboard
name|bb
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|int
name|iField
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|sqlNode
operator|instanceof
name|SqlLiteral
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|RelDataTypeField
name|field
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|iField
argument_list|)
decl_stmt|;
name|RelDataType
name|type
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
comment|// null literals for weird stuff like UDT's need
comment|// special handling during type flattening, so
comment|// don't use ValuesRel for those
return|return
literal|null
return|;
block|}
name|RexNode
name|literalExpr
init|=
name|exprConverter
operator|.
name|convertLiteral
argument_list|(
name|bb
argument_list|,
operator|(
name|SqlLiteral
operator|)
name|sqlNode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|literalExpr
operator|instanceof
name|RexLiteral
operator|)
condition|)
block|{
assert|assert
name|literalExpr
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
assert|;
name|RexNode
name|child
init|=
operator|(
operator|(
name|RexCall
operator|)
name|literalExpr
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|RexLiteral
operator|.
name|isNullLiteral
argument_list|(
name|child
argument_list|)
assert|;
comment|// NOTE jvs 22-Nov-2006:  we preserve type info
comment|// in ValuesRel digest, so it's OK to lose it here
return|return
operator|(
name|RexLiteral
operator|)
name|child
return|;
block|}
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|literalExpr
decl_stmt|;
name|Comparable
name|value
init|=
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|BigDecimal
name|roundedValue
init|=
name|NumberUtil
operator|.
name|rescaleBigDecimal
argument_list|(
operator|(
name|BigDecimal
operator|)
name|value
argument_list|,
name|type
operator|.
name|getScale
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|roundedValue
argument_list|,
name|type
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|value
operator|instanceof
name|NlsString
operator|)
operator|&&
operator|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|CHAR
operator|)
condition|)
block|{
comment|// pad fixed character type
name|NlsString
name|unpadded
init|=
operator|(
name|NlsString
operator|)
name|value
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCharLiteral
argument_list|(
operator|new
name|NlsString
argument_list|(
name|Util
operator|.
name|rpad
argument_list|(
name|unpadded
operator|.
name|getValue
argument_list|()
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
argument_list|,
name|unpadded
operator|.
name|getCharsetName
argument_list|()
argument_list|,
name|unpadded
operator|.
name|getCollation
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
return|return
name|literal
return|;
block|}
specifier|private
name|boolean
name|isRowConstructor
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ROW
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
return|return
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"row"
argument_list|)
return|;
block|}
comment|/**    * Builds a list of all<code>IN</code> or<code>EXISTS</code> operators    * inside SQL parse tree. Does not traverse inside queries.    *    * @param bb                           blackboard    * @param node                         the SQL parse tree    * @param registerOnlyScalarSubqueries if set to true and the parse tree    *                                     corresponds to a variation of a select    *                                     node, only register it if it's a scalar    *                                     subquery    */
specifier|private
name|void
name|findSubqueries
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|boolean
name|registerOnlyScalarSubqueries
parameter_list|)
block|{
specifier|final
name|SqlKind
name|kind
init|=
name|node
operator|.
name|getKind
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|EXISTS
case|:
case|case
name|SELECT
case|:
case|case
name|MULTISET_QUERY_CONSTRUCTOR
case|:
case|case
name|MULTISET_VALUE_CONSTRUCTOR
case|:
case|case
name|CURSOR
case|:
case|case
name|SCALAR_QUERY
case|:
if|if
condition|(
operator|!
name|registerOnlyScalarSubqueries
operator|||
operator|(
name|kind
operator|==
name|SqlKind
operator|.
name|SCALAR_QUERY
operator|)
condition|)
block|{
name|bb
operator|.
name|registerSubquery
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
if|if
condition|(
name|node
operator|instanceof
name|SqlCall
condition|)
block|{
if|if
condition|(
name|kind
operator|==
name|SqlKind
operator|.
name|OR
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|NOT
condition|)
block|{
comment|// It's always correct to outer join subquery with
comment|// containing query; however, when predicates involve Or
comment|// or NOT, outer join might be necessary.
name|bb
operator|.
name|subqueryNeedsOuterJoin
operator|=
literal|true
expr_stmt|;
block|}
for|for
control|(
name|SqlNode
name|operand
range|:
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
control|)
block|{
if|if
condition|(
name|operand
operator|!=
literal|null
condition|)
block|{
comment|// In the case of an IN expression, locate scalar
comment|// subqueries so we can convert them to constants
name|findSubqueries
argument_list|(
name|bb
argument_list|,
name|operand
argument_list|,
name|kind
operator|==
name|SqlKind
operator|.
name|IN
operator|||
name|registerOnlyScalarSubqueries
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlNodeList
condition|)
block|{
specifier|final
name|SqlNodeList
name|nodes
init|=
operator|(
name|SqlNodeList
operator|)
name|node
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|child
init|=
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|findSubqueries
argument_list|(
name|bb
argument_list|,
name|child
argument_list|,
name|kind
operator|==
name|SqlKind
operator|.
name|IN
operator|||
name|registerOnlyScalarSubqueries
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Now that we've located any scalar subqueries inside the IN
comment|// expression, register the IN expression itself.  We need to
comment|// register the scalar subqueries first so they can be converted
comment|// before the IN expression is converted.
if|if
condition|(
name|kind
operator|==
name|SqlKind
operator|.
name|IN
condition|)
block|{
name|bb
operator|.
name|registerSubquery
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Converts an expression from {@link SqlNode} to {@link RexNode} format.    *    * @param node Expression to translate    * @return Converted expression    */
specifier|public
name|RexNode
name|convertExpression
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|nameToTypeMap
init|=
name|Collections
operator|.
name|emptyMap
argument_list|()
decl_stmt|;
name|Blackboard
name|bb
init|=
name|createBlackboard
argument_list|(
operator|new
name|ParameterScope
argument_list|(
operator|(
name|SqlValidatorImpl
operator|)
name|validator
argument_list|,
name|nameToTypeMap
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|bb
operator|.
name|convertExpression
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/**    * Converts an expression from {@link SqlNode} to {@link RexNode} format,    * mapping identifier references to predefined expressions.    *    * @param node          Expression to translate    * @param nameToNodeMap map from String to {@link RexNode}; when an    *                      {@link SqlIdentifier} is encountered, it is used as a    *                      key and translated to the corresponding value from    *                      this map    * @return Converted expression    */
specifier|public
name|RexNode
name|convertExpression
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|nameToNodeMap
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|nameToTypeMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|entry
range|:
name|nameToNodeMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|nameToTypeMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Blackboard
name|bb
init|=
name|createBlackboard
argument_list|(
operator|new
name|ParameterScope
argument_list|(
operator|(
name|SqlValidatorImpl
operator|)
name|validator
argument_list|,
name|nameToTypeMap
argument_list|)
argument_list|,
name|nameToNodeMap
argument_list|)
decl_stmt|;
return|return
name|bb
operator|.
name|convertExpression
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/**    * Converts a non-standard expression.    *    *<p>This method is an extension-point for derived classes can override. If    * this method returns a null result, the normal expression translation    * process will proceeed. The default implementation always returns null.    *    * @param node Expression    * @param bb   Blackboard    * @return null to proceed with the usual expression translation process    */
specifier|protected
name|RexNode
name|convertExtendedExpression
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Blackboard
name|bb
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
specifier|private
name|RexNode
name|convertOver
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlNode
name|node
parameter_list|)
block|{
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
name|SqlCall
name|aggCall
init|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|SqlNode
name|windowOrRef
init|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|SqlWindow
name|window
init|=
name|validator
operator|.
name|resolveWindow
argument_list|(
name|windowOrRef
argument_list|,
name|bb
operator|.
name|scope
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|SqlNodeList
name|partitionList
init|=
name|window
operator|.
name|getPartitionList
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|partitionKeys
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|partition
range|:
name|partitionList
control|)
block|{
name|partitionKeys
operator|.
name|add
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|partition
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|lowerBound
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|window
operator|.
name|getLowerBound
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|upperBound
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|window
operator|.
name|getUpperBound
argument_list|()
argument_list|)
decl_stmt|;
name|SqlNodeList
name|orderList
init|=
name|window
operator|.
name|getOrderList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|orderList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|!
name|window
operator|.
name|isRows
argument_list|()
condition|)
block|{
comment|// A logical range requires an ORDER BY clause. Use the implicit
comment|// ordering of this relation. There must be one, otherwise it would
comment|// have failed validation.
name|orderList
operator|=
name|bb
operator|.
name|scope
operator|.
name|getOrderList
argument_list|()
expr_stmt|;
if|if
condition|(
name|orderList
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Relation should have sort key for implicit ORDER BY"
argument_list|)
throw|;
block|}
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexFieldCollation
argument_list|>
name|orderKeys
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|SqlKind
argument_list|>
name|flags
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|SqlKind
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlNode
name|order
range|:
name|orderList
control|)
block|{
name|flags
operator|.
name|clear
argument_list|()
expr_stmt|;
name|RexNode
name|e
init|=
name|bb
operator|.
name|convertSortExpression
argument_list|(
name|order
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|orderKeys
operator|.
name|add
argument_list|(
operator|new
name|RexFieldCollation
argument_list|(
name|e
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Util
operator|.
name|permAssert
argument_list|(
name|bb
operator|.
name|window
operator|==
literal|null
argument_list|,
literal|"already in window agg mode"
argument_list|)
expr_stmt|;
name|bb
operator|.
name|window
operator|=
name|window
expr_stmt|;
name|RexNode
name|rexAgg
init|=
name|exprConverter
operator|.
name|convertCall
argument_list|(
name|bb
argument_list|,
name|aggCall
argument_list|)
decl_stmt|;
name|rexAgg
operator|=
name|rexBuilder
operator|.
name|ensureType
argument_list|(
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
argument_list|,
name|rexAgg
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Walk over the tree and apply 'over' to all agg functions. This is
comment|// necessary because the returned expression is not necessarily a call
comment|// to an agg function. For example, AVG(x) becomes SUM(x) / COUNT(x).
specifier|final
name|RexShuttle
name|visitor
init|=
operator|new
name|HistogramShuttle
argument_list|(
name|partitionKeys
operator|.
name|build
argument_list|()
argument_list|,
name|orderKeys
operator|.
name|build
argument_list|()
argument_list|,
name|RexWindowBound
operator|.
name|create
argument_list|(
name|window
operator|.
name|getLowerBound
argument_list|()
argument_list|,
name|lowerBound
argument_list|)
argument_list|,
name|RexWindowBound
operator|.
name|create
argument_list|(
name|window
operator|.
name|getUpperBound
argument_list|()
argument_list|,
name|upperBound
argument_list|)
argument_list|,
name|window
argument_list|)
decl_stmt|;
return|return
name|rexAgg
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
return|;
block|}
finally|finally
block|{
name|bb
operator|.
name|window
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Converts a FROM clause into a relational expression.    *    * @param bb   Scope within which to resolve identifiers    * @param from FROM clause of a query. Examples include:    *    *<ul>    *<li>a single table ("SALES.EMP"),    *<li>an aliased table ("EMP AS E"),    *<li>a list of tables ("EMP, DEPT"),    *<li>an ANSI Join expression ("EMP JOIN DEPT ON EMP.DEPTNO =    *             DEPT.DEPTNO"),    *<li>a VALUES clause ("VALUES ('Fred', 20)"),    *<li>a query ("(SELECT * FROM EMP WHERE GENDER = 'F')"),    *<li>or any combination of the above.    *</ul>    */
specifier|protected
name|void
name|convertFrom
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlNode
name|from
parameter_list|)
block|{
name|SqlCall
name|call
decl_stmt|;
specifier|final
name|SqlNode
index|[]
name|operands
decl_stmt|;
switch|switch
condition|(
name|from
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
name|operands
operator|=
operator|(
operator|(
name|SqlBasicCall
operator|)
name|from
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
name|convertFrom
argument_list|(
name|bb
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|WITH_ITEM
case|:
name|convertFrom
argument_list|(
name|bb
argument_list|,
operator|(
operator|(
name|SqlWithItem
operator|)
name|from
operator|)
operator|.
name|query
argument_list|)
expr_stmt|;
return|return;
case|case
name|WITH
case|:
name|convertFrom
argument_list|(
name|bb
argument_list|,
operator|(
operator|(
name|SqlWith
operator|)
name|from
operator|)
operator|.
name|body
argument_list|)
expr_stmt|;
return|return;
case|case
name|TABLESAMPLE
case|:
name|operands
operator|=
operator|(
operator|(
name|SqlBasicCall
operator|)
name|from
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
name|SqlSampleSpec
name|sampleSpec
init|=
name|SqlLiteral
operator|.
name|sampleValue
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|sampleSpec
operator|instanceof
name|SqlSampleSpec
operator|.
name|SqlSubstitutionSampleSpec
condition|)
block|{
name|String
name|sampleName
init|=
operator|(
operator|(
name|SqlSampleSpec
operator|.
name|SqlSubstitutionSampleSpec
operator|)
name|sampleSpec
operator|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|datasetStack
operator|.
name|push
argument_list|(
name|sampleName
argument_list|)
expr_stmt|;
name|convertFrom
argument_list|(
name|bb
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|datasetStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|sampleSpec
operator|instanceof
name|SqlSampleSpec
operator|.
name|SqlTableSampleSpec
condition|)
block|{
name|SqlSampleSpec
operator|.
name|SqlTableSampleSpec
name|tableSampleSpec
init|=
operator|(
name|SqlSampleSpec
operator|.
name|SqlTableSampleSpec
operator|)
name|sampleSpec
decl_stmt|;
name|convertFrom
argument_list|(
name|bb
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|RelOptSamplingParameters
name|params
init|=
operator|new
name|RelOptSamplingParameters
argument_list|(
name|tableSampleSpec
operator|.
name|isBernoulli
argument_list|()
argument_list|,
name|tableSampleSpec
operator|.
name|getSamplePercentage
argument_list|()
argument_list|,
name|tableSampleSpec
operator|.
name|isRepeatable
argument_list|()
argument_list|,
name|tableSampleSpec
operator|.
name|getRepeatableSeed
argument_list|()
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
operator|new
name|SamplingRel
argument_list|(
name|cluster
argument_list|,
name|bb
operator|.
name|root
argument_list|,
name|params
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"unknown TABLESAMPLE type: "
operator|+
name|sampleSpec
argument_list|)
throw|;
block|}
return|return;
case|case
name|IDENTIFIER
case|:
specifier|final
name|SqlValidatorNamespace
name|fromNamespace
init|=
name|validator
operator|.
name|getNamespace
argument_list|(
name|from
argument_list|)
operator|.
name|resolve
argument_list|()
decl_stmt|;
if|if
condition|(
name|fromNamespace
operator|.
name|getNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|convertFrom
argument_list|(
name|bb
argument_list|,
name|fromNamespace
operator|.
name|getNode
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|String
name|datasetName
init|=
name|datasetStack
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|datasetStack
operator|.
name|peek
argument_list|()
decl_stmt|;
name|boolean
index|[]
name|usedDataset
init|=
block|{
literal|false
block|}
decl_stmt|;
name|RelOptTable
name|table
init|=
name|SqlValidatorUtil
operator|.
name|getRelOptTable
argument_list|(
name|fromNamespace
argument_list|,
name|catalogReader
argument_list|,
name|datasetName
argument_list|,
name|usedDataset
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|tableRel
decl_stmt|;
if|if
condition|(
name|shouldConvertTableAccess
condition|)
block|{
name|tableRel
operator|=
name|toRel
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tableRel
operator|=
operator|new
name|TableAccessRel
argument_list|(
name|cluster
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
name|bb
operator|.
name|setRoot
argument_list|(
name|tableRel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|usedDataset
index|[
literal|0
index|]
condition|)
block|{
name|bb
operator|.
name|setDataset
argument_list|(
name|datasetName
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|JOIN
case|:
specifier|final
name|SqlJoin
name|join
init|=
operator|(
name|SqlJoin
operator|)
name|from
decl_stmt|;
specifier|final
name|Blackboard
name|fromBlackboard
init|=
name|createBlackboard
argument_list|(
name|validator
operator|.
name|getJoinScope
argument_list|(
name|from
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|SqlNode
name|left
init|=
name|join
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|SqlNode
name|right
init|=
name|join
operator|.
name|getRight
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isNatural
init|=
name|join
operator|.
name|isNatural
argument_list|()
decl_stmt|;
specifier|final
name|JoinType
name|joinType
init|=
name|join
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
specifier|final
name|Blackboard
name|leftBlackboard
init|=
name|createBlackboard
argument_list|(
name|Util
operator|.
name|first
argument_list|(
name|validator
operator|.
name|getJoinScope
argument_list|(
name|left
argument_list|)
argument_list|,
operator|(
operator|(
name|DelegatingScope
operator|)
name|bb
operator|.
name|scope
operator|)
operator|.
name|getParent
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|Blackboard
name|rightBlackboard
init|=
name|createBlackboard
argument_list|(
name|Util
operator|.
name|first
argument_list|(
name|validator
operator|.
name|getJoinScope
argument_list|(
name|right
argument_list|)
argument_list|,
operator|(
operator|(
name|DelegatingScope
operator|)
name|bb
operator|.
name|scope
operator|)
operator|.
name|getParent
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|convertFrom
argument_list|(
name|leftBlackboard
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|RelNode
name|leftRel
init|=
name|leftBlackboard
operator|.
name|root
decl_stmt|;
name|convertFrom
argument_list|(
name|rightBlackboard
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|RelNode
name|rightRel
init|=
name|rightBlackboard
operator|.
name|root
decl_stmt|;
name|JoinRelType
name|convertedJoinType
init|=
name|convertJoinType
argument_list|(
name|joinType
argument_list|)
decl_stmt|;
name|RexNode
name|conditionExp
decl_stmt|;
if|if
condition|(
name|isNatural
condition|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|columnList
init|=
name|SqlValidatorUtil
operator|.
name|deriveNaturalJoinColumnList
argument_list|(
name|validator
operator|.
name|getNamespace
argument_list|(
name|left
argument_list|)
operator|.
name|getRowType
argument_list|()
argument_list|,
name|validator
operator|.
name|getNamespace
argument_list|(
name|right
argument_list|)
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
name|conditionExp
operator|=
name|convertUsing
argument_list|(
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|columnList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|conditionExp
operator|=
name|convertJoinCondition
argument_list|(
name|fromBlackboard
argument_list|,
name|join
operator|.
name|getCondition
argument_list|()
argument_list|,
name|join
operator|.
name|getConditionType
argument_list|()
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|joinRel
init|=
name|createJoin
argument_list|(
name|fromBlackboard
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|conditionExp
argument_list|,
name|convertedJoinType
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|joinRel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
case|case
name|SELECT
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
case|case
name|UNION
case|:
specifier|final
name|RelNode
name|rel
init|=
name|convertQueryRecursive
argument_list|(
name|from
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|rel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
case|case
name|VALUES
case|:
name|convertValuesImpl
argument_list|(
name|bb
argument_list|,
operator|(
name|SqlCall
operator|)
name|from
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNNEST
case|:
specifier|final
name|SqlNode
name|node
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|from
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|replaceSubqueries
argument_list|(
name|bb
argument_list|,
name|node
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|childRel
init|=
name|CalcRel
operator|.
name|createProject
argument_list|(
operator|(
literal|null
operator|!=
name|bb
operator|.
name|root
operator|)
condition|?
name|bb
operator|.
name|root
else|:
operator|new
name|OneRowRel
argument_list|(
name|cluster
argument_list|)
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|validator
operator|.
name|deriveAlias
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|UncollectRel
name|uncollectRel
init|=
operator|new
name|UncollectRel
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|Convention
operator|.
name|NONE
argument_list|)
argument_list|,
name|childRel
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|uncollectRel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
case|case
name|COLLECTION_TABLE
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|from
expr_stmt|;
comment|// Dig out real call; TABLE() wrapper is just syntactic.
assert|assert
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
name|call
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|convertCollectionTable
argument_list|(
name|bb
argument_list|,
name|call
argument_list|)
expr_stmt|;
return|return;
default|default:
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"not a join operator "
operator|+
name|from
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|void
name|convertCollectionTable
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|operator
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|TABLESAMPLE
condition|)
block|{
specifier|final
name|String
name|sampleName
init|=
name|SqlLiteral
operator|.
name|stringValue
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|datasetStack
operator|.
name|push
argument_list|(
name|sampleName
argument_list|)
expr_stmt|;
name|SqlCall
name|cursorCall
init|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|SqlNode
name|query
init|=
name|cursorCall
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|converted
init|=
name|convertQuery
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|converted
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|datasetStack
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
name|replaceSubqueries
argument_list|(
name|bb
argument_list|,
name|call
argument_list|)
expr_stmt|;
comment|// Expand table macro if possible. It's more efficient than
comment|// TableFunctionRel.
if|if
condition|(
name|operator
operator|instanceof
name|SqlUserDefinedTableMacro
condition|)
block|{
specifier|final
name|SqlUserDefinedTableMacro
name|udf
init|=
operator|(
name|SqlUserDefinedTableMacro
operator|)
name|operator
decl_stmt|;
specifier|final
name|TranslatableTable
name|table
init|=
name|udf
operator|.
name|getTable
argument_list|(
name|typeFactory
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|table
operator|.
name|getRowType
argument_list|(
name|typeFactory
argument_list|)
decl_stmt|;
name|RelOptTable
name|relOptTable
init|=
name|RelOptTableImpl
operator|.
name|create
argument_list|(
literal|null
argument_list|,
name|rowType
argument_list|,
operator|(
name|TranslatableTable
operator|)
name|table
argument_list|)
decl_stmt|;
name|RelNode
name|converted
init|=
name|toRel
argument_list|(
name|relOptTable
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|converted
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|Type
name|elementType
decl_stmt|;
if|if
condition|(
name|operator
operator|instanceof
name|SqlUserDefinedTableFunction
condition|)
block|{
name|SqlUserDefinedTableFunction
name|udtf
init|=
operator|(
name|SqlUserDefinedTableFunction
operator|)
name|operator
decl_stmt|;
name|elementType
operator|=
name|udtf
operator|.
name|getElementType
argument_list|(
name|typeFactory
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elementType
operator|=
literal|null
expr_stmt|;
block|}
name|RexNode
name|rexCall
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|bb
operator|.
name|retrieveCursors
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|RelColumnMapping
argument_list|>
name|columnMappings
init|=
name|getColumnMappings
argument_list|(
name|operator
argument_list|)
decl_stmt|;
name|TableFunctionRel
name|callRel
init|=
operator|new
name|TableFunctionRel
argument_list|(
name|cluster
argument_list|,
name|inputs
argument_list|,
name|rexCall
argument_list|,
name|elementType
argument_list|,
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
argument_list|,
name|columnMappings
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|callRel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|afterTableFunction
argument_list|(
name|bb
argument_list|,
name|call
argument_list|,
name|callRel
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|afterTableFunction
parameter_list|(
name|SqlToRelConverter
operator|.
name|Blackboard
name|bb
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|TableFunctionRel
name|callRel
parameter_list|)
block|{
block|}
specifier|private
name|Set
argument_list|<
name|RelColumnMapping
argument_list|>
name|getColumnMappings
parameter_list|(
name|SqlOperator
name|op
parameter_list|)
block|{
name|SqlReturnTypeInference
name|rti
init|=
name|op
operator|.
name|getReturnTypeInference
argument_list|()
decl_stmt|;
if|if
condition|(
name|rti
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|rti
operator|instanceof
name|TableFunctionReturnTypeInference
condition|)
block|{
name|TableFunctionReturnTypeInference
name|tfrti
init|=
operator|(
name|TableFunctionReturnTypeInference
operator|)
name|rti
decl_stmt|;
return|return
name|tfrti
operator|.
name|getColumnMappings
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|protected
name|RelNode
name|createJoin
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|RelNode
name|leftRel
parameter_list|,
name|RelNode
name|rightRel
parameter_list|,
name|RexNode
name|joinCond
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|correlatedVariables
init|=
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|rightRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|joinCond
operator|==
literal|null
condition|)
block|{
name|joinCond
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|correlatedVariables
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
name|correlations
init|=
operator|new
name|ArrayList
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|correlName
range|:
name|correlatedVariables
control|)
block|{
name|DeferredLookup
name|lookup
init|=
name|mapCorrelToDeferred
operator|.
name|get
argument_list|(
name|correlName
argument_list|)
decl_stmt|;
name|RexFieldAccess
name|fieldAccess
init|=
name|lookup
operator|.
name|getFieldAccess
argument_list|(
name|correlName
argument_list|)
decl_stmt|;
name|String
name|originalRelName
init|=
name|lookup
operator|.
name|getOriginalRelName
argument_list|()
decl_stmt|;
name|String
name|originalFieldName
init|=
name|fieldAccess
operator|.
name|getField
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|int
index|[]
name|nsIndexes
init|=
block|{
operator|-
literal|1
block|}
decl_stmt|;
specifier|final
name|SqlValidatorScope
index|[]
name|ancestorScopes
init|=
block|{
literal|null
block|}
decl_stmt|;
name|SqlValidatorNamespace
name|foundNs
init|=
name|lookup
operator|.
name|bb
operator|.
name|scope
operator|.
name|resolve
argument_list|(
name|originalRelName
argument_list|,
name|ancestorScopes
argument_list|,
name|nsIndexes
argument_list|)
decl_stmt|;
assert|assert
name|foundNs
operator|!=
literal|null
assert|;
assert|assert
name|nsIndexes
operator|.
name|length
operator|==
literal|1
assert|;
name|int
name|childNamespaceIndex
init|=
name|nsIndexes
index|[
literal|0
index|]
decl_stmt|;
name|SqlValidatorScope
name|ancestorScope
init|=
name|ancestorScopes
index|[
literal|0
index|]
decl_stmt|;
name|boolean
name|correlInCurrentScope
init|=
name|ancestorScope
operator|==
name|bb
operator|.
name|scope
decl_stmt|;
if|if
condition|(
name|correlInCurrentScope
condition|)
block|{
name|int
name|namespaceOffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|childNamespaceIndex
operator|>
literal|0
condition|)
block|{
comment|// If not the first child, need to figure out the width
comment|// of output types from all the preceding namespaces
assert|assert
name|ancestorScope
operator|instanceof
name|ListScope
assert|;
name|List
argument_list|<
name|SqlValidatorNamespace
argument_list|>
name|children
init|=
operator|(
operator|(
name|ListScope
operator|)
name|ancestorScope
operator|)
operator|.
name|getChildren
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childNamespaceIndex
condition|;
name|i
operator|++
control|)
block|{
name|SqlValidatorNamespace
name|child
init|=
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|namespaceOffset
operator|+=
name|child
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
block|}
name|RelDataTypeField
name|field
init|=
name|catalogReader
operator|.
name|field
argument_list|(
name|foundNs
operator|.
name|getRowType
argument_list|()
argument_list|,
name|originalFieldName
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|namespaceOffset
operator|+
name|field
operator|.
name|getIndex
argument_list|()
decl_stmt|;
assert|assert
name|field
operator|.
name|getType
argument_list|()
operator|==
name|lookup
operator|.
name|getFieldAccess
argument_list|(
name|correlName
argument_list|)
operator|.
name|getField
argument_list|()
operator|.
name|getType
argument_list|()
assert|;
assert|assert
name|pos
operator|!=
operator|-
literal|1
assert|;
if|if
condition|(
name|bb
operator|.
name|mapRootRelToFieldProjection
operator|.
name|containsKey
argument_list|(
name|bb
operator|.
name|root
argument_list|)
condition|)
block|{
comment|// bb.root is an aggregate and only projects group by
comment|// keys.
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|exprProjection
init|=
name|bb
operator|.
name|mapRootRelToFieldProjection
operator|.
name|get
argument_list|(
name|bb
operator|.
name|root
argument_list|)
decl_stmt|;
comment|// subquery can reference group by keys projected from
comment|// the root of the outer relation.
if|if
condition|(
name|exprProjection
operator|.
name|containsKey
argument_list|(
name|pos
argument_list|)
condition|)
block|{
name|pos
operator|=
name|exprProjection
operator|.
name|get
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// correl not grouped
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Identifier '"
operator|+
name|originalRelName
operator|+
literal|"."
operator|+
name|originalFieldName
operator|+
literal|"' is not a group expr"
argument_list|)
throw|;
block|}
block|}
name|CorrelatorRel
operator|.
name|Correlation
name|newCorVar
init|=
operator|new
name|CorrelatorRel
operator|.
name|Correlation
argument_list|(
name|getCorrelOrdinal
argument_list|(
name|correlName
argument_list|)
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|correlations
operator|.
name|add
argument_list|(
name|newCorVar
argument_list|)
expr_stmt|;
name|mapFieldAccessToCorVar
operator|.
name|put
argument_list|(
name|fieldAccess
argument_list|,
name|newCorVar
argument_list|)
expr_stmt|;
name|RelNode
name|refRel
init|=
name|mapCorrelToRefRel
operator|.
name|get
argument_list|(
name|correlName
argument_list|)
decl_stmt|;
name|SortedSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
name|corVarList
decl_stmt|;
if|if
condition|(
operator|!
name|mapRefRelToCorVar
operator|.
name|containsKey
argument_list|(
name|refRel
argument_list|)
condition|)
block|{
name|corVarList
operator|=
operator|new
name|TreeSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|corVarList
operator|=
name|mapRefRelToCorVar
operator|.
name|get
argument_list|(
name|refRel
argument_list|)
expr_stmt|;
block|}
name|corVarList
operator|.
name|add
argument_list|(
name|newCorVar
argument_list|)
expr_stmt|;
name|mapRefRelToCorVar
operator|.
name|put
argument_list|(
name|refRel
argument_list|,
name|corVarList
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|correlations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|CorrelatorRel
name|rel
init|=
operator|new
name|CorrelatorRel
argument_list|(
name|rightRel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|joinCond
argument_list|,
name|correlations
argument_list|,
name|joinType
argument_list|)
decl_stmt|;
for|for
control|(
name|CorrelatorRel
operator|.
name|Correlation
name|correlation
range|:
name|correlations
control|)
block|{
name|mapCorVarToCorRel
operator|.
name|put
argument_list|(
name|correlation
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraLeftExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraRightExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|leftCount
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|rightCount
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|containsGet
argument_list|(
name|joinCond
argument_list|)
condition|)
block|{
name|joinCond
operator|=
name|pushDownJoinConditions
argument_list|(
name|joinCond
argument_list|,
name|leftCount
argument_list|,
name|rightCount
argument_list|,
name|extraLeftExprs
argument_list|,
name|extraRightExprs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|extraLeftExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|leftRel
operator|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|leftRel
argument_list|,
operator|new
name|AbstractList
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
name|leftCount
condition|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
expr|<
name|RexNode
operator|,
name|String
operator|>
name|of
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|index
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Pair
operator|.
expr|<
name|RexNode
operator|,
name|String
operator|>
name|of
argument_list|(
name|extraLeftExprs
operator|.
name|get
argument_list|(
name|index
operator|-
name|leftCount
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
block|}
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|extraRightExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|newLeftCount
init|=
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
name|rightRel
operator|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|rightRel
argument_list|,
operator|new
name|AbstractList
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rightCount
operator|+
name|extraRightExprs
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
name|rightCount
condition|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
expr|<
name|RexNode
operator|,
name|String
operator|>
name|of
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|index
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|RexUtil
operator|.
name|shift
argument_list|(
name|extraRightExprs
operator|.
name|get
argument_list|(
name|index
operator|-
name|rightCount
argument_list|)
argument_list|,
operator|-
name|newLeftCount
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
block|}
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|join
init|=
name|createJoin
argument_list|(
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|joinCond
argument_list|,
name|joinType
argument_list|,
name|ImmutableSet
operator|.
expr|<
name|String
operator|>
name|of
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|extraLeftExprs
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|extraRightExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Mappings
operator|.
name|createShiftMapping
argument_list|(
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
operator|+
name|rightCount
operator|+
name|extraRightExprs
operator|.
name|size
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|leftCount
argument_list|,
name|leftCount
argument_list|,
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
argument_list|,
name|rightCount
argument_list|)
decl_stmt|;
return|return
name|RelOptUtil
operator|.
name|project
argument_list|(
name|join
argument_list|,
name|mapping
argument_list|)
return|;
block|}
return|return
name|join
return|;
block|}
specifier|private
specifier|static
name|boolean
name|containsGet
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
try|try
block|{
name|node
operator|.
name|accept
argument_list|(
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|RexBuilder
operator|.
name|GET_OPERATOR
condition|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Pushes down parts of a join condition. For example, given    * "emp JOIN dept ON emp.deptno + 1 = dept.deptno", adds a project above    * "emp" that computes the expression    * "emp.deptno + 1". The resulting join condition is a simple combination    * of AND, equals, and input fields.    */
specifier|private
name|RexNode
name|pushDownJoinConditions
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|int
name|leftCount
parameter_list|,
name|int
name|rightCount
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraLeftExprs
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraRightExprs
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
case|case
name|OR
case|:
case|case
name|EQUALS
case|:
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|operand
init|=
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|left2
init|=
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|right2
init|=
name|rightCount
operator|+
name|extraRightExprs
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|e
init|=
name|pushDownJoinConditions
argument_list|(
name|operand
argument_list|,
name|leftCount
argument_list|,
name|rightCount
argument_list|,
name|extraLeftExprs
argument_list|,
name|extraRightExprs
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|remainingOperands
init|=
name|Util
operator|.
name|skip
argument_list|(
name|operands
argument_list|,
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|int
name|left3
init|=
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|right3
init|=
name|rightCount
operator|+
name|extraRightExprs
operator|.
name|size
argument_list|()
decl_stmt|;
name|fix
argument_list|(
name|remainingOperands
argument_list|,
name|left2
argument_list|,
name|left3
argument_list|)
expr_stmt|;
name|fix
argument_list|(
name|list
argument_list|,
name|left2
argument_list|,
name|left3
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|list
operator|.
name|equals
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|call
operator|.
name|clone
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|list
argument_list|)
return|;
block|}
return|return
name|call
return|;
case|case
name|INPUT_REF
case|:
case|case
name|LITERAL
case|:
return|return
name|node
return|;
default|default:
name|BitSet
name|bits
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|final
name|int
name|mid
init|=
name|leftCount
operator|+
name|extraLeftExprs
operator|.
name|size
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|Side
operator|.
name|of
argument_list|(
name|bits
argument_list|,
name|mid
argument_list|)
condition|)
block|{
case|case
name|LEFT
case|:
name|fix
argument_list|(
name|extraRightExprs
argument_list|,
name|mid
argument_list|,
name|mid
operator|+
literal|1
argument_list|)
expr_stmt|;
name|extraLeftExprs
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|mid
argument_list|,
name|node
operator|.
name|getType
argument_list|()
argument_list|)
return|;
case|case
name|RIGHT
case|:
specifier|final
name|int
name|index2
init|=
name|mid
operator|+
name|rightCount
operator|+
name|extraRightExprs
operator|.
name|size
argument_list|()
decl_stmt|;
name|extraRightExprs
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|index2
argument_list|,
name|node
operator|.
name|getType
argument_list|()
argument_list|)
return|;
case|case
name|BOTH
case|:
case|case
name|EMPTY
case|:
default|default:
return|return
name|node
return|;
block|}
block|}
block|}
specifier|private
name|void
name|fix
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|,
name|int
name|before
parameter_list|,
name|int
name|after
parameter_list|)
block|{
if|if
condition|(
name|before
operator|==
name|after
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|node
init|=
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|operands
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|RexUtil
operator|.
name|shift
argument_list|(
name|node
argument_list|,
name|before
argument_list|,
name|after
operator|-
name|before
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Categorizes whether a bit set contains bits left and right of a    * line.    */
enum|enum
name|Side
block|{
name|LEFT
block|,
name|RIGHT
block|,
name|BOTH
block|,
name|EMPTY
block|;
specifier|static
name|Side
name|of
parameter_list|(
name|BitSet
name|bitSet
parameter_list|,
name|int
name|middle
parameter_list|)
block|{
specifier|final
name|int
name|firstBit
init|=
name|bitSet
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstBit
operator|<
literal|0
condition|)
block|{
return|return
name|EMPTY
return|;
block|}
if|if
condition|(
name|firstBit
operator|>=
name|middle
condition|)
block|{
return|return
name|RIGHT
return|;
block|}
if|if
condition|(
name|bitSet
operator|.
name|nextSetBit
argument_list|(
name|middle
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|LEFT
return|;
block|}
return|return
name|BOTH
return|;
block|}
block|}
comment|/**    * Determines whether a subquery is non-correlated. Note that a    * non-correlated subquery can contain correlated references, provided those    * references do not reference select statements that are parents of the    * subquery.    *    * @param subq the subquery    * @param bb   blackboard used while converting the subquery, i.e., the    *             blackboard of the parent query of this subquery    * @return true if the subquery is non-correlated.    */
specifier|private
name|boolean
name|isSubqNonCorrelated
parameter_list|(
name|RelNode
name|subq
parameter_list|,
name|Blackboard
name|bb
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|correlatedVariables
init|=
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|subq
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|correlName
range|:
name|correlatedVariables
control|)
block|{
name|DeferredLookup
name|lookup
init|=
name|mapCorrelToDeferred
operator|.
name|get
argument_list|(
name|correlName
argument_list|)
decl_stmt|;
name|String
name|originalRelName
init|=
name|lookup
operator|.
name|getOriginalRelName
argument_list|()
decl_stmt|;
name|int
index|[]
name|nsIndexes
init|=
block|{
operator|-
literal|1
block|}
decl_stmt|;
specifier|final
name|SqlValidatorScope
index|[]
name|ancestorScopes
init|=
block|{
literal|null
block|}
decl_stmt|;
name|SqlValidatorNamespace
name|foundNs
init|=
name|lookup
operator|.
name|bb
operator|.
name|scope
operator|.
name|resolve
argument_list|(
name|originalRelName
argument_list|,
name|ancestorScopes
argument_list|,
name|nsIndexes
argument_list|)
decl_stmt|;
assert|assert
name|foundNs
operator|!=
literal|null
assert|;
assert|assert
name|nsIndexes
operator|.
name|length
operator|==
literal|1
assert|;
name|SqlValidatorScope
name|ancestorScope
init|=
name|ancestorScopes
index|[
literal|0
index|]
decl_stmt|;
comment|// If the correlated reference is in a scope that's "above" the
comment|// subquery, then this is a correlated subquery.
name|SqlValidatorScope
name|parentScope
init|=
name|bb
operator|.
name|scope
decl_stmt|;
do|do
block|{
if|if
condition|(
name|ancestorScope
operator|==
name|parentScope
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|parentScope
operator|instanceof
name|DelegatingScope
condition|)
block|{
name|parentScope
operator|=
operator|(
operator|(
name|DelegatingScope
operator|)
name|parentScope
operator|)
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
do|while
condition|(
name|parentScope
operator|!=
literal|null
condition|)
do|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns a list of fields to be prefixed to each relational expression.    *    * @return List of system fields    */
specifier|protected
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|getSystemFields
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
specifier|private
name|RexNode
name|convertJoinCondition
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlNode
name|condition
parameter_list|,
name|JoinConditionType
name|conditionType
parameter_list|,
name|RelNode
name|leftRel
parameter_list|,
name|RelNode
name|rightRel
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
block|}
name|bb
operator|.
name|setRoot
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|leftRel
argument_list|,
name|rightRel
argument_list|)
argument_list|)
expr_stmt|;
name|replaceSubqueries
argument_list|(
name|bb
argument_list|,
name|condition
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|conditionType
condition|)
block|{
case|case
name|ON
case|:
name|bb
operator|.
name|setRoot
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|leftRel
argument_list|,
name|rightRel
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bb
operator|.
name|convertExpression
argument_list|(
name|condition
argument_list|)
return|;
case|case
name|USING
case|:
name|SqlNodeList
name|list
init|=
operator|(
name|SqlNodeList
operator|)
name|condition
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|nameList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|columnName
range|:
name|list
control|)
block|{
specifier|final
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|columnName
decl_stmt|;
name|String
name|name
init|=
name|id
operator|.
name|getSimple
argument_list|()
decl_stmt|;
name|nameList
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|convertUsing
argument_list|(
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|nameList
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|conditionType
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns an expression for matching columns of a USING clause or inferred    * from NATURAL JOIN. "a JOIN b USING (x, y)" becomes "a.x = b.x AND a.y =    * b.y". Returns null if the column list is empty.    *    * @param leftRel  Left input to the join    * @param rightRel Right input to the join    * @param nameList List of column names to join on    * @return Expression to match columns from name list, or null if name list    * is empty    */
specifier|private
name|RexNode
name|convertUsing
parameter_list|(
name|RelNode
name|leftRel
parameter_list|,
name|RelNode
name|rightRel
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|)
block|{
name|RexNode
name|conditionExp
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|nameList
control|)
block|{
specifier|final
name|RelDataType
name|leftRowType
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|RelDataTypeField
name|leftField
init|=
name|catalogReader
operator|.
name|field
argument_list|(
name|leftRowType
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|RexNode
name|left
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|leftField
operator|.
name|getType
argument_list|()
argument_list|,
name|leftField
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rightRowType
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|RelDataTypeField
name|rightField
init|=
name|catalogReader
operator|.
name|field
argument_list|(
name|rightRowType
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|RexNode
name|right
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|rightField
operator|.
name|getType
argument_list|()
argument_list|,
name|leftRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
operator|+
name|rightField
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|equalsCall
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|conditionExp
operator|==
literal|null
condition|)
block|{
name|conditionExp
operator|=
name|equalsCall
expr_stmt|;
block|}
else|else
block|{
name|conditionExp
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|conditionExp
argument_list|,
name|equalsCall
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|conditionExp
return|;
block|}
specifier|private
specifier|static
name|JoinRelType
name|convertJoinType
parameter_list|(
name|JoinType
name|joinType
parameter_list|)
block|{
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|COMMA
case|:
case|case
name|INNER
case|:
case|case
name|CROSS
case|:
return|return
name|JoinRelType
operator|.
name|INNER
return|;
case|case
name|FULL
case|:
return|return
name|JoinRelType
operator|.
name|FULL
return|;
case|case
name|LEFT
case|:
return|return
name|JoinRelType
operator|.
name|LEFT
return|;
case|case
name|RIGHT
case|:
return|return
name|JoinRelType
operator|.
name|RIGHT
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|joinType
argument_list|)
throw|;
block|}
block|}
comment|/**    * Converts the SELECT, GROUP BY and HAVING clauses of an aggregate query.    *    *<p>This method extracts SELECT, GROUP BY and HAVING clauses, and creates    * an {@link AggConverter}, then delegates to {@link #createAggImpl}.    * Derived class may override this method to change any of those clauses or    * specify a different {@link AggConverter}.    *    * @param bb            Scope within which to resolve identifiers    * @param select        Query    * @param orderExprList Additional expressions needed to implement ORDER BY    */
specifier|protected
name|void
name|convertAgg
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderExprList
parameter_list|)
block|{
assert|assert
name|bb
operator|.
name|root
operator|!=
literal|null
operator|:
literal|"precondition: child != null"
assert|;
name|SqlNodeList
name|groupList
init|=
name|select
operator|.
name|getGroup
argument_list|()
decl_stmt|;
name|SqlNodeList
name|selectList
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
name|SqlNode
name|having
init|=
name|select
operator|.
name|getHaving
argument_list|()
decl_stmt|;
specifier|final
name|AggConverter
name|aggConverter
init|=
operator|new
name|AggConverter
argument_list|(
name|bb
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|createAggImpl
argument_list|(
name|bb
argument_list|,
name|aggConverter
argument_list|,
name|selectList
argument_list|,
name|groupList
argument_list|,
name|having
argument_list|,
name|orderExprList
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|final
name|void
name|createAggImpl
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|AggConverter
name|aggConverter
parameter_list|,
name|SqlNodeList
name|selectList
parameter_list|,
name|SqlNodeList
name|groupList
parameter_list|,
name|SqlNode
name|having
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderExprList
parameter_list|)
block|{
name|SqlNodeList
name|aggList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlNode
name|selectNode
range|:
name|selectList
control|)
block|{
if|if
condition|(
name|validator
operator|.
name|isAggregate
argument_list|(
name|selectNode
argument_list|)
condition|)
block|{
name|aggList
operator|.
name|add
argument_list|(
name|selectNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|// first replace the subqueries inside the aggregates
comment|// because they will provide input rows to the aggregates.
name|replaceSubqueries
argument_list|(
name|bb
argument_list|,
name|aggList
argument_list|)
expr_stmt|;
comment|// If group-by clause is missing, pretend that it has zero elements.
if|if
condition|(
name|groupList
operator|==
literal|null
condition|)
block|{
name|groupList
operator|=
name|SqlNodeList
operator|.
name|EMPTY
expr_stmt|;
block|}
comment|// register the group exprs
comment|// build a map to remember the projections from the top scope to the
comment|// output of the current root.
comment|//
comment|// Currently farrago allows expressions, not just column references in
comment|// group by list. This is not SQL 2003 compliant.
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|groupExprProjection
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|SqlNode
name|groupExpr
range|:
name|groupList
control|)
block|{
operator|++
name|i
expr_stmt|;
specifier|final
name|SqlNode
name|expandedGroupExpr
init|=
name|validator
operator|.
name|expand
argument_list|(
name|groupExpr
argument_list|,
name|bb
operator|.
name|scope
argument_list|)
decl_stmt|;
name|aggConverter
operator|.
name|addGroupExpr
argument_list|(
name|expandedGroupExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expandedGroupExpr
operator|instanceof
name|SqlIdentifier
condition|)
block|{
comment|// SQL 2003 does not allow expressions of column references
name|SqlIdentifier
name|expr
init|=
operator|(
name|SqlIdentifier
operator|)
name|expandedGroupExpr
decl_stmt|;
comment|// column references should be fully qualified.
assert|assert
name|expr
operator|.
name|names
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
name|String
name|originalRelName
init|=
name|expr
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|originalFieldName
init|=
name|expr
operator|.
name|names
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
index|[]
name|nsIndexes
init|=
block|{
operator|-
literal|1
block|}
decl_stmt|;
specifier|final
name|SqlValidatorScope
index|[]
name|ancestorScopes
init|=
block|{
literal|null
block|}
decl_stmt|;
name|SqlValidatorNamespace
name|foundNs
init|=
name|bb
operator|.
name|scope
operator|.
name|resolve
argument_list|(
name|originalRelName
argument_list|,
name|ancestorScopes
argument_list|,
name|nsIndexes
argument_list|)
decl_stmt|;
assert|assert
name|foundNs
operator|!=
literal|null
assert|;
assert|assert
name|nsIndexes
operator|.
name|length
operator|==
literal|1
assert|;
name|int
name|childNamespaceIndex
init|=
name|nsIndexes
index|[
literal|0
index|]
decl_stmt|;
name|int
name|namespaceOffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|childNamespaceIndex
operator|>
literal|0
condition|)
block|{
comment|// If not the first child, need to figure out the width of
comment|// output types from all the preceding namespaces
assert|assert
name|ancestorScopes
index|[
literal|0
index|]
operator|instanceof
name|ListScope
assert|;
name|List
argument_list|<
name|SqlValidatorNamespace
argument_list|>
name|children
init|=
operator|(
operator|(
name|ListScope
operator|)
name|ancestorScopes
index|[
literal|0
index|]
operator|)
operator|.
name|getChildren
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|childNamespaceIndex
condition|;
name|j
operator|++
control|)
block|{
name|namespaceOffset
operator|+=
name|children
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
block|}
name|RelDataTypeField
name|field
init|=
name|catalogReader
operator|.
name|field
argument_list|(
name|foundNs
operator|.
name|getRowType
argument_list|()
argument_list|,
name|originalFieldName
argument_list|)
decl_stmt|;
name|int
name|origPos
init|=
name|namespaceOffset
operator|+
name|field
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|groupExprProjection
operator|.
name|put
argument_list|(
name|origPos
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|RexNode
name|havingExpr
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|selectExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|selectNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|Util
operator|.
name|permAssert
argument_list|(
name|bb
operator|.
name|agg
operator|==
literal|null
argument_list|,
literal|"already in agg mode"
argument_list|)
expr_stmt|;
name|bb
operator|.
name|agg
operator|=
name|aggConverter
expr_stmt|;
comment|// convert the select and having expressions, so that the
comment|// agg converter knows which aggregations are required
name|selectList
operator|.
name|accept
argument_list|(
name|aggConverter
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|expr
range|:
name|orderExprList
control|)
block|{
name|expr
operator|.
name|accept
argument_list|(
name|aggConverter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|having
operator|!=
literal|null
condition|)
block|{
name|having
operator|.
name|accept
argument_list|(
name|aggConverter
argument_list|)
expr_stmt|;
block|}
comment|// compute inputs to the aggregator
name|List
argument_list|<
name|RexNode
argument_list|>
name|preExprs
init|=
name|aggConverter
operator|.
name|getPreExprs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|preNames
init|=
name|aggConverter
operator|.
name|getPreNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|preExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Special case for COUNT(*), where we can end up with no inputs
comment|// at all.  The rest of the system doesn't like 0-tuples, so we
comment|// select a dummy constant here.
name|preExprs
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
operator|(
name|RexNode
operator|)
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|preNames
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|inputRel
init|=
name|bb
operator|.
name|root
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|correlatedVariablesBefore
init|=
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|inputRel
argument_list|)
decl_stmt|;
comment|// Project the expressions required by agg and having.
name|bb
operator|.
name|setRoot
argument_list|(
name|CalcRel
operator|.
name|createProject
argument_list|(
name|inputRel
argument_list|,
name|preExprs
argument_list|,
name|preNames
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|bb
operator|.
name|mapRootRelToFieldProjection
operator|.
name|put
argument_list|(
name|bb
operator|.
name|root
argument_list|,
name|groupExprProjection
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|correlatedVariables
init|=
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|bb
operator|.
name|root
argument_list|)
decl_stmt|;
name|correlatedVariables
operator|.
name|removeAll
argument_list|(
name|correlatedVariablesBefore
argument_list|)
expr_stmt|;
comment|// Associate the correlated variables with the new project rel.
for|for
control|(
name|String
name|correl
range|:
name|correlatedVariables
control|)
block|{
name|mapCorrelToRefRel
operator|.
name|put
argument_list|(
name|correl
argument_list|,
name|bb
operator|.
name|root
argument_list|)
expr_stmt|;
block|}
comment|// REVIEW jvs 31-Oct-2007:  doesn't the declaration of
comment|// monotonicity here assume sort-based aggregation at
comment|// the physical level?
comment|// Tell bb which of group columns are sorted.
name|bb
operator|.
name|columnMonotonicities
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|SqlNode
name|groupItem
range|:
name|groupList
control|)
block|{
name|bb
operator|.
name|columnMonotonicities
operator|.
name|add
argument_list|(
name|bb
operator|.
name|scope
operator|.
name|getMonotonicity
argument_list|(
name|groupItem
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Add the aggregator
name|bb
operator|.
name|setRoot
argument_list|(
name|createAggregate
argument_list|(
name|bb
argument_list|,
name|BitSets
operator|.
name|range
argument_list|(
name|aggConverter
operator|.
name|groupExprs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|aggConverter
operator|.
name|getAggCalls
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|bb
operator|.
name|mapRootRelToFieldProjection
operator|.
name|put
argument_list|(
name|bb
operator|.
name|root
argument_list|,
name|groupExprProjection
argument_list|)
expr_stmt|;
comment|// Replace subqueries in having here and modify having to use
comment|// the replaced expressions
if|if
condition|(
name|having
operator|!=
literal|null
condition|)
block|{
name|SqlNode
name|newHaving
init|=
name|pushDownNotForIn
argument_list|(
name|having
argument_list|)
decl_stmt|;
name|replaceSubqueries
argument_list|(
name|bb
argument_list|,
name|newHaving
argument_list|)
expr_stmt|;
name|havingExpr
operator|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|newHaving
argument_list|)
expr_stmt|;
if|if
condition|(
name|havingExpr
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|havingExpr
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Now convert the other subqueries in the select list.
comment|// This needs to be done separately from the subquery inside
comment|// any aggregate in the select list, and after the aggregate rel
comment|// is allocated.
name|replaceSubqueries
argument_list|(
name|bb
argument_list|,
name|selectList
argument_list|)
expr_stmt|;
comment|// Now subqueries in the entire select list have been converted.
comment|// Convert the select expressions to get the final list to be
comment|// projected.
name|int
name|k
init|=
literal|0
decl_stmt|;
comment|// For select expressions, use the field names previously assigned
comment|// by the validator. If we derive afresh, we might generate names
comment|// like "EXPR$2" that don't match the names generated by the
comment|// validator. This is especially the case when there are system
comment|// fields; system fields appear in the relnode's rowtype but do not
comment|// (yet) appear in the validator type.
specifier|final
name|SelectScope
name|selectScope
init|=
name|SqlValidatorUtil
operator|.
name|getEnclosingSelectScope
argument_list|(
name|bb
operator|.
name|scope
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|selectNamespace
init|=
name|validator
operator|.
name|getNamespace
argument_list|(
name|selectScope
operator|.
name|getNode
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|selectNamespace
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
name|int
name|sysFieldCount
init|=
name|selectList
operator|.
name|size
argument_list|()
operator|-
name|names
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|expr
range|:
name|selectList
control|)
block|{
name|selectExprs
operator|.
name|add
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|selectNames
operator|.
name|add
argument_list|(
name|k
operator|<
name|sysFieldCount
condition|?
name|validator
operator|.
name|deriveAlias
argument_list|(
name|expr
argument_list|,
name|k
operator|++
argument_list|)
else|:
name|names
operator|.
name|get
argument_list|(
name|k
operator|++
operator|-
name|sysFieldCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SqlNode
name|expr
range|:
name|orderExprList
control|)
block|{
name|selectExprs
operator|.
name|add
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|selectNames
operator|.
name|add
argument_list|(
name|validator
operator|.
name|deriveAlias
argument_list|(
name|expr
argument_list|,
name|k
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|bb
operator|.
name|agg
operator|=
literal|null
expr_stmt|;
block|}
comment|// implement HAVING (we have already checked that it is non-trivial)
if|if
condition|(
name|havingExpr
operator|!=
literal|null
condition|)
block|{
name|bb
operator|.
name|setRoot
argument_list|(
name|CalcRel
operator|.
name|createFilter
argument_list|(
name|bb
operator|.
name|root
argument_list|,
name|havingExpr
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// implement the SELECT list
name|bb
operator|.
name|setRoot
argument_list|(
name|CalcRel
operator|.
name|createProject
argument_list|(
name|bb
operator|.
name|root
argument_list|,
name|selectExprs
argument_list|,
name|selectNames
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Tell bb which of group columns are sorted.
name|bb
operator|.
name|columnMonotonicities
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|SqlNode
name|selectItem
range|:
name|selectList
control|)
block|{
name|bb
operator|.
name|columnMonotonicities
operator|.
name|add
argument_list|(
name|bb
operator|.
name|scope
operator|.
name|getMonotonicity
argument_list|(
name|selectItem
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates an AggregateRel.    *    *<p>In case the aggregate rel changes the order in which it projects    * fields, the<code>groupExprProjection</code> parameter is provided, and    * the implementation of this method may modify it.    *    *<p>The<code>sortedCount</code> parameter is the number of expressions    * known to be monotonic. These expressions must be on the leading edge of    * the grouping keys. The default implementation of this method ignores this    * parameter.    *    * @param bb       Blackboard    * @param groupSet Bit set of ordinals of grouping columns    * @param aggCalls Array of calls to aggregate functions    * @return AggregateRel    */
specifier|protected
name|RelNode
name|createAggregate
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|BitSet
name|groupSet
parameter_list|,
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
parameter_list|)
block|{
return|return
operator|new
name|AggregateRel
argument_list|(
name|cluster
argument_list|,
name|bb
operator|.
name|root
argument_list|,
name|groupSet
argument_list|,
name|aggCalls
argument_list|)
return|;
block|}
specifier|public
name|RexDynamicParam
name|convertDynamicParam
parameter_list|(
specifier|final
name|SqlDynamicParam
name|dynamicParam
parameter_list|)
block|{
comment|// REVIEW jvs 8-Jan-2005:  dynamic params may be encountered out of
comment|// order.  Should probably cross-check with the count from the parser
comment|// at the end and make sure they all got filled in.  Why doesn't List
comment|// have a resize() method?!?  Make this a utility.
while|while
condition|(
name|dynamicParam
operator|.
name|getIndex
argument_list|()
operator|>=
name|dynamicParamSqlNodes
operator|.
name|size
argument_list|()
condition|)
block|{
name|dynamicParamSqlNodes
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|dynamicParamSqlNodes
operator|.
name|set
argument_list|(
name|dynamicParam
operator|.
name|getIndex
argument_list|()
argument_list|,
name|dynamicParam
argument_list|)
expr_stmt|;
return|return
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|getDynamicParamType
argument_list|(
name|dynamicParam
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|,
name|dynamicParam
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a list of collations required to implement the ORDER BY clause,    * if there is one. Populates<code>extraOrderExprs</code> with any sort    * expressions which are not in the select clause.    *    * @param bb              Scope within which to resolve identifiers    * @param select          Select clause. Never null, because we invent a    *                        dummy SELECT if ORDER BY is applied to a set    *                        operation (UNION etc.)    * @param orderList       Order by clause, may be null    * @param extraOrderExprs Sort expressions which are not in the select    *                        clause (output)    * @param collationList   List of collations (output)    */
specifier|protected
name|void
name|gatherOrderExprs
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|SqlNodeList
name|orderList
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|extraOrderExprs
parameter_list|,
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|collationList
parameter_list|)
block|{
comment|// TODO:  add validation rules to SqlValidator also
assert|assert
name|bb
operator|.
name|root
operator|!=
literal|null
operator|:
literal|"precondition: child != null"
assert|;
assert|assert
name|select
operator|!=
literal|null
assert|;
if|if
condition|(
name|orderList
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|SqlNode
name|orderItem
range|:
name|orderList
control|)
block|{
name|collationList
operator|.
name|add
argument_list|(
name|convertOrderItem
argument_list|(
name|select
argument_list|,
name|orderItem
argument_list|,
name|extraOrderExprs
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|ASCENDING
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|RelFieldCollation
name|convertOrderItem
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlNode
name|orderItem
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|extraExprs
parameter_list|,
name|RelFieldCollation
operator|.
name|Direction
name|direction
parameter_list|,
name|RelFieldCollation
operator|.
name|NullDirection
name|nullDirection
parameter_list|)
block|{
assert|assert
name|select
operator|!=
literal|null
assert|;
comment|// Handle DESC keyword, e.g. 'select a, b from t order by a desc'.
switch|switch
condition|(
name|orderItem
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
return|return
name|convertOrderItem
argument_list|(
name|select
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|orderItem
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|extraExprs
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
argument_list|,
name|nullDirection
argument_list|)
return|;
case|case
name|NULLS_FIRST
case|:
return|return
name|convertOrderItem
argument_list|(
name|select
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|orderItem
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|extraExprs
argument_list|,
name|direction
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
argument_list|)
return|;
case|case
name|NULLS_LAST
case|:
return|return
name|convertOrderItem
argument_list|(
name|select
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|orderItem
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|extraExprs
argument_list|,
name|direction
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
argument_list|)
return|;
block|}
name|SqlNode
name|converted
init|=
name|validator
operator|.
name|expandOrderExpr
argument_list|(
name|select
argument_list|,
name|orderItem
argument_list|)
decl_stmt|;
comment|// Scan the select list and order exprs for an identical expression.
specifier|final
name|SelectScope
name|selectScope
init|=
name|validator
operator|.
name|getRawSelectScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|int
name|ordinal
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|SqlNode
name|selectItem
range|:
name|selectScope
operator|.
name|getExpandedSelectList
argument_list|()
control|)
block|{
operator|++
name|ordinal
expr_stmt|;
if|if
condition|(
name|converted
operator|.
name|equalsDeep
argument_list|(
name|stripAs
argument_list|(
name|selectItem
argument_list|)
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
operator|new
name|RelFieldCollation
argument_list|(
name|ordinal
argument_list|,
name|direction
argument_list|,
name|nullDirection
argument_list|)
return|;
block|}
block|}
for|for
control|(
name|SqlNode
name|extraExpr
range|:
name|extraExprs
control|)
block|{
operator|++
name|ordinal
expr_stmt|;
if|if
condition|(
name|converted
operator|.
name|equalsDeep
argument_list|(
name|extraExpr
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
operator|new
name|RelFieldCollation
argument_list|(
name|ordinal
argument_list|,
name|direction
argument_list|,
name|nullDirection
argument_list|)
return|;
block|}
block|}
comment|// TODO:  handle collation sequence
comment|// TODO: flag expressions as non-standard
name|extraExprs
operator|.
name|add
argument_list|(
name|converted
argument_list|)
expr_stmt|;
return|return
operator|new
name|RelFieldCollation
argument_list|(
name|ordinal
operator|+
literal|1
argument_list|,
name|direction
argument_list|,
name|nullDirection
argument_list|)
return|;
block|}
specifier|protected
name|boolean
name|enableDecorrelation
parameter_list|()
block|{
comment|// disable subquery decorrelation when needed.
comment|// e.g. if outer joins are not supported.
return|return
name|decorrelationEnabled
return|;
block|}
comment|/**    * Returns whether there are any correlating variables in this statement.    *    * @return whether there are any correlating variables    */
specifier|public
name|boolean
name|hasCorrelation
parameter_list|()
block|{
return|return
operator|!
name|mapCorVarToCorRel
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|protected
name|RelNode
name|decorrelateQuery
parameter_list|(
name|RelNode
name|rootRel
parameter_list|)
block|{
name|RelDecorrelator
name|decorrelator
init|=
operator|new
name|RelDecorrelator
argument_list|(
name|rexBuilder
argument_list|,
name|mapRefRelToCorVar
argument_list|,
name|mapCorVarToCorRel
argument_list|,
name|mapFieldAccessToCorVar
argument_list|,
name|cluster
operator|.
name|getPlanner
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|dumpPlan
init|=
name|SQL2REL_LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
decl_stmt|;
name|RelNode
name|newRootRel
init|=
name|decorrelator
operator|.
name|removeCorrelationViaRule
argument_list|(
name|rootRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|dumpPlan
condition|)
block|{
name|SQL2REL_LOGGER
operator|.
name|fine
argument_list|(
name|RelOptUtil
operator|.
name|dumpPlan
argument_list|(
literal|"Plan after removing CorrelatorRel"
argument_list|,
name|newRootRel
argument_list|,
literal|false
argument_list|,
name|SqlExplainLevel
operator|.
name|EXPPLAN_ATTRIBUTES
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mapCorVarToCorRel
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newRootRel
operator|=
name|decorrelator
operator|.
name|decorrelate
argument_list|(
name|newRootRel
argument_list|)
expr_stmt|;
block|}
return|return
name|newRootRel
return|;
block|}
comment|/**    * Sets whether to trim unused fields as part of the conversion process.    *    * @param trim Whether to trim unused fields    */
specifier|public
name|void
name|setTrimUnusedFields
parameter_list|(
name|boolean
name|trim
parameter_list|)
block|{
name|this
operator|.
name|trimUnusedFields
operator|=
name|trim
expr_stmt|;
block|}
comment|/**    * Returns whether to trim unused fields as part of the conversion process.    *    * @return Whether to trim unused fields    */
specifier|public
name|boolean
name|isTrimUnusedFields
parameter_list|()
block|{
return|return
name|trimUnusedFields
return|;
block|}
comment|/**    * Recursively converts a query to a relational expression.    *    * @param query         Query    * @param top           Whether this query is the top-level query of the    *                      statement    * @param targetRowType Target row type, or null    * @return Relational expression    */
specifier|protected
name|RelNode
name|convertQueryRecursive
parameter_list|(
name|SqlNode
name|query
parameter_list|,
name|boolean
name|top
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|)
block|{
switch|switch
condition|(
name|query
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|SELECT
case|:
return|return
name|convertSelect
argument_list|(
operator|(
name|SqlSelect
operator|)
name|query
argument_list|)
return|;
case|case
name|INSERT
case|:
return|return
name|convertInsert
argument_list|(
operator|(
name|SqlInsert
operator|)
name|query
argument_list|)
return|;
case|case
name|DELETE
case|:
return|return
name|convertDelete
argument_list|(
operator|(
name|SqlDelete
operator|)
name|query
argument_list|)
return|;
case|case
name|UPDATE
case|:
return|return
name|convertUpdate
argument_list|(
operator|(
name|SqlUpdate
operator|)
name|query
argument_list|)
return|;
case|case
name|MERGE
case|:
return|return
name|convertMerge
argument_list|(
operator|(
name|SqlMerge
operator|)
name|query
argument_list|)
return|;
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
return|return
name|convertSetOp
argument_list|(
operator|(
name|SqlCall
operator|)
name|query
argument_list|)
return|;
case|case
name|WITH
case|:
return|return
name|convertWith
argument_list|(
operator|(
name|SqlWith
operator|)
name|query
argument_list|)
return|;
case|case
name|VALUES
case|:
return|return
name|convertValues
argument_list|(
operator|(
name|SqlCall
operator|)
name|query
argument_list|,
name|targetRowType
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"not a query: "
operator|+
name|query
argument_list|)
throw|;
block|}
block|}
comment|/**    * Converts a set operation (UNION, INTERSECT, MINUS) into relational    * expressions.    *    * @param call Call to set operator    * @return Relational expression    */
specifier|protected
name|RelNode
name|convertSetOp
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RelNode
name|left
init|=
name|convertQueryRecursive
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|right
init|=
name|convertQueryRecursive
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|boolean
name|all
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlSetOperator
condition|)
block|{
name|all
operator|=
operator|(
operator|(
name|SqlSetOperator
operator|)
operator|(
name|call
operator|.
name|getOperator
argument_list|()
operator|)
operator|)
operator|.
name|isAll
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|UNION
case|:
return|return
operator|new
name|UnionRel
argument_list|(
name|cluster
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|,
name|all
argument_list|)
return|;
case|case
name|INTERSECT
case|:
comment|// TODO:  all
if|if
condition|(
operator|!
name|all
condition|)
block|{
return|return
operator|new
name|IntersectRel
argument_list|(
name|cluster
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|,
name|all
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"set operator INTERSECT ALL not suported"
argument_list|)
throw|;
block|}
case|case
name|EXCEPT
case|:
comment|// TODO:  all
if|if
condition|(
operator|!
name|all
condition|)
block|{
return|return
operator|new
name|MinusRel
argument_list|(
name|cluster
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|,
name|all
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"set operator EXCEPT ALL not suported"
argument_list|)
throw|;
block|}
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|call
operator|.
name|getKind
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|RelNode
name|convertInsert
parameter_list|(
name|SqlInsert
name|call
parameter_list|)
block|{
name|RelOptTable
name|targetTable
init|=
name|getTargetTable
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|targetRowType
init|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
assert|assert
name|targetRowType
operator|!=
literal|null
assert|;
name|RelNode
name|sourceRel
init|=
name|convertQueryRecursive
argument_list|(
name|call
operator|.
name|getSource
argument_list|()
argument_list|,
literal|false
argument_list|,
name|targetRowType
argument_list|)
decl_stmt|;
name|RelNode
name|massagedRel
init|=
name|convertColumnList
argument_list|(
name|call
argument_list|,
name|sourceRel
argument_list|)
decl_stmt|;
specifier|final
name|ModifiableTable
name|modifiableTable
init|=
name|targetTable
operator|.
name|unwrap
argument_list|(
name|ModifiableTable
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifiableTable
operator|!=
literal|null
condition|)
block|{
return|return
name|modifiableTable
operator|.
name|toModificationRel
argument_list|(
name|cluster
argument_list|,
name|targetTable
argument_list|,
name|catalogReader
argument_list|,
name|massagedRel
argument_list|,
name|TableModificationRel
operator|.
name|Operation
operator|.
name|INSERT
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
operator|new
name|TableModificationRel
argument_list|(
name|cluster
argument_list|,
name|targetTable
argument_list|,
name|catalogReader
argument_list|,
name|massagedRel
argument_list|,
name|TableModificationRel
operator|.
name|Operation
operator|.
name|INSERT
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|RelOptTable
operator|.
name|ToRelContext
name|createToRelContext
parameter_list|()
block|{
return|return
operator|new
name|RelOptTable
operator|.
name|ToRelContext
argument_list|()
block|{
specifier|public
name|RelOptCluster
name|getCluster
parameter_list|()
block|{
return|return
name|cluster
return|;
block|}
specifier|public
name|RelNode
name|expandView
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|String
name|queryString
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|schemaPath
parameter_list|)
block|{
return|return
name|viewExpander
operator|.
name|expandView
argument_list|(
name|rowType
argument_list|,
name|queryString
argument_list|,
name|schemaPath
argument_list|)
return|;
block|}
block|}
return|;
block|}
specifier|public
name|RelNode
name|toRel
parameter_list|(
name|RelOptTable
name|table
parameter_list|)
block|{
return|return
name|table
operator|.
name|toRel
argument_list|(
name|createToRelContext
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|RelOptTable
name|getTargetTable
parameter_list|(
name|SqlNode
name|call
parameter_list|)
block|{
name|SqlValidatorNamespace
name|targetNs
init|=
name|validator
operator|.
name|getNamespace
argument_list|(
name|call
argument_list|)
operator|.
name|resolve
argument_list|()
decl_stmt|;
return|return
name|SqlValidatorUtil
operator|.
name|getRelOptTable
argument_list|(
name|targetNs
argument_list|,
name|catalogReader
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates a source for an INSERT statement.    *    *<p>If the column list is not specified, source expressions match target    * columns in order.    *    *<p>If the column list is specified, Source expressions are mapped to    * target columns by name via targetColumnList, and may not cover the entire    * target table. So, we'll make up a full row, using a combination of    * default values and the source expressions provided.    *    * @param call      Insert expression    * @param sourceRel Source relational expression    * @return Converted INSERT statement    */
specifier|protected
name|RelNode
name|convertColumnList
parameter_list|(
name|SqlInsert
name|call
parameter_list|,
name|RelNode
name|sourceRel
parameter_list|)
block|{
name|RelDataType
name|sourceRowType
init|=
name|sourceRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|sourceRef
init|=
name|rexBuilder
operator|.
name|makeRangeReference
argument_list|(
name|sourceRowType
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|targetColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|columnExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|collectInsertTargets
argument_list|(
name|call
argument_list|,
name|sourceRef
argument_list|,
name|targetColumnNames
argument_list|,
name|columnExprs
argument_list|)
expr_stmt|;
specifier|final
name|RelOptTable
name|targetTable
init|=
name|getTargetTable
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|targetRowType
init|=
name|targetTable
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|targetFields
init|=
name|targetRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|sourceExps
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|(
name|Collections
operator|.
expr|<
name|RexNode
operator|>
name|nCopies
argument_list|(
name|targetFields
operator|.
name|size
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|Collections
operator|.
expr|<
name|String
operator|>
name|nCopies
argument_list|(
name|targetFields
operator|.
name|size
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
comment|// Walk the name list and place the associated value in the
comment|// expression list according to the ordinal value returned from
comment|// the table construct, leaving nulls in the list for columns
comment|// that are not referenced.
for|for
control|(
name|Pair
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|p
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|targetColumnNames
argument_list|,
name|columnExprs
argument_list|)
control|)
block|{
name|RelDataTypeField
name|field
init|=
name|catalogReader
operator|.
name|field
argument_list|(
name|targetRowType
argument_list|,
name|p
operator|.
name|left
argument_list|)
decl_stmt|;
assert|assert
name|field
operator|!=
literal|null
operator|:
literal|"column "
operator|+
name|p
operator|.
name|left
operator|+
literal|" not found"
assert|;
name|sourceExps
operator|.
name|set
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|,
name|p
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
comment|// Walk the expression list and get default values for any columns
comment|// that were not supplied in the statement. Get field names too.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|targetFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|String
name|fieldName
init|=
name|field
operator|.
name|getName
argument_list|()
decl_stmt|;
name|fieldNames
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceExps
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|defaultValueFactory
operator|.
name|isGeneratedAlways
argument_list|(
name|targetTable
argument_list|,
name|i
argument_list|)
condition|)
block|{
throw|throw
name|RESOURCE
operator|.
name|insertIntoAlwaysGenerated
argument_list|(
name|fieldName
argument_list|)
operator|.
name|ex
argument_list|()
throw|;
block|}
continue|continue;
block|}
name|sourceExps
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|defaultValueFactory
operator|.
name|newColumnDefaultValue
argument_list|(
name|targetTable
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// bare nulls are dangerous in the wrong hands
name|sourceExps
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|castNullLiteralIfNeeded
argument_list|(
name|sourceExps
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|CalcRel
operator|.
name|createProject
argument_list|(
name|sourceRel
argument_list|,
name|sourceExps
argument_list|,
name|fieldNames
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|castNullLiteralIfNeeded
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|RexLiteral
operator|.
name|isNullLiteral
argument_list|(
name|node
argument_list|)
condition|)
block|{
return|return
name|node
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/**    * Given an INSERT statement, collects the list of names to be populated and    * the expressions to put in them.    *    * @param call              Insert statement    * @param sourceRef         Expression representing a row from the source    *                          relational expression    * @param targetColumnNames List of target column names, to be populated    * @param columnExprs       List of expressions, to be populated    */
specifier|protected
name|void
name|collectInsertTargets
parameter_list|(
name|SqlInsert
name|call
parameter_list|,
specifier|final
name|RexNode
name|sourceRef
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|targetColumnNames
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|columnExprs
parameter_list|)
block|{
specifier|final
name|RelOptTable
name|targetTable
init|=
name|getTargetTable
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|targetRowType
init|=
name|targetTable
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|SqlNodeList
name|targetColumnList
init|=
name|call
operator|.
name|getTargetColumnList
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetColumnList
operator|==
literal|null
condition|)
block|{
name|targetColumnNames
operator|.
name|addAll
argument_list|(
name|targetRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetColumnList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|targetColumnList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|targetColumnNames
operator|.
name|add
argument_list|(
name|id
operator|.
name|getSimple
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetColumnNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|sourceRef
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|columnExprs
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|RelNode
name|convertDelete
parameter_list|(
name|SqlDelete
name|call
parameter_list|)
block|{
name|RelOptTable
name|targetTable
init|=
name|getTargetTable
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|RelNode
name|sourceRel
init|=
name|convertSelect
argument_list|(
name|call
operator|.
name|getSourceSelect
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|TableModificationRel
argument_list|(
name|cluster
argument_list|,
name|targetTable
argument_list|,
name|catalogReader
argument_list|,
name|sourceRel
argument_list|,
name|TableModificationRel
operator|.
name|Operation
operator|.
name|DELETE
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|convertUpdate
parameter_list|(
name|SqlUpdate
name|call
parameter_list|)
block|{
name|RelOptTable
name|targetTable
init|=
name|getTargetTable
argument_list|(
name|call
argument_list|)
decl_stmt|;
comment|// convert update column list from SqlIdentifier to String
name|List
argument_list|<
name|String
argument_list|>
name|targetColumnNameList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|call
operator|.
name|getTargetColumnList
argument_list|()
control|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|node
decl_stmt|;
name|String
name|name
init|=
name|id
operator|.
name|getSimple
argument_list|()
decl_stmt|;
name|targetColumnNameList
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|sourceRel
init|=
name|convertSelect
argument_list|(
name|call
operator|.
name|getSourceSelect
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|TableModificationRel
argument_list|(
name|cluster
argument_list|,
name|targetTable
argument_list|,
name|catalogReader
argument_list|,
name|sourceRel
argument_list|,
name|TableModificationRel
operator|.
name|Operation
operator|.
name|UPDATE
argument_list|,
name|targetColumnNameList
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|convertMerge
parameter_list|(
name|SqlMerge
name|call
parameter_list|)
block|{
name|RelOptTable
name|targetTable
init|=
name|getTargetTable
argument_list|(
name|call
argument_list|)
decl_stmt|;
comment|// convert update column list from SqlIdentifier to String
name|List
argument_list|<
name|String
argument_list|>
name|targetColumnNameList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|SqlUpdate
name|updateCall
init|=
name|call
operator|.
name|getUpdateCall
argument_list|()
decl_stmt|;
if|if
condition|(
name|updateCall
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SqlNode
name|targetColumn
range|:
name|updateCall
operator|.
name|getTargetColumnList
argument_list|()
control|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|targetColumn
decl_stmt|;
name|String
name|name
init|=
name|id
operator|.
name|getSimple
argument_list|()
decl_stmt|;
name|targetColumnNameList
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|// replace the projection of the source select with a
comment|// projection that contains the following:
comment|// 1) the expressions corresponding to the new insert row (if there is
comment|//    an insert)
comment|// 2) all columns from the target table (if there is an update)
comment|// 3) the set expressions in the update call (if there is an update)
comment|// first, convert the merge's source select to construct the columns
comment|// from the target table and the set expressions in the update call
name|RelNode
name|mergeSourceRel
init|=
name|convertSelect
argument_list|(
name|call
operator|.
name|getSourceSelect
argument_list|()
argument_list|)
decl_stmt|;
comment|// then, convert the insert statement so we can get the insert
comment|// values expressions
name|SqlInsert
name|insertCall
init|=
name|call
operator|.
name|getInsertCall
argument_list|()
decl_stmt|;
name|int
name|nLevel1Exprs
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|level1InsertExprs
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|level2InsertExprs
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|insertCall
operator|!=
literal|null
condition|)
block|{
name|RelNode
name|insertRel
init|=
name|convertInsert
argument_list|(
name|insertCall
argument_list|)
decl_stmt|;
comment|// if there are 2 level of projections in the insert source, combine
comment|// them into a single project; level1 refers to the topmost project;
comment|// the level1 projection contains references to the level2
comment|// expressions, except in the case where no target expression was
comment|// provided, in which case, the expression is the default value for
comment|// the column; or if the expressions directly map to the source
comment|// table
name|level1InsertExprs
operator|=
operator|(
operator|(
name|ProjectRel
operator|)
name|insertRel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getProjects
argument_list|()
expr_stmt|;
if|if
condition|(
name|insertRel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ProjectRel
condition|)
block|{
name|level2InsertExprs
operator|=
operator|(
operator|(
name|ProjectRel
operator|)
name|insertRel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getProjects
argument_list|()
expr_stmt|;
block|}
name|nLevel1Exprs
operator|=
name|level1InsertExprs
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|JoinRel
name|joinRel
init|=
operator|(
name|JoinRel
operator|)
name|mergeSourceRel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|nSourceFields
init|=
name|joinRel
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level1Idx
init|=
literal|0
init|;
name|level1Idx
operator|<
name|nLevel1Exprs
condition|;
name|level1Idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|level2InsertExprs
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|level1InsertExprs
operator|.
name|get
argument_list|(
name|level1Idx
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|int
name|level2Idx
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|level1InsertExprs
operator|.
name|get
argument_list|(
name|level1Idx
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|projects
operator|.
name|add
argument_list|(
name|level2InsertExprs
operator|.
name|get
argument_list|(
name|level2Idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|projects
operator|.
name|add
argument_list|(
name|level1InsertExprs
operator|.
name|get
argument_list|(
name|level1Idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|updateCall
operator|!=
literal|null
condition|)
block|{
specifier|final
name|ProjectRel
name|project
init|=
operator|(
name|ProjectRel
operator|)
name|mergeSourceRel
decl_stmt|;
name|projects
operator|.
name|addAll
argument_list|(
name|Util
operator|.
name|skip
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
name|nSourceFields
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|massagedRel
init|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|joinRel
argument_list|,
name|projects
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TableModificationRel
argument_list|(
name|cluster
argument_list|,
name|targetTable
argument_list|,
name|catalogReader
argument_list|,
name|massagedRel
argument_list|,
name|TableModificationRel
operator|.
name|Operation
operator|.
name|MERGE
argument_list|,
name|targetColumnNameList
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Converts an identifier into an expression in a given scope. For example,    * the "empno" in "select empno from emp join dept" becomes "emp.empno".    */
specifier|private
name|RexNode
name|convertIdentifier
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlIdentifier
name|identifier
parameter_list|)
block|{
comment|// first check for reserved identifiers like CURRENT_USER
specifier|final
name|SqlCall
name|call
init|=
name|SqlUtil
operator|.
name|makeCall
argument_list|(
name|opTab
argument_list|,
name|identifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
return|return
name|bb
operator|.
name|convertExpression
argument_list|(
name|call
argument_list|)
return|;
block|}
if|if
condition|(
name|bb
operator|.
name|agg
operator|!=
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Identifier '"
operator|+
name|identifier
operator|+
literal|"' is not a group expr"
argument_list|)
throw|;
block|}
name|SqlValidatorNamespace
name|namespace
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|bb
operator|.
name|scope
operator|!=
literal|null
condition|)
block|{
name|identifier
operator|=
name|bb
operator|.
name|scope
operator|.
name|fullyQualify
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
name|namespace
operator|=
name|bb
operator|.
name|scope
operator|.
name|resolve
argument_list|(
name|identifier
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|e
init|=
name|bb
operator|.
name|lookupExp
argument_list|(
name|identifier
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|String
name|correlationName
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|RexCorrelVariable
condition|)
block|{
name|correlationName
operator|=
operator|(
operator|(
name|RexCorrelVariable
operator|)
name|e
operator|)
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|correlationName
operator|=
literal|null
expr_stmt|;
block|}
for|for
control|(
name|String
name|name
range|:
name|Util
operator|.
name|skip
argument_list|(
name|identifier
operator|.
name|names
argument_list|)
control|)
block|{
if|if
condition|(
name|namespace
operator|!=
literal|null
condition|)
block|{
name|name
operator|=
name|namespace
operator|.
name|translate
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|namespace
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|boolean
name|caseSensitive
init|=
literal|true
decl_stmt|;
comment|// name already fully-qualified
name|e
operator|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|e
argument_list|,
name|name
argument_list|,
name|caseSensitive
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|instanceof
name|RexInputRef
condition|)
block|{
comment|// adjust the type to account for nulls introduced by outer joins
name|e
operator|=
name|adjustInputRef
argument_list|(
name|bb
argument_list|,
operator|(
name|RexInputRef
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|correlationName
condition|)
block|{
comment|// REVIEW: make mapCorrelateVariableToRexNode map to RexFieldAccess
assert|assert
name|e
operator|instanceof
name|RexFieldAccess
assert|;
specifier|final
name|RexNode
name|prev
init|=
name|bb
operator|.
name|mapCorrelateVariableToRexNode
operator|.
name|put
argument_list|(
name|correlationName
argument_list|,
name|e
argument_list|)
decl_stmt|;
assert|assert
name|prev
operator|==
literal|null
assert|;
block|}
return|return
name|e
return|;
block|}
comment|/**    * Adjusts the type of a reference to an input field to account for nulls    * introduced by outer joins; and adjusts the offset to match the physical    * implementation.    *    * @param bb       Blackboard    * @param inputRef Input ref    * @return Adjusted input ref    */
specifier|protected
name|RexNode
name|adjustInputRef
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|RelDataTypeField
name|field
init|=
name|bb
operator|.
name|getRootField
argument_list|(
name|inputRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
return|return
name|inputRef
return|;
block|}
comment|/**    * Converts a row constructor into a relational expression.    *    * @param bb             Blackboard    * @param rowConstructor Row constructor expression    * @return Relational expression which returns a single row.    * @pre isRowConstructor(rowConstructor)    */
specifier|private
name|RelNode
name|convertRowConstructor
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlCall
name|rowConstructor
parameter_list|)
block|{
assert|assert
name|isRowConstructor
argument_list|(
name|rowConstructor
argument_list|)
operator|:
name|rowConstructor
assert|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|rowConstructor
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
return|return
name|convertMultisets
argument_list|(
name|operands
argument_list|,
name|bb
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|convertCursor
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlCall
name|cursorCall
parameter_list|)
block|{
assert|assert
name|cursorCall
operator|.
name|operandCount
argument_list|()
operator|==
literal|1
assert|;
name|SqlNode
name|query
init|=
name|cursorCall
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|converted
init|=
name|convertQuery
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|iCursor
init|=
name|bb
operator|.
name|cursors
operator|.
name|size
argument_list|()
decl_stmt|;
name|bb
operator|.
name|cursors
operator|.
name|add
argument_list|(
name|converted
argument_list|)
expr_stmt|;
name|RexNode
name|expr
init|=
operator|new
name|RexInputRef
argument_list|(
name|iCursor
argument_list|,
name|converted
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
name|bb
operator|.
name|mapSubqueryToExpr
operator|.
name|put
argument_list|(
name|cursorCall
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|converted
return|;
block|}
specifier|private
name|RelNode
name|convertMultisets
parameter_list|(
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
parameter_list|,
name|Blackboard
name|bb
parameter_list|)
block|{
comment|// NOTE: Wael 2/04/05: this implementation is not the most efficient in
comment|// terms of planning since it generates XOs that can be reduced.
name|List
argument_list|<
name|Object
argument_list|>
name|joinList
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|lastList
init|=
operator|new
name|ArrayList
argument_list|<
name|SqlNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|operand
init|=
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|operand
operator|instanceof
name|SqlCall
operator|)
condition|)
block|{
name|lastList
operator|.
name|add
argument_list|(
name|operand
argument_list|)
expr_stmt|;
continue|continue;
block|}
specifier|final
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|operand
decl_stmt|;
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|op
operator|!=
name|SqlStdOperatorTable
operator|.
name|MULTISET_VALUE
operator|)
operator|&&
operator|(
name|op
operator|!=
name|SqlStdOperatorTable
operator|.
name|MULTISET_QUERY
operator|)
condition|)
block|{
name|lastList
operator|.
name|add
argument_list|(
name|operand
argument_list|)
expr_stmt|;
continue|continue;
block|}
specifier|final
name|RelNode
name|input
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|SqlStdOperatorTable
operator|.
name|MULTISET_VALUE
condition|)
block|{
specifier|final
name|SqlNodeList
name|list
init|=
operator|new
name|SqlNodeList
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|,
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
comment|//                assert bb.scope instanceof SelectScope : bb.scope;
name|CollectNamespace
name|nss
init|=
operator|(
name|CollectNamespace
operator|)
name|validator
operator|.
name|getNamespace
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|Blackboard
name|usedBb
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|nss
condition|)
block|{
name|usedBb
operator|=
name|createBlackboard
argument_list|(
name|nss
operator|.
name|getScope
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usedBb
operator|=
name|createBlackboard
argument_list|(
operator|new
name|ListScope
argument_list|(
name|bb
operator|.
name|scope
argument_list|)
block|{
specifier|public
name|SqlNode
name|getNode
parameter_list|()
block|{
return|return
name|call
return|;
block|}
block|}
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|RelDataType
name|multisetType
init|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|validator
operator|.
name|setValidatedNodeType
argument_list|(
name|list
argument_list|,
name|multisetType
operator|.
name|getComponentType
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|=
name|convertQueryOrInList
argument_list|(
name|usedBb
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|convertQuery
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|joinList
operator|.
name|add
argument_list|(
name|lastList
argument_list|)
expr_stmt|;
block|}
name|lastList
operator|=
operator|new
name|ArrayList
argument_list|<
name|SqlNode
argument_list|>
argument_list|()
expr_stmt|;
name|CollectRel
name|collectRel
init|=
operator|new
name|CollectRel
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|Convention
operator|.
name|NONE
argument_list|)
argument_list|,
name|input
argument_list|,
name|validator
operator|.
name|deriveAlias
argument_list|(
name|call
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|joinList
operator|.
name|add
argument_list|(
name|collectRel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|joinList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|joinList
operator|.
name|add
argument_list|(
name|lastList
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|joinList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|o
init|=
name|joinList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|List
condition|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|projectList
init|=
operator|(
name|List
argument_list|<
name|SqlNode
argument_list|>
operator|)
name|o
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|selectList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|projectList
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|SqlNode
name|operand
init|=
name|projectList
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
comment|// REVIEW angel 5-June-2005: Use deriveAliasFromOrdinal
comment|// instead of deriveAlias to match field names from
comment|// SqlRowOperator. Otherwise, get error   Type
comment|// 'RecordType(INTEGER EMPNO)' has no field 'EXPR$0' when
comment|// doing   select * from unnest(     select multiset[empno]
comment|// from sales.emps);
name|fieldNameList
operator|.
name|add
argument_list|(
name|SqlUtil
operator|.
name|deriveAliasFromOrdinal
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|projRel
init|=
name|CalcRel
operator|.
name|createProject
argument_list|(
operator|new
name|OneRowRel
argument_list|(
name|cluster
argument_list|)
argument_list|,
name|selectList
argument_list|,
name|fieldNameList
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|correlatedVariables
init|=
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|projRel
argument_list|)
decl_stmt|;
comment|// Associate the correlated variables with the new project rel.
for|for
control|(
name|String
name|correl
range|:
name|correlatedVariables
control|)
block|{
name|mapCorrelToRefRel
operator|.
name|put
argument_list|(
name|correl
argument_list|,
name|projRel
argument_list|)
expr_stmt|;
block|}
name|joinList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|projRel
argument_list|)
expr_stmt|;
block|}
block|}
name|RelNode
name|ret
init|=
operator|(
name|RelNode
operator|)
name|joinList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|joinList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelNode
name|relNode
init|=
operator|(
name|RelNode
operator|)
name|joinList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ret
operator|=
name|createJoin
argument_list|(
name|ret
argument_list|,
name|relNode
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|ImmutableSet
operator|.
expr|<
name|String
operator|>
name|of
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Factory method that creates a join.    * A subclass can override to use a different kind of join.    *    * @param left             Left input    * @param right            Right input    * @param condition        Join condition    * @param joinType         Join type    * @param variablesStopped Set of names of variables which are set by the    *                         LHS and used by the RHS and are not available to    *                         nodes above this JoinRel in the tree    * @return A relational expression representing a join    */
specifier|protected
name|RelNode
name|createJoin
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|RelNode
name|right
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|variablesStopped
parameter_list|)
block|{
return|return
operator|new
name|JoinRel
argument_list|(
name|cluster
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|condition
argument_list|,
name|joinType
argument_list|,
name|variablesStopped
argument_list|)
return|;
block|}
specifier|private
name|void
name|convertSelectList
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderList
parameter_list|)
block|{
name|SqlNodeList
name|selectList
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
name|selectList
operator|=
name|validator
operator|.
name|expandStar
argument_list|(
name|selectList
argument_list|,
name|select
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|replaceSubqueries
argument_list|(
name|bb
argument_list|,
name|selectList
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|aliases
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Project any system fields. (Must be done before regular select items,
comment|// because offsets may be affected.)
specifier|final
name|List
argument_list|<
name|SqlMonotonicity
argument_list|>
name|columnMonotonicityList
init|=
operator|new
name|ArrayList
argument_list|<
name|SqlMonotonicity
argument_list|>
argument_list|()
decl_stmt|;
name|extraSelectItems
argument_list|(
name|bb
argument_list|,
name|select
argument_list|,
name|exprs
argument_list|,
name|fieldNames
argument_list|,
name|aliases
argument_list|,
name|columnMonotonicityList
argument_list|)
expr_stmt|;
comment|// Project select clause.
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|SqlNode
name|expr
range|:
name|selectList
control|)
block|{
operator|++
name|i
expr_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|deriveAlias
argument_list|(
name|expr
argument_list|,
name|aliases
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Project extra fields for sorting.
for|for
control|(
name|SqlNode
name|expr
range|:
name|orderList
control|)
block|{
operator|++
name|i
expr_stmt|;
name|SqlNode
name|expr2
init|=
name|validator
operator|.
name|expandOrderExpr
argument_list|(
name|select
argument_list|,
name|expr
argument_list|)
decl_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|bb
operator|.
name|convertExpression
argument_list|(
name|expr2
argument_list|)
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|deriveAlias
argument_list|(
name|expr
argument_list|,
name|aliases
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fieldNames
operator|=
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|fieldNames
argument_list|)
expr_stmt|;
name|RelNode
name|inputRel
init|=
name|bb
operator|.
name|root
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|correlatedVariablesBefore
init|=
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|inputRel
argument_list|)
decl_stmt|;
name|bb
operator|.
name|setRoot
argument_list|(
name|CalcRel
operator|.
name|createProject
argument_list|(
name|bb
operator|.
name|root
argument_list|,
name|exprs
argument_list|,
name|fieldNames
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
assert|assert
name|bb
operator|.
name|columnMonotonicities
operator|.
name|isEmpty
argument_list|()
assert|;
name|bb
operator|.
name|columnMonotonicities
operator|.
name|addAll
argument_list|(
name|columnMonotonicityList
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|selectItem
range|:
name|selectList
control|)
block|{
name|bb
operator|.
name|columnMonotonicities
operator|.
name|add
argument_list|(
name|selectItem
operator|.
name|getMonotonicity
argument_list|(
name|bb
operator|.
name|scope
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|correlatedVariables
init|=
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|bb
operator|.
name|root
argument_list|)
decl_stmt|;
name|correlatedVariables
operator|.
name|removeAll
argument_list|(
name|correlatedVariablesBefore
argument_list|)
expr_stmt|;
comment|// Associate the correlated variables with the new project rel.
for|for
control|(
name|String
name|correl
range|:
name|correlatedVariables
control|)
block|{
name|mapCorrelToRefRel
operator|.
name|put
argument_list|(
name|correl
argument_list|,
name|bb
operator|.
name|root
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Adds extra select items. The default implementation adds nothing; derived    * classes may add columns to exprList, nameList, aliasList and    * columnMonotonicityList.    *    * @param bb                     Blackboard    * @param select                 Select statement being translated    * @param exprList               List of expressions in select clause    * @param nameList               List of names, one per column    * @param aliasList              Collection of aliases that have been used    *                               already    * @param columnMonotonicityList List of monotonicity, one per column    */
specifier|protected
name|void
name|extraSelectItems
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|nameList
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|aliasList
parameter_list|,
name|List
argument_list|<
name|SqlMonotonicity
argument_list|>
name|columnMonotonicityList
parameter_list|)
block|{
block|}
specifier|private
name|String
name|deriveAlias
parameter_list|(
specifier|final
name|SqlNode
name|node
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|,
specifier|final
name|int
name|ordinal
parameter_list|)
block|{
name|String
name|alias
init|=
name|validator
operator|.
name|deriveAlias
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|alias
operator|==
literal|null
operator|)
operator|||
name|aliases
operator|.
name|contains
argument_list|(
name|alias
argument_list|)
condition|)
block|{
name|String
name|aliasBase
init|=
operator|(
name|alias
operator|==
literal|null
operator|)
condition|?
literal|"EXPR$"
else|:
name|alias
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
block|{
name|alias
operator|=
name|aliasBase
operator|+
name|j
expr_stmt|;
if|if
condition|(
operator|!
name|aliases
operator|.
name|contains
argument_list|(
name|alias
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
name|aliases
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
return|return
name|alias
return|;
block|}
comment|/**    * Converts a WITH sub-query into a relational expression.    */
specifier|public
name|RelNode
name|convertWith
parameter_list|(
name|SqlWith
name|with
parameter_list|)
block|{
return|return
name|convertQuery
argument_list|(
name|with
operator|.
name|body
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Converts a SELECT statement's parse tree into a relational expression.    */
specifier|public
name|RelNode
name|convertValues
parameter_list|(
name|SqlCall
name|values
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|)
block|{
specifier|final
name|SqlValidatorScope
name|scope
init|=
name|validator
operator|.
name|getOverScope
argument_list|(
name|values
argument_list|)
decl_stmt|;
assert|assert
name|scope
operator|!=
literal|null
assert|;
specifier|final
name|Blackboard
name|bb
init|=
name|createBlackboard
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|convertValuesImpl
argument_list|(
name|bb
argument_list|,
name|values
argument_list|,
name|targetRowType
argument_list|)
expr_stmt|;
return|return
name|bb
operator|.
name|root
return|;
block|}
comment|/**    * Converts a values clause (as in "INSERT INTO T(x,y) VALUES (1,2)") into a    * relational expression.    *    * @param bb            Blackboard    * @param values        Call to SQL VALUES operator    * @param targetRowType Target row type    */
specifier|private
name|void
name|convertValuesImpl
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlCall
name|values
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|)
block|{
comment|// Attempt direct conversion to ValuesRel; if that fails, deal with
comment|// fancy stuff like subqueries below.
name|RelNode
name|valuesRel
init|=
name|convertRowValues
argument_list|(
name|bb
argument_list|,
name|values
argument_list|,
name|values
operator|.
name|getOperandList
argument_list|()
argument_list|,
literal|true
argument_list|,
name|targetRowType
argument_list|)
decl_stmt|;
if|if
condition|(
name|valuesRel
operator|!=
literal|null
condition|)
block|{
name|bb
operator|.
name|setRoot
argument_list|(
name|valuesRel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|List
argument_list|<
name|RelNode
argument_list|>
name|unionRels
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|rowConstructor1
range|:
name|values
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|SqlCall
name|rowConstructor
init|=
operator|(
name|SqlCall
operator|)
name|rowConstructor1
decl_stmt|;
name|Blackboard
name|tmpBb
init|=
name|createBlackboard
argument_list|(
name|bb
operator|.
name|scope
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|replaceSubqueries
argument_list|(
name|tmpBb
argument_list|,
name|rowConstructor
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|exps
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|SqlNode
argument_list|>
name|operand
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|rowConstructor
operator|.
name|getOperandList
argument_list|()
argument_list|)
control|)
block|{
name|exps
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|tmpBb
operator|.
name|convertExpression
argument_list|(
name|operand
operator|.
name|e
argument_list|)
argument_list|,
name|validator
operator|.
name|deriveAlias
argument_list|(
name|operand
operator|.
name|e
argument_list|,
name|operand
operator|.
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|in
init|=
operator|(
literal|null
operator|==
name|tmpBb
operator|.
name|root
operator|)
condition|?
operator|new
name|OneRowRel
argument_list|(
name|cluster
argument_list|)
else|:
name|tmpBb
operator|.
name|root
decl_stmt|;
name|unionRels
operator|.
name|add
argument_list|(
name|CalcRel
operator|.
name|createProject
argument_list|(
name|in
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|exps
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|exps
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unionRels
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"empty values clause"
argument_list|)
throw|;
block|}
if|else if
condition|(
name|unionRels
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|bb
operator|.
name|setRoot
argument_list|(
name|unionRels
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bb
operator|.
name|setRoot
argument_list|(
operator|new
name|UnionRel
argument_list|(
name|cluster
argument_list|,
name|unionRels
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// REVIEW jvs 22-Jan-2004:  should I add
comment|// mapScopeToLux.put(validator.getScope(values),bb.root);
comment|// ?
block|}
specifier|private
name|String
name|createCorrel
parameter_list|()
block|{
name|int
name|n
init|=
name|nextCorrel
operator|++
decl_stmt|;
return|return
name|CORREL_PREFIX
operator|+
name|n
return|;
block|}
specifier|private
name|int
name|getCorrelOrdinal
parameter_list|(
name|String
name|correlName
parameter_list|)
block|{
assert|assert
name|correlName
operator|.
name|startsWith
argument_list|(
name|CORREL_PREFIX
argument_list|)
assert|;
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|correlName
operator|.
name|substring
argument_list|(
name|CORREL_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Workspace for translating an individual SELECT statement (or sub-SELECT).    */
specifier|protected
class|class
name|Blackboard
implements|implements
name|SqlRexContext
implements|,
name|SqlVisitor
argument_list|<
name|RexNode
argument_list|>
block|{
comment|/**      * Collection of {@link RelNode} objects which correspond to a SELECT      * statement.      */
specifier|public
specifier|final
name|SqlValidatorScope
name|scope
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|nameToNodeMap
decl_stmt|;
specifier|public
name|RelNode
name|root
decl_stmt|;
specifier|private
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|mapCorrelateVariableToRexNode
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|cursors
decl_stmt|;
comment|/**      * List of<code>IN</code> and<code>EXISTS</code> nodes inside this      *<code>SELECT</code> statement (but not inside sub-queries).      */
specifier|private
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|subqueryList
init|=
operator|new
name|ArrayList
argument_list|<
name|SqlNode
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Maps IN and EXISTS {@link SqlSelect sub-queries} to the expressions      * which will be used to access them.      */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|RexNode
argument_list|>
name|mapSubqueryToExpr
init|=
operator|new
name|HashMap
argument_list|<
name|SqlNode
argument_list|,
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|subqueryNeedsOuterJoin
decl_stmt|;
comment|/**      * Workspace for building aggregates.      */
name|AggConverter
name|agg
decl_stmt|;
comment|/**      * When converting window aggregate, we need to know if the window is      * guaranteed to be non-empty.      */
name|SqlWindow
name|window
decl_stmt|;
comment|/**      * Project the groupby expressions out of the root of this sub-select.      * Subqueries can reference group by expressions projected from the      * "right" to the subquery.      */
specifier|private
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|mapRootRelToFieldProjection
init|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|SqlMonotonicity
argument_list|>
name|columnMonotonicities
init|=
operator|new
name|ArrayList
argument_list|<
name|SqlMonotonicity
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|systemFieldList
init|=
operator|new
name|ArrayList
argument_list|<
name|RelDataTypeField
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Creates a Blackboard.      *      * @param scope         Name-resolution scope for expressions validated      *                      within this query. Can be null if this Blackboard is      *                      for a leaf node, say      * @param nameToNodeMap Map which translates the expression to map a      *                      given parameter into, if translating expressions;      *                      null otherwise      */
specifier|protected
name|Blackboard
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|nameToNodeMap
parameter_list|)
block|{
name|this
operator|.
name|scope
operator|=
name|scope
expr_stmt|;
name|this
operator|.
name|nameToNodeMap
operator|=
name|nameToNodeMap
expr_stmt|;
name|this
operator|.
name|cursors
operator|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
expr_stmt|;
name|subqueryNeedsOuterJoin
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|RexNode
name|register
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|)
block|{
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|joinType
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Registers a relational expression.      *      * @param rel               Relational expression      * @param joinType          Join type      * @param leftJoinKeysForIn LHS of IN clause, or null for expressions      *                          other than IN      * @return Expression with which to refer to the row (or partial row)      * coming from this relational expression's side of the join. rchen      * 2006-08-17: temporarily translate select * from X where a not in      * (select b form Y); to select X.* from X, (select distinct b from Y)      * where not (a = b);      */
specifier|public
name|RexNode
name|register
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|,
name|RexNode
index|[]
name|leftJoinKeysForIn
parameter_list|)
block|{
assert|assert
name|joinType
operator|!=
literal|null
assert|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
assert|assert
name|leftJoinKeysForIn
operator|==
literal|null
assert|;
name|setRoot
argument_list|(
name|rel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|rexBuilder
operator|.
name|makeRangeReference
argument_list|(
name|root
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
return|;
block|}
else|else
block|{
name|RexNode
name|joinCond
init|=
literal|null
decl_stmt|;
specifier|final
name|int
name|origLeftInputCount
init|=
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftJoinKeysForIn
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|newLeftInputExpr
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|origLeftInputCount
condition|;
name|i
operator|++
control|)
block|{
name|newLeftInputExpr
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|root
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|addAll
argument_list|(
name|newLeftInputExpr
argument_list|,
name|leftJoinKeysForIn
argument_list|)
expr_stmt|;
name|ProjectRel
name|newLeftInput
init|=
operator|(
name|ProjectRel
operator|)
name|CalcRel
operator|.
name|createProject
argument_list|(
name|root
argument_list|,
name|newLeftInputExpr
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// maintain the group by mapping in the new ProjectRel
if|if
condition|(
name|mapRootRelToFieldProjection
operator|.
name|containsKey
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|mapRootRelToFieldProjection
operator|.
name|put
argument_list|(
name|newLeftInput
argument_list|,
name|mapRootRelToFieldProjection
operator|.
name|get
argument_list|(
name|root
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|setRoot
argument_list|(
name|newLeftInput
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newLeftJoinKeysForIn
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftJoinKeysForIn
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|x
init|=
name|origLeftInputCount
operator|+
name|i
decl_stmt|;
name|newLeftJoinKeysForIn
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|newLeftInput
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|x
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|joinCond
operator|=
name|createJoinConditionForIn
argument_list|(
name|this
argument_list|,
name|newLeftJoinKeysForIn
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
name|int
name|leftFieldCount
init|=
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|join
init|=
name|createJoin
argument_list|(
name|this
argument_list|,
name|root
argument_list|,
name|rel
argument_list|,
name|joinCond
argument_list|,
name|joinType
argument_list|)
decl_stmt|;
name|setRoot
argument_list|(
name|join
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|leftJoinKeysForIn
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|joinType
operator|==
name|JoinRelType
operator|.
name|LEFT
operator|)
condition|)
block|{
name|int
name|rightFieldLength
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
name|leftJoinKeysForIn
operator|.
name|length
operator|==
name|rightFieldLength
operator|-
literal|1
assert|;
specifier|final
name|int
name|rexRangeRefLength
init|=
name|leftJoinKeysForIn
operator|.
name|length
operator|+
name|rightFieldLength
decl_stmt|;
name|RelDataType
name|returnType
init|=
name|typeFactory
operator|.
name|createStructType
argument_list|(
operator|new
name|AbstractList
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|join
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|origLeftInputCount
operator|+
name|index
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rexRangeRefLength
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeRangeReference
argument_list|(
name|returnType
argument_list|,
name|origLeftInputCount
argument_list|,
literal|false
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|rexBuilder
operator|.
name|makeRangeReference
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|leftFieldCount
argument_list|,
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
comment|/**      * Sets a new root relational expression, as the translation process      * backs its way further up the tree.      *      * @param root New root relational expression      * @param leaf Whether the relational expression is a leaf, that is,      *             derived from an atomic relational expression such as a table      *             name in the from clause, or the projection on top of a      *             select-subquery. In particular, relational expressions      *             derived from JOIN operators are not leaves, but set      *             expressions are.      */
specifier|public
name|void
name|setRoot
parameter_list|(
name|RelNode
name|root
parameter_list|,
name|boolean
name|leaf
parameter_list|)
block|{
name|setRoot
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|root
argument_list|)
argument_list|,
name|root
argument_list|,
name|root
operator|instanceof
name|JoinRel
argument_list|)
expr_stmt|;
if|if
condition|(
name|leaf
condition|)
block|{
name|leaves
operator|.
name|add
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|columnMonotonicities
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|setRoot
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|,
name|RelNode
name|root
parameter_list|,
name|boolean
name|hasSystemFields
parameter_list|)
block|{
name|this
operator|.
name|inputs
operator|=
name|inputs
expr_stmt|;
name|this
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|this
operator|.
name|systemFieldList
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|hasSystemFields
condition|)
block|{
name|this
operator|.
name|systemFieldList
operator|.
name|addAll
argument_list|(
name|getSystemFields
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Notifies this Blackboard that the root just set using {@link      * #setRoot(RelNode, boolean)} was derived using dataset substitution.      *      *<p>The default implementation is not interested in such      * notifications, and does nothing.      *      * @param datasetName Dataset name      */
specifier|public
name|void
name|setDataset
parameter_list|(
name|String
name|datasetName
parameter_list|)
block|{
block|}
name|void
name|setRoot
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|)
block|{
name|setRoot
argument_list|(
name|inputs
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns an expression with which to reference a from-list item.      *      * @param name the alias of the from item      * @return a {@link RexFieldAccess} or {@link RexRangeRef}, or null if      * not found      */
name|RexNode
name|lookupExp
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|nameToNodeMap
operator|!=
literal|null
condition|)
block|{
name|RexNode
name|node
init|=
name|nameToNodeMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Unknown identifier '"
operator|+
name|name
operator|+
literal|"' encountered while expanding expression"
operator|+
name|node
argument_list|)
throw|;
block|}
return|return
name|node
return|;
block|}
name|int
index|[]
name|offsets
init|=
block|{
operator|-
literal|1
block|}
decl_stmt|;
specifier|final
name|SqlValidatorScope
index|[]
name|ancestorScopes
init|=
block|{
literal|null
block|}
decl_stmt|;
name|SqlValidatorNamespace
name|foundNs
init|=
name|scope
operator|.
name|resolve
argument_list|(
name|name
argument_list|,
name|ancestorScopes
argument_list|,
name|offsets
argument_list|)
decl_stmt|;
if|if
condition|(
name|foundNs
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Found in current query's from list.  Find which from item.
comment|// We assume that the order of the from clause items has been
comment|// preserved.
name|SqlValidatorScope
name|ancestorScope
init|=
name|ancestorScopes
index|[
literal|0
index|]
decl_stmt|;
name|boolean
name|isParent
init|=
name|ancestorScope
operator|!=
name|scope
decl_stmt|;
if|if
condition|(
operator|(
name|inputs
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|isParent
condition|)
block|{
name|int
name|offset
init|=
name|offsets
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|LookupContext
name|rels
init|=
operator|new
name|LookupContext
argument_list|(
name|this
argument_list|,
name|inputs
argument_list|,
name|systemFieldList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|lookup
argument_list|(
name|offset
argument_list|,
name|rels
argument_list|)
return|;
block|}
else|else
block|{
comment|// We're referencing a relational expression which has not been
comment|// converted yet. This occurs when from items are correlated,
comment|// e.g. "select from emp as emp join emp.getDepts() as dept".
comment|// Create a temporary expression.
assert|assert
name|isParent
assert|;
name|DeferredLookup
name|lookup
init|=
operator|new
name|DeferredLookup
argument_list|(
name|this
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|String
name|correlName
init|=
name|createCorrel
argument_list|()
decl_stmt|;
name|mapCorrelToDeferred
operator|.
name|put
argument_list|(
name|correlName
argument_list|,
name|lookup
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|foundNs
operator|.
name|getRowType
argument_list|()
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCorrel
argument_list|(
name|rowType
argument_list|,
name|correlName
argument_list|)
return|;
block|}
block|}
comment|/**      * Creates an expression with which to reference the expression whose      * offset in its from-list is {@code offset}.      */
name|RexNode
name|lookup
parameter_list|(
name|int
name|offset
parameter_list|,
name|LookupContext
name|lookupContext
parameter_list|)
block|{
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
name|pair
init|=
name|lookupContext
operator|.
name|findRel
argument_list|(
name|offset
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeRangeReference
argument_list|(
name|pair
operator|.
name|left
operator|.
name|getRowType
argument_list|()
argument_list|,
name|pair
operator|.
name|right
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|RelDataTypeField
name|getRootField
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|int
name|fieldOffset
init|=
name|inputRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|inputs
control|)
block|{
name|RelDataType
name|rowType
init|=
name|input
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|rowType
operator|==
literal|null
condition|)
block|{
comment|// TODO:  remove this once leastRestrictive
comment|// is correctly implemented
return|return
literal|null
return|;
block|}
if|if
condition|(
name|fieldOffset
operator|<
name|rowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|fieldOffset
argument_list|)
return|;
block|}
name|fieldOffset
operator|-=
name|rowType
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
specifier|public
name|void
name|flatten
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|rels
parameter_list|,
name|int
name|systemFieldCount
parameter_list|,
name|int
index|[]
name|start
parameter_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|relOffsetList
parameter_list|)
block|{
for|for
control|(
name|RelNode
name|rel
range|:
name|rels
control|)
block|{
if|if
condition|(
name|leaves
operator|.
name|contains
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|relOffsetList
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|rel
argument_list|,
name|start
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|start
index|[
literal|0
index|]
operator|+=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rel
operator|instanceof
name|JoinRel
operator|||
name|rel
operator|instanceof
name|AggregateRel
condition|)
block|{
name|start
index|[
literal|0
index|]
operator|+=
name|systemFieldCount
expr_stmt|;
block|}
name|flatten
argument_list|(
name|rel
operator|.
name|getInputs
argument_list|()
argument_list|,
name|systemFieldCount
argument_list|,
name|start
argument_list|,
name|relOffsetList
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|void
name|registerSubquery
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
name|subqueryList
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|ImmutableList
argument_list|<
name|RelNode
argument_list|>
name|retrieveCursors
parameter_list|()
block|{
try|try
block|{
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|cursors
argument_list|)
return|;
block|}
finally|finally
block|{
name|cursors
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|// implement SqlRexContext
specifier|public
name|RexNode
name|convertExpression
parameter_list|(
name|SqlNode
name|expr
parameter_list|)
block|{
comment|// If we're in aggregation mode and this is an expression in the
comment|// GROUP BY clause, return a reference to the field.
if|if
condition|(
name|agg
operator|!=
literal|null
condition|)
block|{
specifier|final
name|SqlNode
name|expandedGroupExpr
init|=
name|validator
operator|.
name|expand
argument_list|(
name|expr
argument_list|,
name|scope
argument_list|)
decl_stmt|;
name|RexNode
name|rex
init|=
name|agg
operator|.
name|lookupGroupExpr
argument_list|(
name|expandedGroupExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|rex
operator|!=
literal|null
condition|)
block|{
return|return
name|rex
return|;
block|}
if|if
condition|(
name|expr
operator|instanceof
name|SqlCall
condition|)
block|{
name|rex
operator|=
name|agg
operator|.
name|lookupAggregates
argument_list|(
operator|(
name|SqlCall
operator|)
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rex
operator|!=
literal|null
condition|)
block|{
return|return
name|rex
return|;
block|}
block|}
block|}
comment|// Allow the derived class chance to override the standard
comment|// behavior for special kinds of expressions.
name|RexNode
name|rex
init|=
name|convertExtendedExpression
argument_list|(
name|expr
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|rex
operator|!=
literal|null
condition|)
block|{
return|return
name|rex
return|;
block|}
name|boolean
name|needTruthTest
decl_stmt|;
comment|// Sub-queries and OVER expressions are not like ordinary
comment|// expressions.
specifier|final
name|SqlKind
name|kind
init|=
name|expr
operator|.
name|getKind
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CURSOR
case|:
case|case
name|SELECT
case|:
case|case
name|EXISTS
case|:
case|case
name|SCALAR_QUERY
case|:
name|rex
operator|=
name|mapSubqueryToExpr
operator|.
name|get
argument_list|(
name|expr
argument_list|)
expr_stmt|;
assert|assert
name|rex
operator|!=
literal|null
operator|:
literal|"rex != null"
assert|;
if|if
condition|(
name|kind
operator|==
name|SqlKind
operator|.
name|CURSOR
condition|)
block|{
comment|// cursor reference is pre-baked
return|return
name|rex
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|kind
operator|==
name|SqlKind
operator|.
name|SCALAR_QUERY
operator|)
operator|||
operator|(
name|kind
operator|==
name|SqlKind
operator|.
name|EXISTS
operator|)
operator|)
operator|&&
name|isConvertedSubq
argument_list|(
name|rex
argument_list|)
condition|)
block|{
comment|// scalar subquery or EXISTS has been converted to a
comment|// constant
return|return
name|rex
return|;
block|}
name|RexNode
name|fieldAccess
decl_stmt|;
name|needTruthTest
operator|=
literal|false
expr_stmt|;
comment|// The indicator column is the last field of the subquery.
name|fieldAccess
operator|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|rex
argument_list|,
name|rex
operator|.
name|getType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// The indicator column will be nullable if it comes from
comment|// the null-generating side of the join. For EXISTS, add an
comment|// "IS TRUE" check so that the result is "BOOLEAN NOT NULL".
if|if
condition|(
name|fieldAccess
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
if|if
condition|(
name|kind
operator|==
name|SqlKind
operator|.
name|EXISTS
condition|)
block|{
name|needTruthTest
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needTruthTest
condition|)
block|{
name|fieldAccess
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|fieldAccess
argument_list|)
expr_stmt|;
block|}
return|return
name|fieldAccess
return|;
case|case
name|IN
case|:
name|rex
operator|=
name|mapSubqueryToExpr
operator|.
name|get
argument_list|(
name|expr
argument_list|)
expr_stmt|;
assert|assert
name|rex
operator|!=
literal|null
operator|:
literal|"rex != null"
assert|;
name|RexNode
name|rexNode
decl_stmt|;
name|boolean
name|isNotInFilter
decl_stmt|;
if|if
condition|(
name|rex
operator|instanceof
name|RexRangeRef
condition|)
block|{
comment|// IN was converted to subquery.
name|isNotInFilter
operator|=
operator|(
operator|(
name|SqlInOperator
operator|)
operator|(
operator|(
name|SqlCall
operator|)
name|expr
operator|)
operator|.
name|getOperator
argument_list|()
operator|)
operator|.
name|isNotIn
argument_list|()
expr_stmt|;
name|needTruthTest
operator|=
name|subqueryNeedsOuterJoin
operator|||
name|isNotInFilter
expr_stmt|;
block|}
else|else
block|{
comment|// IN was converted to OR; nothing more needed.
return|return
name|rex
return|;
block|}
if|if
condition|(
name|needTruthTest
condition|)
block|{
assert|assert
name|rex
operator|instanceof
name|RexRangeRef
assert|;
name|rexNode
operator|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|rex
argument_list|,
name|rex
operator|.
name|getType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isNotInFilter
condition|)
block|{
name|rexNode
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
argument_list|,
name|rexNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rexNode
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
argument_list|,
name|rexNode
argument_list|)
argument_list|)
expr_stmt|;
comment|// then append the IS NOT NULL(leftKeysForIn)
comment|// RexRangeRef contains the following fields:
comment|// leftKeysForIn, rightKeysForIn(the original subquery
comment|// select list), nullIndicator The first two lists
comment|// contain the same number of fields
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
name|rex
operator|.
name|getType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
literal|1
operator|)
operator|/
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|rexNode
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|rexNode
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|rex
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|rexNode
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|rexNode
return|;
case|case
name|OVER
case|:
return|return
name|convertOver
argument_list|(
name|this
argument_list|,
name|expr
argument_list|)
return|;
default|default:
comment|// fall through
block|}
comment|// Apply standard conversions.
name|rex
operator|=
name|expr
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|Util
operator|.
name|permAssert
argument_list|(
name|rex
operator|!=
literal|null
argument_list|,
literal|"conversion result not null"
argument_list|)
expr_stmt|;
return|return
name|rex
return|;
block|}
comment|/**      * Converts an item in an ORDER BY clause, extracting DESC, NULLS LAST      * and NULLS FIRST flags first.      */
specifier|public
name|RexNode
name|convertSortExpression
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|Set
argument_list|<
name|SqlKind
argument_list|>
name|flags
parameter_list|)
block|{
switch|switch
condition|(
name|expr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
case|case
name|NULLS_LAST
case|:
case|case
name|NULLS_FIRST
case|:
name|flags
operator|.
name|add
argument_list|(
name|expr
operator|.
name|getKind
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|operand
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|expr
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|convertSortExpression
argument_list|(
name|operand
argument_list|,
name|flags
argument_list|)
return|;
default|default:
return|return
name|convertExpression
argument_list|(
name|expr
argument_list|)
return|;
block|}
block|}
comment|/**      * Determines whether a RexNode corresponds to a subquery that's been      * converted to a constant.      *      * @param rex the expression to be examined      * @return true if the expression is a dynamic parameter, a literal, or      * a literal that is being cast      */
specifier|private
name|boolean
name|isConvertedSubq
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
if|if
condition|(
operator|(
name|rex
operator|instanceof
name|RexLiteral
operator|)
operator|||
operator|(
name|rex
operator|instanceof
name|RexDynamicParam
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|rex
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|rex
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|CAST
condition|)
block|{
name|RexNode
name|operand
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand
operator|instanceof
name|RexLiteral
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// implement SqlRexContext
specifier|public
name|int
name|getGroupCount
parameter_list|()
block|{
if|if
condition|(
name|agg
operator|!=
literal|null
condition|)
block|{
return|return
name|agg
operator|.
name|groupExprs
operator|.
name|size
argument_list|()
return|;
block|}
if|if
condition|(
name|window
operator|!=
literal|null
condition|)
block|{
return|return
name|window
operator|.
name|isAlwaysNonEmpty
argument_list|()
condition|?
literal|1
else|:
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|// implement SqlRexContext
specifier|public
name|RexBuilder
name|getRexBuilder
parameter_list|()
block|{
return|return
name|rexBuilder
return|;
block|}
comment|// implement SqlRexContext
specifier|public
name|RexRangeRef
name|getSubqueryExpr
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
return|return
operator|(
name|RexRangeRef
operator|)
name|mapSubqueryToExpr
operator|.
name|get
argument_list|(
name|call
argument_list|)
return|;
block|}
comment|// implement SqlRexContext
specifier|public
name|RelDataTypeFactory
name|getTypeFactory
parameter_list|()
block|{
return|return
name|typeFactory
return|;
block|}
comment|// implement SqlRexContext
specifier|public
name|DefaultValueFactory
name|getDefaultValueFactory
parameter_list|()
block|{
return|return
name|defaultValueFactory
return|;
block|}
comment|// implement SqlRexContext
specifier|public
name|SqlValidator
name|getValidator
parameter_list|()
block|{
return|return
name|validator
return|;
block|}
comment|// implement SqlRexContext
specifier|public
name|RexNode
name|convertLiteral
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
return|return
name|exprConverter
operator|.
name|convertLiteral
argument_list|(
name|this
argument_list|,
name|literal
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertInterval
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
name|exprConverter
operator|.
name|convertInterval
argument_list|(
name|this
argument_list|,
name|intervalQualifier
argument_list|)
return|;
block|}
comment|// implement SqlVisitor
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
return|return
name|exprConverter
operator|.
name|convertLiteral
argument_list|(
name|this
argument_list|,
name|literal
argument_list|)
return|;
block|}
comment|// implement SqlVisitor
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|agg
operator|!=
literal|null
condition|)
block|{
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|isAggregator
argument_list|()
condition|)
block|{
return|return
name|agg
operator|.
name|lookupAggregates
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
return|return
name|exprConverter
operator|.
name|convertCall
argument_list|(
name|this
argument_list|,
name|call
argument_list|)
return|;
block|}
comment|// implement SqlVisitor
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|// implement SqlVisitor
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
return|return
name|convertIdentifier
argument_list|(
name|this
argument_list|,
name|id
argument_list|)
return|;
block|}
comment|// implement SqlVisitor
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlDataTypeSpec
name|type
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|// implement SqlVisitor
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
return|return
name|convertDynamicParam
argument_list|(
name|param
argument_list|)
return|;
block|}
comment|// implement SqlVisitor
specifier|public
name|RexNode
name|visit
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
name|convertInterval
argument_list|(
name|intervalQualifier
argument_list|)
return|;
block|}
comment|/**      * Shifts the expressions used to reference subqueries to the right.      * Moves any reference&ge;<code>index</code><code>count</code> places      * to the right.      *      * @param index Position where new expression was inserted      * @param count Number of new expressions inserted      */
specifier|public
name|void
name|adjustSubqueries
parameter_list|(
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|int
name|count
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SqlNode
argument_list|,
name|RexNode
argument_list|>
name|entry
range|:
name|mapSubqueryToExpr
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|RexNode
name|expr
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|RexShuttle
name|shuttle
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
specifier|public
name|RexNode
name|visitRangeRef
parameter_list|(
name|RexRangeRef
name|rangeRef
parameter_list|)
block|{
if|if
condition|(
name|rangeRef
operator|.
name|getOffset
argument_list|()
operator|>=
name|index
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeRangeReference
argument_list|(
name|rangeRef
operator|.
name|getType
argument_list|()
argument_list|,
name|rangeRef
operator|.
name|getOffset
argument_list|()
operator|+
name|count
argument_list|,
literal|false
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|rangeRef
return|;
block|}
block|}
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
if|if
condition|(
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|>=
name|index
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|,
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|+
name|count
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|inputRef
return|;
block|}
block|}
block|}
decl_stmt|;
name|RexNode
name|newExpr
init|=
name|expr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
name|entry
operator|.
name|setValue
argument_list|(
name|newExpr
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|List
argument_list|<
name|SqlMonotonicity
argument_list|>
name|getColumnMonotonicities
parameter_list|()
block|{
return|return
name|columnMonotonicities
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|DeferredLookup
block|{
name|Blackboard
name|bb
decl_stmt|;
name|String
name|originalRelName
decl_stmt|;
name|DeferredLookup
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|String
name|originalRelName
parameter_list|)
block|{
name|this
operator|.
name|bb
operator|=
name|bb
expr_stmt|;
name|this
operator|.
name|originalRelName
operator|=
name|originalRelName
expr_stmt|;
block|}
specifier|public
name|RexFieldAccess
name|getFieldAccess
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
operator|(
name|RexFieldAccess
operator|)
name|bb
operator|.
name|mapCorrelateVariableToRexNode
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
specifier|public
name|String
name|getOriginalRelName
parameter_list|()
block|{
return|return
name|originalRelName
return|;
block|}
block|}
comment|/**    * An implementation of DefaultValueFactory which always supplies NULL.    */
class|class
name|NullDefaultValueFactory
implements|implements
name|DefaultValueFactory
block|{
specifier|public
name|boolean
name|isGeneratedAlways
parameter_list|(
name|RelOptTable
name|table
parameter_list|,
name|int
name|iColumn
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|RexNode
name|newColumnDefaultValue
parameter_list|(
name|RelOptTable
name|table
parameter_list|,
name|int
name|iColumn
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|constantNull
argument_list|()
return|;
block|}
specifier|public
name|RexNode
name|newAttributeInitializer
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|SqlFunction
name|constructor
parameter_list|,
name|int
name|iAttribute
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|constructorArgs
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|constantNull
argument_list|()
return|;
block|}
block|}
comment|/**    * A default implementation of SubqueryConverter that does no conversion.    */
specifier|private
class|class
name|NoOpSubqueryConverter
implements|implements
name|SubqueryConverter
block|{
comment|// implement SubqueryConverter
specifier|public
name|boolean
name|canConvertSubquery
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|// implement SubqueryConverter
specifier|public
name|RexNode
name|convertSubquery
parameter_list|(
name|SqlCall
name|subquery
parameter_list|,
name|SqlToRelConverter
name|parentConverter
parameter_list|,
name|boolean
name|isExists
parameter_list|,
name|boolean
name|isExplain
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Converts expressions to aggregates.    *    *<p>Consider the expression SELECT deptno, SUM(2 * sal) FROM emp GROUP BY    * deptno Then    *    *<ul>    *<li>groupExprs = {SqlIdentifier(deptno)}</li>    *<li>convertedInputExprs = {RexInputRef(deptno), 2 *    * RefInputRef(sal)}</li>    *<li>inputRefs = {RefInputRef(#0), RexInputRef(#1)}</li>    *<li>aggCalls = {AggCall(SUM, {1})}</li>    *</ul>    */
specifier|protected
class|class
name|AggConverter
implements|implements
name|SqlVisitor
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|Blackboard
name|bb
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|nameMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * The group-by expressions, in {@link SqlNode} format.      */
specifier|private
specifier|final
name|SqlNodeList
name|groupExprs
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
comment|/**      * Input expressions for the group columns and aggregates, in {@link      * RexNode} format. The first elements of the list correspond to the      * elements in {@link #groupExprs}; the remaining elements are for      * aggregates.      */
specifier|private
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|convertedInputExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Names of {@link #convertedInputExprs}, where the expressions are      * simple mappings to input fields.      */
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|convertedInputExprNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|inputRefs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexInputRef
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregateCall
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|RexNode
argument_list|>
name|aggMapping
init|=
operator|new
name|HashMap
argument_list|<
name|SqlNode
argument_list|,
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|AggregateCall
argument_list|,
name|RexNode
argument_list|>
name|aggCallMapping
init|=
operator|new
name|HashMap
argument_list|<
name|AggregateCall
argument_list|,
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Creates an AggConverter.      *      *<p>The<code>select</code> parameter provides enough context to name      * aggregate calls which are top-level select list items.      *      * @param bb     Blackboard      * @param select Query being translated; provides context to give      */
specifier|public
name|AggConverter
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|SqlSelect
name|select
parameter_list|)
block|{
name|this
operator|.
name|bb
operator|=
name|bb
expr_stmt|;
comment|// Collect all expressions used in the select list so that aggregate
comment|// calls can be named correctly.
specifier|final
name|SqlNodeList
name|selectList
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|selectItem
init|=
name|selectList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|name
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|SqlUtil
operator|.
name|isCallTo
argument_list|(
name|selectItem
argument_list|,
name|SqlStdOperatorTable
operator|.
name|AS
argument_list|)
condition|)
block|{
specifier|final
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|selectItem
decl_stmt|;
name|selectItem
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|name
operator|=
name|validator
operator|.
name|deriveAlias
argument_list|(
name|selectItem
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|nameMap
operator|.
name|put
argument_list|(
name|selectItem
operator|.
name|toString
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|addGroupExpr
parameter_list|(
name|SqlNode
name|expr
parameter_list|)
block|{
name|RexNode
name|convExpr
init|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|expr
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|rex
init|=
name|lookupGroupExpr
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|rex
operator|!=
literal|null
condition|)
block|{
return|return;
comment|// don't add duplicates, in e.g. "GROUP BY x, y, x"
block|}
name|groupExprs
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|nameMap
operator|.
name|get
argument_list|(
name|expr
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|addExpr
argument_list|(
name|convExpr
argument_list|,
name|name
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|convExpr
operator|.
name|getType
argument_list|()
decl_stmt|;
name|inputRefs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|type
argument_list|,
name|inputRefs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds an expression, deducing an appropriate name if possible.      *      * @param expr Expression      * @param name Suggested name      */
specifier|private
name|void
name|addExpr
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|convertedInputExprs
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|==
literal|null
operator|)
operator|&&
operator|(
name|expr
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
specifier|final
name|int
name|i
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|expr
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|name
operator|=
name|bb
operator|.
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|convertedInputExprNames
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|// In case like 'SELECT ... GROUP BY x, y, x', don't add
comment|// name 'x' twice.
name|name
operator|=
literal|null
expr_stmt|;
block|}
name|convertedInputExprNames
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|// implement SqlVisitor
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
comment|// implement SqlVisitor
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|nodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// implement SqlVisitor
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlLiteral
name|lit
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
comment|// implement SqlVisitor
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlDataTypeSpec
name|type
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
comment|// implement SqlVisitor
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
comment|// implement SqlVisitor
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|isAggregator
argument_list|()
condition|)
block|{
assert|assert
name|bb
operator|.
name|agg
operator|==
name|this
assert|;
name|List
argument_list|<
name|Integer
argument_list|>
name|args
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
init|=
name|call
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlCountAggFunction
condition|?
operator|new
name|ArrayList
argument_list|<
name|RelDataType
argument_list|>
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
else|:
literal|null
decl_stmt|;
try|try
block|{
comment|// switch out of agg mode
name|bb
operator|.
name|agg
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|RexNode
name|convertedExpr
decl_stmt|;
comment|// special case for COUNT(*):  delete the *
if|if
condition|(
name|operand
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|operand
decl_stmt|;
if|if
condition|(
name|id
operator|.
name|isStar
argument_list|()
condition|)
block|{
assert|assert
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|1
assert|;
assert|assert
name|args
operator|.
name|isEmpty
argument_list|()
assert|;
break|break;
block|}
block|}
name|convertedExpr
operator|=
name|bb
operator|.
name|convertExpression
argument_list|(
name|operand
argument_list|)
expr_stmt|;
assert|assert
name|convertedExpr
operator|!=
literal|null
assert|;
if|if
condition|(
name|argTypes
operator|!=
literal|null
condition|)
block|{
name|argTypes
operator|.
name|add
argument_list|(
name|convertedExpr
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|args
operator|.
name|add
argument_list|(
name|lookupOrCreateGroupExpr
argument_list|(
name|convertedExpr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// switch back into agg mode
name|bb
operator|.
name|agg
operator|=
name|this
expr_stmt|;
block|}
specifier|final
name|Aggregation
name|aggregation
init|=
operator|(
name|Aggregation
operator|)
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
name|RelDataType
name|type
init|=
name|validator
operator|.
name|deriveType
argument_list|(
name|bb
operator|.
name|scope
argument_list|,
name|call
argument_list|)
decl_stmt|;
name|boolean
name|distinct
init|=
literal|false
decl_stmt|;
name|SqlLiteral
name|quantifier
init|=
name|call
operator|.
name|getFunctionQuantifier
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
literal|null
operator|!=
name|quantifier
operator|)
operator|&&
operator|(
name|quantifier
operator|.
name|getValue
argument_list|()
operator|==
name|SqlSelectKeyword
operator|.
name|DISTINCT
operator|)
condition|)
block|{
name|distinct
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|AggregateCall
name|aggCall
init|=
operator|new
name|AggregateCall
argument_list|(
name|aggregation
argument_list|,
name|distinct
argument_list|,
name|args
argument_list|,
name|type
argument_list|,
name|nameMap
operator|.
name|get
argument_list|(
name|call
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|rex
init|=
name|rexBuilder
operator|.
name|addAggCall
argument_list|(
name|aggCall
argument_list|,
name|groupExprs
operator|.
name|size
argument_list|()
argument_list|,
name|aggCalls
argument_list|,
name|aggCallMapping
argument_list|,
name|argTypes
argument_list|)
decl_stmt|;
name|aggMapping
operator|.
name|put
argument_list|(
name|call
argument_list|,
name|rex
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|call
operator|instanceof
name|SqlSelect
condition|)
block|{
comment|// rchen 2006-10-17:
comment|// for now do not detect aggregates in subqueries.
return|return
literal|null
return|;
block|}
else|else
block|{
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
comment|// Operands are occasionally null, e.g. switched CASE arg 0.
if|if
condition|(
name|operand
operator|!=
literal|null
condition|)
block|{
name|operand
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|int
name|lookupOrCreateGroupExpr
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|convertedInputExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|convertedInputExpr
init|=
name|convertedInputExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|convertedInputExpr
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
comment|// not found -- add it
name|int
name|index
init|=
name|convertedInputExprs
operator|.
name|size
argument_list|()
decl_stmt|;
name|addExpr
argument_list|(
name|expr
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
comment|/**      * If an expression is structurally identical to one of the group-by      * expressions, returns a reference to the expression, otherwise returns      * null.      */
specifier|public
name|RexNode
name|lookupGroupExpr
parameter_list|(
name|SqlNode
name|expr
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|groupExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|groupExpr
init|=
name|groupExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|.
name|equalsDeep
argument_list|(
name|groupExpr
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
name|inputRefs
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|RexNode
name|lookupAggregates
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
comment|// assert call.getOperator().isAggregator();
assert|assert
name|bb
operator|.
name|agg
operator|==
name|this
assert|;
return|return
name|aggMapping
operator|.
name|get
argument_list|(
name|call
argument_list|)
return|;
block|}
specifier|public
name|List
argument_list|<
name|RexNode
argument_list|>
name|getPreExprs
parameter_list|()
block|{
return|return
name|convertedInputExprs
return|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getPreNames
parameter_list|()
block|{
return|return
name|convertedInputExprNames
return|;
block|}
specifier|public
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|getAggCalls
parameter_list|()
block|{
return|return
name|aggCalls
return|;
block|}
specifier|public
name|RelDataTypeFactory
name|getTypeFactory
parameter_list|()
block|{
return|return
name|typeFactory
return|;
block|}
block|}
comment|/**    * Context to find a relational expression to a field offset.    */
specifier|private
specifier|static
class|class
name|LookupContext
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|relOffsetList
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Creates a LookupContext with multiple input relational expressions.      *      * @param bb               Context for translating this subquery      * @param rels             Relational expressions      * @param systemFieldCount Number of system fields      */
name|LookupContext
parameter_list|(
name|Blackboard
name|bb
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|rels
parameter_list|,
name|int
name|systemFieldCount
parameter_list|)
block|{
name|bb
operator|.
name|flatten
argument_list|(
name|rels
argument_list|,
name|systemFieldCount
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|}
argument_list|,
name|relOffsetList
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the relational expression with a given offset, and the      * ordinal in the combined row of its first field.      *      *<p>For example, in {@code Emp JOIN Dept}, findRel(1) returns the      * relational expression for {@code Dept} and offset 6 (because      * {@code Emp} has 6 fields, therefore the first field of {@code Dept}      * is field 6.      *      * @param offset Offset of relational expression in FROM clause      * @return Relational expression and the ordinal of its first field      */
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
name|findRel
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
return|return
name|relOffsetList
operator|.
name|get
argument_list|(
name|offset
argument_list|)
return|;
block|}
block|}
comment|/**    * Shuttle which walks over a tree of {@link RexNode}s and applies 'over' to    * all agg functions.    *    *<p>This is necessary because the returned expression is not necessarily a    * call to an agg function. For example,    *    *<blockquote><code>AVG(x)</code></blockquote>    *    * becomes    *    *<blockquote><code>SUM(x) / COUNT(x)</code></blockquote>    *    *<p>Any aggregate functions are converted to calls to the internal<code>    * $Histogram</code> aggregation function and accessors such as<code>    * $HistogramMin</code>; for example,    *    *<blockquote><code>MIN(x), MAX(x)</code></blockquote>    *    * are converted to    *    *<blockquote><code>$HistogramMin($Histogram(x)),    * $HistogramMax($Histogram(x))</code></blockquote>    *    * Common sub-expression elmination will ensure that only one histogram is    * computed.    */
specifier|private
class|class
name|HistogramShuttle
extends|extends
name|RexShuttle
block|{
comment|/**      * Whether to convert calls to MIN(x) to HISTOGRAM_MIN(HISTOGRAM(x)).      * Histograms allow rolling computation, but require more space.      */
specifier|static
specifier|final
name|boolean
name|ENABLE_HISTOGRAM_AGG
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|partitionKeys
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|RexFieldCollation
argument_list|>
name|orderKeys
decl_stmt|;
specifier|private
specifier|final
name|RexWindowBound
name|lowerBound
decl_stmt|;
specifier|private
specifier|final
name|RexWindowBound
name|upperBound
decl_stmt|;
specifier|private
specifier|final
name|SqlWindow
name|window
decl_stmt|;
name|HistogramShuttle
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|partitionKeys
parameter_list|,
name|ImmutableList
argument_list|<
name|RexFieldCollation
argument_list|>
name|orderKeys
parameter_list|,
name|RexWindowBound
name|lowerBound
parameter_list|,
name|RexWindowBound
name|upperBound
parameter_list|,
name|SqlWindow
name|window
parameter_list|)
block|{
name|this
operator|.
name|partitionKeys
operator|=
name|partitionKeys
expr_stmt|;
name|this
operator|.
name|orderKeys
operator|=
name|orderKeys
expr_stmt|;
name|this
operator|.
name|lowerBound
operator|=
name|lowerBound
expr_stmt|;
name|this
operator|.
name|upperBound
operator|=
name|upperBound
expr_stmt|;
name|this
operator|.
name|window
operator|=
name|window
expr_stmt|;
block|}
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|op
operator|instanceof
name|SqlAggFunction
operator|)
condition|)
block|{
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
specifier|final
name|SqlAggFunction
name|aggOp
init|=
operator|(
name|SqlAggFunction
operator|)
name|op
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|call
operator|.
name|getType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|SqlFunction
name|histogramOp
init|=
operator|!
name|ENABLE_HISTOGRAM_AGG
condition|?
literal|null
else|:
name|getHistogramOp
argument_list|(
name|aggOp
argument_list|)
decl_stmt|;
if|if
condition|(
name|histogramOp
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RelDataType
name|histogramType
init|=
name|computeHistogramType
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|// For DECIMAL, since it's already represented as a bigint we
comment|// want to do a reinterpretCast instead of a cast to avoid
comment|// losing any precision.
name|boolean
name|reinterpretCast
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|DECIMAL
decl_stmt|;
comment|// Replace original expression with CAST of not one
comment|// of the supported types
if|if
condition|(
name|histogramType
operator|!=
name|type
condition|)
block|{
name|exprs
operator|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|(
name|exprs
argument_list|)
expr_stmt|;
name|exprs
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|reinterpretCast
condition|?
name|rexBuilder
operator|.
name|makeReinterpretCast
argument_list|(
name|histogramType
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
else|:
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|histogramType
argument_list|,
name|exprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RexCallBinding
name|bind
init|=
operator|new
name|RexCallBinding
argument_list|(
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|SqlStdOperatorTable
operator|.
name|HISTOGRAM_AGG
argument_list|,
name|exprs
argument_list|)
decl_stmt|;
name|RexNode
name|over
init|=
name|rexBuilder
operator|.
name|makeOver
argument_list|(
name|SqlStdOperatorTable
operator|.
name|HISTOGRAM_AGG
operator|.
name|inferReturnType
argument_list|(
name|bind
argument_list|)
argument_list|,
name|SqlStdOperatorTable
operator|.
name|HISTOGRAM_AGG
argument_list|,
name|exprs
argument_list|,
name|partitionKeys
argument_list|,
name|orderKeys
argument_list|,
name|lowerBound
argument_list|,
name|upperBound
argument_list|,
name|window
operator|.
name|isRows
argument_list|()
argument_list|,
name|window
operator|.
name|isAllowPartial
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|RexNode
name|histogramCall
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|histogramType
argument_list|,
name|histogramOp
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|over
argument_list|)
argument_list|)
decl_stmt|;
comment|// If needed, post Cast result back to original
comment|// type.
if|if
condition|(
name|histogramType
operator|!=
name|type
condition|)
block|{
if|if
condition|(
name|reinterpretCast
condition|)
block|{
name|histogramCall
operator|=
name|rexBuilder
operator|.
name|makeReinterpretCast
argument_list|(
name|type
argument_list|,
name|histogramCall
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|histogramCall
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|histogramCall
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|histogramCall
return|;
block|}
else|else
block|{
name|boolean
name|needSum0
init|=
name|aggOp
operator|==
name|SqlStdOperatorTable
operator|.
name|SUM
operator|&&
name|type
operator|.
name|isNullable
argument_list|()
decl_stmt|;
name|SqlAggFunction
name|aggOpToUse
init|=
name|needSum0
condition|?
name|SqlStdOperatorTable
operator|.
name|SUM0
else|:
name|aggOp
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeOver
argument_list|(
name|type
argument_list|,
name|aggOpToUse
argument_list|,
name|exprs
argument_list|,
name|partitionKeys
argument_list|,
name|orderKeys
argument_list|,
name|lowerBound
argument_list|,
name|upperBound
argument_list|,
name|window
operator|.
name|isRows
argument_list|()
argument_list|,
name|window
operator|.
name|isAllowPartial
argument_list|()
argument_list|,
name|needSum0
argument_list|)
return|;
block|}
block|}
comment|/**      * Returns the histogram operator corresponding to a given aggregate      * function.      *      *<p>For example,<code>getHistogramOp({@link      * SqlStdOperatorTable#MIN}}</code> returns {@link      * SqlStdOperatorTable#HISTOGRAM_MIN}.      *      * @param aggFunction An aggregate function      * @return Its histogram function, or null      */
name|SqlFunction
name|getHistogramOp
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|)
block|{
if|if
condition|(
name|aggFunction
operator|==
name|SqlStdOperatorTable
operator|.
name|MIN
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|HISTOGRAM_MIN
return|;
block|}
if|else if
condition|(
name|aggFunction
operator|==
name|SqlStdOperatorTable
operator|.
name|MAX
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|HISTOGRAM_MAX
return|;
block|}
if|else if
condition|(
name|aggFunction
operator|==
name|SqlStdOperatorTable
operator|.
name|FIRST_VALUE
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|HISTOGRAM_FIRST_VALUE
return|;
block|}
if|else if
condition|(
name|aggFunction
operator|==
name|SqlStdOperatorTable
operator|.
name|LAST_VALUE
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|HISTOGRAM_LAST_VALUE
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Returns the type for a histogram function. It is either the actual      * type or an an approximation to it.      */
specifier|private
name|RelDataType
name|computeHistogramType
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|BIGINT
operator|)
condition|)
block|{
return|return
operator|new
name|BasicSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
return|;
block|}
if|else if
condition|(
name|SqlTypeUtil
operator|.
name|isApproximateNumeric
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|DOUBLE
operator|)
condition|)
block|{
return|return
operator|new
name|BasicSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|type
return|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|// End SqlToRelConverter.java
end_comment

end_unit

