begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|util14
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_comment
comment|/**  *<code>Enum14</code> is a pre-JDK1.5-enum helper class for declaring a set of  * symbolic constants which have names, ordinals, and possibly descriptions. The  * ordinals do not have to be contiguous.  *  *<p>Typically, for a particular set of constants, you derive a class from this  * interface, and declare the constants as<code>public static final</code>  * members. Give it a private constructor, and a<code>public static final<i>  * ClassName</i> instance</code> member to hold the singleton instance.</p>  */
end_comment

begin_class
specifier|public
class|class
name|Enum14
implements|implements
name|Cloneable
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|emptyStringArray
init|=
operator|new
name|String
index|[
literal|0
index|]
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|/**    * map symbol names to values    */
specifier|private
name|HashMap
name|valuesByName
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|// the variables below are only set AFTER makeImmutable() has been called
comment|/**    * An array mapping ordinals to {@link Value}s. It is biased by the min    * value. It is built by {@link #makeImmutable}.    */
specifier|private
name|Value
index|[]
name|ordinalToValueMap
decl_stmt|;
comment|/**    * the largest ordinal value    */
specifier|private
name|int
name|max
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
comment|/**    * the smallest ordinal value    */
specifier|private
name|int
name|min
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a new empty, mutable enumeration.    */
specifier|public
name|Enum14
parameter_list|()
block|{
block|}
comment|/**    * Creates an enumeration, with an array of values, and freezes it.    */
specifier|public
name|Enum14
parameter_list|(
name|Value
index|[]
name|values
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|register
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|makeImmutable
argument_list|()
expr_stmt|;
block|}
comment|/**    * Creates an enumeration, initialize it with an array of strings, and    * freezes it.    */
specifier|public
name|Enum14
parameter_list|(
name|String
index|[]
name|names
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|names
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|register
argument_list|(
operator|new
name|BasicValue
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|makeImmutable
argument_list|()
expr_stmt|;
block|}
comment|/**    * Create an enumeration, initializes it with arrays of code/name pairs, and    * freezes it.    */
specifier|public
name|Enum14
parameter_list|(
name|String
index|[]
name|names
parameter_list|,
name|int
index|[]
name|codes
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|names
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|register
argument_list|(
operator|new
name|BasicValue
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
name|codes
index|[
name|i
index|]
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|makeImmutable
argument_list|()
expr_stmt|;
block|}
comment|/**    * Create an enumeration, initializes it with arrays of code/name pairs, and    * freezes it.    */
specifier|public
name|Enum14
parameter_list|(
name|String
index|[]
name|names
parameter_list|,
name|int
index|[]
name|codes
parameter_list|,
name|String
index|[]
name|descriptions
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|names
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|register
argument_list|(
operator|new
name|BasicValue
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
name|codes
index|[
name|i
index|]
argument_list|,
name|descriptions
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|makeImmutable
argument_list|()
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Returns the description associated with an ordinal; the return value is    * null if the ordinal is not a member of the enumeration.    *    * @pre isImmutable()    */
specifier|public
specifier|final
name|String
name|getDescription
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
assert|assert
operator|(
name|isImmutable
argument_list|()
operator|)
assert|;
specifier|final
name|Value
name|value
init|=
name|ordinalToValueMap
index|[
name|ordinal
operator|-
name|min
index|]
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|value
operator|.
name|getDescription
argument_list|()
return|;
block|}
block|}
specifier|public
specifier|final
name|boolean
name|isImmutable
parameter_list|()
block|{
return|return
operator|(
name|ordinalToValueMap
operator|!=
literal|null
operator|)
return|;
block|}
comment|/**    * Returns the number of enumerated values currently contained in this    * enumeration    */
specifier|public
specifier|final
name|int
name|getSize
parameter_list|()
block|{
return|return
name|valuesByName
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Returns the largest ordinal defined by this enumeration.    */
specifier|public
specifier|final
name|int
name|getMax
parameter_list|()
block|{
return|return
name|max
return|;
block|}
comment|/**    * Returns the smallest ordinal defined by this enumeration.    */
specifier|public
specifier|final
name|int
name|getMin
parameter_list|()
block|{
return|return
name|min
return|;
block|}
comment|/**    * Creates a mutable enumeration from an existing enumeration, which may    * already be immutable.    */
specifier|public
name|Enum14
name|getMutableClone14
parameter_list|()
block|{
return|return
operator|(
name|Enum14
operator|)
name|clone
argument_list|()
return|;
block|}
comment|/**    * Returns the name associated with an ordinal; the return value is null if    * the ordinal is not a member of the enumeration.    *    * @pre isImmutable()    */
specifier|public
specifier|final
name|String
name|getName
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
specifier|final
name|Value
name|value
init|=
name|getValue
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
return|return
operator|(
name|value
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|value
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/**    * Returns the value associated with an ordinal; the return value is null if    * the ordinal is not a member of the enumeration.    *    * @pre isImmutable()    */
specifier|public
specifier|final
name|Value
name|getValue
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
assert|assert
operator|(
name|isImmutable
argument_list|()
operator|)
assert|;
specifier|final
name|Value
name|value
init|=
name|ordinalToValueMap
index|[
name|ordinal
operator|-
name|min
index|]
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|value
return|;
block|}
block|}
comment|/**    * Returns the ordinal associated with a name    *    * @throws Error if the name is not a member of the enumeration    */
specifier|public
specifier|final
name|int
name|getOrdinal
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|getValue
argument_list|(
name|name
argument_list|)
operator|.
name|getOrdinal
argument_list|()
return|;
block|}
comment|/**    * Returns whether<code>ordinal</code> is valid for this enumeration. This    * method is particularly useful in pre- and post-conditions, for example    *    *<blockquote>    *<pre>&#64;param axisCode Axis code, must be a {&#64;link AxisCode} value    *&#64;pre AxisCode.instance.isValid(axisCode)</pre>    *</blockquote>    *    * @param ordinal Suspected ordinal from this enumeration.    * @return Whether<code>ordinal</code> is valid.    */
specifier|public
specifier|final
name|boolean
name|isValid
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ordinal
operator|<
name|min
operator|)
operator|||
operator|(
name|ordinal
operator|>
name|max
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getName
argument_list|(
name|ordinal
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns an iterator over the values of this enumeration.    */
specifier|public
name|Iterator
name|iterator
parameter_list|()
block|{
specifier|final
name|Collection
name|values
init|=
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|valuesByName
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|values
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/**    * Returns the names in this enumeration, in no particular order.    */
specifier|public
name|String
index|[]
name|getNames
parameter_list|()
block|{
return|return
operator|(
name|String
index|[]
operator|)
name|valuesByName
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
name|emptyStringArray
argument_list|)
return|;
block|}
comment|/**    * Returns the ordinal associated with a name.    *    * @throws Error if the name is not a member of the enumeration    */
specifier|public
name|Value
name|getValue
parameter_list|(
name|String
name|name
parameter_list|)
block|{
specifier|final
name|Value
name|value
init|=
operator|(
name|Value
operator|)
name|valuesByName
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
literal|"Unknown enum name:  "
operator|+
name|name
argument_list|)
throw|;
block|}
return|return
name|value
return|;
block|}
comment|/**    * Returns true if this enumerationr contains<code>name</code>, else false.    */
specifier|public
name|boolean
name|containsName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|valuesByName
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**    * Returns an error indicating that the value is illegal. (The client needs    * to throw the error.)    */
specifier|public
name|Error
name|badValue
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
return|return
operator|new
name|AssertionError
argument_list|(
literal|"bad value "
operator|+
name|ordinal
operator|+
literal|"("
operator|+
name|getName
argument_list|(
name|ordinal
argument_list|)
operator|+
literal|") for enumeration '"
operator|+
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
return|;
block|}
comment|/**    * Freezes the enumeration, preventing it from being further modified.    */
specifier|public
name|void
name|makeImmutable
parameter_list|()
block|{
name|ordinalToValueMap
operator|=
operator|new
name|Value
index|[
operator|(
literal|1
operator|+
name|max
operator|)
operator|-
name|min
index|]
expr_stmt|;
for|for
control|(
name|Iterator
name|values
init|=
name|valuesByName
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|values
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Value
name|value
init|=
operator|(
name|Value
operator|)
name|values
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|value
operator|.
name|getOrdinal
argument_list|()
operator|-
name|min
decl_stmt|;
if|if
condition|(
name|ordinalToValueMap
index|[
name|index
index|]
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Enumeration has more than one value with ordinal "
operator|+
name|value
operator|.
name|getOrdinal
argument_list|()
argument_list|)
throw|;
block|}
name|ordinalToValueMap
index|[
name|index
index|]
operator|=
name|value
expr_stmt|;
block|}
block|}
comment|/**    * Associates a symbolic name with an ordinal value.    *    * @pre value != null    * @pre !isImmutable()    * @pre value.getName() != null    */
specifier|public
name|void
name|register
parameter_list|(
name|Value
name|value
parameter_list|)
block|{
assert|assert
operator|(
name|value
operator|!=
literal|null
operator|)
assert|;
assert|assert
operator|(
operator|!
name|isImmutable
argument_list|()
operator|)
assert|;
specifier|final
name|String
name|name
init|=
name|value
operator|.
name|getName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|name
operator|!=
literal|null
operator|)
assert|;
name|Value
name|old
init|=
operator|(
name|Value
operator|)
name|valuesByName
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Enumeration already contained a value '"
operator|+
name|old
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|ordinal
init|=
name|value
operator|.
name|getOrdinal
argument_list|()
decl_stmt|;
name|min
operator|=
name|Math
operator|.
name|min
argument_list|(
name|min
argument_list|,
name|ordinal
argument_list|)
expr_stmt|;
name|max
operator|=
name|Math
operator|.
name|max
argument_list|(
name|max
argument_list|,
name|ordinal
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns an exception indicating that we didn't expect to find this value    * here.    *    * @see org.eigenbase.util.Util#unexpected    */
specifier|public
name|Error
name|unexpected
parameter_list|(
name|Value
name|value
parameter_list|)
block|{
return|return
operator|new
name|AssertionError
argument_list|(
literal|"Was not expecting value '"
operator|+
name|value
operator|+
literal|"' for enumeration '"
operator|+
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' in this context"
argument_list|)
return|;
block|}
specifier|protected
name|Object
name|clone
parameter_list|()
block|{
name|Enum14
name|clone
init|=
literal|null
decl_stmt|;
try|try
block|{
name|clone
operator|=
operator|(
name|Enum14
operator|)
name|super
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|ex
parameter_list|)
block|{
comment|// IMPLEMENT internal error?
block|}
name|clone
operator|.
name|valuesByName
operator|=
operator|(
name|HashMap
operator|)
name|valuesByName
operator|.
name|clone
argument_list|()
expr_stmt|;
name|clone
operator|.
name|ordinalToValueMap
operator|=
literal|null
expr_stmt|;
return|return
name|clone
return|;
block|}
comment|//~ Inner Interfaces -------------------------------------------------------
comment|/**    * A<code>Value</code> represents a member of an enumerated type. If an    * enumerated type is not based upon an explicit array of values, an array    * of {@link Enum14.BasicValue}s will implicitly be created.    */
specifier|public
interface|interface
name|Value
extends|extends
name|Comparable
block|{
name|String
name|getDescription
parameter_list|()
function_decl|;
name|String
name|getName
parameter_list|()
function_decl|;
name|int
name|getOrdinal
parameter_list|()
function_decl|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    *<code>BasicValue</code> is an obvious implementation of {@link    * Enum14.Value}. This class is marked Serializable so that serializable    * subclasses can be supported without requiring a default (no-argument)    * constructor. However, note that while<code>BasicValue</code> is marked    * Serializable, deserialized instances will be new instances rather than    * members of the original enumeration. In other words,<code>    * deserializedBasicValue == origBasicValue</code> will be false. Use {@link    * Enum14.SerializableValue} for instances that deserialize into members of    * the original enumeration so that<code>deserializedBasicValue ==    * origBasicValue</code> will be true.    */
specifier|public
specifier|static
class|class
name|BasicValue
implements|implements
name|Value
implements|,
name|Serializable
block|{
comment|/**      * SerialVersionUID created with JDK 1.5 serialver tool.      */
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|7944099370846909699L
decl_stmt|;
specifier|private
specifier|final
name|String
name|description
decl_stmt|;
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
specifier|final
name|int
name|ordinal
decl_stmt|;
comment|/**      * @pre name != null      */
specifier|public
name|BasicValue
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|String
name|description
parameter_list|)
block|{
assert|assert
operator|(
name|name
operator|!=
literal|null
operator|)
assert|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|this
operator|.
name|description
operator|=
name|description
expr_stmt|;
block|}
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
return|return
name|description
return|;
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
specifier|public
name|int
name|getOrdinal
parameter_list|()
block|{
return|return
name|ordinal
return|;
block|}
comment|/**      * Returns whether this value is equal to a given string.      *      * @deprecated I bet you meant to write<code>      * value.name.equals(s)</code> rather than<code>value.equals(s)</code>,      * didn't you?      */
specifier|public
name|boolean
name|equals
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|super
operator|.
name|equals
argument_list|(
name|s
argument_list|)
return|;
block|}
comment|// forwarding function for super.equals
specifier|public
specifier|final
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|super
operator|.
name|equals
argument_list|(
name|o
argument_list|)
return|;
block|}
comment|// keep checkstyle happy
specifier|public
specifier|final
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|super
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|// implement Comparable
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
assert|assert
operator|(
name|other
operator|instanceof
name|BasicValue
operator|)
assert|;
name|BasicValue
name|otherValue
init|=
operator|(
name|BasicValue
operator|)
name|other
decl_stmt|;
return|return
name|ordinal
operator|-
name|otherValue
operator|.
name|ordinal
return|;
block|}
comment|/**      * Returns the value's name.      */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
specifier|public
name|Error
name|unexpected
parameter_list|()
block|{
return|return
operator|new
name|AssertionError
argument_list|(
literal|"Value "
operator|+
name|name
operator|+
literal|" of class "
operator|+
name|getClass
argument_list|()
operator|+
literal|" unexpected here"
argument_list|)
return|;
block|}
block|}
comment|/**    *<code>SerializableValue</code> extends<code>BasicValue</code> to provide    * better support for serializable subclasses. Instances of<code>    * SerializableValue</code> will deserialize into members of the original    * enumeration so that<code>deserializedBasicValue == origBasicValue</code>    * will be true.    */
specifier|public
specifier|static
specifier|abstract
class|class
name|SerializableValue
extends|extends
name|BasicValue
implements|implements
name|Serializable
block|{
comment|/**      * SerialVersionUID created with JDK 1.5 serialver tool.      */
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1534436036499327177L
decl_stmt|;
comment|/**      * Ordinal value which, when deserialized, can be used by {@link      * #readResolve} to locate a matching instance in the original      * enumeration.      */
specifier|protected
name|int
name|_ordinal
decl_stmt|;
comment|/**      * Creates a new SerializableValue.      */
specifier|public
name|SerializableValue
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|String
name|description
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|,
name|ordinal
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
comment|/**      * Subclass must implement this method to retrieve a matching instance      * based on the<code>_ordinal</code> deserialized by {@link      * #readObject}. This would typically be an instance from the original      * enumeration. Current instance is the candidate object deserialized      * from the ObjectInputStream. It is incomplete, cannot be used as-is,      * and this method must return a valid replacement. For example,<br>      *<code>return SqlTypeName.get(_ordinal);</code>      *      * @return replacement instance that matches<code>_ordinal</code>      * @throws java.io.ObjectStreamException      */
specifier|protected
specifier|abstract
name|Object
name|readResolve
parameter_list|()
throws|throws
name|ObjectStreamException
function_decl|;
comment|/**      * Deserialization method reads the<code>_ordinal</code> value.      */
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|_ordinal
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
comment|/**      * Serialization method writes just the ordinal value.      */
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|this
operator|.
name|getOrdinal
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End Enum14.java
end_comment

end_unit

