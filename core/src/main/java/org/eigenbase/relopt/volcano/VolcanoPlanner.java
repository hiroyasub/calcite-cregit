begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|volcano
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|convert
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|metadata
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|rules
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|hep
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|expressions
operator|.
name|Expressions
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|runtime
operator|.
name|Spaces
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|util
operator|.
name|graph
operator|.
name|*
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Stacks
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * VolcanoPlanner optimizes queries by transforming expressions selectively  * according to a dynamic programming algorithm.  */
end_comment

begin_class
specifier|public
class|class
name|VolcanoPlanner
extends|extends
name|AbstractRelOptPlanner
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|protected
specifier|static
specifier|final
name|double
name|COST_IMPROVEMENT
init|=
literal|.5
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|protected
name|RelSubset
name|root
decl_stmt|;
comment|/**    * If true, the planner keeps applying rules as long as they continue to    * reduce the cost. If false, the planner terminates as soon as it has found    * any implementation, no matter how expensive. The default is false due to    * unresolved bugs with various rules.    */
specifier|protected
name|boolean
name|ambitious
init|=
literal|true
decl_stmt|;
comment|/**    * If true, and if {@link #ambitious} is true, the planner waits a finite    * number of iterations for the cost to improve.    *    *<p>The number of iterations K is equal to the number of iterations    * required to get the first finite plan. After the first finite plan, it    * continues to fire rules to try to improve it. The planner sets a target    * cost of the current best cost multiplied by {@link #COST_IMPROVEMENT}. If    * it does not meet that cost target within K steps, it quits, and uses the    * current best plan. If it meets the cost, it sets a new, lower target, and    * has another K iterations to meet it. And so forth.    *    *<p>If false, the planner continues to fire rules until the rule queue is    * empty.    */
specifier|protected
name|boolean
name|impatient
init|=
literal|false
decl_stmt|;
comment|/**    * Operands that apply to a given class of {@link RelNode}.    *    *<p>Any operand can be an 'entry point' to a rule call, when a RelNode is    * registered which matches the operand. This map allows us to narrow down    * operands based on the class of the RelNode.</p>    */
specifier|private
specifier|final
name|Multimap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|RelOptRuleOperand
argument_list|>
name|classOperands
init|=
name|LinkedListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
comment|/**    * List of all sets. Used only for debugging.    */
specifier|final
name|List
argument_list|<
name|RelSet
argument_list|>
name|allSets
init|=
operator|new
name|ArrayList
argument_list|<
name|RelSet
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Canonical map from {@link String digest} to the unique    * {@link RelNode relational expression} with that digest.    *    *<p>Row type is part of the key for the rare occasion that similar    * expressions have different types, e.g. variants of    * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a    * null VARCHAR(10).    */
specifier|private
specifier|final
name|Map
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|,
name|RelNode
argument_list|>
name|mapDigestToRel
init|=
operator|new
name|HashMap
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|,
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Map each registered expression ({@link RelNode}) to its equivalence set    * ({@link RelSubset}).    *    *<p>We use an {@link IdentityHashMap} to simplify the process of merging    * {@link RelSet} objects. Most {@link RelNode} objects are identified by    * their digest, which involves the set that their child relational    * expressions belong to. If those children belong to the same set, we have    * to be careful, otherwise it gets incestuous.</p>    */
specifier|private
specifier|final
name|IdentityHashMap
argument_list|<
name|RelNode
argument_list|,
name|RelSubset
argument_list|>
name|mapRel2Subset
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|RelNode
argument_list|,
name|RelSubset
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * The importance of relational expressions.    *    *<p>The map contains only RelNodes whose importance has been overridden    * using {@link RelOptPlanner#setImportance(RelNode, double)}. Other    * RelNodes are presumed to have 'normal' importance.    *    *<p>If a RelNode has 0 importance, all {@link RelOptRuleCall}s using it    * are ignored, and future RelOptRuleCalls are not queued up.    */
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Double
argument_list|>
name|relImportances
init|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|Double
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * List of all schemas which have been registered.    */
specifier|private
specifier|final
name|Set
argument_list|<
name|RelOptSchema
argument_list|>
name|registeredSchemas
init|=
operator|new
name|HashSet
argument_list|<
name|RelOptSchema
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Holds rule calls waiting to be fired.    */
specifier|final
name|RuleQueue
name|ruleQueue
init|=
operator|new
name|RuleQueue
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|/**    * Holds the currently registered RelTraitDefs.    */
specifier|private
specifier|final
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|traitDefs
init|=
operator|new
name|ArrayList
argument_list|<
name|RelTraitDef
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Set of all registered rules.    */
specifier|protected
specifier|final
name|Set
argument_list|<
name|RelOptRule
argument_list|>
name|ruleSet
init|=
operator|new
name|HashSet
argument_list|<
name|RelOptRule
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|int
name|nextSetId
init|=
literal|0
decl_stmt|;
comment|/**    * Incremented every time a relational expression is registered or two sets    * are merged. Tells us whether anything is going on.    */
specifier|private
name|int
name|registerCount
decl_stmt|;
comment|/**    * Listener for this planner, or null if none set.    */
name|RelOptListener
name|listener
decl_stmt|;
comment|/**    * Dump of the root relational expression, as it was before any rules were    * applied. For debugging.    */
specifier|private
name|String
name|originalRootString
decl_stmt|;
specifier|private
name|RelNode
name|originalRoot
decl_stmt|;
comment|/**    * Whether the planner can accept new rules.    */
specifier|private
name|boolean
name|locked
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|materializations
init|=
operator|new
name|ArrayList
argument_list|<
name|RelOptMaterialization
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Provenance
argument_list|>
name|provenanceMap
init|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|Provenance
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|VolcanoRuleCall
argument_list|>
name|ruleCallStack
init|=
operator|new
name|ArrayList
argument_list|<
name|VolcanoRuleCall
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Zero cost, according to {@link #costFactory}. Not necessarily a    * {@link org.eigenbase.relopt.volcano.VolcanoCost}. */
specifier|private
specifier|final
name|RelOptCost
name|zeroCost
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a uninitialized<code>VolcanoPlanner</code>. To fully initialize    * it, the caller must register the desired set of relations, rules, and    * calling conventions.    */
specifier|public
name|VolcanoPlanner
parameter_list|()
block|{
name|this
argument_list|(
name|VolcanoCost
operator|.
name|FACTORY
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a {@code VolcanoPlanner} with a given cost factory.    */
specifier|protected
name|VolcanoPlanner
parameter_list|(
name|RelOptCostFactory
name|costFactory
parameter_list|)
block|{
name|super
argument_list|(
name|costFactory
argument_list|)
expr_stmt|;
name|this
operator|.
name|zeroCost
operator|=
name|costFactory
operator|.
name|makeZeroCost
argument_list|()
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|protected
name|VolcanoPlannerPhaseRuleMappingInitializer
name|getPhaseRuleMappingInitializer
parameter_list|()
block|{
return|return
operator|new
name|VolcanoPlannerPhaseRuleMappingInitializer
argument_list|()
block|{
specifier|public
name|void
name|initialize
parameter_list|(
name|Map
argument_list|<
name|VolcanoPlannerPhase
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|phaseRuleMap
parameter_list|)
block|{
comment|// Disable all phases except OPTIMIZE by adding one useless rule name.
name|phaseRuleMap
operator|.
name|get
argument_list|(
name|VolcanoPlannerPhase
operator|.
name|PRE_PROCESS_MDR
argument_list|)
operator|.
name|add
argument_list|(
literal|"xxx"
argument_list|)
expr_stmt|;
name|phaseRuleMap
operator|.
name|get
argument_list|(
name|VolcanoPlannerPhase
operator|.
name|PRE_PROCESS
argument_list|)
operator|.
name|add
argument_list|(
literal|"xxx"
argument_list|)
expr_stmt|;
name|phaseRuleMap
operator|.
name|get
argument_list|(
name|VolcanoPlannerPhase
operator|.
name|CLEANUP
argument_list|)
operator|.
name|add
argument_list|(
literal|"xxx"
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|boolean
name|isRegistered
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|mapRel2Subset
operator|.
name|get
argument_list|(
name|rel
argument_list|)
operator|!=
literal|null
return|;
block|}
specifier|public
name|void
name|setRoot
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|this
operator|.
name|root
operator|=
name|registerImpl
argument_list|(
name|rel
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|originalRoot
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|originalRoot
operator|=
name|rel
expr_stmt|;
block|}
name|this
operator|.
name|originalRootString
operator|=
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|,
name|SqlExplainLevel
operator|.
name|ALL_ATTRIBUTES
argument_list|)
expr_stmt|;
comment|// Making a node the root changes its importance.
name|this
operator|.
name|ruleQueue
operator|.
name|recompute
argument_list|(
name|this
operator|.
name|root
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RelNode
name|getRoot
parameter_list|()
block|{
return|return
name|root
return|;
block|}
specifier|public
name|void
name|addMaterialization
parameter_list|(
name|RelOptMaterialization
name|materialization
parameter_list|)
block|{
name|materializations
operator|.
name|add
argument_list|(
name|materialization
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|useMaterialization
parameter_list|(
name|RelOptMaterialization
name|materialization
parameter_list|)
block|{
comment|// Try to rewrite the original root query in terms of the materialized
comment|// query. If that is possible, register the remnant query as equivalent
comment|// to the root.
comment|//
name|RelNode
name|sub
init|=
name|substitute
argument_list|(
name|originalRoot
argument_list|,
name|materialization
argument_list|)
decl_stmt|;
if|if
condition|(
name|sub
operator|!=
literal|null
condition|)
block|{
comment|// TODO: try to substitute other materializations in the remnant.
comment|// Useful for big queries, e.g.
comment|//   (t1 group by c1) join (t2 group by c2).
name|registerImpl
argument_list|(
name|sub
argument_list|,
name|root
operator|.
name|set
argument_list|)
expr_stmt|;
return|return;
block|}
name|RelSubset
name|subset
init|=
name|registerImpl
argument_list|(
name|materialization
operator|.
name|queryRel
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|RelNode
name|tableRel2
init|=
name|RelOptUtil
operator|.
name|createCastRel
argument_list|(
name|materialization
operator|.
name|tableRel
argument_list|,
name|materialization
operator|.
name|queryRel
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|registerImpl
argument_list|(
name|tableRel2
argument_list|,
name|subset
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
specifier|private
name|RelNode
name|substitute
parameter_list|(
name|RelNode
name|root
parameter_list|,
name|RelOptMaterialization
name|materialization
parameter_list|)
block|{
comment|// First, if the materialization is in terms of a star table, rewrite
comment|// the query in terms of the star table.
if|if
condition|(
name|materialization
operator|.
name|starTable
operator|!=
literal|null
condition|)
block|{
name|root
operator|=
name|RelOptMaterialization
operator|.
name|tryUseStar
argument_list|(
name|root
argument_list|,
name|materialization
operator|.
name|starRelOptTable
argument_list|)
expr_stmt|;
block|}
comment|// Push filters to the bottom, and combine projects on top.
name|RelNode
name|target
init|=
name|materialization
operator|.
name|queryRel
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|MergeProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|target
operator|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
return|return
operator|new
name|SubstitutionVisitor
argument_list|(
name|target
argument_list|,
name|root
argument_list|)
operator|.
name|go
argument_list|(
name|materialization
operator|.
name|tableRel
argument_list|)
return|;
block|}
specifier|private
name|void
name|useApplicableMaterializations
parameter_list|()
block|{
comment|// Given materializations:
comment|//   T = Emps Join Depts
comment|//   T2 = T Group by C1
comment|// graph will contain
comment|//   (T, Emps), (T, Depts), (T2, T)
comment|// and therefore we can deduce T2 uses Emps.
name|DirectedGraph
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|DefaultEdge
argument_list|>
name|usesGraph
init|=
name|DefaultDirectedGraph
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|RelOptMaterialization
name|materialization
range|:
name|materializations
control|)
block|{
if|if
condition|(
name|materialization
operator|.
name|table
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|RelOptTable
name|usedTable
range|:
name|findTables
argument_list|(
name|materialization
operator|.
name|queryRel
argument_list|)
control|)
block|{
name|usesGraph
operator|.
name|addVertex
argument_list|(
name|materialization
operator|.
name|table
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
expr_stmt|;
name|usesGraph
operator|.
name|addVertex
argument_list|(
name|usedTable
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
expr_stmt|;
name|usesGraph
operator|.
name|addEdge
argument_list|(
name|materialization
operator|.
name|table
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|usedTable
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Use a materialization if uses at least one of the tables are used by
comment|// the query. (Simple rule that includes some materializations we won't
comment|// actually use.)
specifier|final
name|Graphs
operator|.
name|FrozenGraph
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|DefaultEdge
argument_list|>
name|frozenGraph
init|=
name|Graphs
operator|.
name|makeImmutable
argument_list|(
name|usesGraph
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelOptTable
argument_list|>
name|queryTables
init|=
name|findTables
argument_list|(
name|originalRoot
argument_list|)
decl_stmt|;
for|for
control|(
name|RelOptMaterialization
name|materialization
range|:
name|materializations
control|)
block|{
if|if
condition|(
name|materialization
operator|.
name|table
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|usesTable
argument_list|(
name|materialization
operator|.
name|table
argument_list|,
name|queryTables
argument_list|,
name|frozenGraph
argument_list|)
condition|)
block|{
name|useMaterialization
argument_list|(
name|materialization
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Returns whether {@code table} uses one or more of the tables in    * {@code usedTables}.    */
specifier|private
name|boolean
name|usesTable
parameter_list|(
name|RelOptTable
name|table
parameter_list|,
name|Set
argument_list|<
name|RelOptTable
argument_list|>
name|usedTables
parameter_list|,
name|Graphs
operator|.
name|FrozenGraph
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|DefaultEdge
argument_list|>
name|usesGraph
parameter_list|)
block|{
for|for
control|(
name|RelOptTable
name|queryTable
range|:
name|usedTables
control|)
block|{
if|if
condition|(
name|usesGraph
operator|.
name|getShortestPath
argument_list|(
name|table
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|queryTable
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
name|Set
argument_list|<
name|RelOptTable
argument_list|>
name|findTables
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|RelOptTable
argument_list|>
name|usedTables
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|RelOptTable
argument_list|>
argument_list|()
decl_stmt|;
operator|new
name|RelVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|TableAccessRelBase
condition|)
block|{
name|usedTables
operator|.
name|add
argument_list|(
name|node
operator|.
name|getTable
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// CHECKSTYLE: IGNORE 1
block|}
operator|.
name|go
argument_list|(
name|rel
argument_list|)
expr_stmt|;
return|return
name|usedTables
return|;
block|}
comment|/**    * Finds an expression's equivalence set. If the expression is not    * registered, returns null.    *    * @param rel Relational expression    * @return Equivalence set that expression belongs to, or null if it is not    * registered    */
specifier|public
name|RelSet
name|getSet
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
assert|assert
name|rel
operator|!=
literal|null
operator|:
literal|"pre: rel != null"
assert|;
specifier|final
name|RelSubset
name|subset
init|=
name|getSubset
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|subset
operator|!=
literal|null
condition|)
block|{
assert|assert
name|subset
operator|.
name|set
operator|!=
literal|null
assert|;
return|return
name|subset
operator|.
name|set
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|addRelTraitDef
parameter_list|(
name|RelTraitDef
name|relTraitDef
parameter_list|)
block|{
return|return
operator|!
name|traitDefs
operator|.
name|contains
argument_list|(
name|relTraitDef
argument_list|)
operator|&&
name|traitDefs
operator|.
name|add
argument_list|(
name|relTraitDef
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clearRelTraitDefs
parameter_list|()
block|{
name|traitDefs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|getRelTraitDefs
parameter_list|()
block|{
return|return
name|traitDefs
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelTraitSet
name|emptyTraitSet
parameter_list|()
block|{
name|RelTraitSet
name|traitSet
init|=
name|super
operator|.
name|emptyTraitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTraitDef
name|traitDef
range|:
name|traitDefs
control|)
block|{
if|if
condition|(
name|traitDef
operator|.
name|multiple
argument_list|()
condition|)
block|{
comment|// TODO: restructure RelTraitSet to allow a list of entries
comment|//  for any given trait
block|}
name|traitSet
operator|=
name|traitSet
operator|.
name|plus
argument_list|(
name|traitDef
operator|.
name|getDefault
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|traitSet
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|super
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|ruleSet
argument_list|)
control|)
block|{
name|removeRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|classOperands
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|allSets
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|mapDigestToRel
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|mapRel2Subset
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|relImportances
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|ruleQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|addRule
parameter_list|(
name|RelOptRule
name|rule
parameter_list|)
block|{
if|if
condition|(
name|locked
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|ruleSet
operator|.
name|contains
argument_list|(
name|rule
argument_list|)
condition|)
block|{
comment|// Rule already exists.
return|return
literal|false
return|;
block|}
specifier|final
name|boolean
name|added
init|=
name|ruleSet
operator|.
name|add
argument_list|(
name|rule
argument_list|)
decl_stmt|;
assert|assert
name|added
assert|;
name|mapRuleDescription
argument_list|(
name|rule
argument_list|)
expr_stmt|;
comment|// Each of this rule's operands is an 'entry point' for a rule call.
comment|// Register each operand against all concrete sub-classes that could match
comment|// it.
for|for
control|(
name|RelOptRuleOperand
name|operand
range|:
name|rule
operator|.
name|getOperands
argument_list|()
control|)
block|{
for|for
control|(
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|subClass
range|:
name|subClasses
argument_list|(
name|operand
operator|.
name|getMatchedClass
argument_list|()
argument_list|)
control|)
block|{
name|classOperands
operator|.
name|put
argument_list|(
name|subClass
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If this is a converter rule, check that it operates on one of the
comment|// kinds of trait we are interested in, and if so, register the rule
comment|// with the trait.
if|if
condition|(
name|rule
operator|instanceof
name|ConverterRule
condition|)
block|{
name|ConverterRule
name|converterRule
init|=
operator|(
name|ConverterRule
operator|)
name|rule
decl_stmt|;
specifier|final
name|RelTrait
name|ruleTrait
init|=
name|converterRule
operator|.
name|getInTrait
argument_list|()
decl_stmt|;
specifier|final
name|RelTraitDef
name|ruleTraitDef
init|=
name|ruleTrait
operator|.
name|getTraitDef
argument_list|()
decl_stmt|;
if|if
condition|(
name|traitDefs
operator|.
name|contains
argument_list|(
name|ruleTraitDef
argument_list|)
condition|)
block|{
name|ruleTraitDef
operator|.
name|registerConverterRule
argument_list|(
name|this
argument_list|,
name|converterRule
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|removeRule
parameter_list|(
name|RelOptRule
name|rule
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ruleSet
operator|.
name|remove
argument_list|(
name|rule
argument_list|)
condition|)
block|{
comment|// Rule was not present.
return|return
literal|false
return|;
block|}
comment|// Remove description.
name|unmapRuleDescription
argument_list|(
name|rule
argument_list|)
expr_stmt|;
comment|// Remove operands.
for|for
control|(
name|Iterator
argument_list|<
name|RelOptRuleOperand
argument_list|>
name|iter
init|=
name|classOperands
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|RelOptRuleOperand
name|entry
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|getRule
argument_list|()
operator|.
name|equals
argument_list|(
name|rule
argument_list|)
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Remove trait mappings. (In particular, entries from conversion
comment|// graph.)
if|if
condition|(
name|rule
operator|instanceof
name|ConverterRule
condition|)
block|{
name|ConverterRule
name|converterRule
init|=
operator|(
name|ConverterRule
operator|)
name|rule
decl_stmt|;
specifier|final
name|RelTrait
name|ruleTrait
init|=
name|converterRule
operator|.
name|getInTrait
argument_list|()
decl_stmt|;
specifier|final
name|RelTraitDef
name|ruleTraitDef
init|=
name|ruleTrait
operator|.
name|getTraitDef
argument_list|()
decl_stmt|;
if|if
condition|(
name|traitDefs
operator|.
name|contains
argument_list|(
name|ruleTraitDef
argument_list|)
condition|)
block|{
name|ruleTraitDef
operator|.
name|deregisterConverterRule
argument_list|(
name|this
argument_list|,
name|converterRule
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|onNewClass
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
name|super
operator|.
name|onNewClass
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// Create mappings so that instances of this class will match existing
comment|// operands.
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|clazz
init|=
name|node
operator|.
name|getClass
argument_list|()
decl_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|ruleSet
control|)
block|{
for|for
control|(
name|RelOptRuleOperand
name|operand
range|:
name|rule
operator|.
name|getOperands
argument_list|()
control|)
block|{
if|if
condition|(
name|operand
operator|.
name|getMatchedClass
argument_list|()
operator|.
name|isAssignableFrom
argument_list|(
name|clazz
argument_list|)
condition|)
block|{
name|classOperands
operator|.
name|put
argument_list|(
name|clazz
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|boolean
name|canConvert
parameter_list|(
name|RelTraitSet
name|fromTraits
parameter_list|,
name|RelTraitSet
name|toTraits
parameter_list|)
block|{
assert|assert
name|fromTraits
operator|.
name|size
argument_list|()
operator|>=
name|toTraits
operator|.
name|size
argument_list|()
assert|;
name|boolean
name|canConvert
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
operator|(
name|i
operator|<
name|toTraits
operator|.
name|size
argument_list|()
operator|)
operator|&&
name|canConvert
condition|;
name|i
operator|++
control|)
block|{
name|RelTrait
name|fromTrait
init|=
name|fromTraits
operator|.
name|getTrait
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RelTrait
name|toTrait
init|=
name|toTraits
operator|.
name|getTrait
argument_list|(
name|i
argument_list|)
decl_stmt|;
assert|assert
name|fromTrait
operator|.
name|getTraitDef
argument_list|()
operator|==
name|toTrait
operator|.
name|getTraitDef
argument_list|()
assert|;
assert|assert
name|traitDefs
operator|.
name|contains
argument_list|(
name|fromTrait
operator|.
name|getTraitDef
argument_list|()
argument_list|)
assert|;
assert|assert
name|traitDefs
operator|.
name|contains
argument_list|(
name|toTrait
operator|.
name|getTraitDef
argument_list|()
argument_list|)
assert|;
name|canConvert
operator|=
name|fromTrait
operator|.
name|getTraitDef
argument_list|()
operator|.
name|canConvert
argument_list|(
name|this
argument_list|,
name|fromTrait
argument_list|,
name|toTrait
argument_list|)
expr_stmt|;
block|}
return|return
name|canConvert
return|;
block|}
specifier|public
name|RelNode
name|changeTraits
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|toTraits
parameter_list|)
block|{
assert|assert
operator|!
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|toTraits
argument_list|)
operator|:
literal|"pre: !rel.getTraits().equals(toTraits)"
assert|;
name|RelSubset
name|rel2
init|=
name|ensureRegistered
argument_list|(
name|rel
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|rel2
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|toTraits
argument_list|)
condition|)
block|{
return|return
name|rel2
return|;
block|}
return|return
name|rel2
operator|.
name|set
operator|.
name|getOrCreateSubset
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|toTraits
argument_list|)
return|;
block|}
specifier|public
name|RelOptPlanner
name|chooseDelegate
parameter_list|()
block|{
return|return
name|this
return|;
block|}
comment|/**    * Finds the most efficient expression to implement the query given via    * {@link org.eigenbase.relopt.RelOptPlanner#setRoot(org.eigenbase.rel.RelNode)}.    *    *<p>The algorithm executes repeatedly in a series of phases. In each phase    * the exact rules that may be fired varies. The mapping of phases to rule    * sets is maintained in the {@link #ruleQueue}.    *    *<p>In each phase, the planner sets the initial importance of the existing    * RelSubSets ({@link #setInitialImportance()}). The planner then iterates    * over the rule matches presented by the rule queue until:    *    *<ol>    *<li>The rule queue becomes empty.</li>    *<li>For ambitious planners: No improvements to the plan have been made    * recently (specifically within a number of iterations that is 10% of the    * number of iterations necessary to first reach an implementable plan or 25    * iterations whichever is larger).</li>    *<li>For non-ambitious planners: When an implementable plan is found.</li>    *</ol>    *    *<p>Furthermore, after every 10 iterations without an implementable plan,    * RelSubSets that contain only logical RelNodes are given an importance    * boost via {@link #injectImportanceBoost()}. Once an implementable plan is    * found, the artificially raised importances are cleared ({@link    * #clearImportanceBoost()}).    *    * @return the most efficient RelNode tree found for implementing the given    * query    */
specifier|public
name|RelNode
name|findBestExp
parameter_list|()
block|{
name|useApplicableMaterializations
argument_list|()
expr_stmt|;
name|int
name|cumulativeTicks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|VolcanoPlannerPhase
name|phase
range|:
name|VolcanoPlannerPhase
operator|.
name|values
argument_list|()
control|)
block|{
name|setInitialImportance
argument_list|()
expr_stmt|;
name|RelOptCost
name|targetCost
init|=
name|costFactory
operator|.
name|makeHugeCost
argument_list|()
decl_stmt|;
name|int
name|tick
init|=
literal|0
decl_stmt|;
name|int
name|firstFiniteTick
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|splitCount
init|=
literal|0
decl_stmt|;
name|int
name|giveUpTick
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
operator|++
name|tick
expr_stmt|;
operator|++
name|cumulativeTicks
expr_stmt|;
if|if
condition|(
name|root
operator|.
name|bestCost
operator|.
name|isLe
argument_list|(
name|targetCost
argument_list|)
condition|)
block|{
if|if
condition|(
name|firstFiniteTick
operator|<
literal|0
condition|)
block|{
name|firstFiniteTick
operator|=
name|cumulativeTicks
expr_stmt|;
name|clearImportanceBoost
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ambitious
condition|)
block|{
comment|// Choose a slightly more ambitious target cost, and
comment|// try again. If it took us 1000 iterations to find our
comment|// first finite plan, give ourselves another 100
comment|// iterations to reduce the cost by 10%.
name|targetCost
operator|=
name|root
operator|.
name|bestCost
operator|.
name|multiplyBy
argument_list|(
literal|0.9
argument_list|)
expr_stmt|;
operator|++
name|splitCount
expr_stmt|;
if|if
condition|(
name|impatient
condition|)
block|{
if|if
condition|(
name|firstFiniteTick
operator|<
literal|10
condition|)
block|{
comment|// It's possible pre-processing can create
comment|// an implementable plan -- give us some time
comment|// to actually optimize it.
name|giveUpTick
operator|=
name|cumulativeTicks
operator|+
literal|25
expr_stmt|;
block|}
else|else
block|{
name|giveUpTick
operator|=
name|cumulativeTicks
operator|+
name|Math
operator|.
name|max
argument_list|(
name|firstFiniteTick
operator|/
literal|10
argument_list|,
literal|25
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
if|else if
condition|(
name|cumulativeTicks
operator|>
name|giveUpTick
condition|)
block|{
comment|// We haven't made progress recently. Take the current best.
break|break;
block|}
if|else if
condition|(
name|root
operator|.
name|bestCost
operator|.
name|isInfinite
argument_list|()
operator|&&
operator|(
operator|(
name|tick
operator|%
literal|10
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|injectImportanceBoost
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|fine
argument_list|(
literal|"PLANNER = "
operator|+
name|this
operator|+
literal|"; TICK = "
operator|+
name|cumulativeTicks
operator|+
literal|"/"
operator|+
name|tick
operator|+
literal|"; PHASE = "
operator|+
name|phase
operator|.
name|toString
argument_list|()
operator|+
literal|"; COST = "
operator|+
name|root
operator|.
name|bestCost
argument_list|)
expr_stmt|;
block|}
name|VolcanoRuleMatch
name|match
init|=
name|ruleQueue
operator|.
name|popMatch
argument_list|(
name|phase
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|==
literal|null
condition|)
block|{
break|break;
block|}
assert|assert
name|match
operator|.
name|getRule
argument_list|()
operator|.
name|matches
argument_list|(
name|match
argument_list|)
assert|;
name|match
operator|.
name|onMatch
argument_list|()
expr_stmt|;
comment|// The root may have been merged with another
comment|// subset. Find the new root subset.
name|root
operator|=
name|canonize
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
name|ruleQueue
operator|.
name|phaseCompleted
argument_list|(
name|phase
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINER
argument_list|)
condition|)
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|dump
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
name|LOGGER
operator|.
name|finer
argument_list|(
name|sw
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|cheapest
init|=
name|root
operator|.
name|buildCheapestPlan
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|fine
argument_list|(
literal|"Cheapest plan:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|cheapest
argument_list|,
name|SqlExplainLevel
operator|.
name|ALL_ATTRIBUTES
argument_list|)
argument_list|)
expr_stmt|;
name|LOGGER
operator|.
name|fine
argument_list|(
literal|"Provenance:\n"
operator|+
name|provenance
argument_list|(
name|cheapest
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cheapest
return|;
block|}
comment|/**    * Returns a multi-line string describing the provenance of a tree of    * relational expressions. For each node in the tree, prints the rule that    * created the node, if any. Recursively describes the provenance of the    * relational expressions that are the arguments to that rule.    *    *<p>Thus, every relational expression and rule invocation that affected    * the final outcome is described in the provenance. This can be useful    * when finding the root cause of "mistakes" in a query plan.</p>    *    * @param root Root relational expression in a tree    * @return Multi-line string describing the rules that created the tree    */
specifier|private
name|String
name|provenance
parameter_list|(
name|RelNode
name|root
parameter_list|)
block|{
specifier|final
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
operator|new
name|RelVisitor
argument_list|()
block|{
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// CHECKSTYLE: IGNORE 1
block|}
operator|.
name|go
argument_list|(
name|root
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|RelNode
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|node
range|:
name|nodes
control|)
block|{
name|provenanceRecurse
argument_list|(
name|pw
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
name|visited
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Helper for {@link #provenance(org.eigenbase.rel.RelNode)}.    */
specifier|private
name|void
name|provenanceRecurse
parameter_list|(
name|PrintWriter
name|pw
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|int
name|i
parameter_list|,
name|Set
argument_list|<
name|RelNode
argument_list|>
name|visited
parameter_list|)
block|{
name|Spaces
operator|.
name|append
argument_list|(
name|pw
argument_list|,
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|visited
operator|.
name|add
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|"rel#"
operator|+
name|node
operator|.
name|getId
argument_list|()
operator|+
literal|" (see above)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pw
operator|.
name|println
argument_list|(
name|node
argument_list|)
expr_stmt|;
specifier|final
name|Provenance
name|o
init|=
name|provenanceMap
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|Spaces
operator|.
name|append
argument_list|(
name|pw
argument_list|,
name|i
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|Provenance
operator|.
name|EMPTY
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|"no parent"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|o
operator|instanceof
name|DirectProvenance
condition|)
block|{
name|RelNode
name|rel
init|=
operator|(
operator|(
name|DirectProvenance
operator|)
name|o
operator|)
operator|.
name|source
decl_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"direct"
argument_list|)
expr_stmt|;
name|provenanceRecurse
argument_list|(
name|pw
argument_list|,
name|rel
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|visited
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|o
operator|instanceof
name|RuleProvenance
condition|)
block|{
name|RuleProvenance
name|rule
init|=
operator|(
name|RuleProvenance
operator|)
name|o
decl_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"call#"
operator|+
name|rule
operator|.
name|callId
operator|+
literal|" rule ["
operator|+
name|rule
operator|.
name|rule
operator|+
literal|"]"
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|rule
operator|.
name|rels
control|)
block|{
name|provenanceRecurse
argument_list|(
name|pw
argument_list|,
name|rel
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|visited
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"bad type "
operator|+
name|o
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|setInitialImportance
parameter_list|()
block|{
name|RelVisitor
name|visitor
init|=
operator|new
name|RelVisitor
argument_list|()
block|{
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|HashSet
argument_list|<
name|RelSubset
argument_list|>
name|visitedSubsets
init|=
operator|new
name|HashSet
argument_list|<
name|RelSubset
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|p
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|p
operator|instanceof
name|RelSubset
condition|)
block|{
name|RelSubset
name|subset
init|=
operator|(
name|RelSubset
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|visitedSubsets
operator|.
name|contains
argument_list|(
name|subset
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|subset
operator|!=
name|root
condition|)
block|{
name|Double
name|importance
init|=
name|Math
operator|.
name|pow
argument_list|(
literal|0.9
argument_list|,
operator|(
name|double
operator|)
name|depth
argument_list|)
decl_stmt|;
name|ruleQueue
operator|.
name|updateImportance
argument_list|(
name|subset
argument_list|,
name|importance
argument_list|)
expr_stmt|;
block|}
name|visitedSubsets
operator|.
name|add
argument_list|(
name|subset
argument_list|)
expr_stmt|;
name|depth
operator|++
expr_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|subset
operator|.
name|getRels
argument_list|()
control|)
block|{
name|visit
argument_list|(
name|rel
argument_list|,
operator|-
literal|1
argument_list|,
name|subset
argument_list|)
expr_stmt|;
block|}
name|depth
operator|--
expr_stmt|;
block|}
else|else
block|{
name|super
operator|.
name|visit
argument_list|(
name|p
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|visitor
operator|.
name|go
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
comment|/**    * Finds RelSubsets in the plan that contain only rels of {@link    * Convention#NONE} and boosts their importance by 25%.    */
specifier|private
name|void
name|injectImportanceBoost
parameter_list|()
block|{
name|HashSet
argument_list|<
name|RelSubset
argument_list|>
name|requireBoost
init|=
operator|new
name|HashSet
argument_list|<
name|RelSubset
argument_list|>
argument_list|()
decl_stmt|;
name|SUBSET_LOOP
label|:
for|for
control|(
name|RelSubset
name|subset
range|:
name|ruleQueue
operator|.
name|subsetImportances
operator|.
name|keySet
argument_list|()
control|)
block|{
for|for
control|(
name|RelNode
name|rel
range|:
name|subset
operator|.
name|getRels
argument_list|()
control|)
block|{
if|if
condition|(
name|rel
operator|.
name|getConvention
argument_list|()
operator|!=
name|Convention
operator|.
name|NONE
condition|)
block|{
continue|continue
name|SUBSET_LOOP
continue|;
block|}
block|}
name|requireBoost
operator|.
name|add
argument_list|(
name|subset
argument_list|)
expr_stmt|;
block|}
name|ruleQueue
operator|.
name|boostImportance
argument_list|(
name|requireBoost
argument_list|,
literal|1.25
argument_list|)
expr_stmt|;
block|}
comment|/**    * Clear all importance boosts.    */
specifier|private
name|void
name|clearImportanceBoost
parameter_list|()
block|{
name|Collection
argument_list|<
name|RelSubset
argument_list|>
name|empty
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
name|ruleQueue
operator|.
name|boostImportance
argument_list|(
name|empty
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RelSubset
name|register
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|equivRel
parameter_list|)
block|{
assert|assert
operator|!
name|isRegistered
argument_list|(
name|rel
argument_list|)
operator|:
literal|"pre: isRegistered(rel)"
assert|;
specifier|final
name|RelSet
name|set
decl_stmt|;
if|if
condition|(
name|equivRel
operator|==
literal|null
condition|)
block|{
name|set
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|RelOptUtil
operator|.
name|equal
argument_list|(
literal|"rel rowtype"
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|"equivRel rowtype"
argument_list|,
name|equivRel
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|true
argument_list|)
assert|;
name|set
operator|=
name|getSet
argument_list|(
name|equivRel
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelSubset
name|subset
init|=
name|registerImpl
argument_list|(
name|rel
argument_list|,
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|validate
argument_list|()
expr_stmt|;
block|}
return|return
name|subset
return|;
block|}
specifier|public
name|RelSubset
name|ensureRegistered
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|equivRel
parameter_list|)
block|{
specifier|final
name|RelSubset
name|subset
init|=
name|mapRel2Subset
operator|.
name|get
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|subset
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|equivRel
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RelSubset
name|equivSubset
init|=
name|getSubset
argument_list|(
name|equivRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivSubset
operator|!=
name|subset
condition|)
block|{
assert|assert
name|subset
operator|.
name|set
operator|!=
name|equivSubset
operator|.
name|set
operator|:
literal|"Same set, different subsets means rel and equivRel"
operator|+
literal|" have different traits, and that's an error"
assert|;
name|merge
argument_list|(
name|subset
operator|.
name|set
argument_list|,
name|equivSubset
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|subset
return|;
block|}
else|else
block|{
return|return
name|register
argument_list|(
name|rel
argument_list|,
name|equivRel
argument_list|)
return|;
block|}
block|}
comment|/**    * Checks internal consistency.    */
specifier|protected
name|void
name|validate
parameter_list|()
block|{
for|for
control|(
name|RelSet
name|set
range|:
name|allSets
control|)
block|{
if|if
condition|(
name|set
operator|.
name|equivalentSet
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"set ["
operator|+
name|set
operator|+
literal|"] has been merged: it should not be in the list"
argument_list|)
throw|;
block|}
for|for
control|(
name|RelSubset
name|subset
range|:
name|set
operator|.
name|subsets
control|)
block|{
if|if
condition|(
name|subset
operator|.
name|set
operator|!=
name|set
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"subset ["
operator|+
name|subset
operator|.
name|getDescription
argument_list|()
operator|+
literal|"] is in wrong set ["
operator|+
name|set
operator|+
literal|"]"
argument_list|)
throw|;
block|}
for|for
control|(
name|RelNode
name|rel
range|:
name|subset
operator|.
name|getRels
argument_list|()
control|)
block|{
name|RelOptCost
name|relCost
init|=
name|getCost
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|relCost
operator|.
name|isLt
argument_list|(
name|subset
operator|.
name|bestCost
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"rel ["
operator|+
name|rel
operator|.
name|getDescription
argument_list|()
operator|+
literal|"] has lower cost "
operator|+
name|relCost
operator|+
literal|" than best cost "
operator|+
name|subset
operator|.
name|bestCost
operator|+
literal|" of subset ["
operator|+
name|subset
operator|.
name|getDescription
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
specifier|public
name|void
name|registerAbstractRelationalRules
parameter_list|()
block|{
name|addRule
argument_list|(
name|AbstractConverter
operator|.
name|ExpandConversionRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|addRule
argument_list|(
name|SwapJoinRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|addRule
argument_list|(
name|RemoveDistinctRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|addRule
argument_list|(
name|UnionToDistinctRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|addRule
argument_list|(
name|RemoveTrivialProjectRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|addRule
argument_list|(
name|RemoveTrivialCalcRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|addRule
argument_list|(
name|RemoveSortRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// todo: rule which makes Project({OrdinalRef}) disappear
block|}
specifier|public
name|void
name|registerSchema
parameter_list|(
name|RelOptSchema
name|schema
parameter_list|)
block|{
if|if
condition|(
name|registeredSchemas
operator|.
name|add
argument_list|(
name|schema
argument_list|)
condition|)
block|{
try|try
block|{
name|schema
operator|.
name|registerRules
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
name|e
argument_list|,
literal|"Error while registering schema "
operator|+
name|schema
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
name|RelOptCost
name|getCost
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
assert|assert
name|rel
operator|!=
literal|null
operator|:
literal|"pre-condition: rel != null"
assert|;
if|if
condition|(
name|rel
operator|instanceof
name|RelSubset
condition|)
block|{
return|return
operator|(
operator|(
name|RelSubset
operator|)
name|rel
operator|)
operator|.
name|bestCost
return|;
block|}
if|if
condition|(
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTrait
argument_list|(
literal|0
argument_list|)
operator|==
name|Convention
operator|.
name|NONE
condition|)
block|{
return|return
name|costFactory
operator|.
name|makeInfiniteCost
argument_list|()
return|;
block|}
name|RelOptCost
name|cost
init|=
name|RelMetadataQuery
operator|.
name|getNonCumulativeCost
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|zeroCost
operator|.
name|isLt
argument_list|(
name|cost
argument_list|)
condition|)
block|{
comment|// cost must be positive, so nudge it
name|cost
operator|=
name|costFactory
operator|.
name|makeTinyCost
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|cost
operator|=
name|cost
operator|.
name|plus
argument_list|(
name|getCost
argument_list|(
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
comment|/**    * Returns the subset that a relational expression belongs to.    *    * @param rel Relational expression    * @return Subset it belongs to, or null if it is not registered    */
specifier|public
name|RelSubset
name|getSubset
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
assert|assert
name|rel
operator|!=
literal|null
operator|:
literal|"pre: rel != null"
assert|;
if|if
condition|(
name|rel
operator|instanceof
name|RelSubset
condition|)
block|{
return|return
operator|(
name|RelSubset
operator|)
name|rel
return|;
block|}
else|else
block|{
return|return
name|mapRel2Subset
operator|.
name|get
argument_list|(
name|rel
argument_list|)
return|;
block|}
block|}
specifier|public
name|RelSubset
name|getSubset
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|traits
parameter_list|)
block|{
return|return
name|getSubset
argument_list|(
name|rel
argument_list|,
name|traits
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|RelSubset
name|getSubset
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|traits
parameter_list|,
name|boolean
name|createIfMissing
parameter_list|)
block|{
if|if
condition|(
operator|(
name|rel
operator|instanceof
name|RelSubset
operator|)
operator|&&
operator|(
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|traits
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|RelSubset
operator|)
name|rel
return|;
block|}
name|RelSet
name|set
init|=
name|getSet
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|createIfMissing
condition|)
block|{
return|return
name|set
operator|.
name|getOrCreateSubset
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|traits
argument_list|)
return|;
block|}
return|return
name|set
operator|.
name|getSubset
argument_list|(
name|traits
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|changeTraitsUsingConverters
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|toTraits
parameter_list|,
name|boolean
name|allowAbstractConverters
parameter_list|)
block|{
specifier|final
name|RelTraitSet
name|fromTraits
init|=
name|rel
operator|.
name|getTraitSet
argument_list|()
decl_stmt|;
assert|assert
name|fromTraits
operator|.
name|size
argument_list|()
operator|>=
name|toTraits
operator|.
name|size
argument_list|()
assert|;
specifier|final
name|boolean
name|allowInfiniteCostConverters
init|=
name|SaffronProperties
operator|.
name|instance
argument_list|()
operator|.
name|allowInfiniteCostConverters
operator|.
name|get
argument_list|()
decl_stmt|;
comment|// Traits may build on top of another...for example a collation trait
comment|// would typically come after a distribution trait since distribution
comment|// destroys collation; so when doing the conversion below we use
comment|// fromTraits as the trait of the just previously converted RelNode.
comment|// Also, toTraits may have fewer traits than fromTraits, excess traits
comment|// will be left as is.  Finally, any null entries in toTraits are
comment|// ignored.
name|RelNode
name|converted
init|=
name|rel
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
operator|(
name|converted
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|i
operator|<
name|toTraits
operator|.
name|size
argument_list|()
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|RelTrait
name|fromTrait
init|=
name|converted
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTrait
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|RelTraitDef
name|traitDef
init|=
name|fromTrait
operator|.
name|getTraitDef
argument_list|()
decl_stmt|;
name|RelTrait
name|toTrait
init|=
name|toTraits
operator|.
name|getTrait
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|toTrait
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
assert|assert
name|traitDef
operator|==
name|toTrait
operator|.
name|getTraitDef
argument_list|()
assert|;
comment|//            if (fromTrait.subsumes(toTrait)) {
if|if
condition|(
name|fromTrait
operator|.
name|equals
argument_list|(
name|toTrait
argument_list|)
condition|)
block|{
comment|// No need to convert; it's already correct.
continue|continue;
block|}
name|rel
operator|=
name|traitDef
operator|.
name|convert
argument_list|(
name|this
argument_list|,
name|converted
argument_list|,
name|toTrait
argument_list|,
name|allowInfiniteCostConverters
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|!=
literal|null
condition|)
block|{
assert|assert
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTrait
argument_list|(
name|traitDef
argument_list|)
operator|.
name|subsumes
argument_list|(
name|toTrait
argument_list|)
assert|;
name|rel
operator|=
name|completeConversion
argument_list|(
name|rel
argument_list|,
name|allowInfiniteCostConverters
argument_list|,
name|toTraits
argument_list|,
name|Expressions
operator|.
name|list
argument_list|(
name|traitDef
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|!=
literal|null
condition|)
block|{
name|register
argument_list|(
name|rel
argument_list|,
name|converted
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|rel
operator|==
literal|null
operator|)
operator|&&
name|allowAbstractConverters
condition|)
block|{
name|RelTraitSet
name|stepTraits
init|=
name|converted
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|toTrait
argument_list|)
decl_stmt|;
name|rel
operator|=
name|getSubset
argument_list|(
name|converted
argument_list|,
name|stepTraits
argument_list|)
expr_stmt|;
block|}
name|converted
operator|=
name|rel
expr_stmt|;
block|}
comment|// make sure final converted traitset subsumes what was required
if|if
condition|(
name|converted
operator|!=
literal|null
condition|)
block|{
assert|assert
name|converted
operator|.
name|getTraitSet
argument_list|()
operator|.
name|subsumes
argument_list|(
name|toTraits
argument_list|)
assert|;
block|}
return|return
name|converted
return|;
block|}
comment|/**    * Converts traits using well-founded induction. We don't require that    * each conversion preserves all traits that have previously been converted,    * but if it changes "locked in" traits we'll try some other conversion.    *    * @param rel                         Relational expression    * @param allowInfiniteCostConverters Whether to allow infinite converters    * @param toTraits                    Target trait set    * @param usedTraits                  Traits that have been locked in    * @return Converted relational expression    */
specifier|private
name|RelNode
name|completeConversion
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|boolean
name|allowInfiniteCostConverters
parameter_list|,
name|RelTraitSet
name|toTraits
parameter_list|,
name|Expressions
operator|.
name|FluentList
argument_list|<
name|RelTraitDef
argument_list|>
name|usedTraits
parameter_list|)
block|{
if|if
condition|(
literal|true
condition|)
block|{
return|return
name|rel
return|;
block|}
for|for
control|(
name|RelTrait
name|trait
range|:
name|rel
operator|.
name|getTraitSet
argument_list|()
control|)
block|{
if|if
condition|(
name|toTraits
operator|.
name|contains
argument_list|(
name|trait
argument_list|)
condition|)
block|{
comment|// We're already a match on this trait type.
continue|continue;
block|}
specifier|final
name|RelTraitDef
name|traitDef
init|=
name|trait
operator|.
name|getTraitDef
argument_list|()
decl_stmt|;
name|RelNode
name|rel2
init|=
name|traitDef
operator|.
name|convert
argument_list|(
name|this
argument_list|,
name|rel
argument_list|,
name|toTraits
operator|.
name|getTrait
argument_list|(
name|traitDef
argument_list|)
argument_list|,
name|allowInfiniteCostConverters
argument_list|)
decl_stmt|;
comment|// if any of the used traits have been knocked out, we could be
comment|// heading for a cycle.
for|for
control|(
name|RelTraitDef
name|usedTrait
range|:
name|usedTraits
control|)
block|{
if|if
condition|(
operator|!
name|rel2
operator|.
name|getTraitSet
argument_list|()
operator|.
name|contains
argument_list|(
name|usedTrait
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
comment|// recursive call, to convert one more trait
name|rel
operator|=
name|completeConversion
argument_list|(
name|rel2
argument_list|,
name|allowInfiniteCostConverters
argument_list|,
name|toTraits
argument_list|,
name|usedTraits
operator|.
name|append
argument_list|(
name|traitDef
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|!=
literal|null
condition|)
block|{
return|return
name|rel
return|;
block|}
block|}
assert|assert
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|toTraits
argument_list|)
assert|;
return|return
name|rel
return|;
block|}
name|RelNode
name|changeTraitsUsingConverters
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|toTraits
parameter_list|)
block|{
return|return
name|changeTraitsUsingConverters
argument_list|(
name|rel
argument_list|,
name|toTraits
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|void
name|checkForSatisfiedConverters
parameter_list|(
name|RelSet
name|set
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|set
operator|.
name|abstractConverters
operator|.
name|size
argument_list|()
condition|)
block|{
name|AbstractConverter
name|converter
init|=
name|set
operator|.
name|abstractConverters
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RelNode
name|converted
init|=
name|changeTraitsUsingConverters
argument_list|(
name|rel
argument_list|,
name|converter
operator|.
name|getTraitSet
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|converted
operator|==
literal|null
condition|)
block|{
name|i
operator|++
expr_stmt|;
comment|// couldn't convert this; move on to the next
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isRegistered
argument_list|(
name|converted
argument_list|)
condition|)
block|{
name|registerImpl
argument_list|(
name|converted
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
name|set
operator|.
name|abstractConverters
operator|.
name|remove
argument_list|(
name|converter
argument_list|)
expr_stmt|;
comment|// success
block|}
block|}
block|}
specifier|public
name|void
name|setImportance
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|double
name|importance
parameter_list|)
block|{
assert|assert
name|rel
operator|!=
literal|null
assert|;
if|if
condition|(
name|importance
operator|==
literal|0d
condition|)
block|{
name|relImportances
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|importance
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Dumps the internal state of this VolcanoPlanner to a writer.    *    * @param pw Print writer    * @see #normalizePlan(String)    */
specifier|public
name|void
name|dump
parameter_list|(
name|PrintWriter
name|pw
parameter_list|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|"Root: "
operator|+
name|root
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"Original rel:"
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
name|originalRootString
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"Sets:"
argument_list|)
expr_stmt|;
name|RelSet
index|[]
name|sets
init|=
name|allSets
operator|.
name|toArray
argument_list|(
operator|new
name|RelSet
index|[
name|allSets
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|sets
argument_list|,
operator|new
name|Comparator
argument_list|<
name|RelSet
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|RelSet
name|o1
parameter_list|,
name|RelSet
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|.
name|id
operator|-
name|o2
operator|.
name|id
return|;
block|}
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|RelSet
name|set
range|:
name|sets
control|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|"Set#"
operator|+
name|set
operator|.
name|id
operator|+
literal|", type: "
operator|+
name|set
operator|.
name|subsets
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|j
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|RelSubset
name|subset
range|:
name|set
operator|.
name|subsets
control|)
block|{
operator|++
name|j
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|"\t"
operator|+
name|subset
operator|.
name|getDescription
argument_list|()
operator|+
literal|", best="
operator|+
operator|(
operator|(
name|subset
operator|.
name|best
operator|==
literal|null
operator|)
condition|?
literal|"null"
else|:
operator|(
literal|"rel#"
operator|+
name|subset
operator|.
name|best
operator|.
name|getId
argument_list|()
operator|)
operator|)
operator|+
literal|", importance="
operator|+
name|ruleQueue
operator|.
name|getImportance
argument_list|(
name|subset
argument_list|)
argument_list|)
expr_stmt|;
assert|assert
name|subset
operator|.
name|set
operator|==
name|set
assert|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
assert|assert
operator|!
name|set
operator|.
name|subsets
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|subset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
assert|;
block|}
for|for
control|(
name|RelNode
name|rel
range|:
name|subset
operator|.
name|getRels
argument_list|()
control|)
block|{
comment|// "\t\trel#34:JavaProject(rel#32:JavaFilter(...), ...)"
name|pw
operator|.
name|print
argument_list|(
literal|"\t\t"
operator|+
name|rel
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|RelSubset
name|inputSubset
init|=
name|getSubset
argument_list|(
name|input
argument_list|,
name|input
operator|.
name|getTraitSet
argument_list|()
argument_list|)
decl_stmt|;
name|RelSet
name|inputSet
init|=
name|inputSubset
operator|.
name|set
decl_stmt|;
if|if
condition|(
name|input
operator|instanceof
name|RelSubset
condition|)
block|{
specifier|final
name|Iterator
argument_list|<
name|RelNode
argument_list|>
name|rels
init|=
name|inputSubset
operator|.
name|getRels
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|rels
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|input
operator|=
name|rels
operator|.
name|next
argument_list|()
expr_stmt|;
assert|assert
name|input
operator|.
name|getTraitSet
argument_list|()
operator|.
name|subsumes
argument_list|(
name|inputSubset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
assert|;
assert|assert
name|inputSet
operator|.
name|rels
operator|.
name|contains
argument_list|(
name|input
argument_list|)
assert|;
assert|assert
name|inputSet
operator|.
name|subsets
operator|.
name|contains
argument_list|(
name|inputSubset
argument_list|)
assert|;
block|}
block|}
block|}
name|Double
name|importance
init|=
name|relImportances
operator|.
name|get
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|importance
operator|!=
literal|null
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|", importance="
operator|+
name|importance
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|", rowcount="
operator|+
name|RelMetadataQuery
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|(
literal|", cumulative cost="
operator|+
name|getCost
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|/** Computes the key for {@link #mapDigestToRel}. */
specifier|private
specifier|static
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|key
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|rel
operator|.
name|getDigest
argument_list|()
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Re-computes the digest of a {@link RelNode}.    *    *<p>Since a relational expression's digest contains the identifiers of its    * children, this method needs to be called when the child has been renamed,    * for example if the child's set merges with another.    *    * @param rel Relational expression    */
name|void
name|rename
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|String
name|oldDigest
init|=
name|rel
operator|.
name|getDigest
argument_list|()
decl_stmt|;
if|if
condition|(
name|fixUpInputs
argument_list|(
name|rel
argument_list|)
condition|)
block|{
specifier|final
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|oldKey
init|=
name|Pair
operator|.
name|of
argument_list|(
name|oldDigest
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|removed
init|=
name|mapDigestToRel
operator|.
name|remove
argument_list|(
name|oldKey
argument_list|)
decl_stmt|;
assert|assert
name|removed
operator|==
name|rel
assert|;
specifier|final
name|String
name|newDigest
init|=
name|rel
operator|.
name|recomputeDigest
argument_list|()
decl_stmt|;
name|LOGGER
operator|.
name|finer
argument_list|(
literal|"Rename #"
operator|+
name|rel
operator|.
name|getId
argument_list|()
operator|+
literal|" from '"
operator|+
name|oldDigest
operator|+
literal|"' to '"
operator|+
name|newDigest
operator|+
literal|"'"
argument_list|)
expr_stmt|;
specifier|final
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|key
init|=
name|key
argument_list|(
name|rel
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|equivRel
init|=
name|mapDigestToRel
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivRel
operator|!=
literal|null
condition|)
block|{
assert|assert
name|equivRel
operator|!=
name|rel
assert|;
comment|// There's already an equivalent with the same name, and we
comment|// just knocked it out. Put it back, and forget about 'rel'.
name|LOGGER
operator|.
name|finer
argument_list|(
literal|"After renaming rel#"
operator|+
name|rel
operator|.
name|getId
argument_list|()
operator|+
literal|", it is now equivalent to rel#"
operator|+
name|equivRel
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|mapDigestToRel
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|equivRel
argument_list|)
expr_stmt|;
name|RelSubset
name|equivRelSubset
init|=
name|getSubset
argument_list|(
name|equivRel
argument_list|)
decl_stmt|;
name|ruleQueue
operator|.
name|recompute
argument_list|(
name|equivRelSubset
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Remove back-links from children.
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
operator|(
operator|(
name|RelSubset
operator|)
name|input
operator|)
operator|.
name|set
operator|.
name|parents
operator|.
name|remove
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
comment|// Remove rel from its subset. (This may leave the subset
comment|// empty, but if so, that will be dealt with when the sets
comment|// get merged.)
specifier|final
name|RelSubset
name|subset
init|=
name|mapRel2Subset
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|equivRelSubset
argument_list|)
decl_stmt|;
assert|assert
name|subset
operator|!=
literal|null
assert|;
comment|//boolean existed = subset.rels.remove(rel);
comment|//assert existed : "rel was not known to its subset";
name|boolean
name|existed
init|=
name|subset
operator|.
name|set
operator|.
name|rels
operator|.
name|remove
argument_list|(
name|rel
argument_list|)
decl_stmt|;
assert|assert
name|existed
operator|:
literal|"rel was not known to its set"
assert|;
specifier|final
name|RelSubset
name|equivSubset
init|=
name|getSubset
argument_list|(
name|equivRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivSubset
operator|!=
name|subset
condition|)
block|{
comment|// The equivalent relational expression is in a different
comment|// subset, therefore the sets are equivalent.
assert|assert
name|equivSubset
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|subset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
assert|;
assert|assert
name|equivSubset
operator|.
name|set
operator|!=
name|subset
operator|.
name|set
assert|;
name|merge
argument_list|(
name|equivSubset
operator|.
name|set
argument_list|,
name|subset
operator|.
name|set
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Registers a {@link RelNode}, which has already been registered, in a new    * {@link RelSet}.    *    * @param set Set    * @param rel Relational expression    */
name|void
name|reregister
parameter_list|(
name|RelSet
name|set
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
comment|// Is there an equivalent relational expression? (This might have
comment|// just occurred because the relational expression's child was just
comment|// found to be equivalent to another set.)
specifier|final
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|key
init|=
name|key
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|RelNode
name|equivRel
init|=
name|mapDigestToRel
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivRel
operator|!=
literal|null
operator|&&
name|equivRel
operator|!=
name|rel
condition|)
block|{
assert|assert
name|equivRel
operator|.
name|getClass
argument_list|()
operator|==
name|rel
operator|.
name|getClass
argument_list|()
assert|;
assert|assert
name|equivRel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|rel
operator|.
name|getTraitSet
argument_list|()
argument_list|)
assert|;
name|RelSubset
name|equivRelSubset
init|=
name|getSubset
argument_list|(
name|equivRel
argument_list|)
decl_stmt|;
name|ruleQueue
operator|.
name|recompute
argument_list|(
name|equivRelSubset
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Add the relational expression into the correct set and subset.
name|RelSubset
name|subset2
init|=
name|asd
argument_list|(
name|rel
argument_list|,
name|set
argument_list|)
decl_stmt|;
block|}
comment|/**    * If a subset has one or more equivalent subsets (owing to a set having    * merged with another), returns the subset which is the leader of the    * equivalence class.    *    * @param subset Subset    * @return Leader of subset's equivalence class    */
specifier|private
name|RelSubset
name|canonize
parameter_list|(
specifier|final
name|RelSubset
name|subset
parameter_list|)
block|{
if|if
condition|(
name|subset
operator|.
name|set
operator|.
name|equivalentSet
operator|==
literal|null
condition|)
block|{
return|return
name|subset
return|;
block|}
name|RelSet
name|set
init|=
name|subset
operator|.
name|set
decl_stmt|;
do|do
block|{
name|set
operator|=
name|set
operator|.
name|equivalentSet
expr_stmt|;
block|}
do|while
condition|(
name|set
operator|.
name|equivalentSet
operator|!=
literal|null
condition|)
do|;
return|return
name|set
operator|.
name|getOrCreateSubset
argument_list|(
name|subset
operator|.
name|getCluster
argument_list|()
argument_list|,
name|subset
operator|.
name|getTraitSet
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Fires all rules matched by a relational expression.    *    * @param rel      Relational expression which has just been created (or maybe    *                 from the queue)    * @param deferred If true, each time a rule matches, just add an entry to    *                 the queue.    */
name|void
name|fireRules
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|boolean
name|deferred
parameter_list|)
block|{
for|for
control|(
name|RelOptRuleOperand
name|operand
range|:
name|classOperands
operator|.
name|get
argument_list|(
name|rel
operator|.
name|getClass
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|operand
operator|.
name|matches
argument_list|(
name|rel
argument_list|)
condition|)
block|{
specifier|final
name|VolcanoRuleCall
name|ruleCall
decl_stmt|;
if|if
condition|(
name|deferred
condition|)
block|{
name|ruleCall
operator|=
operator|new
name|DeferringRuleCall
argument_list|(
name|this
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ruleCall
operator|=
operator|new
name|VolcanoRuleCall
argument_list|(
name|this
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
name|ruleCall
operator|.
name|match
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|fixUpInputs
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|rel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|changeCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|inputs
control|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|input
operator|instanceof
name|RelSubset
condition|)
block|{
specifier|final
name|RelSubset
name|subset
init|=
operator|(
name|RelSubset
operator|)
name|input
decl_stmt|;
name|RelSubset
name|newSubset
init|=
name|canonize
argument_list|(
name|subset
argument_list|)
decl_stmt|;
if|if
condition|(
name|newSubset
operator|!=
name|subset
condition|)
block|{
name|rel
operator|.
name|replaceInput
argument_list|(
name|i
argument_list|,
name|newSubset
argument_list|)
expr_stmt|;
if|if
condition|(
name|subset
operator|.
name|set
operator|!=
name|newSubset
operator|.
name|set
condition|)
block|{
name|subset
operator|.
name|set
operator|.
name|parents
operator|.
name|remove
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|newSubset
operator|.
name|set
operator|.
name|parents
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
name|changeCount
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|changeCount
operator|>
literal|0
return|;
block|}
specifier|private
name|void
name|merge
parameter_list|(
name|RelSet
name|set
parameter_list|,
name|RelSet
name|set2
parameter_list|)
block|{
assert|assert
name|set
operator|!=
name|set2
operator|:
literal|"pre: set != set2"
assert|;
assert|assert
name|set
operator|.
name|equivalentSet
operator|==
literal|null
assert|;
comment|// Find the root of set2's equivalence tree.
if|if
condition|(
name|set2
operator|.
name|equivalentSet
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|RelSet
argument_list|>
name|seen
init|=
operator|new
name|HashSet
argument_list|<
name|RelSet
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|!
name|seen
operator|.
name|add
argument_list|(
name|set2
argument_list|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"cycle in equivalence tree"
argument_list|)
throw|;
block|}
if|if
condition|(
name|set2
operator|.
name|equivalentSet
operator|==
literal|null
condition|)
block|{
break|break;
block|}
else|else
block|{
name|set2
operator|=
name|set2
operator|.
name|equivalentSet
expr_stmt|;
block|}
block|}
comment|// Looks like set2 was already marked as equivalent to set. Nothing
comment|// to do.
if|if
condition|(
name|set2
operator|==
name|set
condition|)
block|{
return|return;
block|}
block|}
comment|// If necessary, swap the sets, so we're always merging the newer set
comment|// into the older.
if|if
condition|(
name|set
operator|.
name|id
operator|>
name|set2
operator|.
name|id
condition|)
block|{
name|RelSet
name|t
init|=
name|set
decl_stmt|;
name|set
operator|=
name|set2
expr_stmt|;
name|set2
operator|=
name|t
expr_stmt|;
block|}
comment|// Merge.
name|set
operator|.
name|mergeWith
argument_list|(
name|this
argument_list|,
name|set2
argument_list|)
expr_stmt|;
comment|// Was the set we merged with the root? If so, the result is the new
comment|// root.
if|if
condition|(
name|set2
operator|==
name|getSet
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|root
operator|=
name|set
operator|.
name|getOrCreateSubset
argument_list|(
name|root
operator|.
name|getCluster
argument_list|()
argument_list|,
name|root
operator|.
name|getTraitSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Registers a new expression<code>exp</code> and queues up rule matches.    * If<code>set</code> is not null, makes the expression part of that    * equivalence set. If an identical expression is already registered, we    * don't need to register this one and nor should we queue up rule matches.    *    * @param rel relational expression to register. Must be either a {@link    *            RelSubset}, or an unregistered {@link RelNode}    * @param set set that rel belongs to, or<code>null</code>    * @return the equivalence-set    * @pre rel instanceof RelSubset || !isRegistered(rel)    */
specifier|private
name|RelSubset
name|registerImpl
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelSet
name|set
parameter_list|)
block|{
assert|assert
operator|(
name|rel
operator|instanceof
name|RelSubset
operator|)
operator|||
operator|!
name|isRegistered
argument_list|(
name|rel
argument_list|)
operator|:
literal|"pre: rel instanceof RelSubset || !isRegistered(rel)"
operator|+
literal|" : {rel="
operator|+
name|rel
operator|+
literal|"}"
assert|;
if|if
condition|(
name|rel
operator|instanceof
name|RelSubset
condition|)
block|{
return|return
name|registerSubset
argument_list|(
name|set
argument_list|,
operator|(
name|RelSubset
operator|)
name|rel
argument_list|)
return|;
block|}
if|if
condition|(
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|!=
name|this
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Relational expression "
operator|+
name|rel
operator|+
literal|" belongs to a different planner than is currently being"
operator|+
literal|" used."
argument_list|)
throw|;
block|}
comment|// Now is a good time to ensure that the relational expression
comment|// implements the interface required by its calling convention.
specifier|final
name|RelTraitSet
name|traits
init|=
name|rel
operator|.
name|getTraitSet
argument_list|()
decl_stmt|;
specifier|final
name|Convention
name|convention
init|=
operator|(
name|Convention
operator|)
name|traits
operator|.
name|getTrait
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|convention
operator|.
name|getInterface
argument_list|()
operator|.
name|isInstance
argument_list|(
name|rel
argument_list|)
operator|&&
operator|!
operator|(
name|rel
operator|instanceof
name|ConverterRel
operator|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Relational expression "
operator|+
name|rel
operator|+
literal|" has calling-convention "
operator|+
name|convention
operator|+
literal|" but does not implement the required interface '"
operator|+
name|convention
operator|.
name|getInterface
argument_list|()
operator|+
literal|"' of that convention"
argument_list|)
throw|;
block|}
if|if
condition|(
name|traits
operator|.
name|size
argument_list|()
operator|!=
name|traitDefs
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Relational expression "
operator|+
name|rel
operator|+
literal|" does not have the correct number of traits "
operator|+
name|traits
operator|.
name|size
argument_list|()
operator|+
literal|" != "
operator|+
name|traitDefs
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
comment|// Ensure that its sub-expressions are registered.
name|rel
operator|=
name|rel
operator|.
name|onRegister
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Record its provenance. (Rule call may be null.)
specifier|final
name|VolcanoRuleCall
name|ruleCall
decl_stmt|;
if|if
condition|(
name|ruleCallStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ruleCall
operator|=
literal|null
expr_stmt|;
name|provenanceMap
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|Provenance
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ruleCall
operator|=
name|peek
argument_list|(
name|ruleCallStack
argument_list|)
expr_stmt|;
name|provenanceMap
operator|.
name|put
argument_list|(
name|rel
argument_list|,
operator|new
name|RuleProvenance
argument_list|(
name|ruleCall
operator|.
name|rule
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RelNode
operator|>
name|copyOf
argument_list|(
name|ruleCall
operator|.
name|rels
argument_list|)
argument_list|,
name|ruleCall
operator|.
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If it is equivalent to an existing expression, return the set that
comment|// the equivalent expression belongs to.
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|key
init|=
name|key
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|RelNode
name|equivExp
init|=
name|mapDigestToRel
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivExp
operator|==
literal|null
condition|)
block|{
comment|// do nothing
block|}
if|else if
condition|(
name|equivExp
operator|==
name|rel
condition|)
block|{
return|return
name|getSubset
argument_list|(
name|rel
argument_list|)
return|;
block|}
else|else
block|{
assert|assert
name|equivExp
operator|.
name|getTraitSet
argument_list|()
operator|.
name|equals
argument_list|(
name|traits
argument_list|)
operator|&&
operator|(
name|equivExp
operator|.
name|getClass
argument_list|()
operator|==
name|rel
operator|.
name|getClass
argument_list|()
operator|)
assert|;
assert|assert
name|RelOptUtil
operator|.
name|equal
argument_list|(
literal|"left"
argument_list|,
name|equivExp
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|"right"
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|true
argument_list|)
assert|;
name|RelSet
name|equivSet
init|=
name|getSet
argument_list|(
name|equivExp
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivSet
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINER
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|finer
argument_list|(
literal|"Register: rel#"
operator|+
name|rel
operator|.
name|getId
argument_list|()
operator|+
literal|" is equivalent to "
operator|+
name|equivExp
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|registerSubset
argument_list|(
name|set
argument_list|,
name|getSubset
argument_list|(
name|equivExp
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|// Converters are in the same set as their children.
if|if
condition|(
name|rel
operator|instanceof
name|ConverterRel
condition|)
block|{
specifier|final
name|RelNode
name|input
init|=
operator|(
operator|(
name|ConverterRel
operator|)
name|rel
operator|)
operator|.
name|getChild
argument_list|()
decl_stmt|;
specifier|final
name|RelSet
name|childSet
init|=
name|getSet
argument_list|(
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|set
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|set
operator|!=
name|childSet
operator|)
operator|&&
operator|(
name|set
operator|.
name|equivalentSet
operator|==
literal|null
operator|)
condition|)
block|{
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINER
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|finer
argument_list|(
literal|"Register #"
operator|+
name|rel
operator|.
name|getId
argument_list|()
operator|+
literal|" "
operator|+
name|rel
operator|.
name|getDigest
argument_list|()
operator|+
literal|" (and merge sets, because it is a conversion)"
argument_list|)
expr_stmt|;
block|}
name|merge
argument_list|(
name|set
argument_list|,
name|childSet
argument_list|)
expr_stmt|;
name|registerCount
operator|++
expr_stmt|;
comment|// During the mergers, the child set may have changed, and since
comment|// we're not registered yet, we won't have been informed. So
comment|// check whether we are now equivalent to an existing
comment|// expression.
if|if
condition|(
name|fixUpInputs
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|rel
operator|.
name|recomputeDigest
argument_list|()
expr_stmt|;
name|key
operator|=
name|key
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|RelNode
name|equivRel
init|=
name|mapDigestToRel
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|equivRel
operator|!=
name|rel
operator|)
operator|&&
operator|(
name|equivRel
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// make sure this bad rel didn't get into the
comment|// set in any way (fixupInputs will do this but it
comment|// doesn't know if it should so it does it anyway)
name|set
operator|.
name|obliterateRelNode
argument_list|(
name|rel
argument_list|)
expr_stmt|;
comment|// There is already an equivalent expression. Use that
comment|// one, and forget about this one.
return|return
name|getSubset
argument_list|(
name|equivRel
argument_list|)
return|;
block|}
block|}
block|}
else|else
block|{
name|set
operator|=
name|childSet
expr_stmt|;
block|}
block|}
comment|// Place the expression in the appropriate equivalence set.
if|if
condition|(
name|set
operator|==
literal|null
condition|)
block|{
name|set
operator|=
operator|new
name|RelSet
argument_list|(
name|nextSetId
operator|++
argument_list|,
name|Util
operator|.
name|minus
argument_list|(
name|RelOptUtil
operator|.
name|getVariablesSet
argument_list|(
name|rel
argument_list|)
argument_list|,
name|rel
operator|.
name|getVariablesStopped
argument_list|()
argument_list|)
argument_list|,
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|allSets
operator|.
name|add
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
comment|// Chain to find 'live' equivalent set, just in case several sets are
comment|// merging at the same time.
while|while
condition|(
name|set
operator|.
name|equivalentSet
operator|!=
literal|null
condition|)
block|{
name|set
operator|=
name|set
operator|.
name|equivalentSet
expr_stmt|;
block|}
comment|// Allow each rel to register its own rules.
name|registerClass
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|registerCount
operator|++
expr_stmt|;
specifier|final
name|int
name|subsetBeforeCount
init|=
name|set
operator|.
name|subsets
operator|.
name|size
argument_list|()
decl_stmt|;
name|RelSubset
name|subset
init|=
name|asd
argument_list|(
name|rel
argument_list|,
name|set
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|xx
init|=
name|mapDigestToRel
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|rel
argument_list|)
decl_stmt|;
assert|assert
name|xx
operator|==
literal|null
operator|||
name|xx
operator|==
name|rel
operator|:
name|rel
operator|.
name|getDigest
argument_list|()
assert|;
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINER
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|finer
argument_list|(
literal|"Register "
operator|+
name|rel
operator|.
name|getDescription
argument_list|()
operator|+
literal|" in "
operator|+
name|subset
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// This relational expression may have been registered while we
comment|// recursively registered its children. If this is the case, we're done.
if|if
condition|(
name|xx
operator|!=
literal|null
condition|)
block|{
return|return
name|subset
return|;
block|}
comment|// Create back-links from its children, which makes children more
comment|// important.
if|if
condition|(
name|rel
operator|==
name|this
operator|.
name|root
condition|)
block|{
name|ruleQueue
operator|.
name|subsetImportances
operator|.
name|put
argument_list|(
name|subset
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
comment|// todo: remove
block|}
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|RelSubset
name|childSubset
init|=
operator|(
name|RelSubset
operator|)
name|input
decl_stmt|;
name|childSubset
operator|.
name|set
operator|.
name|parents
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
comment|// Child subset is more important now a new parent uses it.
name|ruleQueue
operator|.
name|recompute
argument_list|(
name|childSubset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rel
operator|==
name|this
operator|.
name|root
condition|)
block|{
name|ruleQueue
operator|.
name|subsetImportances
operator|.
name|remove
argument_list|(
name|subset
argument_list|)
expr_stmt|;
block|}
comment|// Remember abstract converters until they're satisfied
if|if
condition|(
name|rel
operator|instanceof
name|AbstractConverter
condition|)
block|{
name|set
operator|.
name|abstractConverters
operator|.
name|add
argument_list|(
operator|(
name|AbstractConverter
operator|)
name|rel
argument_list|)
expr_stmt|;
block|}
comment|// If this set has any unsatisfied converters, try to satisfy them.
name|checkForSatisfiedConverters
argument_list|(
name|set
argument_list|,
name|rel
argument_list|)
expr_stmt|;
comment|// Make sure this rel's subset importance is updated
name|ruleQueue
operator|.
name|recompute
argument_list|(
name|subset
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Queue up all rules triggered by this relexp's creation.
name|fireRules
argument_list|(
name|rel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// It's a new subset.
if|if
condition|(
name|set
operator|.
name|subsets
operator|.
name|size
argument_list|()
operator|>
name|subsetBeforeCount
condition|)
block|{
name|fireRules
argument_list|(
name|subset
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|subset
return|;
block|}
specifier|private
name|RelSubset
name|asd
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelSet
name|set
parameter_list|)
block|{
name|RelSubset
name|subset
init|=
name|set
operator|.
name|add
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|mapRel2Subset
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|subset
argument_list|)
expr_stmt|;
comment|// While a tree of RelNodes is being registered, sometimes nodes' costs
comment|// improve and the subset doesn't hear about it. You can end up with
comment|// a subset with a single rel of cost 99 which thinks its best cost is
comment|// 100. We think this happens because the back-links to parents are
comment|// not established. So, give the subset another change to figure out
comment|// its cost.
name|subset
operator|.
name|propagateCostImprovements
argument_list|(
name|this
argument_list|,
name|rel
argument_list|,
operator|new
name|HashSet
argument_list|<
name|RelSubset
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|subset
return|;
block|}
specifier|private
name|RelSubset
name|registerSubset
parameter_list|(
name|RelSet
name|set
parameter_list|,
name|RelSubset
name|subset
parameter_list|)
block|{
if|if
condition|(
operator|(
name|set
operator|!=
name|subset
operator|.
name|set
operator|)
operator|&&
operator|(
name|set
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|set
operator|.
name|equivalentSet
operator|==
literal|null
operator|)
operator|&&
operator|(
name|subset
operator|.
name|set
operator|.
name|equivalentSet
operator|==
literal|null
operator|)
condition|)
block|{
name|LOGGER
operator|.
name|finer
argument_list|(
literal|"Register #"
operator|+
name|subset
operator|.
name|getId
argument_list|()
operator|+
literal|" "
operator|+
name|subset
operator|+
literal|", and merge sets"
argument_list|)
expr_stmt|;
name|merge
argument_list|(
name|set
argument_list|,
name|subset
operator|.
name|set
argument_list|)
expr_stmt|;
name|registerCount
operator|++
expr_stmt|;
block|}
return|return
name|subset
return|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|void
name|addListener
parameter_list|(
name|RelOptListener
name|newListener
parameter_list|)
block|{
comment|// TODO jvs 6-Apr-2006:  new superclass AbstractRelOptPlanner
comment|// now defines a multicast listener; just need to hook it in
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|"multiple VolcanoPlanner listeners"
argument_list|)
throw|;
block|}
name|listener
operator|=
name|newListener
expr_stmt|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|void
name|registerMetadataProviders
parameter_list|(
name|List
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
parameter_list|)
block|{
name|list
operator|.
name|add
argument_list|(
literal|0
argument_list|,
operator|new
name|VolcanoRelMetadataProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|long
name|getRelMetadataTimestamp
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|RelSubset
name|subset
init|=
name|getSubset
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|subset
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|subset
operator|.
name|timestamp
return|;
block|}
block|}
comment|/**    * Normalizes references to subsets within the string representation of a    * plan.    *    *<p>This is useful when writing tests: it helps to ensure that tests don't    * break when an extra rule is introduced that generates a new subset and    * causes subsequent subset numbers to be off by one.    *    *<p>For example,    *    *<blockquote>    * FennelAggRel.FENNEL_EXEC(child=Subset#17.FENNEL_EXEC,groupCount=1,    * EXPR$1=COUNT())<br>    *&nbsp;&nbsp;FennelSortRel.FENNEL_EXEC(child=Subset#2.FENNEL_EXEC,    * key=[0], discardDuplicates=false)<br>    *&nbsp;&nbsp;&nbsp;&nbsp;FennelCalcRel.FENNEL_EXEC(    * child=Subset#4.FENNEL_EXEC, expr#0..8={inputs}, expr#9=3456,    * DEPTNO=$t7, $f0=$t9)<br>    *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MockTableImplRel.FENNEL_EXEC(    * table=[CATALOG, SALES, EMP])</blockquote>    *    * becomes    *    *<blockquote>    * FennelAggRel.FENNEL_EXEC(child=Subset#{0}.FENNEL_EXEC, groupCount=1,    * EXPR$1=COUNT())<br>    *&nbsp;&nbsp;FennelSortRel.FENNEL_EXEC(child=Subset#{1}.FENNEL_EXEC,    * key=[0], discardDuplicates=false)<br>    *&nbsp;&nbsp;&nbsp;&nbsp;FennelCalcRel.FENNEL_EXEC(    * child=Subset#{2}.FENNEL_EXEC,expr#0..8={inputs},expr#9=3456,DEPTNO=$t7,    * $f0=$t9)<br>    *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MockTableImplRel.FENNEL_EXEC(    * table=[CATALOG, SALES, EMP])</blockquote>    *    * @param plan Plan    * @return Normalized plan    */
specifier|public
specifier|static
name|String
name|normalizePlan
parameter_list|(
name|String
name|plan
parameter_list|)
block|{
if|if
condition|(
name|plan
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Pattern
name|poundDigits
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"Subset#[0-9]+\\."
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|Matcher
name|matcher
init|=
name|poundDigits
operator|.
name|matcher
argument_list|(
name|plan
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
return|return
name|plan
return|;
block|}
specifier|final
name|String
name|token
init|=
name|matcher
operator|.
name|group
argument_list|()
decl_stmt|;
comment|// e.g. "Subset#23."
name|plan
operator|=
name|plan
operator|.
name|replace
argument_list|(
name|token
argument_list|,
literal|"Subset#{"
operator|+
name|i
operator|++
operator|+
literal|"}."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Sets whether this planner is locked. A locked planner does not accept    * new rules. {@link #addRule(org.eigenbase.relopt.RelOptRule)} will do    * nothing and return false.    *    * @param locked Whether planner is locked    */
specifier|public
name|void
name|setLocked
parameter_list|(
name|boolean
name|locked
parameter_list|)
block|{
name|this
operator|.
name|locked
operator|=
name|locked
expr_stmt|;
block|}
specifier|public
name|void
name|ensureRegistered
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|equivRel
parameter_list|,
name|VolcanoRuleCall
name|ruleCall
parameter_list|)
block|{
name|push
argument_list|(
name|ruleCallStack
argument_list|,
name|ruleCall
argument_list|)
expr_stmt|;
name|ensureRegistered
argument_list|(
name|rel
argument_list|,
name|equivRel
argument_list|)
expr_stmt|;
name|pop
argument_list|(
name|ruleCallStack
argument_list|,
name|ruleCall
argument_list|)
expr_stmt|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * A rule call which defers its actions. Whereas {@link RelOptRuleCall}    * invokes the rule when it finds a match, a<code>DeferringRuleCall</code>    * creates a {@link VolcanoRuleMatch} which can be invoked later.    */
specifier|private
specifier|static
class|class
name|DeferringRuleCall
extends|extends
name|VolcanoRuleCall
block|{
name|DeferringRuleCall
parameter_list|(
name|VolcanoPlanner
name|planner
parameter_list|,
name|RelOptRuleOperand
name|operand
parameter_list|)
block|{
name|super
argument_list|(
name|planner
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
comment|/**      * Rather than invoking the rule (as the base method does), creates a      * {@link VolcanoRuleMatch} which can be invoked later.      */
specifier|protected
name|void
name|onMatch
parameter_list|()
block|{
specifier|final
name|VolcanoRuleMatch
name|match
init|=
operator|new
name|VolcanoRuleMatch
argument_list|(
name|volcanoPlanner
argument_list|,
name|getOperand0
argument_list|()
argument_list|,
name|rels
argument_list|)
decl_stmt|;
name|volcanoPlanner
operator|.
name|ruleQueue
operator|.
name|addMatch
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Where a RelNode came from.    */
specifier|private
specifier|abstract
specifier|static
class|class
name|Provenance
block|{
specifier|public
specifier|static
specifier|final
name|Provenance
name|EMPTY
init|=
operator|new
name|UnknownProvenance
argument_list|()
decl_stmt|;
block|}
comment|/**    * We do not know where this RelNode came from. Probably created by hand,    * or by sql-to-rel converter.    */
specifier|private
specifier|static
class|class
name|UnknownProvenance
extends|extends
name|Provenance
block|{   }
comment|/**    * A RelNode that came directly from another RelNode via a copy.    */
specifier|static
class|class
name|DirectProvenance
extends|extends
name|Provenance
block|{
specifier|final
name|RelNode
name|source
decl_stmt|;
name|DirectProvenance
parameter_list|(
name|RelNode
name|source
parameter_list|)
block|{
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
block|}
block|}
comment|/**    * A RelNode that came via the firing of a rule.    */
specifier|static
class|class
name|RuleProvenance
extends|extends
name|Provenance
block|{
specifier|final
name|RelOptRule
name|rule
decl_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|RelNode
argument_list|>
name|rels
decl_stmt|;
specifier|final
name|int
name|callId
decl_stmt|;
name|RuleProvenance
parameter_list|(
name|RelOptRule
name|rule
parameter_list|,
name|ImmutableList
argument_list|<
name|RelNode
argument_list|>
name|rels
parameter_list|,
name|int
name|callId
parameter_list|)
block|{
name|this
operator|.
name|rule
operator|=
name|rule
expr_stmt|;
name|this
operator|.
name|rels
operator|=
name|rels
expr_stmt|;
name|this
operator|.
name|callId
operator|=
name|callId
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End VolcanoPlanner.java
end_comment

end_unit

