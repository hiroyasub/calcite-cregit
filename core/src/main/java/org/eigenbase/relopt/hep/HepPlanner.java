begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to the Apache Software Foundation (ASF) under one or more // contributor license agreements.  See the NOTICE file distributed with // this work for additional information regarding copyright ownership. // The ASF licenses this file to you under the Apache License, Version 2.0 // (the "License"); you may not use this file except in compliance with // the License.  You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|hep
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|convert
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|metadata
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function2
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Functions
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|util
operator|.
name|graph
operator|.
name|*
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_comment
comment|/**  * HepPlanner is a heuristic implementation of the {@link RelOptPlanner}  * interface.  */
end_comment

begin_class
specifier|public
class|class
name|HepPlanner
extends|extends
name|AbstractRelOptPlanner
block|{
comment|//~ Instance fields --------------------------------------------------------
specifier|private
name|HepProgram
name|mainProgram
decl_stmt|;
specifier|private
name|HepProgram
name|currentProgram
decl_stmt|;
specifier|private
name|HepRelVertex
name|root
decl_stmt|;
specifier|private
name|RelTraitSet
name|requestedRootTraits
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|HepRelVertex
argument_list|>
name|mapDigestToVertex
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|RelOptRule
argument_list|>
name|allRules
decl_stmt|;
specifier|private
name|int
name|nTransformations
decl_stmt|;
specifier|private
name|int
name|graphSizeLastGC
decl_stmt|;
specifier|private
name|int
name|nTransformationsLastGC
decl_stmt|;
specifier|private
name|boolean
name|noDAG
decl_stmt|;
comment|/**    * Query graph, with edges directed from parent to child. This is a    * single-rooted DAG, possibly with additional roots corresponding to    * discarded plan fragments which remain to be garbage-collected.    */
specifier|private
name|DirectedGraph
argument_list|<
name|HepRelVertex
argument_list|,
name|DefaultEdge
argument_list|>
name|graph
decl_stmt|;
specifier|private
specifier|final
name|Function2
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|,
name|Void
argument_list|>
name|onCopyHook
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a new HepPlanner that allows DAG.    *    * @param program program controlling rule application    */
specifier|public
name|HepPlanner
parameter_list|(
name|HepProgram
name|program
parameter_list|)
block|{
name|this
argument_list|(
name|program
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|RelOptCostImpl
operator|.
name|FACTORY
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new HepPlanner that allows DAG.    *    * @param program program controlling rule application    * @param context to carry while planning    */
specifier|public
name|HepPlanner
parameter_list|(
name|HepProgram
name|program
parameter_list|,
name|Context
name|context
parameter_list|)
block|{
name|this
argument_list|(
name|program
argument_list|,
name|context
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|RelOptCostImpl
operator|.
name|FACTORY
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new HepPlanner with the option to keep the graph a    * tree(noDAG=true) or allow DAG(noDAG=false).    *    * @param program    program controlling rule application    * @param onCopyHook Function to call when a node is copied    */
specifier|public
name|HepPlanner
parameter_list|(
name|HepProgram
name|program
parameter_list|,
name|Context
name|context
parameter_list|,
name|boolean
name|noDAG
parameter_list|,
name|Function2
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|,
name|Void
argument_list|>
name|onCopyHook
parameter_list|,
name|RelOptCostFactory
name|costFactory
parameter_list|)
block|{
name|super
argument_list|(
name|costFactory
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|mainProgram
operator|=
name|program
expr_stmt|;
name|this
operator|.
name|onCopyHook
operator|=
name|Util
operator|.
name|first
argument_list|(
name|onCopyHook
argument_list|,
name|Functions
operator|.
expr|<
name|RelNode
argument_list|,
name|RelNode
argument_list|,
name|Void
operator|>
name|ignore2
argument_list|()
argument_list|)
expr_stmt|;
name|mapDigestToVertex
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HepRelVertex
argument_list|>
argument_list|()
expr_stmt|;
name|graph
operator|=
name|DefaultDirectedGraph
operator|.
name|create
argument_list|()
expr_stmt|;
comment|// NOTE jvs 24-Apr-2006:  We use LinkedHashSet here and below
comment|// in order to provide deterministic behavior.
name|allRules
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|RelOptRule
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|noDAG
operator|=
name|noDAG
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|// implement RelOptPlanner
specifier|public
name|void
name|setRoot
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|root
operator|=
name|addRelToGraph
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|dumpGraph
argument_list|()
expr_stmt|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|RelNode
name|getRoot
parameter_list|()
block|{
return|return
name|root
return|;
block|}
specifier|public
name|void
name|addMaterialization
parameter_list|(
name|RelOptMaterialization
name|materialization
parameter_list|)
block|{
comment|// ignore - this planner does not support materializations
block|}
comment|// implement RelOptPlanner
specifier|public
name|boolean
name|addRule
parameter_list|(
name|RelOptRule
name|rule
parameter_list|)
block|{
name|boolean
name|added
init|=
name|allRules
operator|.
name|add
argument_list|(
name|rule
argument_list|)
decl_stmt|;
if|if
condition|(
name|added
condition|)
block|{
name|mapRuleDescription
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
return|return
name|added
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|super
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|allRules
argument_list|)
control|)
block|{
name|removeRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|removeRule
parameter_list|(
name|RelOptRule
name|rule
parameter_list|)
block|{
name|unmapRuleDescription
argument_list|(
name|rule
argument_list|)
expr_stmt|;
return|return
name|allRules
operator|.
name|remove
argument_list|(
name|rule
argument_list|)
return|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|RelNode
name|changeTraits
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelTraitSet
name|toTraits
parameter_list|)
block|{
comment|// Ignore traits, except for the root, where we remember
comment|// what the final conversion should be.
if|if
condition|(
operator|(
name|rel
operator|==
name|root
operator|)
operator|||
operator|(
name|rel
operator|==
name|root
operator|.
name|getCurrentRel
argument_list|()
operator|)
condition|)
block|{
name|requestedRootTraits
operator|=
name|toTraits
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|RelNode
name|findBestExp
parameter_list|()
block|{
assert|assert
name|root
operator|!=
literal|null
assert|;
name|executeProgram
argument_list|(
name|mainProgram
argument_list|)
expr_stmt|;
comment|// Get rid of everything except what's in the final plan.
name|collectGarbage
argument_list|()
expr_stmt|;
return|return
name|buildFinalPlan
argument_list|(
name|root
argument_list|)
return|;
block|}
specifier|private
name|void
name|executeProgram
parameter_list|(
name|HepProgram
name|program
parameter_list|)
block|{
name|HepProgram
name|savedProgram
init|=
name|currentProgram
decl_stmt|;
name|currentProgram
operator|=
name|program
expr_stmt|;
name|currentProgram
operator|.
name|initialize
argument_list|(
name|program
operator|==
name|mainProgram
argument_list|)
expr_stmt|;
for|for
control|(
name|HepInstruction
name|instruction
range|:
name|currentProgram
operator|.
name|instructions
control|)
block|{
name|instruction
operator|.
name|execute
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|int
name|delta
init|=
name|nTransformations
operator|-
name|nTransformationsLastGC
decl_stmt|;
if|if
condition|(
name|delta
operator|>
name|graphSizeLastGC
condition|)
block|{
comment|// The number of transformations performed since the last
comment|// garbage collection is greater than the number of vertices in
comment|// the graph at that time.  That means there should be a
comment|// reasonable amount of garbage to collect now.  We do it this
comment|// way to amortize garbage collection cost over multiple
comment|// instructions, while keeping the highwater memory usage
comment|// proportional to the graph size.
name|collectGarbage
argument_list|()
expr_stmt|;
block|}
block|}
name|currentProgram
operator|=
name|savedProgram
expr_stmt|;
block|}
name|void
name|executeInstruction
parameter_list|(
name|HepInstruction
operator|.
name|MatchLimit
name|instruction
parameter_list|)
block|{
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINEST
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|finest
argument_list|(
literal|"Setting match limit to "
operator|+
name|instruction
operator|.
name|limit
argument_list|)
expr_stmt|;
block|}
name|currentProgram
operator|.
name|matchLimit
operator|=
name|instruction
operator|.
name|limit
expr_stmt|;
block|}
name|void
name|executeInstruction
parameter_list|(
name|HepInstruction
operator|.
name|MatchOrder
name|instruction
parameter_list|)
block|{
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINEST
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|finest
argument_list|(
literal|"Setting match limit to "
operator|+
name|instruction
operator|.
name|order
argument_list|)
expr_stmt|;
block|}
name|currentProgram
operator|.
name|matchOrder
operator|=
name|instruction
operator|.
name|order
expr_stmt|;
block|}
name|void
name|executeInstruction
parameter_list|(
name|HepInstruction
operator|.
name|RuleInstance
name|instruction
parameter_list|)
block|{
if|if
condition|(
name|skippingGroup
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|instruction
operator|.
name|rule
operator|==
literal|null
condition|)
block|{
assert|assert
name|instruction
operator|.
name|ruleDescription
operator|!=
literal|null
assert|;
name|instruction
operator|.
name|rule
operator|=
name|getRuleByDescription
argument_list|(
name|instruction
operator|.
name|ruleDescription
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINEST
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|finest
argument_list|(
literal|"Looking up rule with description "
operator|+
name|instruction
operator|.
name|ruleDescription
operator|+
literal|", found "
operator|+
name|instruction
operator|.
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|instruction
operator|.
name|rule
operator|!=
literal|null
condition|)
block|{
name|applyRules
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|instruction
operator|.
name|rule
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|executeInstruction
parameter_list|(
name|HepInstruction
operator|.
name|RuleClass
argument_list|<
name|?
argument_list|>
name|instruction
parameter_list|)
block|{
if|if
condition|(
name|skippingGroup
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINEST
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|finest
argument_list|(
literal|"Applying rule class "
operator|+
name|instruction
operator|.
name|ruleClass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|instruction
operator|.
name|ruleSet
operator|==
literal|null
condition|)
block|{
name|instruction
operator|.
name|ruleSet
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|RelOptRule
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|allRules
control|)
block|{
if|if
condition|(
name|instruction
operator|.
name|ruleClass
operator|.
name|isInstance
argument_list|(
name|rule
argument_list|)
condition|)
block|{
name|instruction
operator|.
name|ruleSet
operator|.
name|add
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|applyRules
argument_list|(
name|instruction
operator|.
name|ruleSet
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|void
name|executeInstruction
parameter_list|(
name|HepInstruction
operator|.
name|RuleCollection
name|instruction
parameter_list|)
block|{
if|if
condition|(
name|skippingGroup
argument_list|()
condition|)
block|{
return|return;
block|}
name|applyRules
argument_list|(
name|instruction
operator|.
name|rules
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|skippingGroup
parameter_list|()
block|{
if|if
condition|(
name|currentProgram
operator|.
name|group
operator|!=
literal|null
condition|)
block|{
comment|// Skip if we've already collected the ruleset.
return|return
operator|!
name|currentProgram
operator|.
name|group
operator|.
name|collecting
return|;
block|}
else|else
block|{
comment|// Not grouping.
return|return
literal|false
return|;
block|}
block|}
name|void
name|executeInstruction
parameter_list|(
name|HepInstruction
operator|.
name|ConverterRules
name|instruction
parameter_list|)
block|{
assert|assert
name|currentProgram
operator|.
name|group
operator|==
literal|null
assert|;
if|if
condition|(
name|instruction
operator|.
name|ruleSet
operator|==
literal|null
condition|)
block|{
name|instruction
operator|.
name|ruleSet
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|RelOptRule
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|allRules
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|rule
operator|instanceof
name|ConverterRule
operator|)
condition|)
block|{
continue|continue;
block|}
name|ConverterRule
name|converter
init|=
operator|(
name|ConverterRule
operator|)
name|rule
decl_stmt|;
if|if
condition|(
name|converter
operator|.
name|isGuaranteed
argument_list|()
operator|!=
name|instruction
operator|.
name|guaranteed
condition|)
block|{
continue|continue;
block|}
comment|// Add the rule itself to work top-down
name|instruction
operator|.
name|ruleSet
operator|.
name|add
argument_list|(
name|converter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instruction
operator|.
name|guaranteed
condition|)
block|{
comment|// Add a TraitMatchingRule to work bottom-up
name|instruction
operator|.
name|ruleSet
operator|.
name|add
argument_list|(
operator|new
name|TraitMatchingRule
argument_list|(
name|converter
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|applyRules
argument_list|(
name|instruction
operator|.
name|ruleSet
argument_list|,
name|instruction
operator|.
name|guaranteed
argument_list|)
expr_stmt|;
block|}
name|void
name|executeInstruction
parameter_list|(
name|HepInstruction
operator|.
name|CommonRelSubExprRules
name|instruction
parameter_list|)
block|{
assert|assert
name|currentProgram
operator|.
name|group
operator|==
literal|null
assert|;
if|if
condition|(
name|instruction
operator|.
name|ruleSet
operator|==
literal|null
condition|)
block|{
name|instruction
operator|.
name|ruleSet
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|RelOptRule
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|allRules
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|rule
operator|instanceof
name|CommonRelSubExprRule
operator|)
condition|)
block|{
continue|continue;
block|}
name|instruction
operator|.
name|ruleSet
operator|.
name|add
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
name|applyRules
argument_list|(
name|instruction
operator|.
name|ruleSet
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|void
name|executeInstruction
parameter_list|(
name|HepInstruction
operator|.
name|Subprogram
name|instruction
parameter_list|)
block|{
name|LOGGER
operator|.
name|finest
argument_list|(
literal|"Entering subprogram"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|nTransformationsBefore
init|=
name|nTransformations
decl_stmt|;
name|executeProgram
argument_list|(
name|instruction
operator|.
name|subprogram
argument_list|)
expr_stmt|;
if|if
condition|(
name|nTransformations
operator|==
name|nTransformationsBefore
condition|)
block|{
comment|// Nothing happened this time around.
break|break;
block|}
block|}
name|LOGGER
operator|.
name|finest
argument_list|(
literal|"Leaving subprogram"
argument_list|)
expr_stmt|;
block|}
name|void
name|executeInstruction
parameter_list|(
name|HepInstruction
operator|.
name|BeginGroup
name|instruction
parameter_list|)
block|{
assert|assert
name|currentProgram
operator|.
name|group
operator|==
literal|null
assert|;
name|currentProgram
operator|.
name|group
operator|=
name|instruction
operator|.
name|endGroup
expr_stmt|;
name|LOGGER
operator|.
name|finest
argument_list|(
literal|"Entering group"
argument_list|)
expr_stmt|;
block|}
name|void
name|executeInstruction
parameter_list|(
name|HepInstruction
operator|.
name|EndGroup
name|instruction
parameter_list|)
block|{
assert|assert
name|currentProgram
operator|.
name|group
operator|==
name|instruction
assert|;
name|currentProgram
operator|.
name|group
operator|=
literal|null
expr_stmt|;
name|instruction
operator|.
name|collecting
operator|=
literal|false
expr_stmt|;
name|applyRules
argument_list|(
name|instruction
operator|.
name|ruleSet
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|LOGGER
operator|.
name|finest
argument_list|(
literal|"Leaving group"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|applyRules
parameter_list|(
name|Collection
argument_list|<
name|RelOptRule
argument_list|>
name|rules
parameter_list|,
name|boolean
name|forceConversions
parameter_list|)
block|{
if|if
condition|(
name|currentProgram
operator|.
name|group
operator|!=
literal|null
condition|)
block|{
assert|assert
name|currentProgram
operator|.
name|group
operator|.
name|collecting
assert|;
name|currentProgram
operator|.
name|group
operator|.
name|ruleSet
operator|.
name|addAll
argument_list|(
name|rules
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINEST
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|finest
argument_list|(
literal|"Applying rule set "
operator|+
name|rules
argument_list|)
expr_stmt|;
block|}
name|boolean
name|fullRestartAfterTransformation
init|=
name|currentProgram
operator|.
name|matchOrder
operator|!=
name|HepMatchOrder
operator|.
name|ARBITRARY
decl_stmt|;
name|int
name|nMatches
init|=
literal|0
decl_stmt|;
name|boolean
name|fixpoint
decl_stmt|;
do|do
block|{
name|Iterator
argument_list|<
name|HepRelVertex
argument_list|>
name|iter
init|=
name|getGraphIterator
argument_list|(
name|root
argument_list|)
decl_stmt|;
name|fixpoint
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|HepRelVertex
name|vertex
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|rules
control|)
block|{
name|HepRelVertex
name|newVertex
init|=
name|applyRule
argument_list|(
name|rule
argument_list|,
name|vertex
argument_list|,
name|forceConversions
argument_list|)
decl_stmt|;
if|if
condition|(
name|newVertex
operator|!=
literal|null
condition|)
block|{
operator|++
name|nMatches
expr_stmt|;
if|if
condition|(
name|nMatches
operator|>=
name|currentProgram
operator|.
name|matchLimit
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|fullRestartAfterTransformation
condition|)
block|{
name|iter
operator|=
name|getGraphIterator
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// To the extent possible, pick up where we left
comment|// off; have to create a new iterator because old
comment|// one was invalidated by transformation.
name|iter
operator|=
name|getGraphIterator
argument_list|(
name|newVertex
argument_list|)
expr_stmt|;
comment|// Remember to go around again since we're
comment|// skipping some stuff.
name|fixpoint
operator|=
literal|false
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
do|while
condition|(
operator|!
name|fixpoint
condition|)
do|;
block|}
specifier|private
name|Iterator
argument_list|<
name|HepRelVertex
argument_list|>
name|getGraphIterator
parameter_list|(
name|HepRelVertex
name|start
parameter_list|)
block|{
comment|// Make sure there's no garbage, because topological sort
comment|// doesn't start from a specific root, and rules can't
comment|// deal with firing on garbage.
comment|// FIXME jvs 25-Sept-2006:  I had to move this earlier because
comment|// of FRG-215, which is still under investigation.  Once we
comment|// figure that one out, move down to location below for
comment|// better optimizer performance.
name|collectGarbage
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentProgram
operator|.
name|matchOrder
operator|==
name|HepMatchOrder
operator|.
name|ARBITRARY
condition|)
block|{
return|return
name|DepthFirstIterator
operator|.
name|of
argument_list|(
name|graph
argument_list|,
name|start
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
assert|assert
name|start
operator|==
name|root
assert|;
comment|// see above
comment|/*         collectGarbage(); */
name|Iterable
argument_list|<
name|HepRelVertex
argument_list|>
name|iter
init|=
name|TopologicalOrderIterator
operator|.
name|of
argument_list|(
name|graph
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentProgram
operator|.
name|matchOrder
operator|==
name|HepMatchOrder
operator|.
name|TOP_DOWN
condition|)
block|{
return|return
name|iter
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|// TODO jvs 4-Apr-2006:  enhance TopologicalOrderIterator
comment|// to support reverse walk.
assert|assert
name|currentProgram
operator|.
name|matchOrder
operator|==
name|HepMatchOrder
operator|.
name|BOTTOM_UP
assert|;
specifier|final
name|List
argument_list|<
name|HepRelVertex
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|HepRelVertex
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HepRelVertex
name|vertex
range|:
name|iter
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|vertex
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|reverse
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|list
operator|.
name|iterator
argument_list|()
return|;
block|}
specifier|private
name|HepRelVertex
name|applyRule
parameter_list|(
name|RelOptRule
name|rule
parameter_list|,
name|HepRelVertex
name|vertex
parameter_list|,
name|boolean
name|forceConversions
parameter_list|)
block|{
name|RelTrait
name|parentTrait
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|parents
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rule
operator|instanceof
name|ConverterRule
condition|)
block|{
comment|// Guaranteed converter rules require special casing to make sure
comment|// they only fire where actually needed, otherwise they tend to
comment|// fire to infinity and beyond.
name|ConverterRule
name|converterRule
init|=
operator|(
name|ConverterRule
operator|)
name|rule
decl_stmt|;
if|if
condition|(
name|converterRule
operator|.
name|isGuaranteed
argument_list|()
operator|||
operator|!
name|forceConversions
condition|)
block|{
if|if
condition|(
operator|!
name|doesConverterApply
argument_list|(
name|converterRule
argument_list|,
name|vertex
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|parentTrait
operator|=
name|converterRule
operator|.
name|getOutTrait
argument_list|()
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|rule
operator|instanceof
name|CommonRelSubExprRule
condition|)
block|{
comment|// Only fire CommonRelSubExprRules if the vertex is a common
comment|// subexpression.
name|List
argument_list|<
name|HepRelVertex
argument_list|>
name|parentVertices
init|=
name|getVertexParents
argument_list|(
name|vertex
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentVertices
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
return|return
literal|null
return|;
block|}
name|parents
operator|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|HepRelVertex
name|pVertex
range|:
name|parentVertices
control|)
block|{
name|parents
operator|.
name|add
argument_list|(
name|pVertex
operator|.
name|getCurrentRel
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|RelNode
argument_list|>
name|bindings
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
argument_list|>
name|nodeChildren
init|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|match
init|=
name|matchOperands
argument_list|(
name|rule
operator|.
name|getOperand
argument_list|()
argument_list|,
name|vertex
operator|.
name|getCurrentRel
argument_list|()
argument_list|,
name|bindings
argument_list|,
name|nodeChildren
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
block|{
return|return
literal|null
return|;
block|}
name|HepRuleCall
name|call
init|=
operator|new
name|HepRuleCall
argument_list|(
name|this
argument_list|,
name|rule
operator|.
name|getOperand
argument_list|()
argument_list|,
name|bindings
operator|.
name|toArray
argument_list|(
operator|new
name|RelNode
index|[
name|bindings
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|nodeChildren
argument_list|,
name|parents
argument_list|)
decl_stmt|;
comment|// Allow the rule to apply its own side-conditions.
if|if
condition|(
operator|!
name|rule
operator|.
name|matches
argument_list|(
name|call
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|fireRule
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|call
operator|.
name|getResults
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|applyTransformationResults
argument_list|(
name|vertex
argument_list|,
name|call
argument_list|,
name|parentTrait
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|boolean
name|doesConverterApply
parameter_list|(
name|ConverterRule
name|converterRule
parameter_list|,
name|HepRelVertex
name|vertex
parameter_list|)
block|{
name|RelTrait
name|outTrait
init|=
name|converterRule
operator|.
name|getOutTrait
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HepRelVertex
argument_list|>
name|parents
init|=
name|Graphs
operator|.
name|predecessorListOf
argument_list|(
name|graph
argument_list|,
name|vertex
argument_list|)
decl_stmt|;
for|for
control|(
name|HepRelVertex
name|parent
range|:
name|parents
control|)
block|{
name|RelNode
name|parentRel
init|=
name|parent
operator|.
name|getCurrentRel
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentRel
operator|instanceof
name|ConverterRel
condition|)
block|{
comment|// We don't support converter chains.
continue|continue;
block|}
if|if
condition|(
name|parentRel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|contains
argument_list|(
name|outTrait
argument_list|)
condition|)
block|{
comment|// This parent wants the traits produced by the converter.
return|return
literal|true
return|;
block|}
block|}
return|return
operator|(
name|vertex
operator|==
name|root
operator|)
operator|&&
operator|(
name|requestedRootTraits
operator|!=
literal|null
operator|)
operator|&&
name|requestedRootTraits
operator|.
name|contains
argument_list|(
name|outTrait
argument_list|)
return|;
block|}
comment|/**    * Retrieves the parent vertices of a vertex.  If a vertex appears multiple    * times as an input into a parent, then that counts as multiple parents,    * one per input reference.    *    * @param vertex the vertex    * @return the list of parents for the vertex    */
specifier|private
name|List
argument_list|<
name|HepRelVertex
argument_list|>
name|getVertexParents
parameter_list|(
name|HepRelVertex
name|vertex
parameter_list|)
block|{
name|List
argument_list|<
name|HepRelVertex
argument_list|>
name|parents
init|=
operator|new
name|ArrayList
argument_list|<
name|HepRelVertex
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HepRelVertex
argument_list|>
name|parentVertices
init|=
name|Graphs
operator|.
name|predecessorListOf
argument_list|(
name|graph
argument_list|,
name|vertex
argument_list|)
decl_stmt|;
for|for
control|(
name|HepRelVertex
name|pVertex
range|:
name|parentVertices
control|)
block|{
name|RelNode
name|parent
init|=
name|pVertex
operator|.
name|getCurrentRel
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parent
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|HepRelVertex
name|child
init|=
operator|(
name|HepRelVertex
operator|)
name|parent
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
name|vertex
condition|)
block|{
name|parents
operator|.
name|add
argument_list|(
name|pVertex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|parents
return|;
block|}
specifier|private
name|boolean
name|matchOperands
parameter_list|(
name|RelOptRuleOperand
name|operand
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|bindings
parameter_list|,
name|Map
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
argument_list|>
name|nodeChildren
parameter_list|)
block|{
if|if
condition|(
operator|!
name|operand
operator|.
name|matches
argument_list|(
name|rel
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|bindings
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|HepRelVertex
argument_list|>
name|childRels
init|=
operator|(
name|List
operator|)
name|rel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|operand
operator|.
name|childPolicy
condition|)
block|{
case|case
name|ANY
case|:
return|return
literal|true
return|;
case|case
name|UNORDERED
case|:
comment|// For each operand, at least one child must match. If
comment|// matchAnyChildren, usually there's just one operand.
for|for
control|(
name|RelOptRuleOperand
name|childOperand
range|:
name|operand
operator|.
name|getChildOperands
argument_list|()
control|)
block|{
name|boolean
name|match
init|=
literal|false
decl_stmt|;
for|for
control|(
name|HepRelVertex
name|childRel
range|:
name|childRels
control|)
block|{
name|match
operator|=
name|matchOperands
argument_list|(
name|childOperand
argument_list|,
name|childRel
operator|.
name|getCurrentRel
argument_list|()
argument_list|,
name|bindings
argument_list|,
name|nodeChildren
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|List
argument_list|<
name|RelNode
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|(
name|childRels
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|HepRelVertex
name|childRel
range|:
name|childRels
control|)
block|{
name|children
operator|.
name|add
argument_list|(
name|childRel
operator|.
name|getCurrentRel
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nodeChildren
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|children
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
default|default:
name|int
name|n
init|=
name|operand
operator|.
name|getChildOperands
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|childRels
operator|.
name|size
argument_list|()
operator|<
name|n
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|HepRelVertex
argument_list|,
name|RelOptRuleOperand
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|childRels
argument_list|,
name|operand
operator|.
name|getChildOperands
argument_list|()
argument_list|)
control|)
block|{
name|boolean
name|match
init|=
name|matchOperands
argument_list|(
name|pair
operator|.
name|right
argument_list|,
name|pair
operator|.
name|left
operator|.
name|getCurrentRel
argument_list|()
argument_list|,
name|bindings
argument_list|,
name|nodeChildren
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|private
name|HepRelVertex
name|applyTransformationResults
parameter_list|(
name|HepRelVertex
name|vertex
parameter_list|,
name|HepRuleCall
name|call
parameter_list|,
name|RelTrait
name|parentTrait
parameter_list|)
block|{
comment|// TODO jvs 5-Apr-2006:  Take the one that gives the best
comment|// global cost rather than the best local cost.  That requires
comment|// "tentative" graph edits.
assert|assert
operator|!
name|call
operator|.
name|getResults
argument_list|()
operator|.
name|isEmpty
argument_list|()
assert|;
name|RelNode
name|bestRel
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getResults
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// No costing required; skip it to minimize the chance of hitting
comment|// rels without cost information.
name|bestRel
operator|=
name|call
operator|.
name|getResults
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RelOptCost
name|bestCost
init|=
literal|null
decl_stmt|;
for|for
control|(
name|RelNode
name|rel
range|:
name|call
operator|.
name|getResults
argument_list|()
control|)
block|{
name|RelOptCost
name|thisCost
init|=
name|getCost
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINER
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|finer
argument_list|(
literal|"considering "
operator|+
name|rel
operator|+
literal|" with cumulative cost="
operator|+
name|thisCost
operator|+
literal|" and rowcount="
operator|+
name|RelMetadataQuery
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bestRel
operator|==
literal|null
operator|)
operator|||
name|thisCost
operator|.
name|isLt
argument_list|(
name|bestCost
argument_list|)
condition|)
block|{
name|bestRel
operator|=
name|rel
expr_stmt|;
name|bestCost
operator|=
name|thisCost
expr_stmt|;
block|}
block|}
block|}
operator|++
name|nTransformations
expr_stmt|;
name|notifyTransformation
argument_list|(
name|call
argument_list|,
name|bestRel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Before we add the result, make a copy of the list of vertex's
comment|// parents.  We'll need this later during contraction so that
comment|// we only update the existing parents, not the new parents
comment|// (otherwise loops can result).  Also take care of filtering
comment|// out parents by traits in case we're dealing with a converter rule.
name|List
argument_list|<
name|HepRelVertex
argument_list|>
name|allParents
init|=
name|Graphs
operator|.
name|predecessorListOf
argument_list|(
name|graph
argument_list|,
name|vertex
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|HepRelVertex
argument_list|>
name|parents
init|=
operator|new
name|ArrayList
argument_list|<
name|HepRelVertex
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HepRelVertex
name|parent
range|:
name|allParents
control|)
block|{
if|if
condition|(
name|parentTrait
operator|!=
literal|null
condition|)
block|{
name|RelNode
name|parentRel
init|=
name|parent
operator|.
name|getCurrentRel
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentRel
operator|instanceof
name|ConverterRel
condition|)
block|{
comment|// We don't support automatically chaining conversions.
comment|// Treating a converter as a candidate parent here
comment|// can cause the "iParentMatch" check below to
comment|// throw away a new converter needed in
comment|// the multi-parent DAG case.
continue|continue;
block|}
if|if
condition|(
operator|!
name|parentRel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|contains
argument_list|(
name|parentTrait
argument_list|)
condition|)
block|{
comment|// This parent does not want the converted result.
continue|continue;
block|}
block|}
name|parents
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
name|HepRelVertex
name|newVertex
init|=
name|addRelToGraph
argument_list|(
name|bestRel
argument_list|)
decl_stmt|;
comment|// There's a chance that newVertex is the same as one
comment|// of the parents due to common subexpression recognition
comment|// (e.g. the ProjectRel added by SwapJoinRule).  In that
comment|// case, treat the transformation as a nop to avoid
comment|// creating a loop.
name|int
name|iParentMatch
init|=
name|parents
operator|.
name|indexOf
argument_list|(
name|newVertex
argument_list|)
decl_stmt|;
if|if
condition|(
name|iParentMatch
operator|!=
operator|-
literal|1
condition|)
block|{
name|newVertex
operator|=
name|parents
operator|.
name|get
argument_list|(
name|iParentMatch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|contractVertices
argument_list|(
name|newVertex
argument_list|,
name|vertex
argument_list|,
name|parents
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getListener
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// Assume listener doesn't want to see garbage.
name|collectGarbage
argument_list|()
expr_stmt|;
block|}
name|notifyTransformation
argument_list|(
name|call
argument_list|,
name|bestRel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|dumpGraph
argument_list|()
expr_stmt|;
return|return
name|newVertex
return|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|RelNode
name|register
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|equivRel
parameter_list|)
block|{
comment|// Ignore; this call is mostly to tell Volcano how to avoid
comment|// infinite loops.
return|return
name|rel
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onCopy
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|newRel
parameter_list|)
block|{
name|onCopyHook
operator|.
name|apply
argument_list|(
name|rel
argument_list|,
name|newRel
argument_list|)
expr_stmt|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|RelNode
name|ensureRegistered
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|equivRel
parameter_list|)
block|{
return|return
name|rel
return|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|boolean
name|isRegistered
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
specifier|private
name|HepRelVertex
name|addRelToGraph
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
comment|// Check if a transformation already produced a reference
comment|// to an existing vertex.
if|if
condition|(
name|rel
operator|instanceof
name|HepRelVertex
condition|)
block|{
return|return
operator|(
name|HepRelVertex
operator|)
name|rel
return|;
block|}
comment|// Recursively add children, replacing this rel's inputs
comment|// with corresponding child vertices.
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|rel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|newInputs
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input1
range|:
name|inputs
control|)
block|{
name|HepRelVertex
name|childVertex
init|=
name|addRelToGraph
argument_list|(
name|input1
argument_list|)
decl_stmt|;
name|newInputs
operator|.
name|add
argument_list|(
name|childVertex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Util
operator|.
name|equalShallow
argument_list|(
name|inputs
argument_list|,
name|newInputs
argument_list|)
condition|)
block|{
name|RelNode
name|oldRel
init|=
name|rel
decl_stmt|;
name|rel
operator|=
name|rel
operator|.
name|copy
argument_list|(
name|rel
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newInputs
argument_list|)
expr_stmt|;
name|onCopy
argument_list|(
name|oldRel
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
comment|// try to find equivalent rel only if DAG is allowed
if|if
condition|(
operator|!
name|noDAG
condition|)
block|{
comment|// Now, check if an equivalent vertex already exists in graph.
name|String
name|digest
init|=
name|rel
operator|.
name|getDigest
argument_list|()
decl_stmt|;
name|HepRelVertex
name|equivVertex
init|=
name|mapDigestToVertex
operator|.
name|get
argument_list|(
name|digest
argument_list|)
decl_stmt|;
if|if
condition|(
name|equivVertex
operator|!=
literal|null
condition|)
block|{
comment|// Use existing vertex.
return|return
name|equivVertex
return|;
block|}
block|}
comment|// No equivalence:  create a new vertex to represent this rel.
name|HepRelVertex
name|newVertex
init|=
operator|new
name|HepRelVertex
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|graph
operator|.
name|addVertex
argument_list|(
name|newVertex
argument_list|)
expr_stmt|;
name|updateVertex
argument_list|(
name|newVertex
argument_list|,
name|rel
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|graph
operator|.
name|addEdge
argument_list|(
name|newVertex
argument_list|,
operator|(
name|HepRelVertex
operator|)
name|input
argument_list|)
expr_stmt|;
block|}
return|return
name|newVertex
return|;
block|}
specifier|private
name|void
name|contractVertices
parameter_list|(
name|HepRelVertex
name|preservedVertex
parameter_list|,
name|HepRelVertex
name|discardedVertex
parameter_list|,
name|List
argument_list|<
name|HepRelVertex
argument_list|>
name|parents
parameter_list|)
block|{
if|if
condition|(
name|preservedVertex
operator|==
name|discardedVertex
condition|)
block|{
comment|// Nop.
return|return;
block|}
name|RelNode
name|rel
init|=
name|preservedVertex
operator|.
name|getCurrentRel
argument_list|()
decl_stmt|;
name|updateVertex
argument_list|(
name|preservedVertex
argument_list|,
name|rel
argument_list|)
expr_stmt|;
comment|// Update specified parents of discardedVertex.
for|for
control|(
name|HepRelVertex
name|parent
range|:
name|parents
control|)
block|{
name|RelNode
name|parentRel
init|=
name|parent
operator|.
name|getCurrentRel
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|parentRel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|RelNode
name|child
init|=
name|inputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|!=
name|discardedVertex
condition|)
block|{
continue|continue;
block|}
name|parentRel
operator|.
name|replaceInput
argument_list|(
name|i
argument_list|,
name|preservedVertex
argument_list|)
expr_stmt|;
block|}
name|graph
operator|.
name|removeEdge
argument_list|(
name|parent
argument_list|,
name|discardedVertex
argument_list|)
expr_stmt|;
name|graph
operator|.
name|addEdge
argument_list|(
name|parent
argument_list|,
name|preservedVertex
argument_list|)
expr_stmt|;
name|updateVertex
argument_list|(
name|parent
argument_list|,
name|parentRel
argument_list|)
expr_stmt|;
block|}
comment|// NOTE:  we don't actually do graph.removeVertex(discardedVertex),
comment|// because it might still be reachable from preservedVertex.
comment|// Leave that job for garbage collection.
if|if
condition|(
name|discardedVertex
operator|==
name|root
condition|)
block|{
name|root
operator|=
name|preservedVertex
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|updateVertex
parameter_list|(
name|HepRelVertex
name|vertex
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|!=
name|vertex
operator|.
name|getCurrentRel
argument_list|()
condition|)
block|{
comment|// REVIEW jvs 5-Apr-2006:  We'll do this again later
comment|// during garbage collection.  Or we could get rid
comment|// of mark/sweep garbage collection and do it precisely
comment|// at this point by walking down to all rels which are only
comment|// reachable from here.
name|notifyDiscard
argument_list|(
name|vertex
operator|.
name|getCurrentRel
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|oldDigest
init|=
name|vertex
operator|.
name|getCurrentRel
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|mapDigestToVertex
operator|.
name|get
argument_list|(
name|oldDigest
argument_list|)
operator|==
name|vertex
condition|)
block|{
name|mapDigestToVertex
operator|.
name|remove
argument_list|(
name|oldDigest
argument_list|)
expr_stmt|;
block|}
name|String
name|newDigest
init|=
name|rel
operator|.
name|recomputeDigest
argument_list|()
decl_stmt|;
if|if
condition|(
name|mapDigestToVertex
operator|.
name|get
argument_list|(
name|newDigest
argument_list|)
operator|==
literal|null
condition|)
block|{
name|mapDigestToVertex
operator|.
name|put
argument_list|(
name|newDigest
argument_list|,
name|vertex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// REVIEW jvs 5-Apr-2006:  Could this lead us to
comment|// miss common subexpressions?  When called from
comment|// addRelToGraph, we'll check after this method returns,
comment|// but what about the other callers?
block|}
if|if
condition|(
name|rel
operator|!=
name|vertex
operator|.
name|getCurrentRel
argument_list|()
condition|)
block|{
name|vertex
operator|.
name|replaceRel
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
name|notifyEquivalence
argument_list|(
name|rel
argument_list|,
name|vertex
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|RelNode
name|buildFinalPlan
parameter_list|(
name|HepRelVertex
name|vertex
parameter_list|)
block|{
name|RelNode
name|rel
init|=
name|vertex
operator|.
name|getCurrentRel
argument_list|()
decl_stmt|;
name|notifyChosen
argument_list|(
name|rel
argument_list|)
expr_stmt|;
comment|// Recursively process children, replacing this rel's inputs
comment|// with corresponding child rels.
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|rel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|RelNode
name|child
init|=
name|inputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|HepRelVertex
operator|)
condition|)
block|{
comment|// Already replaced.
continue|continue;
block|}
name|child
operator|=
name|buildFinalPlan
argument_list|(
operator|(
name|HepRelVertex
operator|)
name|child
argument_list|)
expr_stmt|;
name|rel
operator|.
name|replaceInput
argument_list|(
name|i
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|rel
operator|.
name|recomputeDigest
argument_list|()
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
specifier|private
name|void
name|collectGarbage
parameter_list|()
block|{
if|if
condition|(
name|nTransformations
operator|==
name|nTransformationsLastGC
condition|)
block|{
comment|// No modifications have taken place since the last gc,
comment|// so there can't be any garbage.
return|return;
block|}
name|nTransformationsLastGC
operator|=
name|nTransformations
expr_stmt|;
name|LOGGER
operator|.
name|finest
argument_list|(
literal|"collecting garbage"
argument_list|)
expr_stmt|;
comment|// Yer basic mark-and-sweep.
name|Set
argument_list|<
name|HepRelVertex
argument_list|>
name|rootSet
init|=
operator|new
name|HashSet
argument_list|<
name|HepRelVertex
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|HepRelVertex
argument_list|>
name|iter
init|=
operator|new
name|DepthFirstIterator
argument_list|<
name|HepRelVertex
argument_list|,
name|DefaultEdge
argument_list|>
argument_list|(
name|graph
argument_list|,
name|root
argument_list|)
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|rootSet
operator|.
name|add
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rootSet
operator|.
name|size
argument_list|()
operator|==
name|graph
operator|.
name|vertexSet
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// Everything is reachable:  no garbage to collect.
return|return;
block|}
name|Set
argument_list|<
name|HepRelVertex
argument_list|>
name|sweepSet
init|=
operator|new
name|HashSet
argument_list|<
name|HepRelVertex
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HepRelVertex
name|vertex
range|:
name|graph
operator|.
name|vertexSet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|rootSet
operator|.
name|contains
argument_list|(
name|vertex
argument_list|)
condition|)
block|{
name|sweepSet
operator|.
name|add
argument_list|(
name|vertex
argument_list|)
expr_stmt|;
name|RelNode
name|rel
init|=
name|vertex
operator|.
name|getCurrentRel
argument_list|()
decl_stmt|;
name|notifyDiscard
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
operator|!
name|sweepSet
operator|.
name|isEmpty
argument_list|()
assert|;
name|graph
operator|.
name|removeAllVertices
argument_list|(
name|sweepSet
argument_list|)
expr_stmt|;
name|graphSizeLastGC
operator|=
name|graph
operator|.
name|vertexSet
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
comment|// Clean up digest map too.
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HepRelVertex
argument_list|>
argument_list|>
name|digestIter
init|=
name|mapDigestToVertex
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|digestIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|HepRelVertex
name|vertex
init|=
name|digestIter
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|sweepSet
operator|.
name|contains
argument_list|(
name|vertex
argument_list|)
condition|)
block|{
name|digestIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|assertNoCycles
parameter_list|()
block|{
comment|// Verify that the graph is acyclic.
name|CycleDetector
argument_list|<
name|HepRelVertex
argument_list|,
name|DefaultEdge
argument_list|>
name|cycleDetector
init|=
operator|new
name|CycleDetector
argument_list|<
name|HepRelVertex
argument_list|,
name|DefaultEdge
argument_list|>
argument_list|(
name|graph
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|HepRelVertex
argument_list|>
name|cyclicVertices
init|=
name|cycleDetector
operator|.
name|findCycles
argument_list|()
decl_stmt|;
if|if
condition|(
name|cyclicVertices
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Query graph cycle detected in HepPlanner:  "
operator|+
name|cyclicVertices
argument_list|)
throw|;
block|}
specifier|private
name|void
name|dumpGraph
parameter_list|()
block|{
if|if
condition|(
operator|!
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINER
argument_list|)
condition|)
block|{
return|return;
block|}
name|assertNoCycles
argument_list|()
expr_stmt|;
name|Iterator
argument_list|<
name|HepRelVertex
argument_list|>
name|bfsIter
init|=
operator|new
name|BreadthFirstIterator
argument_list|<
name|HepRelVertex
argument_list|,
name|DefaultEdge
argument_list|>
argument_list|(
name|graph
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\nBreadth-first from root:  {\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|bfsIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|HepRelVertex
name|vertex
init|=
name|bfsIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"    "
argument_list|)
operator|.
name|append
argument_list|(
name|vertex
argument_list|)
operator|.
name|append
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|RelNode
name|rel
init|=
name|vertex
operator|.
name|getCurrentRel
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|rel
argument_list|)
operator|.
name|append
argument_list|(
literal|", rowcount="
argument_list|)
operator|.
name|append
argument_list|(
name|RelMetadataQuery
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|", cumulative cost="
argument_list|)
operator|.
name|append
argument_list|(
name|getCost
argument_list|(
name|rel
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|LOGGER
operator|.
name|finer
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|void
name|registerMetadataProviders
parameter_list|(
name|List
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
parameter_list|)
block|{
name|list
operator|.
name|add
argument_list|(
literal|0
argument_list|,
operator|new
name|HepRelMetadataProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// implement RelOptPlanner
specifier|public
name|long
name|getRelMetadataTimestamp
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
comment|// TODO jvs 20-Apr-2006: This is overly conservative.  Better would be
comment|// to keep a timestamp per HepRelVertex, and update only affected
comment|// vertices and all ancestors on each transformation.
return|return
name|nTransformations
return|;
block|}
block|}
end_class

begin_comment
comment|// End HepPlanner.java
end_comment

end_unit

