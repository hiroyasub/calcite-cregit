begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to the Apache Software Foundation (ASF) under one or more // contributor license agreements.  See the NOTICE file distributed with // this work for additional information regarding copyright ownership. // The ASF licenses this file to you under the Apache License, Version 2.0 // (the "License"); you may not use this file except in compliance with // the License.  You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|relopt
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|rules
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|mapping
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|util
operator|.
name|BitSets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  *<code>RelOptUtil</code> defines static utility methods for use in optimizing  * {@link RelNode}s.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|RelOptUtil
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|public
specifier|static
specifier|final
name|double
name|EPSILON
init|=
literal|1.0e-5
decl_stmt|;
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Returns a list of variables set by a relational expression or its    * descendants.    */
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|getVariablesSet
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|VariableSetVisitor
name|visitor
init|=
operator|new
name|VariableSetVisitor
argument_list|()
decl_stmt|;
name|go
argument_list|(
name|visitor
argument_list|,
name|rel
argument_list|)
expr_stmt|;
return|return
name|visitor
operator|.
name|variables
return|;
block|}
comment|/**    * Returns a set of distinct variables set by<code>rel0</code> and used by    *<code>rel1</code>.    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|getVariablesSetAndUsed
parameter_list|(
name|RelNode
name|rel0
parameter_list|,
name|RelNode
name|rel1
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
name|getVariablesSet
argument_list|(
name|rel0
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|used
init|=
name|getVariablesUsed
argument_list|(
name|rel1
argument_list|)
decl_stmt|;
if|if
condition|(
name|used
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|set
control|)
block|{
if|if
condition|(
name|used
operator|.
name|contains
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|result
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns a set of variables used by a relational expression or its    * descendants. The set may contain duplicates. The item type is the same as    * {@link org.eigenbase.rex.RexVariable#getName}    */
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|getVariablesUsed
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|VariableUsedVisitor
name|vuv
init|=
operator|new
name|VariableUsedVisitor
argument_list|()
decl_stmt|;
specifier|final
name|VisitorRelVisitor
name|visitor
init|=
operator|new
name|VisitorRelVisitor
argument_list|(
name|vuv
argument_list|)
block|{
comment|// implement RelVisitor
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|p
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
name|p
operator|.
name|collectVariablesUsed
argument_list|(
name|vuv
operator|.
name|variables
argument_list|)
expr_stmt|;
name|super
operator|.
name|visit
argument_list|(
name|p
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
comment|// Important! Remove stopped variables AFTER we visit
comment|// children. (which what super.visit() does)
name|vuv
operator|.
name|variables
operator|.
name|removeAll
argument_list|(
name|p
operator|.
name|getVariablesStopped
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|visitor
operator|.
name|go
argument_list|(
name|rel
argument_list|)
expr_stmt|;
return|return
name|vuv
operator|.
name|variables
return|;
block|}
comment|/**    * Sets a {@link RelVisitor} going on a given relational expression, and    * returns the result.    */
specifier|public
specifier|static
name|void
name|go
parameter_list|(
name|RelVisitor
name|visitor
parameter_list|,
name|RelNode
name|p
parameter_list|)
block|{
try|try
block|{
name|visitor
operator|.
name|go
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
name|e
argument_list|,
literal|"while visiting tree"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns a list of the types of the fields in a given struct type. The    * list is immutable.    *    * @param type Struct type    * @return List of field types    * @see org.eigenbase.reltype.RelDataType#getFieldNames()    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataType
argument_list|>
name|getFieldTypeList
parameter_list|(
specifier|final
name|RelDataType
name|type
parameter_list|)
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|type
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getType
argument_list|()
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|type
operator|.
name|getFieldCount
argument_list|()
return|;
block|}
block|}
return|;
block|}
specifier|public
specifier|static
name|boolean
name|areRowTypesEqual
parameter_list|(
name|RelDataType
name|rowType1
parameter_list|,
name|RelDataType
name|rowType2
parameter_list|,
name|boolean
name|compareNames
parameter_list|)
block|{
if|if
condition|(
name|rowType1
operator|==
name|rowType2
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|compareNames
condition|)
block|{
comment|// if types are not identity-equal, then either the names or
comment|// the types must be different
return|return
literal|false
return|;
block|}
if|if
condition|(
name|rowType2
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|rowType1
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|f1
init|=
name|rowType1
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|f2
init|=
name|rowType2
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|f1
argument_list|,
name|f2
argument_list|)
control|)
block|{
specifier|final
name|RelDataType
name|type1
init|=
name|pair
operator|.
name|left
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type2
init|=
name|pair
operator|.
name|right
operator|.
name|getType
argument_list|()
decl_stmt|;
comment|// If one of the types is ANY comparison should succeed
if|if
condition|(
name|type1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
operator|||
name|type2
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|type1
operator|.
name|equals
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Verifies that a row type being added to an equivalence class matches the    * existing type, raising an assertion if this is not the case.    *    * @param originalRel      canonical rel for equivalence class    * @param newRel           rel being added to equivalence class    * @param equivalenceClass object representing equivalence class    */
specifier|public
specifier|static
name|void
name|verifyTypeEquivalence
parameter_list|(
name|RelNode
name|originalRel
parameter_list|,
name|RelNode
name|newRel
parameter_list|,
name|Object
name|equivalenceClass
parameter_list|)
block|{
name|RelDataType
name|expectedRowType
init|=
name|originalRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|RelDataType
name|actualRowType
init|=
name|newRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
comment|// Row types must be the same, except for field names.
if|if
condition|(
name|areRowTypesEqual
argument_list|(
name|expectedRowType
argument_list|,
name|actualRowType
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|String
name|s
init|=
literal|"Cannot add expression of different type to set:\n"
operator|+
literal|"set type is "
operator|+
name|expectedRowType
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\nexpression type is "
operator|+
name|actualRowType
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\nset is "
operator|+
name|equivalenceClass
operator|.
name|toString
argument_list|()
operator|+
literal|"\nexpression is "
operator|+
name|newRel
operator|.
name|toString
argument_list|()
decl_stmt|;
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
name|s
argument_list|)
throw|;
block|}
comment|/**    * Returns a permutation describing where output fields come from. In    * the returned map, value of {@code map.getTargetOpt(i)} is {@code n} if    * field {@code i} projects input field {@code n}, -1 if it is an    * expression.    */
specifier|public
specifier|static
name|Mappings
operator|.
name|TargetMapping
name|permutation
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|)
block|{
specifier|final
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|PARTIAL_FUNCTION
argument_list|,
name|nodes
operator|.
name|size
argument_list|()
argument_list|,
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RexNode
argument_list|>
name|node
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|nodes
argument_list|)
control|)
block|{
if|if
condition|(
name|node
operator|.
name|e
operator|instanceof
name|RexInputRef
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|node
operator|.
name|i
argument_list|,
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|.
name|e
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|node
operator|.
name|e
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
condition|)
block|{
name|RexNode
name|operand
init|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|.
name|e
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand
operator|instanceof
name|RexInputRef
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|node
operator|.
name|i
argument_list|,
operator|(
operator|(
name|RexInputRef
operator|)
name|operand
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|mapping
return|;
block|}
comment|/**    * Creates a plan suitable for use in<code>EXISTS</code> or<code>IN</code>    * statements. See {@link    * org.eigenbase.sql2rel.SqlToRelConverter#convertExists} Note: this    * implementation of createExistsPlan is only called from    * net.sf.farrago.fennel.rel. The last two arguments do not apply to    * those invocations and can be removed from the method.    *    * @param cluster    Cluster    * @param seekRel    A query rel, for example the resulting rel from 'select *    *                   from emp' or 'values (1,2,3)' or '('Foo', 34)'.    * @param conditions May be null    * @param extraExpr  Column expression to add. "TRUE" for EXISTS and IN    * @param extraName  Name of expression to add.    * @return relational expression which outer joins a boolean condition    * column    */
specifier|public
specifier|static
name|RelNode
name|createExistsPlan
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelNode
name|seekRel
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|conditions
parameter_list|,
name|RexLiteral
name|extraExpr
parameter_list|,
name|String
name|extraName
parameter_list|)
block|{
assert|assert
name|extraExpr
operator|==
literal|null
operator|||
name|extraName
operator|!=
literal|null
assert|;
name|RelNode
name|ret
init|=
name|seekRel
decl_stmt|;
if|if
condition|(
operator|(
name|conditions
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|conditions
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|RexNode
name|conditionExp
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|conditions
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|ret
operator|=
name|CalcRel
operator|.
name|createFilter
argument_list|(
name|ret
argument_list|,
name|conditionExp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extraExpr
operator|!=
literal|null
condition|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataTypeFactory
name|typeFactory
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
assert|assert
name|extraExpr
operator|==
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
assert|;
comment|// this should only be called for the exists case
comment|// first stick an Agg on top of the subquery
comment|// agg does not like no agg functions so just pretend it is
comment|// doing a min(TRUE)
name|ret
operator|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|ret
argument_list|,
name|Collections
operator|.
expr|<
name|RexNode
operator|>
name|singletonList
argument_list|(
name|extraExpr
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
decl_stmt|;
name|SqlAggFunction
name|minFunction
init|=
operator|new
name|SqlMinMaxAggFunction
argument_list|(
name|argTypes
argument_list|,
literal|true
argument_list|,
name|SqlMinMaxAggFunction
operator|.
name|MINMAX_COMPARABLE
argument_list|)
decl_stmt|;
name|RelDataType
name|returnType
init|=
name|minFunction
operator|.
name|inferReturnType
argument_list|(
operator|new
name|AggregateRelBase
operator|.
name|AggCallBinding
argument_list|(
name|typeFactory
argument_list|,
name|minFunction
argument_list|,
name|argTypes
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|AggregateCall
name|aggCall
init|=
operator|new
name|AggregateCall
argument_list|(
name|minFunction
argument_list|,
literal|false
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
literal|0
argument_list|)
argument_list|,
name|returnType
argument_list|,
name|extraName
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|new
name|AggregateRel
argument_list|(
name|ret
operator|.
name|getCluster
argument_list|()
argument_list|,
name|ret
argument_list|,
name|BitSets
operator|.
name|of
argument_list|()
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|aggCall
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|public
specifier|static
name|RelNode
name|createExistsPlan
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelNode
name|seekRel
parameter_list|,
name|boolean
name|isIn
parameter_list|,
name|boolean
name|isExists
parameter_list|,
name|boolean
name|needsOuterJoin
parameter_list|)
block|{
name|RelNode
name|ret
init|=
name|seekRel
decl_stmt|;
if|if
condition|(
name|isIn
operator|||
name|isExists
condition|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataTypeFactory
name|typeFactory
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
comment|// for IN/NOT IN , it needs to output the fields
if|if
condition|(
name|isIn
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ret
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|ret
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needsOuterJoin
condition|)
block|{
comment|// First insert an Agg on top of the subquery
comment|// agg does not like no agg functions so just pretend it is
comment|// doing a min(TRUE)
name|RexNode
name|trueExp
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|trueExp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|ret
argument_list|,
name|exprs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
decl_stmt|;
name|SqlAggFunction
name|minFunction
init|=
operator|new
name|SqlMinMaxAggFunction
argument_list|(
name|argTypes
argument_list|,
literal|true
argument_list|,
name|SqlMinMaxAggFunction
operator|.
name|MINMAX_COMPARABLE
argument_list|)
decl_stmt|;
name|int
name|newProjFieldCount
init|=
name|ret
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|RelDataType
name|returnType
init|=
name|minFunction
operator|.
name|inferReturnType
argument_list|(
operator|new
name|AggregateRelBase
operator|.
name|AggCallBinding
argument_list|(
name|typeFactory
argument_list|,
name|minFunction
argument_list|,
name|argTypes
argument_list|,
name|newProjFieldCount
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|AggregateCall
name|aggCall
init|=
operator|new
name|AggregateCall
argument_list|(
name|minFunction
argument_list|,
literal|false
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|newProjFieldCount
operator|-
literal|1
argument_list|)
argument_list|,
name|returnType
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|new
name|AggregateRel
argument_list|(
name|ret
operator|.
name|getCluster
argument_list|()
argument_list|,
name|ret
argument_list|,
name|BitSets
operator|.
name|range
argument_list|(
name|newProjFieldCount
operator|-
literal|1
argument_list|)
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|aggCall
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|new
name|AggregateRel
argument_list|(
name|ret
operator|.
name|getCluster
argument_list|()
argument_list|,
name|ret
argument_list|,
name|BitSets
operator|.
name|range
argument_list|(
name|ret
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|,
name|Collections
operator|.
expr|<
name|AggregateCall
operator|>
name|emptyList
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Creates a ProjectRel which accomplishes a rename.    *    * @param outputType a row type descriptor whose field names the generated    *                   ProjectRel must match    * @param rel        the rel whose output is to be renamed; rel.getRowType()    *                   must be the same as outputType except for field names    * @return generated relational expression    */
specifier|public
specifier|static
name|RelNode
name|createRenameRel
parameter_list|(
name|RelDataType
name|outputType
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
name|RelDataType
name|inputType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputFields
init|=
name|inputType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|inputFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|outputFields
init|=
name|outputType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|outputFields
operator|.
name|size
argument_list|()
operator|==
name|n
operator|:
literal|"rename: field count mismatch: in="
operator|+
name|inputType
operator|+
literal|", out"
operator|+
name|outputType
assert|;
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|renames
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|inputFields
argument_list|,
name|outputFields
argument_list|)
control|)
block|{
specifier|final
name|RelDataTypeField
name|inputField
init|=
name|pair
operator|.
name|left
decl_stmt|;
specifier|final
name|RelDataTypeField
name|outputField
init|=
name|pair
operator|.
name|right
decl_stmt|;
assert|assert
name|inputField
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|outputField
operator|.
name|getType
argument_list|()
argument_list|)
assert|;
name|renames
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
operator|(
name|RexNode
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|inputField
operator|.
name|getType
argument_list|()
argument_list|,
name|inputField
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|,
name|outputField
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|CalcRel
operator|.
name|createProject
argument_list|(
name|rel
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|renames
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|renames
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a filter which will remove rows containing NULL values.    *    * @param rel           the rel to be filtered    * @param fieldOrdinals array of 0-based field ordinals to filter, or null    *                      for all fields    * @return filtered rel    */
specifier|public
specifier|static
name|RelNode
name|createNullFilter
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Integer
index|[]
name|fieldOrdinals
parameter_list|)
block|{
name|RexNode
name|condition
init|=
literal|null
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|fieldOrdinals
operator|!=
literal|null
condition|)
block|{
name|n
operator|=
name|fieldOrdinals
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|int
name|iField
decl_stmt|;
if|if
condition|(
name|fieldOrdinals
operator|!=
literal|null
condition|)
block|{
name|iField
operator|=
name|fieldOrdinals
index|[
name|i
index|]
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|iField
operator|=
name|i
expr_stmt|;
block|}
name|RelDataType
name|type
init|=
name|fields
operator|.
name|get
argument_list|(
name|iField
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|RexNode
name|newCondition
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|type
argument_list|,
name|iField
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
name|condition
operator|=
name|newCondition
expr_stmt|;
block|}
else|else
block|{
name|condition
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|condition
argument_list|,
name|newCondition
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
comment|// no filtering required
return|return
name|rel
return|;
block|}
return|return
name|CalcRel
operator|.
name|createFilter
argument_list|(
name|rel
argument_list|,
name|condition
argument_list|)
return|;
block|}
comment|/**    * Creates a projection which casts a rel's output to a desired row type.    *    * @param rel         producer of rows to be converted    * @param castRowType row type after cast    * @param rename      if true, use field names from castRowType; if false,    *                    preserve field names from rel    * @return conversion rel    */
specifier|public
specifier|static
name|RelNode
name|createCastRel
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
name|RelDataType
name|castRowType
parameter_list|,
name|boolean
name|rename
parameter_list|)
block|{
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|areRowTypesEqual
argument_list|(
name|rowType
argument_list|,
name|castRowType
argument_list|,
name|rename
argument_list|)
condition|)
block|{
comment|// nothing to do
return|return
name|rel
return|;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|castExps
init|=
name|RexUtil
operator|.
name|generateCastExpressions
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|castRowType
argument_list|,
name|rowType
argument_list|)
decl_stmt|;
if|if
condition|(
name|rename
condition|)
block|{
comment|// Use names and types from castRowType.
return|return
name|CalcRel
operator|.
name|createProject
argument_list|(
name|rel
argument_list|,
name|castExps
argument_list|,
name|castRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// Use names from rowType, types from castRowType.
return|return
name|CalcRel
operator|.
name|createProject
argument_list|(
name|rel
argument_list|,
name|castExps
argument_list|,
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Creates an AggregateRel which removes all duplicates from the result of    * an underlying rel.    *    * @param rel underlying rel    * @return rel implementing SingleValueAgg    */
specifier|public
specifier|static
name|RelNode
name|createSingleValueAggRel
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
comment|// assert (rel.getRowType().getFieldCount() == 1);
name|int
name|aggCallCnt
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregateCall
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggCallCnt
condition|;
name|i
operator|++
control|)
block|{
name|RelDataType
name|returnType
init|=
name|SqlStdOperatorTable
operator|.
name|SINGLE_VALUE
operator|.
name|inferReturnType
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|aggCalls
operator|.
name|add
argument_list|(
operator|new
name|AggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SINGLE_VALUE
argument_list|,
literal|false
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|i
argument_list|)
argument_list|,
name|returnType
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|AggregateRel
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|rel
argument_list|,
name|BitSets
operator|.
name|of
argument_list|()
argument_list|,
name|aggCalls
argument_list|)
return|;
block|}
comment|/**    * Creates an AggregateRel which removes all duplicates from the result of    * an underlying rel.    *    * @param rel underlying rel    * @return rel implementing DISTINCT    */
specifier|public
specifier|static
name|RelNode
name|createDistinctRel
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
operator|new
name|AggregateRel
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|rel
argument_list|,
name|BitSets
operator|.
name|range
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|,
name|ImmutableList
operator|.
expr|<
name|AggregateCall
operator|>
name|of
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|analyzeSimpleEquiJoin
parameter_list|(
name|JoinRel
name|joinRel
parameter_list|,
name|int
index|[]
name|joinFieldOrdinals
parameter_list|)
block|{
name|RexNode
name|joinExp
init|=
name|joinRel
operator|.
name|getCondition
argument_list|()
decl_stmt|;
if|if
condition|(
name|joinExp
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RexCall
name|binaryExpression
init|=
operator|(
name|RexCall
operator|)
name|joinExp
decl_stmt|;
name|RexNode
name|leftComparand
init|=
name|binaryExpression
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|rightComparand
init|=
name|binaryExpression
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|leftComparand
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|rightComparand
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|leftFieldCount
init|=
name|joinRel
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|RexInputRef
name|leftFieldAccess
init|=
operator|(
name|RexInputRef
operator|)
name|leftComparand
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|leftFieldAccess
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|)
condition|)
block|{
comment|// left field must access left side of join
return|return
literal|false
return|;
block|}
name|RexInputRef
name|rightFieldAccess
init|=
operator|(
name|RexInputRef
operator|)
name|rightComparand
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rightFieldAccess
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
operator|)
condition|)
block|{
comment|// right field must access right side of join
return|return
literal|false
return|;
block|}
name|joinFieldOrdinals
index|[
literal|0
index|]
operator|=
name|leftFieldAccess
operator|.
name|getIndex
argument_list|()
expr_stmt|;
name|joinFieldOrdinals
index|[
literal|1
index|]
operator|=
name|rightFieldAccess
operator|.
name|getIndex
argument_list|()
operator|-
name|leftFieldCount
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Splits out the equi-join components of a join condition, and returns    * what's left. For example, given the condition    *    *<blockquote><code>L.A = R.X AND L.B = L.C AND (L.D = 5 OR L.E =    * R.Y)</code></blockquote>    *    * returns    *    *<ul>    *<li>leftKeys = {A}    *<li>rightKeys = {X}    *<li>rest = L.B = L.C AND (L.D = 5 OR L.E = R.Y)</li>    *</ul>    *    * @param left      left input to join    * @param right     right input to join    * @param condition join condition    * @param leftKeys  The ordinals of the fields from the left input which are    *                  equi-join keys    * @param rightKeys The ordinals of the fields from the right input which    *                  are equi-join keys    * @return remaining join filters that are not equijoins; may return a    * {@link RexLiteral} true, but never null    */
specifier|public
specifier|static
name|RexNode
name|splitJoinCondition
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|RelNode
name|right
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|splitJoinCondition
argument_list|(
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|condition
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|left
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns whether a join condition is an "equi-join" condition.    *    * @param left      Left input of join    * @param right     Right input of join    * @param condition Condition    * @return Whether condition is equi-join    */
specifier|public
specifier|static
name|boolean
name|isEqui
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|RelNode
name|right
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|splitJoinCondition
argument_list|(
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|condition
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
return|return
name|nonEquiList
operator|.
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/**    * Splits out the equi-join (and optionally, a single non-equi) components    * of a join condition, and returns what's left. Projection might be    * required by the caller to provide join keys that are not direct field    * references.    *    * @param sysFieldList  list of system fields    * @param leftRel       left join input    * @param rightRel      right join input    * @param condition     join condition    * @param leftJoinKeys  The join keys from the left input which are equi-join    *                      keys    * @param rightJoinKeys The join keys from the right input which are    *                      equi-join keys    * @param filterNulls   The join key positions for which null values will not    *                      match. null values only match for the "is not distinct    *                      from" condition.    * @param rangeOp       if null, only locate equi-joins; otherwise, locate a    *                      single non-equi join predicate and return its operator    *                      in this list; join keys associated with the non-equi    *                      join predicate are at the end of the key lists    *                      returned    * @return What's left, never null    */
specifier|public
specifier|static
name|RexNode
name|splitJoinCondition
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sysFieldList
parameter_list|,
name|RelNode
name|leftRel
parameter_list|,
name|RelNode
name|rightRel
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|filterNulls
parameter_list|,
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|rangeOp
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|splitJoinCondition
argument_list|(
name|sysFieldList
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|condition
argument_list|,
name|leftJoinKeys
argument_list|,
name|rightJoinKeys
argument_list|,
name|filterNulls
argument_list|,
name|rangeOp
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
comment|// Convert the remainders into a list that are AND'ed together.
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|leftRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RexNode
name|splitCorrelatedFilterCondition
parameter_list|(
name|FilterRel
name|filterRel
parameter_list|,
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|splitCorrelatedFilterCondition
argument_list|(
name|filterRel
argument_list|,
name|filterRel
operator|.
name|getCondition
argument_list|()
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
comment|// Convert the remainders into a list that are AND'ed together.
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|filterRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RexNode
name|splitCorrelatedFilterCondition
parameter_list|(
name|FilterRel
name|filterRel
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|boolean
name|extractCorrelatedFieldAccess
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|splitCorrelatedFilterCondition
argument_list|(
name|filterRel
argument_list|,
name|filterRel
operator|.
name|getCondition
argument_list|()
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|,
name|extractCorrelatedFieldAccess
argument_list|)
expr_stmt|;
comment|// Convert the remainders into a list that are AND'ed together.
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|filterRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|splitJoinCondition
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sysFieldList
parameter_list|,
name|RelNode
name|leftRel
parameter_list|,
name|RelNode
name|rightRel
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|filterNulls
parameter_list|,
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|rangeOp
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|)
block|{
specifier|final
name|int
name|sysFieldCount
init|=
name|sysFieldList
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|leftFieldCount
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|rightFieldCount
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|firstLeftField
init|=
name|sysFieldCount
decl_stmt|;
specifier|final
name|int
name|firstRightField
init|=
name|sysFieldCount
operator|+
name|leftFieldCount
decl_stmt|;
specifier|final
name|int
name|totalFieldCount
init|=
name|firstRightField
operator|+
name|rightFieldCount
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftFields
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightFields
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|leftRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataTypeFactory
name|typeFactory
init|=
name|leftRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
comment|// adjustment array
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|totalFieldCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|firstLeftField
init|;
name|i
operator|<
name|firstRightField
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
operator|-
name|firstLeftField
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|firstRightField
init|;
name|i
operator|<
name|totalFieldCount
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
operator|-
name|firstRightField
expr_stmt|;
block|}
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|AND
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitJoinCondition
argument_list|(
name|sysFieldList
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|operand
argument_list|,
name|leftJoinKeys
argument_list|,
name|rightJoinKeys
argument_list|,
name|filterNulls
argument_list|,
name|rangeOp
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|RexNode
name|leftKey
init|=
literal|null
decl_stmt|;
name|RexNode
name|rightKey
init|=
literal|null
decl_stmt|;
name|boolean
name|reverse
init|=
literal|false
decl_stmt|;
name|SqlKind
name|kind
init|=
name|call
operator|.
name|getKind
argument_list|()
decl_stmt|;
comment|// Only consider range operators if we haven't already seen one
if|if
condition|(
operator|(
name|kind
operator|==
name|SqlKind
operator|.
name|EQUALS
operator|)
operator|||
operator|(
name|filterNulls
operator|!=
literal|null
operator|&&
name|kind
operator|==
name|SqlKind
operator|.
name|IS_NOT_DISTINCT_FROM
operator|)
operator|||
operator|(
name|rangeOp
operator|!=
literal|null
operator|&&
name|rangeOp
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|kind
operator|==
name|SqlKind
operator|.
name|GREATER_THAN
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|GREATER_THAN_OR_EQUAL
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|LESS_THAN
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|LESS_THAN_OR_EQUAL
operator|)
operator|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|op0
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|op1
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|BitSet
name|projRefs0
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|op0
argument_list|)
decl_stmt|;
specifier|final
name|BitSet
name|projRefs1
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|projRefs0
operator|.
name|nextSetBit
argument_list|(
name|firstRightField
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|projRefs1
operator|.
name|nextSetBit
argument_list|(
name|firstLeftField
argument_list|)
operator|>=
name|firstRightField
operator|)
condition|)
block|{
name|leftKey
operator|=
name|op0
expr_stmt|;
name|rightKey
operator|=
name|op1
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|projRefs1
operator|.
name|nextSetBit
argument_list|(
name|firstRightField
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|projRefs0
operator|.
name|nextSetBit
argument_list|(
name|firstLeftField
argument_list|)
operator|>=
name|firstRightField
operator|)
condition|)
block|{
name|leftKey
operator|=
name|op1
expr_stmt|;
name|rightKey
operator|=
name|op0
expr_stmt|;
name|reverse
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|leftKey
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|rightKey
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// replace right Key input ref
name|rightKey
operator|=
name|rightKey
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|rightFields
argument_list|,
name|rightFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
comment|// left key only needs to be adjusted if there are system
comment|// fields, but do it for uniformity
name|leftKey
operator|=
name|leftKey
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|leftFields
argument_list|,
name|leftFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
name|RelDataType
name|leftKeyType
init|=
name|leftKey
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|rightKeyType
init|=
name|rightKey
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftKeyType
operator|!=
name|rightKeyType
condition|)
block|{
comment|// perform casting
name|RelDataType
name|targetKeyType
init|=
name|typeFactory
operator|.
name|leastRestrictive
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|leftKeyType
argument_list|,
name|rightKeyType
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetKeyType
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Cannot find common type for join keys "
operator|+
name|leftKey
operator|+
literal|" (type "
operator|+
name|leftKeyType
operator|+
literal|") and "
operator|+
name|rightKey
operator|+
literal|" (type "
operator|+
name|rightKeyType
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|leftKeyType
operator|!=
name|targetKeyType
condition|)
block|{
name|leftKey
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|targetKeyType
argument_list|,
name|leftKey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rightKeyType
operator|!=
name|targetKeyType
condition|)
block|{
name|rightKey
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|targetKeyType
argument_list|,
name|rightKey
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|rangeOp
operator|==
literal|null
operator|)
operator|&&
operator|(
operator|(
name|leftKey
operator|==
literal|null
operator|)
operator|||
operator|(
name|rightKey
operator|==
literal|null
operator|)
operator|)
condition|)
block|{
comment|// no equality join keys found yet:
comment|// try transforming the condition to
comment|// equality "join" conditions, e.g.
comment|//     f(LHS)> 0 ===> ( f(LHS)> 0 ) = TRUE,
comment|// and make the RHS produce TRUE, but only if we're strictly
comment|// looking for equi-joins
specifier|final
name|BitSet
name|projRefs
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|condition
argument_list|)
decl_stmt|;
name|leftKey
operator|=
literal|null
expr_stmt|;
name|rightKey
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|projRefs
operator|.
name|nextSetBit
argument_list|(
name|firstRightField
argument_list|)
operator|<
literal|0
condition|)
block|{
name|leftKey
operator|=
name|condition
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|leftFields
argument_list|,
name|leftFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
name|rightKey
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// effectively performing an equality comparison
name|kind
operator|=
name|SqlKind
operator|.
name|EQUALS
expr_stmt|;
block|}
if|else if
condition|(
name|projRefs
operator|.
name|nextSetBit
argument_list|(
name|firstLeftField
argument_list|)
operator|>=
name|firstRightField
condition|)
block|{
name|leftKey
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// replace right Key input ref
name|rightKey
operator|=
name|condition
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|rightFields
argument_list|,
name|rightFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
comment|// effectively performing an equality comparison
name|kind
operator|=
name|SqlKind
operator|.
name|EQUALS
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|leftKey
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|rightKey
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// found suitable join keys
comment|// add them to key list, ensuring that if there is a
comment|// non-equi join predicate, it appears at the end of the
comment|// key list; also mark the null filtering property
name|addJoinKey
argument_list|(
name|leftJoinKeys
argument_list|,
name|leftKey
argument_list|,
operator|(
name|rangeOp
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|rangeOp
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|addJoinKey
argument_list|(
name|rightJoinKeys
argument_list|,
name|rightKey
argument_list|,
operator|(
name|rangeOp
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|rangeOp
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|filterNulls
operator|!=
literal|null
operator|&&
name|kind
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
comment|// nulls are considered not matching for equality comparison
comment|// add the position of the most recently inserted key
name|filterNulls
operator|.
name|add
argument_list|(
name|leftJoinKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rangeOp
operator|!=
literal|null
operator|&&
name|kind
operator|!=
name|SqlKind
operator|.
name|EQUALS
operator|&&
name|kind
operator|!=
name|SqlKind
operator|.
name|IS_DISTINCT_FROM
condition|)
block|{
if|if
condition|(
name|reverse
condition|)
block|{
name|kind
operator|=
name|reverse
argument_list|(
name|kind
argument_list|)
expr_stmt|;
block|}
name|rangeOp
operator|.
name|add
argument_list|(
name|op
argument_list|(
name|kind
argument_list|,
name|call
operator|.
name|getOperator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// else fall through and add this condition as nonEqui condition
block|}
comment|// The operator is not of RexCall type
comment|// So we fail. Fall through.
comment|// Add this condition to the list of non-equi-join conditions.
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|SqlKind
name|reverse
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|GREATER_THAN
case|:
return|return
name|SqlKind
operator|.
name|LESS_THAN
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|SqlKind
operator|.
name|LESS_THAN_OR_EQUAL
return|;
case|case
name|LESS_THAN
case|:
return|return
name|SqlKind
operator|.
name|GREATER_THAN
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|SqlKind
operator|.
name|GREATER_THAN_OR_EQUAL
return|;
default|default:
return|return
name|kind
return|;
block|}
block|}
specifier|private
specifier|static
name|SqlOperator
name|op
parameter_list|(
name|SqlKind
name|kind
parameter_list|,
name|SqlOperator
name|operator
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|EQUALS
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|EQUALS
return|;
case|case
name|NOT_EQUALS
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
return|;
case|case
name|GREATER_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
return|;
case|case
name|LESS_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
return|;
case|case
name|IS_DISTINCT_FROM
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_DISTINCT_FROM
return|;
case|case
name|IS_NOT_DISTINCT_FROM
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
return|;
default|default:
return|return
name|operator
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|addJoinKey
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeyList
parameter_list|,
name|RexNode
name|key
parameter_list|,
name|boolean
name|preserveLastElementInList
parameter_list|)
block|{
if|if
condition|(
operator|!
name|joinKeyList
operator|.
name|isEmpty
argument_list|()
operator|&&
name|preserveLastElementInList
condition|)
block|{
name|joinKeyList
operator|.
name|add
argument_list|(
name|joinKeyList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|joinKeyList
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|splitCorrelatedFilterCondition
parameter_list|(
name|FilterRel
name|filterRel
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|AND
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitCorrelatedFilterCondition
argument_list|(
name|filterRel
argument_list|,
name|operand
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|EQUALS
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|op0
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|op1
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op0
argument_list|)
operator|)
operator|&&
operator|(
name|op1
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|joinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexInputRef
operator|)
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
if|else if
condition|(
operator|(
name|op0
operator|instanceof
name|RexInputRef
operator|)
operator|&&
operator|!
operator|(
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op1
argument_list|)
operator|)
condition|)
block|{
name|joinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexInputRef
operator|)
name|op0
argument_list|)
expr_stmt|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// The operator is not of RexCall type
comment|// So we fail. Fall through.
comment|// Add this condition to the list of non-equi-join conditions.
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|splitCorrelatedFilterCondition
parameter_list|(
name|FilterRel
name|filterRel
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|,
name|boolean
name|extractCorrelatedFieldAccess
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|AND
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitCorrelatedFilterCondition
argument_list|(
name|filterRel
argument_list|,
name|operand
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|,
name|extractCorrelatedFieldAccess
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|EQUALS
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|op0
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|op1
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|extractCorrelatedFieldAccess
condition|)
block|{
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|containsFieldAccess
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|op1
operator|instanceof
name|RexFieldAccess
operator|)
condition|)
block|{
name|joinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
if|else if
condition|(
operator|(
name|op0
operator|instanceof
name|RexFieldAccess
operator|)
operator|&&
operator|!
name|RexUtil
operator|.
name|containsFieldAccess
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|joinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op0
argument_list|)
operator|)
operator|&&
operator|(
name|op1
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|joinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
if|else if
condition|(
operator|(
name|op0
operator|instanceof
name|RexInputRef
operator|)
operator|&&
operator|!
operator|(
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op1
argument_list|)
operator|)
condition|)
block|{
name|joinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|// The operator is not of RexCall type
comment|// So we fail. Fall through.
comment|// Add this condition to the list of non-equi-join conditions.
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|splitJoinCondition
parameter_list|(
specifier|final
name|int
name|leftFieldCount
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
specifier|final
name|SqlOperator
name|operator
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|AND
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitJoinCondition
argument_list|(
name|leftFieldCount
argument_list|,
name|operand
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// "=" and "IS NOT DISTINCT FROM" are the same except for how they
comment|// treat nulls. TODO: record null treatment
if|if
condition|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|EQUALS
operator|||
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
operator|&&
operator|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|RexInputRef
name|op0
init|=
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexInputRef
name|op1
init|=
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|RexInputRef
name|leftField
decl_stmt|;
name|RexInputRef
name|rightField
decl_stmt|;
if|if
condition|(
operator|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|)
operator|&&
operator|(
name|op1
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
operator|)
condition|)
block|{
comment|// Arguments were of form 'op0 = op1'
name|leftField
operator|=
name|op0
expr_stmt|;
name|rightField
operator|=
name|op1
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|op1
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|)
operator|&&
operator|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
operator|)
condition|)
block|{
comment|// Arguments were of form 'op1 = op0'
name|leftField
operator|=
name|op1
expr_stmt|;
name|rightField
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
return|return;
block|}
name|leftKeys
operator|.
name|add
argument_list|(
name|leftField
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|rightKeys
operator|.
name|add
argument_list|(
name|rightField
operator|.
name|getIndex
argument_list|()
operator|-
name|leftFieldCount
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Arguments were not field references, one from each side, so
comment|// we fail. Fall through.
block|}
block|}
comment|// Add this condition to the list of non-equi-join conditions.
if|if
condition|(
operator|!
name|condition
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Adding projection to the inputs of a join to produce the required join    * keys.    *    * @param inputRels      inputs to a join    * @param leftJoinKeys   expressions for LHS of join key    * @param rightJoinKeys  expressions for RHS of join key    * @param systemColCount number of system columns, usually zero. These    *                       columns are projected at the leading edge of the    *                       output row.    * @param leftKeys       on return this contains the join key positions from    *                       the new project rel on the LHS.    * @param rightKeys      on return this contains the join key positions from    *                       the new project rel on the RHS.    * @param outputProj     on return this contains the positions of the original    *                       join output in the (to be formed by caller)    *                       LhxJoinRel. Caller needs to be responsible for adding    *                       projection on the new join output.    */
specifier|public
specifier|static
name|void
name|projectJoinInputs
parameter_list|(
name|RelNode
index|[]
name|inputRels
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
parameter_list|,
name|int
name|systemColCount
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|outputProj
parameter_list|)
block|{
name|RelNode
name|leftRel
init|=
name|inputRels
index|[
literal|0
index|]
decl_stmt|;
name|RelNode
name|rightRel
init|=
name|inputRels
index|[
literal|1
index|]
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|leftRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|int
name|origLeftInputSize
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|origRightInputSize
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newLeftFields
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|newLeftFieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newRightFields
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|newRightFieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|leftKeyCount
init|=
name|leftJoinKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|rightKeyCount
init|=
name|rightJoinKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|systemColCount
condition|;
name|i
operator|++
control|)
block|{
name|outputProj
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origLeftInputSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newLeftFields
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|newLeftFieldNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|outputProj
operator|.
name|add
argument_list|(
name|systemColCount
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|newLeftKeyCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leftKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|leftKey
init|=
name|leftJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftKey
operator|instanceof
name|RexInputRef
condition|)
block|{
comment|// already added to the projected left fields
comment|// only need to remember the index in the join key list
name|leftKeys
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|leftKey
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newLeftFields
operator|.
name|add
argument_list|(
name|leftKey
argument_list|)
expr_stmt|;
name|newLeftFieldNames
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|leftKeys
operator|.
name|add
argument_list|(
name|origLeftInputSize
operator|+
name|newLeftKeyCount
argument_list|)
expr_stmt|;
name|newLeftKeyCount
operator|++
expr_stmt|;
block|}
block|}
name|int
name|leftFieldCount
init|=
name|origLeftInputSize
operator|+
name|newLeftKeyCount
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origRightInputSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newRightFields
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|newRightFieldNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|outputProj
operator|.
name|add
argument_list|(
name|systemColCount
operator|+
name|leftFieldCount
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|newRightKeyCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rightKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|rightKey
init|=
name|rightJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightKey
operator|instanceof
name|RexInputRef
condition|)
block|{
comment|// already added to the projected left fields
comment|// only need to remember the index in the join key list
name|rightKeys
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|rightKey
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newRightFields
operator|.
name|add
argument_list|(
name|rightKey
argument_list|)
expr_stmt|;
name|newRightFieldNames
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|rightKeys
operator|.
name|add
argument_list|(
name|origRightInputSize
operator|+
name|newRightKeyCount
argument_list|)
expr_stmt|;
name|newRightKeyCount
operator|++
expr_stmt|;
block|}
block|}
comment|// added project if need to produce new keys than the original input
comment|// fields
if|if
condition|(
name|newLeftKeyCount
operator|>
literal|0
condition|)
block|{
name|leftRel
operator|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|leftRel
argument_list|,
name|newLeftFields
argument_list|,
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|newLeftFieldNames
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newRightKeyCount
operator|>
literal|0
condition|)
block|{
name|rightRel
operator|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|rightRel
argument_list|,
name|newRightFields
argument_list|,
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|newRightFieldNames
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inputRels
index|[
literal|0
index|]
operator|=
name|leftRel
expr_stmt|;
name|inputRels
index|[
literal|1
index|]
operator|=
name|rightRel
expr_stmt|;
block|}
comment|/**    * Creates a projection on top of a join, if the desired projection is a    * subset of the join columns    *    * @param outputProj desired projection; if null, return original join node    * @param joinRel    the join node    * @return projected join node or the original join if projection is    * unnecessary    */
specifier|public
specifier|static
name|RelNode
name|createProjectJoinRel
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|outputProj
parameter_list|,
name|RelNode
name|joinRel
parameter_list|)
block|{
name|int
name|newProjectOutputSize
init|=
name|outputProj
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|joinOutputFields
init|=
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
comment|// If no projection was passed in, or the number of desired projection
comment|// columns is the same as the number of columns returned from the
comment|// join, then no need to create a projection
if|if
condition|(
operator|(
name|newProjectOutputSize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|newProjectOutputSize
operator|<
name|joinOutputFields
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|newProjects
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|fieldIndex
range|:
name|outputProj
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|joinOutputFields
operator|.
name|get
argument_list|(
name|fieldIndex
argument_list|)
decl_stmt|;
name|newProjects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
operator|(
name|RexNode
operator|)
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|fieldIndex
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Create a project rel on the output of the join.
return|return
name|CalcRel
operator|.
name|createProject
argument_list|(
name|joinRel
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|newProjects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|newProjects
argument_list|)
argument_list|)
return|;
block|}
return|return
name|joinRel
return|;
block|}
specifier|public
specifier|static
name|void
name|registerAbstractRels
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|PullConstantsThroughAggregatesRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|RemoveEmptyRules
operator|.
name|UNION_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|RemoveEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|RemoveEmptyRules
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|RemoveEmptyRules
operator|.
name|SORT_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|RemoveEmptyRules
operator|.
name|AGGREGATE_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|RemoveEmptyRules
operator|.
name|JOIN_LEFT_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|RemoveEmptyRules
operator|.
name|JOIN_RIGHT_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|RemoveEmptyRules
operator|.
name|SORT_FETCH_ZERO_INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|WindowedAggSplitterRule
operator|.
name|PROJECT
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|MergeFilterRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Dumps a plan as a string.    *    * @param header      Header to print before the plan. Ignored if the format    *                    is XML.    * @param rel         Relational expression to explain.    * @param asXml       Whether to format as XML.    * @param detailLevel Detail level.    * @return Plan    */
specifier|public
specifier|static
name|String
name|dumpPlan
parameter_list|(
name|String
name|header
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|boolean
name|asXml
parameter_list|,
name|SqlExplainLevel
name|detailLevel
parameter_list|)
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|header
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
name|RelWriter
name|planWriter
decl_stmt|;
if|if
condition|(
name|asXml
condition|)
block|{
name|planWriter
operator|=
operator|new
name|RelXmlWriter
argument_list|(
name|pw
argument_list|,
name|detailLevel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|planWriter
operator|=
operator|new
name|RelWriterImpl
argument_list|(
name|pw
argument_list|,
name|detailLevel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|rel
operator|.
name|explain
argument_list|(
name|planWriter
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Creates the row type descriptor for the result of a DML operation, which    * is a single column named ROWCOUNT of type BIGINT for INSERT;    * a single column named PLAN for EXPLAIN.    *    * @param kind        Kind of node    * @param typeFactory factory to use for creating type descriptor    * @return created type    */
specifier|public
specifier|static
name|RelDataType
name|createDmlRowType
parameter_list|(
name|SqlKind
name|kind
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|INSERT
case|:
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
literal|"ROWCOUNT"
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|EXPLAIN
case|:
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
literal|"PLAN"
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|kind
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns whether two types are equal using '='.    *    * @param desc1 Description of first type    * @param type1 First type    * @param desc2 Description of second type    * @param type2 Second type    * @param fail  Whether to assert if they are not equal    * @return Whether the types are equal    */
specifier|public
specifier|static
name|boolean
name|eq
parameter_list|(
specifier|final
name|String
name|desc1
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
specifier|final
name|String
name|desc2
parameter_list|,
name|RelDataType
name|type2
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
comment|// if any one of the types is ANY return true
if|if
condition|(
name|type1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
operator|||
name|type2
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|type1
operator|!=
name|type2
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"type mismatch:\n"
operator|+
name|desc1
operator|+
literal|":\n"
operator|+
name|type1
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\n"
operator|+
name|desc2
operator|+
literal|":\n"
operator|+
name|type2
operator|.
name|getFullTypeString
argument_list|()
assert|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether two types are equal using {@link    * #areRowTypesEqual(RelDataType, RelDataType, boolean)}. Both types must    * not be null.    *    * @param desc1 Description of role of first type    * @param type1 First type    * @param desc2 Description of role of second type    * @param type2 Second type    * @param fail  Whether to assert if they are not equal    * @return Whether the types are equal    */
specifier|public
specifier|static
name|boolean
name|equal
parameter_list|(
specifier|final
name|String
name|desc1
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
specifier|final
name|String
name|desc2
parameter_list|,
name|RelDataType
name|type2
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
if|if
condition|(
operator|!
name|areRowTypesEqual
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|,
literal|false
argument_list|)
condition|)
block|{
if|if
condition|(
name|fail
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Type mismatch:\n"
operator|+
name|desc1
operator|+
literal|":\n"
operator|+
name|type1
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\n"
operator|+
name|desc2
operator|+
literal|":\n"
operator|+
name|type2
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Returns whether two relational expressions have the same row-type. */
specifier|public
specifier|static
name|boolean
name|equalType
parameter_list|(
name|String
name|desc0
parameter_list|,
name|RelNode
name|rel0
parameter_list|,
name|String
name|desc1
parameter_list|,
name|RelNode
name|rel1
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
comment|// TODO: change 'equal' to 'eq', which is stronger.
return|return
name|equal
argument_list|(
name|desc0
argument_list|,
name|rel0
operator|.
name|getRowType
argument_list|()
argument_list|,
name|desc1
argument_list|,
name|rel1
operator|.
name|getRowType
argument_list|()
argument_list|,
name|fail
argument_list|)
return|;
block|}
comment|/**    * Returns a translation of the<code>IS DISTINCT FROM</code> (or<code>IS    * NOT DISTINCT FROM</code>) sql operator.    *    * @param neg if false, returns a translation of IS NOT DISTINCT FROM    */
specifier|public
specifier|static
name|RexNode
name|isDistinctFrom
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|x
parameter_list|,
name|RexNode
name|y
parameter_list|,
name|boolean
name|neg
parameter_list|)
block|{
name|RexNode
name|ret
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|x
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
assert|assert
name|y
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
assert|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|xFields
init|=
name|x
operator|.
name|getType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|yFields
init|=
name|y
operator|.
name|getType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|xFields
operator|.
name|size
argument_list|()
operator|==
name|yFields
operator|.
name|size
argument_list|()
assert|;
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|xFields
argument_list|,
name|yFields
argument_list|)
control|)
block|{
name|RelDataTypeField
name|xField
init|=
name|pair
operator|.
name|left
decl_stmt|;
name|RelDataTypeField
name|yField
init|=
name|pair
operator|.
name|right
decl_stmt|;
name|RexNode
name|newX
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|x
argument_list|,
name|xField
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|newY
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|y
argument_list|,
name|yField
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|newCall
init|=
name|isDistinctFromInternal
argument_list|(
name|rexBuilder
argument_list|,
name|newX
argument_list|,
name|newY
argument_list|,
name|neg
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
name|ret
operator|=
name|newCall
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|ret
argument_list|,
name|newCall
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ret
operator|=
name|isDistinctFromInternal
argument_list|(
name|rexBuilder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|neg
argument_list|)
expr_stmt|;
block|}
comment|// The result of IS DISTINCT FROM is NOT NULL because it can
comment|// only return TRUE or FALSE.
name|ret
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|isDistinctFromInternal
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|x
parameter_list|,
name|RexNode
name|y
parameter_list|,
name|boolean
name|neg
parameter_list|)
block|{
name|SqlOperator
name|nullOp
decl_stmt|;
name|SqlOperator
name|eqOp
decl_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|nullOp
operator|=
name|SqlStdOperatorTable
operator|.
name|IS_NULL
expr_stmt|;
name|eqOp
operator|=
name|SqlStdOperatorTable
operator|.
name|EQUALS
expr_stmt|;
block|}
else|else
block|{
name|nullOp
operator|=
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
expr_stmt|;
name|eqOp
operator|=
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
expr_stmt|;
block|}
name|RexNode
index|[]
name|whenThenElse
init|=
block|{
comment|// when x is null
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|x
argument_list|)
block|,
comment|// then return y is [not] null
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|nullOp
argument_list|,
name|y
argument_list|)
block|,
comment|// when y is null
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|y
argument_list|)
block|,
comment|// then return x is [not] null
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|nullOp
argument_list|,
name|x
argument_list|)
block|,
comment|// else return x compared to y
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|eqOp
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
block|}
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|whenThenElse
argument_list|)
return|;
block|}
comment|/**    * Converts a relational expression to a string, showing just basic    * attributes.    */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|toString
argument_list|(
name|rel
argument_list|,
name|SqlExplainLevel
operator|.
name|EXPPLAN_ATTRIBUTES
argument_list|)
return|;
block|}
comment|/**    * Converts a relational expression to a string.    */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
name|SqlExplainLevel
name|detailLevel
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|RelWriter
name|planWriter
init|=
operator|new
name|RelWriterImpl
argument_list|(
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
argument_list|,
name|detailLevel
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|rel
operator|.
name|explain
argument_list|(
name|planWriter
argument_list|)
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Renames a relational expression to make its field names the same as    * another row type. If the row type is already identical, or if the row    * type is too different (the fields are different in number or type) does    * nothing.    *    * @param rel            Relational expression    * @param desiredRowType Desired row type (including desired field names)    * @return Renamed relational expression, or the original expression if    * there is nothing to do or nothing we<em>can</em> do.    */
specifier|public
specifier|static
name|RelNode
name|renameIfNecessary
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelDataType
name|desiredRowType
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|rowType
operator|==
name|desiredRowType
condition|)
block|{
comment|// Nothing to do.
return|return
name|rel
return|;
block|}
assert|assert
operator|!
name|rowType
operator|.
name|equals
argument_list|(
name|desiredRowType
argument_list|)
assert|;
if|if
condition|(
operator|!
name|areRowTypesEqual
argument_list|(
name|rowType
argument_list|,
name|desiredRowType
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// The row types are different ignoring names. Nothing we can do.
return|return
name|rel
return|;
block|}
name|rel
operator|=
name|CalcRel
operator|.
name|createRename
argument_list|(
name|rel
argument_list|,
name|desiredRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rel
return|;
block|}
specifier|public
specifier|static
name|String
name|dumpType
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
specifier|final
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
specifier|final
name|TypeDumper
name|typeDumper
init|=
operator|new
name|TypeDumper
argument_list|(
name|pw
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|typeDumper
operator|.
name|acceptFields
argument_list|(
name|type
operator|.
name|getFieldList
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|typeDumper
operator|.
name|accept
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Decomposes a predicate into a list of expressions that are AND'ed    * together.    *    * @param rexPredicate predicate to be analyzed    * @param rexList      list of decomposed RexNodes    */
specifier|public
specifier|static
name|void
name|decomposeConjunction
parameter_list|(
name|RexNode
name|rexPredicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexList
parameter_list|)
block|{
if|if
condition|(
name|rexPredicate
operator|==
literal|null
operator|||
name|rexPredicate
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|rexPredicate
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|AND
argument_list|)
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexPredicate
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|decomposeConjunction
argument_list|(
name|operand
argument_list|,
name|rexList
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rexList
operator|.
name|add
argument_list|(
name|rexPredicate
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Decomposes a predicate into a list of expressions that are AND'ed    * together, and a list of expressions that are preceded by NOT.    *    *<p>For example, {@code a AND NOT b AND NOT (c and d) AND TRUE AND NOT    * FALSE} returns {@code rexList = [a], notList = [b, c AND d]}.</p>    *    *<p>TRUE and NOT FALSE expressions are ignored. FALSE and NOT TRUE    * expressions are placed on {@code rexList} and {@code notList} as other    * expressions.</p>    *    *<p>For example, {@code a AND TRUE AND NOT TRUE} returns    * {@code rexList = [a], notList = [TRUE]}.</p>    *    * @param rexPredicate predicate to be analyzed    * @param rexList      list of decomposed RexNodes (except those with NOT)    * @param notList      list of decomposed RexNodes that were prefixed NOT    */
specifier|public
specifier|static
name|void
name|decomposeConjunction
parameter_list|(
name|RexNode
name|rexPredicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexList
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|notList
parameter_list|)
block|{
if|if
condition|(
name|rexPredicate
operator|==
literal|null
operator|||
name|rexPredicate
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return;
block|}
switch|switch
condition|(
name|rexPredicate
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexPredicate
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|decomposeConjunction
argument_list|(
name|operand
argument_list|,
name|rexList
argument_list|,
name|notList
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NOT
case|:
specifier|final
name|RexNode
name|e
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rexPredicate
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return;
block|}
name|notList
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rexList
operator|.
name|add
argument_list|(
name|rexPredicate
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/**    * Decomposes a predicate into a list of expressions that are OR'ed    * together.    *    * @param rexPredicate predicate to be analyzed    * @param rexList      list of decomposed RexNodes    */
specifier|public
specifier|static
name|void
name|decomposeDisjunction
parameter_list|(
name|RexNode
name|rexPredicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexList
parameter_list|)
block|{
if|if
condition|(
name|rexPredicate
operator|==
literal|null
operator|||
name|rexPredicate
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|rexPredicate
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|OR
argument_list|)
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexPredicate
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|decomposeDisjunction
argument_list|(
name|operand
argument_list|,
name|rexList
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rexList
operator|.
name|add
argument_list|(
name|rexPredicate
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns a condition decomposed by AND.    *    *<p>For example, {@code conjunctions(TRUE)} returns the empty list;    * {@code conjunctions(FALSE)} returns list {@code {FALSE}}.</p>    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|conjunctions
parameter_list|(
name|RexNode
name|rexPredicate
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|decomposeConjunction
argument_list|(
name|rexPredicate
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|/**    * Returns a condition decomposed by OR.    *    *<p>For example, {@code disjunctions(FALSE)} returns the empty list.</p>    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|disjunctions
parameter_list|(
name|RexNode
name|rexPredicate
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|decomposeDisjunction
argument_list|(
name|rexPredicate
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|/**    * Ands two sets of join filters together, either of which can be null.    *    * @param rexBuilder rexBuilder to create AND expression    * @param left       filter on the left that the right will be AND'd to    * @param right      filter on the right    * @return AND'd filter    *    * @see org.eigenbase.rex.RexUtil#composeConjunction    */
specifier|public
specifier|static
name|RexNode
name|andJoinFilters
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|left
parameter_list|,
name|RexNode
name|right
parameter_list|)
block|{
comment|// don't bother AND'ing in expressions that always evaluate to
comment|// true
if|if
condition|(
operator|(
name|left
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|left
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|right
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|right
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|left
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|left
operator|=
name|right
expr_stmt|;
block|}
comment|// Joins must have some filter
if|if
condition|(
name|left
operator|==
literal|null
condition|)
block|{
name|left
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|left
return|;
block|}
comment|/**    * Adjusts key values in a list by some fixed amount.    *    * @param keys       list of key values    * @param adjustment the amount to adjust the key values by    * @return modified list    */
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|adjustKeys
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|keys
parameter_list|,
name|int
name|adjustment
parameter_list|)
block|{
if|if
condition|(
name|adjustment
operator|==
literal|0
condition|)
block|{
return|return
name|keys
return|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|newKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|key
range|:
name|keys
control|)
block|{
name|newKeys
operator|.
name|add
argument_list|(
name|key
operator|+
name|adjustment
argument_list|)
expr_stmt|;
block|}
return|return
name|newKeys
return|;
block|}
comment|/**    * Classifies filters according to where they should be processed. They    * either stay where they are, are pushed to the join (if they originated    * from above the join), or are pushed to one of the children. Filters that    * are pushed are added to list passed in as input parameters.    *    * @param joinRel      join node    * @param filters      filters to be classified    * @param joinType     join type; determines whether filters can be pushed    *                     into the ON clause    * @param pushLeft     true if filters can be pushed to the left    * @param pushRight    true if filters can be pushed to the right    * @param joinFilters  list of filters to push to the join    * @param leftFilters  list of filters to push to the left child    * @param rightFilters list of filters to push to the right child    * @param smart        Whether to try to strengthen the join type    * @return true if at least one filter was pushed    */
specifier|public
specifier|static
name|boolean
name|classifyFilters
parameter_list|(
name|RelNode
name|joinRel
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|,
name|boolean
name|pushLeft
parameter_list|,
name|boolean
name|pushRight
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilters
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftFilters
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightFilters
parameter_list|,
name|Holder
argument_list|<
name|JoinRelType
argument_list|>
name|joinTypeHolder
parameter_list|,
name|boolean
name|smart
parameter_list|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|JoinRelType
name|oldJoinType
init|=
name|joinType
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|joinFields
init|=
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nTotalFields
init|=
name|joinFields
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nSysFields
init|=
literal|0
decl_stmt|;
comment|// joinRel.getSystemFieldList().size();
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftFields
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nFieldsLeft
init|=
name|leftFields
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightFields
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nFieldsRight
init|=
name|rightFields
operator|.
name|size
argument_list|()
decl_stmt|;
assert|assert
name|nTotalFields
operator|==
name|nSysFields
operator|+
name|nFieldsLeft
operator|+
name|nFieldsRight
assert|;
comment|// set the reference bitmaps for the left and right children
name|BitSet
name|leftBitmap
init|=
name|BitSets
operator|.
name|range
argument_list|(
name|nSysFields
argument_list|,
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|)
decl_stmt|;
name|BitSet
name|rightBitmap
init|=
name|BitSets
operator|.
name|range
argument_list|(
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
name|nTotalFields
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToRemove
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|filter
range|:
name|filters
control|)
block|{
specifier|final
name|InputFinder
name|inputFinder
init|=
name|InputFinder
operator|.
name|analyze
argument_list|(
name|filter
argument_list|)
decl_stmt|;
comment|// REVIEW - are there any expressions that need special handling
comment|// and therefore cannot be pushed?
comment|// filters can be pushed to the left child if the left child
comment|// does not generate NULLs and the only columns referenced in
comment|// the filter originate from the left child
if|if
condition|(
name|pushLeft
operator|&&
name|BitSets
operator|.
name|contains
argument_list|(
name|leftBitmap
argument_list|,
name|inputFinder
operator|.
name|inputBitSet
argument_list|)
condition|)
block|{
comment|// ignore filters that always evaluate to true
if|if
condition|(
operator|!
name|filter
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// adjust the field references in the filter to reflect
comment|// that fields in the left now shift over by the number
comment|// of system fields
specifier|final
name|RexNode
name|shiftedFilter
init|=
name|shiftFilter
argument_list|(
name|nSysFields
argument_list|,
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
operator|-
name|nSysFields
argument_list|,
name|rexBuilder
argument_list|,
name|joinFields
argument_list|,
name|nTotalFields
argument_list|,
name|leftFields
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|leftFilters
operator|.
name|add
argument_list|(
name|shiftedFilter
argument_list|)
expr_stmt|;
block|}
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
comment|// filters can be pushed to the right child if the right child
comment|// does not generate NULLs and the only columns referenced in
comment|// the filter originate from the right child
block|}
if|else if
condition|(
name|pushRight
operator|&&
name|BitSets
operator|.
name|contains
argument_list|(
name|rightBitmap
argument_list|,
name|inputFinder
operator|.
name|inputBitSet
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|filter
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// adjust the field references in the filter to reflect
comment|// that fields in the right now shift over to the left;
comment|// since we never push filters to a NULL generating
comment|// child, the types of the source should match the dest
comment|// so we don't need to explicitly pass the destination
comment|// fields to RexInputConverter
specifier|final
name|RexNode
name|shiftedFilter
init|=
name|shiftFilter
argument_list|(
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
name|nTotalFields
argument_list|,
operator|-
operator|(
name|nSysFields
operator|+
name|nFieldsLeft
operator|)
argument_list|,
name|rexBuilder
argument_list|,
name|joinFields
argument_list|,
name|nTotalFields
argument_list|,
name|rightFields
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|rightFilters
operator|.
name|add
argument_list|(
name|shiftedFilter
argument_list|)
expr_stmt|;
block|}
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
comment|// if the filter can't be pushed to either child and the join
comment|// is an inner join, push them to the join if they originated
comment|// from above the join
block|}
if|else if
condition|(
name|joinType
operator|==
name|JoinRelType
operator|.
name|INNER
condition|)
block|{
name|joinFilters
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
comment|// If the filter will only evaluate to true if fields from the left
comment|// are not null, and the left is null-generating, then we can make the
comment|// left. Similarly for the right.
block|}
else|else
block|{
if|if
condition|(
name|smart
operator|&&
name|joinType
operator|!=
literal|null
operator|&&
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
operator|&&
name|Strong
operator|.
name|is
argument_list|(
name|filter
argument_list|,
name|rightBitmap
argument_list|)
condition|)
block|{
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|joinType
operator|=
name|joinType
operator|.
name|cancelNullsOnRight
argument_list|()
expr_stmt|;
name|joinTypeHolder
operator|.
name|set
argument_list|(
name|joinType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|joinFilters
operator|.
name|contains
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|joinFilters
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|smart
operator|&&
name|joinType
operator|!=
literal|null
operator|&&
name|joinType
operator|.
name|generatesNullsOnLeft
argument_list|()
operator|&&
name|Strong
operator|.
name|is
argument_list|(
name|filter
argument_list|,
name|leftBitmap
argument_list|)
condition|)
block|{
name|filtersToRemove
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|joinType
operator|=
name|joinType
operator|.
name|cancelNullsOnLeft
argument_list|()
expr_stmt|;
name|joinTypeHolder
operator|.
name|set
argument_list|(
name|joinType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|joinFilters
operator|.
name|contains
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|joinFilters
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// else, leave the filter where it is
block|}
comment|// Remove filters after the loop, to prevent concurrent modification.
if|if
condition|(
operator|!
name|filtersToRemove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|filters
operator|.
name|removeAll
argument_list|(
name|filtersToRemove
argument_list|)
expr_stmt|;
block|}
comment|// Did anything change?
return|return
operator|!
name|filtersToRemove
operator|.
name|isEmpty
argument_list|()
operator|||
name|joinType
operator|!=
name|oldJoinType
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|shiftFilter
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|offset
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|joinFields
parameter_list|,
name|int
name|nTotalFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightFields
parameter_list|,
name|RexNode
name|filter
parameter_list|)
block|{
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|nTotalFields
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
block|}
return|return
name|filter
operator|.
name|accept
argument_list|(
operator|new
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|joinFields
argument_list|,
name|rightFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Splits a filter into two lists, depending on whether or not the filter    * only references its child input    *    * @param childBitmap Fields in the child    * @param predicate   filters that will be split    * @param pushable    returns the list of filters that can be pushed to the    *                    child input    * @param notPushable returns the list of filters that cannot be pushed to    *                    the child input    */
specifier|public
specifier|static
name|void
name|splitFilters
parameter_list|(
name|BitSet
name|childBitmap
parameter_list|,
name|RexNode
name|predicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|pushable
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|notPushable
parameter_list|)
block|{
comment|// for each filter, if the filter only references the child inputs,
comment|// then it can be pushed
for|for
control|(
name|RexNode
name|filter
range|:
name|conjunctions
argument_list|(
name|predicate
argument_list|)
control|)
block|{
name|BitSet
name|filterRefs
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|filter
argument_list|)
decl_stmt|;
if|if
condition|(
name|BitSets
operator|.
name|contains
argument_list|(
name|childBitmap
argument_list|,
name|filterRefs
argument_list|)
condition|)
block|{
name|pushable
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notPushable
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Splits a join condition.    *    * @param left      Left input to the join    * @param right     Right input to the join    * @param condition Join condition    * @return Array holding the output; neither element is null. Element 0 is    * the equi-join condition (or TRUE if empty); Element 1 is rest of the    * condition (or TRUE if empty).    *    * @deprecated Will be removed after 0.9.1    */
specifier|public
specifier|static
name|RexNode
index|[]
name|splitJoinCondition
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|RelNode
name|right
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
name|Bug
operator|.
name|upgrade
argument_list|(
literal|"remove after 0.9.1"
argument_list|)
expr_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|left
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|nonEquiCondition
init|=
name|splitJoinCondition
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|condition
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|)
decl_stmt|;
assert|assert
name|nonEquiCondition
operator|!=
literal|null
assert|;
name|RexNode
name|equiCondition
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
decl_stmt|;
assert|assert
name|leftKeys
operator|.
name|size
argument_list|()
operator|==
name|rightKeys
operator|.
name|size
argument_list|()
assert|;
specifier|final
name|int
name|keyCount
init|=
name|leftKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|offset
init|=
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyCount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|leftKey
init|=
name|leftKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|rightKey
init|=
name|rightKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RexNode
name|equi
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|left
argument_list|,
name|leftKey
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|right
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|rightKey
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|rightKey
operator|+
name|offset
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|equiCondition
operator|=
name|equi
expr_stmt|;
block|}
else|else
block|{
name|equiCondition
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|equiCondition
argument_list|,
name|equi
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|RexNode
index|[]
block|{
name|equiCondition
block|,
name|nonEquiCondition
block|}
return|;
block|}
comment|/**    * Determines if a projection and its input reference identical input    * references.    *    * @param project    projection being examined    * @param checkNames if true, also compare that the names of the project    *                   fields and its child fields    * @return if checkNames is false, true is returned if the project and its    * child reference the same input references, regardless of the names of the    * project and child fields; if checkNames is true, then true is returned if    * the input references are the same but the field names are different    */
specifier|public
specifier|static
name|boolean
name|checkProjAndChildInputs
parameter_list|(
name|ProjectRelBase
name|project
parameter_list|,
name|boolean
name|checkNames
parameter_list|)
block|{
if|if
condition|(
operator|!
name|project
operator|.
name|isBoxed
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|n
init|=
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|RelDataType
name|inputType
init|=
name|project
operator|.
name|getChild
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputType
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|n
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|projFields
init|=
name|project
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputFields
init|=
name|inputType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|boolean
name|namesDifferent
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|RexNode
name|exp
init|=
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|exp
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RexInputRef
name|fieldAccess
init|=
operator|(
name|RexInputRef
operator|)
name|exp
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|fieldAccess
operator|.
name|getIndex
argument_list|()
condition|)
block|{
comment|// can't support reorder yet
return|return
literal|false
return|;
block|}
if|if
condition|(
name|checkNames
condition|)
block|{
name|String
name|inputFieldName
init|=
name|inputFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|projFieldName
init|=
name|projFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|projFieldName
operator|.
name|equals
argument_list|(
name|inputFieldName
argument_list|)
condition|)
block|{
name|namesDifferent
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// inputs are the same; return value depends on the checkNames
comment|// parameter
return|return
operator|!
name|checkNames
operator|||
name|namesDifferent
return|;
block|}
comment|/**    * Creates projection expressions reflecting the swapping of a join's input.    *    * @param newJoin   the RelNode corresponding to the join with its inputs    *                  swapped    * @param origJoin  original JoinRel    * @param origOrder if true, create the projection expressions to reflect    *                  the original (pre-swapped) join projection; otherwise,    *                  create the projection to reflect the order of the swapped    *                  projection    * @return array of expression representing the swapped join inputs    */
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|createSwappedJoinExprs
parameter_list|(
name|RelNode
name|newJoin
parameter_list|,
name|JoinRelBase
name|origJoin
parameter_list|,
name|boolean
name|origOrder
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|newJoinFields
init|=
name|newJoin
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|newJoin
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exps
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nFields
init|=
name|origOrder
condition|?
name|origJoin
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
else|:
name|origJoin
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newJoinFields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|source
init|=
operator|(
name|i
operator|+
name|nFields
operator|)
operator|%
name|newJoinFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|RelDataTypeField
name|field
init|=
name|origOrder
condition|?
name|newJoinFields
operator|.
name|get
argument_list|(
name|source
argument_list|)
else|:
name|newJoinFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|exps
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|exps
return|;
block|}
comment|/**    * Converts a filter to the new filter that would result if the filter is    * pushed past a ProjectRel that it currently is referencing.    *    * @param filter  the filter to be converted    * @param projRel project rel underneath the filter    * @return converted filter    */
specifier|public
specifier|static
name|RexNode
name|pushFilterPastProject
parameter_list|(
name|RexNode
name|filter
parameter_list|,
name|ProjectRelBase
name|projRel
parameter_list|)
block|{
comment|// use RexPrograms to merge the filter and ProjectRel into a
comment|// single program so we can convert the FilterRel condition to
comment|// directly reference the ProjectRel's child
name|RexBuilder
name|rexBuilder
init|=
name|projRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexProgram
name|bottomProgram
init|=
name|RexProgram
operator|.
name|create
argument_list|(
name|projRel
operator|.
name|getChild
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|projRel
operator|.
name|getProjects
argument_list|()
argument_list|,
literal|null
argument_list|,
name|projRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|RexProgramBuilder
name|topProgramBuilder
init|=
operator|new
name|RexProgramBuilder
argument_list|(
name|projRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|topProgramBuilder
operator|.
name|addIdentity
argument_list|()
expr_stmt|;
name|topProgramBuilder
operator|.
name|addCondition
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|RexProgram
name|topProgram
init|=
name|topProgramBuilder
operator|.
name|getProgram
argument_list|()
decl_stmt|;
name|RexProgram
name|mergedProgram
init|=
name|RexProgramBuilder
operator|.
name|mergePrograms
argument_list|(
name|topProgram
argument_list|,
name|bottomProgram
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
return|return
name|mergedProgram
operator|.
name|expandLocalRef
argument_list|(
name|mergedProgram
operator|.
name|getCondition
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@link MultiJoinRel} to reflect projection references from    * a {@link ProjectRel} that is on top of the {@link MultiJoinRel}.    *    * @param multiJoin the original MultiJoinRel    * @param project   the ProjectRel on top of the MultiJoinRel    * @return the new MultiJoinRel    */
specifier|public
specifier|static
name|MultiJoinRel
name|projectMultiJoin
parameter_list|(
name|MultiJoinRel
name|multiJoin
parameter_list|,
name|ProjectRel
name|project
parameter_list|)
block|{
comment|// Locate all input references in the projection expressions as well
comment|// the post-join filter.  Since the filter effectively sits in
comment|// between the ProjectRel and the MultiJoinRel, the projection needs
comment|// to include those filter references.
name|BitSet
name|inputRefs
init|=
name|InputFinder
operator|.
name|bits
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getPostJoinFilter
argument_list|()
argument_list|)
decl_stmt|;
comment|// create new copies of the bitmaps
name|List
argument_list|<
name|RelNode
argument_list|>
name|multiJoinInputs
init|=
name|multiJoin
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|BitSet
argument_list|>
name|newProjFields
init|=
operator|new
name|ArrayList
argument_list|<
name|BitSet
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|multiJoinInput
range|:
name|multiJoinInputs
control|)
block|{
name|newProjFields
operator|.
name|add
argument_list|(
operator|new
name|BitSet
argument_list|(
name|multiJoinInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// set the bits found in the expressions
name|int
name|currInput
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|startField
init|=
literal|0
decl_stmt|;
name|int
name|nFields
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|bit
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|inputRefs
argument_list|)
control|)
block|{
while|while
condition|(
name|bit
operator|>=
operator|(
name|startField
operator|+
name|nFields
operator|)
condition|)
block|{
name|startField
operator|+=
name|nFields
expr_stmt|;
name|currInput
operator|++
expr_stmt|;
assert|assert
name|currInput
operator|<
name|multiJoinInputs
operator|.
name|size
argument_list|()
assert|;
name|nFields
operator|=
name|multiJoinInputs
operator|.
name|get
argument_list|(
name|currInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
name|newProjFields
operator|.
name|get
argument_list|(
name|currInput
argument_list|)
operator|.
name|set
argument_list|(
name|bit
operator|-
name|startField
argument_list|)
expr_stmt|;
block|}
comment|// create a new MultiJoinRel containing the new field bitmaps
comment|// for each input
return|return
operator|new
name|MultiJoinRel
argument_list|(
name|multiJoin
operator|.
name|getCluster
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getInputs
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getJoinFilter
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getRowType
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|isFullOuterJoin
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getOuterJoinConditions
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getJoinTypes
argument_list|()
argument_list|,
name|newProjFields
argument_list|,
name|multiJoin
operator|.
name|getJoinFieldRefCountsMap
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getPostJoinFilter
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|RelNode
parameter_list|>
name|T
name|addTrait
parameter_list|(
name|T
name|rel
parameter_list|,
name|RelTrait
name|trait
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|T
operator|)
name|rel
operator|.
name|copy
argument_list|(
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|trait
argument_list|)
argument_list|,
operator|(
name|List
operator|)
name|rel
operator|.
name|getInputs
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a shallow copy of a relational expression with a particular    * input replaced.    */
specifier|public
specifier|static
name|RelNode
name|replaceInput
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|newInput
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|(
name|parent
operator|.
name|getInputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputs
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
operator|==
name|newInput
condition|)
block|{
return|return
name|parent
return|;
block|}
name|inputs
operator|.
name|set
argument_list|(
name|ordinal
argument_list|,
name|newInput
argument_list|)
expr_stmt|;
return|return
name|parent
operator|.
name|copy
argument_list|(
name|parent
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|inputs
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link org.eigenbase.rel.ProjectRel} that projects particular    * fields of its input, according to a mapping.    */
specifier|public
specifier|static
name|ProjectRel
name|project
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|child
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mapping
operator|.
name|getTargetCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|source
init|=
name|mapping
operator|.
name|getSourceOpt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|nodes
operator|.
name|add
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|source
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|names
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ProjectRel
argument_list|(
name|child
operator|.
name|getCluster
argument_list|()
argument_list|,
name|child
argument_list|,
name|nodes
argument_list|,
name|names
argument_list|,
name|ProjectRel
operator|.
name|Flags
operator|.
name|BOXED
argument_list|)
return|;
block|}
comment|/** Returns whether relational expression {@code target} occurs within a    * relational expression {@code ancestor}. */
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|RelNode
name|ancestor
parameter_list|,
specifier|final
name|RelNode
name|target
parameter_list|)
block|{
if|if
condition|(
name|ancestor
operator|==
name|target
condition|)
block|{
comment|// Short-cut common case.
return|return
literal|true
return|;
block|}
try|try
block|{
operator|new
name|RelVisitor
argument_list|()
block|{
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
name|target
condition|)
block|{
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// CHECKSTYLE: IGNORE 1
block|}
operator|.
name|go
argument_list|(
name|ancestor
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/** Within a relational expression {@code query}, replaces occurrences of    * {@code find} with {@code replace}. */
specifier|public
specifier|static
name|RelNode
name|replace
parameter_list|(
name|RelNode
name|query
parameter_list|,
name|RelNode
name|find
parameter_list|,
name|RelNode
name|replace
parameter_list|)
block|{
if|if
condition|(
name|find
operator|==
name|replace
condition|)
block|{
comment|// Short-cut common case.
return|return
name|query
return|;
block|}
assert|assert
name|equalType
argument_list|(
literal|"find"
argument_list|,
name|find
argument_list|,
literal|"replace"
argument_list|,
name|replace
argument_list|,
literal|true
argument_list|)
assert|;
if|if
condition|(
name|query
operator|==
name|find
condition|)
block|{
comment|// Short-cut another common case.
return|return
name|replace
return|;
block|}
return|return
name|replaceRecurse
argument_list|(
name|query
argument_list|,
name|find
argument_list|,
name|replace
argument_list|)
return|;
block|}
comment|/** Helper for {@link #replace}. */
specifier|private
specifier|static
name|RelNode
name|replaceRecurse
parameter_list|(
name|RelNode
name|query
parameter_list|,
name|RelNode
name|find
parameter_list|,
name|RelNode
name|replace
parameter_list|)
block|{
if|if
condition|(
name|query
operator|==
name|find
condition|)
block|{
return|return
name|replace
return|;
block|}
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|query
operator|.
name|getInputs
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|inputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|newInputs
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|inputs
control|)
block|{
name|newInputs
operator|.
name|add
argument_list|(
name|replaceRecurse
argument_list|(
name|input
argument_list|,
name|find
argument_list|,
name|replace
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newInputs
operator|.
name|equals
argument_list|(
name|inputs
argument_list|)
condition|)
block|{
return|return
name|query
operator|.
name|copy
argument_list|(
name|query
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newInputs
argument_list|)
return|;
block|}
block|}
return|return
name|query
return|;
block|}
comment|/** Returns a simple {@link org.eigenbase.relopt.RelOptTable.ToRelContext}. */
specifier|public
specifier|static
name|RelOptTable
operator|.
name|ToRelContext
name|getContext
parameter_list|(
specifier|final
name|RelOptCluster
name|cluster
parameter_list|)
block|{
return|return
operator|new
name|RelOptTable
operator|.
name|ToRelContext
argument_list|()
block|{
specifier|public
name|RelOptCluster
name|getCluster
parameter_list|()
block|{
return|return
name|cluster
return|;
block|}
specifier|public
name|RelNode
name|expandView
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|String
name|queryString
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|schemaPath
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
comment|/** Returns the number of {@link org.eigenbase.rel.JoinRelBase} nodes in a    * tree. */
specifier|public
specifier|static
name|int
name|countJoins
parameter_list|(
name|RelNode
name|rootRel
parameter_list|)
block|{
comment|/** Visitor that counts join nodes. */
class|class
name|JoinCounter
extends|extends
name|RelVisitor
block|{
name|int
name|joinCount
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|JoinRelBase
condition|)
block|{
operator|++
name|joinCount
expr_stmt|;
block|}
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
name|int
name|run
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
name|go
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|joinCount
return|;
block|}
block|}
return|return
operator|new
name|JoinCounter
argument_list|()
operator|.
name|run
argument_list|(
name|rootRel
argument_list|)
return|;
block|}
comment|/** Permutes a record type according to a mapping. */
specifier|public
specifier|static
name|RelDataType
name|permute
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|Mapping
name|mapping
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|Mappings
operator|.
name|apply3
argument_list|(
name|mapping
argument_list|,
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/** Visitor that finds all variables used but not stopped in an expression. */
specifier|private
specifier|static
class|class
name|VariableSetVisitor
extends|extends
name|RelVisitor
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|variables
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// implement RelVisitor
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|p
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
name|super
operator|.
name|visit
argument_list|(
name|p
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|p
operator|.
name|collectVariablesUsed
argument_list|(
name|variables
argument_list|)
expr_stmt|;
comment|// Important! Remove stopped variables AFTER we visit children
comment|// (which what super.visit() does)
name|variables
operator|.
name|removeAll
argument_list|(
name|p
operator|.
name|getVariablesStopped
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Visitor that finds all variables used in an expression. */
specifier|public
specifier|static
class|class
name|VariableUsedVisitor
extends|extends
name|RexShuttle
block|{
specifier|public
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|variables
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|RexNode
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|p
parameter_list|)
block|{
name|variables
operator|.
name|add
argument_list|(
name|p
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
comment|/** Shuttle that finds the set of inputs that are used. */
specifier|public
specifier|static
class|class
name|InputReferencedVisitor
extends|extends
name|RexShuttle
block|{
specifier|public
specifier|final
name|SortedSet
argument_list|<
name|Integer
argument_list|>
name|inputPosReferenced
init|=
operator|new
name|TreeSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|inputPosReferenced
operator|.
name|add
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|inputRef
return|;
block|}
block|}
comment|/** Converts types to descriptive strings. */
specifier|public
specifier|static
class|class
name|TypeDumper
block|{
specifier|private
specifier|final
name|String
name|extraIndent
init|=
literal|"  "
decl_stmt|;
specifier|private
name|String
name|indent
decl_stmt|;
specifier|private
specifier|final
name|PrintWriter
name|pw
decl_stmt|;
name|TypeDumper
parameter_list|(
name|PrintWriter
name|pw
parameter_list|)
block|{
name|this
operator|.
name|pw
operator|=
name|pw
expr_stmt|;
name|this
operator|.
name|indent
operator|=
literal|""
expr_stmt|;
block|}
name|void
name|accept
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|type
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
comment|// RECORD (
comment|//   I INTEGER NOT NULL,
comment|//   J VARCHAR(240))
name|pw
operator|.
name|println
argument_list|(
literal|"RECORD ("
argument_list|)
expr_stmt|;
name|String
name|prevIndent
init|=
name|indent
decl_stmt|;
name|this
operator|.
name|indent
operator|=
name|indent
operator|+
name|extraIndent
expr_stmt|;
name|acceptFields
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|this
operator|.
name|indent
operator|=
name|prevIndent
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|" NOT NULL"
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|type
operator|instanceof
name|MultisetSqlType
condition|)
block|{
comment|// E.g. "INTEGER NOT NULL MULTISET NOT NULL"
name|accept
argument_list|(
name|type
operator|.
name|getComponentType
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" MULTISET"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|" NOT NULL"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// E.g. "INTEGER" E.g. "VARCHAR(240) CHARACTER SET "ISO-8859-1"
comment|// COLLATE "ISO-8859-1$en_US$primary" NOT NULL"
name|pw
operator|.
name|print
argument_list|(
name|type
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|acceptFields
parameter_list|(
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|accept
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Visitor which builds a bitmap of the inputs used by an expression.    */
specifier|public
specifier|static
class|class
name|InputFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|final
name|BitSet
name|inputBitSet
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
decl_stmt|;
specifier|public
name|InputFinder
parameter_list|(
name|BitSet
name|inputBitSet
parameter_list|)
block|{
name|this
argument_list|(
name|inputBitSet
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|InputFinder
parameter_list|(
name|BitSet
name|inputBitSet
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputBitSet
operator|=
name|inputBitSet
expr_stmt|;
name|this
operator|.
name|extraFields
operator|=
name|extraFields
expr_stmt|;
block|}
comment|/** Returns an input finder that has analyzed a given expression. */
specifier|public
specifier|static
name|InputFinder
name|analyze
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
specifier|final
name|InputFinder
name|inputFinder
init|=
operator|new
name|InputFinder
argument_list|(
operator|new
name|BitSet
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|.
name|accept
argument_list|(
name|inputFinder
argument_list|)
expr_stmt|;
return|return
name|inputFinder
return|;
block|}
comment|/**      * Returns a bit set describing the inputs used by an expression.      */
specifier|public
specifier|static
name|BitSet
name|bits
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|analyze
argument_list|(
name|node
argument_list|)
operator|.
name|inputBitSet
return|;
block|}
comment|/**      * Returns a bit set describing the inputs used by a collection of      * project expressions and an optional condition.      */
specifier|public
specifier|static
name|BitSet
name|bits
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|RexNode
name|expr
parameter_list|)
block|{
specifier|final
name|BitSet
name|inputBitSet
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|RexProgram
operator|.
name|apply
argument_list|(
operator|new
name|InputFinder
argument_list|(
name|inputBitSet
argument_list|)
argument_list|,
name|exprs
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|inputBitSet
return|;
block|}
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|inputBitSet
operator|.
name|set
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|RexBuilder
operator|.
name|GET_OPERATOR
condition|)
block|{
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|extraFields
operator|.
name|add
argument_list|(
operator|new
name|RelDataTypeFieldImpl
argument_list|(
operator|(
name|String
operator|)
name|literal
operator|.
name|getValue2
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
comment|/**    * Walks an expression tree, converting the index of RexInputRefs based on    * some adjustment factor.    */
specifier|public
specifier|static
class|class
name|RexInputConverter
extends|extends
name|RexShuttle
block|{
specifier|protected
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
decl_stmt|;
specifier|protected
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|destFields
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftDestFields
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightDestFields
decl_stmt|;
specifier|private
specifier|final
name|int
name|nLeftDestFields
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|adjustments
decl_stmt|;
comment|/**      * @param rexBuilder      builder for creating new RexInputRefs      * @param srcFields       fields where the RexInputRefs originated      *                        from; if null, a new RexInputRef is always      *                        created, referencing the input from destFields      *                        corresponding to its current index value      * @param destFields      fields that the new RexInputRefs will be      *                        referencing; if null, use the type information      *                        from the source field when creating the new      *                        RexInputRef      * @param leftDestFields  in the case where the destination is a join,      *                        these are the fields from the left join input      * @param rightDestFields in the case where the destination is a join,      *                        these are the fields from the right join input      * @param adjustments     the amount to adjust each field by      */
specifier|private
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|destFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftDestFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightDestFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
name|this
operator|.
name|srcFields
operator|=
name|srcFields
expr_stmt|;
name|this
operator|.
name|destFields
operator|=
name|destFields
expr_stmt|;
name|this
operator|.
name|adjustments
operator|=
name|adjustments
expr_stmt|;
name|this
operator|.
name|leftDestFields
operator|=
name|leftDestFields
expr_stmt|;
name|this
operator|.
name|rightDestFields
operator|=
name|rightDestFields
expr_stmt|;
if|if
condition|(
name|leftDestFields
operator|==
literal|null
condition|)
block|{
name|nLeftDestFields
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|destFields
operator|==
literal|null
assert|;
name|nLeftDestFields
operator|=
name|leftDestFields
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftDestFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightDestFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|srcFields
argument_list|,
literal|null
argument_list|,
name|leftDestFields
argument_list|,
name|rightDestFields
argument_list|,
name|adjustments
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|destFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|srcFields
argument_list|,
name|destFields
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|adjustments
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|srcFields
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|adjustments
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|var
parameter_list|)
block|{
name|int
name|srcIndex
init|=
name|var
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|int
name|destIndex
init|=
name|srcIndex
operator|+
name|adjustments
index|[
name|srcIndex
index|]
decl_stmt|;
name|RelDataType
name|type
decl_stmt|;
if|if
condition|(
name|destFields
operator|!=
literal|null
condition|)
block|{
name|type
operator|=
name|destFields
operator|.
name|get
argument_list|(
name|destIndex
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|leftDestFields
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|destIndex
operator|<
name|nLeftDestFields
condition|)
block|{
name|type
operator|=
name|leftDestFields
operator|.
name|get
argument_list|(
name|destIndex
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|rightDestFields
operator|.
name|get
argument_list|(
name|destIndex
operator|-
name|nLeftDestFields
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|type
operator|=
name|srcFields
operator|.
name|get
argument_list|(
name|srcIndex
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|adjustments
index|[
name|srcIndex
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|srcFields
operator|==
literal|null
operator|)
operator|||
operator|(
name|type
operator|!=
name|srcFields
operator|.
name|get
argument_list|(
name|srcIndex
argument_list|)
operator|.
name|getType
argument_list|()
operator|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|type
argument_list|,
name|destIndex
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|var
return|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|// End RelOptUtil.java
end_comment

end_unit

