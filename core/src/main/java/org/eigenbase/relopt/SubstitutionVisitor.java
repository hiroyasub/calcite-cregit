begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|relopt
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|rules
operator|.
name|RemoveTrivialProjectRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|trace
operator|.
name|EigenbaseTrace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|ControlFlowException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|IntList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|prepare
operator|.
name|OptiqPrepareImpl
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|util
operator|.
name|BitSets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * Substitutes part of a tree of relational expressions with another tree.  *  *<p>The call {@code new SubstitutionVisitor(target, query).go(replacement))}  * will return {@code query} with every occurrence of {@code target} replaced  * by {@code replacement}.</p>  *  *<p>The following example shows how {@code SubstitutionVisitor} can be used  * for materialized view recognition.</p>  *  *<ul>  *<li>query = SELECT a, c FROM t WHERE x = 5 AND b = 4</li>  *<li>target = SELECT a, b, c FROM t WHERE x = 5</li>  *<li>replacement = SELECT * FROM mv</li>  *<li>result = SELECT a, c FROM mv WHERE b = 4</li>  *</ul>  *  *<p>Note that {@code result} uses the materialized view table {@code mv} and a  * simplified condition {@code b = 4}.</p>  *  *<p>Uses a bottom-up matching algorithm. Nodes do not need to be identical.  * At each level, returns the residue.</p>  *  *<p>The inputs must only include the core relational operators:  * {@link TableAccessRel},  * {@link FilterRel},  * {@link ProjectRel},  * {@link JoinRel},  * {@link UnionRel},  * {@link AggregateRel}.</p>  */
end_comment

begin_class
specifier|public
class|class
name|SubstitutionVisitor
block|{
specifier|private
specifier|static
specifier|final
name|boolean
name|DEBUG
init|=
name|OptiqPrepareImpl
operator|.
name|DEBUG
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|EigenbaseTrace
operator|.
name|getPlannerTracer
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|UnifyRule
argument_list|>
name|RULES
init|=
name|ImmutableList
operator|.
expr|<
name|UnifyRule
operator|>
name|of
argument_list|(
name|TrivialRule
operator|.
name|INSTANCE
argument_list|,
name|ProjectToProjectUnifyRule
operator|.
name|INSTANCE
argument_list|,
name|FilterToProjectUnifyRule
operator|.
name|INSTANCE
argument_list|,
comment|//          ProjectToFilterUnifyRule.INSTANCE,
name|FilterToFilterUnifyRule
operator|.
name|INSTANCE
argument_list|,
name|AggregateToAggregateUnifyRule
operator|.
name|INSTANCE
argument_list|,
name|AggregateOnProjectToAggregateUnifyRule
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Pair
argument_list|<
name|Class
argument_list|,
name|Class
argument_list|>
argument_list|,
name|List
argument_list|<
name|UnifyRule
argument_list|>
argument_list|>
name|RULE_MAP
init|=
operator|new
name|HashMap
argument_list|<
name|Pair
argument_list|<
name|Class
argument_list|,
name|Class
argument_list|>
argument_list|,
name|List
argument_list|<
name|UnifyRule
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|RelVisitor
name|registrar
init|=
operator|new
name|RelVisitor
argument_list|()
block|{
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parentMap
operator|.
name|put
argument_list|(
name|node
argument_list|,
operator|new
name|Parentage
argument_list|(
name|parent
argument_list|,
name|ordinal
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|query
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|target
decl_stmt|;
comment|/**    * Map from each node in the query and the materialization query    * to its parent.    */
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Parentage
argument_list|>
name|parentMap
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|RelNode
argument_list|,
name|Parentage
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Nodes in {@link #target} that have no children.    */
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|targetLeaves
decl_stmt|;
comment|/**    * Nodes in {@link #query} that have no children.    */
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|queryLeaves
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|replacementMap
init|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|SubstitutionVisitor
parameter_list|(
name|RelNode
name|target
parameter_list|,
name|RelNode
name|query
parameter_list|)
block|{
name|this
operator|.
name|query
operator|=
name|query
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|RelNode
argument_list|>
name|parents
init|=
operator|new
name|HashSet
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|allNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|RelVisitor
name|visitor
init|=
operator|new
name|RelVisitor
argument_list|()
block|{
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
name|parentMap
operator|.
name|put
argument_list|(
name|node
argument_list|,
operator|new
name|Parentage
argument_list|(
name|parent
argument_list|,
name|ordinal
argument_list|)
argument_list|)
expr_stmt|;
name|parents
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|allNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|visitor
operator|.
name|go
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|// Populate the list of leaves in the tree under "target".
comment|// Leaves are all nodes that are not parents.
comment|// For determinism, it is important that the list is in scan order.
name|allNodes
operator|.
name|removeAll
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|targetLeaves
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|allNodes
argument_list|)
expr_stmt|;
name|allNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|visitor
operator|.
name|go
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|allNodes
operator|.
name|removeAll
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|queryLeaves
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|allNodes
argument_list|)
expr_stmt|;
block|}
name|void
name|register
parameter_list|(
name|RelNode
name|result
parameter_list|,
name|RelNode
name|query
parameter_list|)
block|{
name|equiv
argument_list|(
name|result
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|registrar
operator|.
name|go
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
comment|/** Marks that {@code result} is equivalent to (existing node) {@code query},    * and inherits its parentage. */
name|void
name|equiv
parameter_list|(
name|RelNode
name|result
parameter_list|,
name|RelNode
name|query
parameter_list|)
block|{
if|if
condition|(
name|result
operator|!=
name|query
operator|&&
name|parentMap
operator|.
name|get
argument_list|(
name|result
argument_list|)
operator|==
literal|null
condition|)
block|{
specifier|final
name|Parentage
name|parentage
init|=
name|parentMap
operator|.
name|get
argument_list|(
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentage
operator|!=
literal|null
condition|)
block|{
name|parentMap
operator|.
name|put
argument_list|(
name|result
argument_list|,
name|parentage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Maps a condition onto a target.    *    *<p>If condition is stronger than target, returns the residue.    * If it is equal to target, returns the expression that evaluates to    * the constant {@code true}. If it is weaker than target, returns    * {@code null}.</p>    *    *<p>The terms satisfy the relation</p>    *    *<pre>    *     {@code condition = target AND residue}    *</pre>    *    *<p>and {@code residue} must be as weak as possible.</p>    *    *<p>Example #1: condition stronger than target</p>    *<ul>    *<li>condition: x = 1 AND y = 2</li>    *<li>target: x = 1</li>    *<li>residue: y = 2</li>    *</ul>    *    *<p>Note that residue {@code x&gt; 0 AND y = 2} would also satisfy the    * relation {@code condition = target AND residue} but is stronger than    * necessary, so we prefer {@code y = 2}.</p>    *    *<p>Example #2: target weaker than condition (valid, but not currently    * implemented)</p>    *<ul>    *<li>condition: x = 1</li>    *<li>target: x = 1 OR z = 3</li>    *<li>residue: NOT (z = 3)</li>    *</ul>    *    *<p>Example #3: condition and target are equivalent</p>    *<ul>    *<li>condition: x = 1 AND y = 2</li>    *<li>target: y = 2 AND x = 1</li>    *<li>residue: TRUE</li>    *</ul>    *    *<p>Example #4: condition weaker than target</p>    *<ul>    *<li>condition: x = 1</li>    *<li>target: x = 1 AND y = 2</li>    *<li>residue: null (i.e. no match)</li>    *</ul>    *    *<p>There are many other possible examples. It amounts to solving    * whether {@code condition AND NOT target} can ever evaluate to    * true, and therefore is a form of the NP-complete    *<a href="http://en.wikipedia.org/wiki/Satisfiability">Satisfiability</a>    * problem.</p>    */
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
name|RexNode
name|splitFilter
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|RexNode
name|target
parameter_list|)
block|{
comment|// First, try splitting into ORs.
comment|// Given target    c1 OR c2 OR c3 OR c4
comment|// and condition   c2 OR c4
comment|// residue is      NOT c1 AND NOT c3
comment|// Also deals with case target [x] condition [x] yields residue [true].
name|RexNode
name|z
init|=
name|splitOr
argument_list|(
name|rexBuilder
argument_list|,
name|condition
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|z
operator|!=
literal|null
condition|)
block|{
return|return
name|z
return|;
block|}
name|RexNode
name|x
init|=
name|andNot
argument_list|(
name|rexBuilder
argument_list|,
name|target
argument_list|,
name|condition
argument_list|)
decl_stmt|;
if|if
condition|(
name|mayBeSatisfiable
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|RexNode
name|x2
init|=
name|andNot
argument_list|(
name|rexBuilder
argument_list|,
name|condition
argument_list|,
name|target
argument_list|)
decl_stmt|;
return|return
name|simplify
argument_list|(
name|rexBuilder
argument_list|,
name|x2
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|splitOr
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|RexNode
name|target
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|targets
init|=
name|RelOptUtil
operator|.
name|disjunctions
argument_list|(
name|target
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|RelOptUtil
operator|.
name|disjunctions
argument_list|(
name|condition
argument_list|)
control|)
block|{
name|boolean
name|found
init|=
name|removeAll
argument_list|(
name|targets
argument_list|,
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|Lists
operator|.
name|transform
argument_list|(
name|targets
argument_list|,
name|not
argument_list|(
name|rexBuilder
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Returns a function that applies NOT to its argument. */
specifier|public
specifier|static
name|Function
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|not
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
return|return
operator|new
name|Function
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
specifier|public
name|RexNode
name|apply
parameter_list|(
name|RexNode
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|isAlwaysTrue
argument_list|()
condition|?
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
else|:
name|input
operator|.
name|isAlwaysFalse
argument_list|()
condition|?
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
else|:
name|input
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|NOT
condition|?
operator|(
operator|(
name|RexCall
operator|)
name|input
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
else|:
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|input
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Removes all expressions from a list that are equivalent to a given    * expression. Returns whether any were removed. */
specifier|private
specifier|static
name|boolean
name|removeAll
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|targets
parameter_list|,
name|RexNode
name|e
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|RexNode
argument_list|>
name|iterator
init|=
name|targets
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RexNode
name|next
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|equivalent
argument_list|(
name|next
argument_list|,
name|e
argument_list|)
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|count
operator|>
literal|0
return|;
block|}
comment|/** Returns whether two expressions are equivalent. */
specifier|private
specifier|static
name|boolean
name|equivalent
parameter_list|(
name|RexNode
name|e1
parameter_list|,
name|RexNode
name|e2
parameter_list|)
block|{
comment|// TODO: make broader;
comment|// 1. 'x = y' should be equivalent to 'y = x'.
comment|// 2. 'c2 and c1' should be equivalent to 'c1 and c2'.
return|return
name|e1
operator|==
name|e2
operator|||
name|e1
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|e2
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns whether a boolean expression ever returns true.    *    *<p>This method may give false positives. For instance, it will say    * that {@code x = 5 AND x> 10} is satisfiable, because at present it    * cannot prove that it is not.</p>    */
specifier|public
specifier|static
name|boolean
name|mayBeSatisfiable
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
comment|// Example:
comment|//  e: x = 1 AND y = 2 AND z = 3 AND NOT (x = 1 AND y = 2)
comment|//  disjunctions: {x = 1, y = 2, z = 3}
comment|//  notDisjunctions: {x = 1 AND y = 2}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|disjunctions
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|notDisjunctions
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|RelOptUtil
operator|.
name|decomposeConjunction
argument_list|(
name|e
argument_list|,
name|disjunctions
argument_list|,
name|notDisjunctions
argument_list|)
expr_stmt|;
comment|// If there is a single FALSE or NOT TRUE, the whole expression is
comment|// always false.
for|for
control|(
name|RexNode
name|disjunction
range|:
name|disjunctions
control|)
block|{
switch|switch
condition|(
name|disjunction
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LITERAL
case|:
if|if
condition|(
operator|!
name|RexLiteral
operator|.
name|booleanValue
argument_list|(
name|disjunction
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
for|for
control|(
name|RexNode
name|disjunction
range|:
name|notDisjunctions
control|)
block|{
switch|switch
condition|(
name|disjunction
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LITERAL
case|:
if|if
condition|(
name|RexLiteral
operator|.
name|booleanValue
argument_list|(
name|disjunction
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// If one of the not-disjunctions is a disjunction that is wholly
comment|// contained in the disjunctions list, the expression is not
comment|// satisfiable.
comment|//
comment|// Example #1. x AND y AND z AND NOT (x AND y)  - not satisfiable
comment|// Example #2. x AND y AND NOT (x AND y)        - not satisfiable
comment|// Example #3. x AND y AND NOT (x AND y AND z)  - may be satisfiable
for|for
control|(
name|RexNode
name|notDisjunction
range|:
name|notDisjunctions
control|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|disjunctions2
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|notDisjunction
argument_list|)
decl_stmt|;
if|if
condition|(
name|disjunctions
operator|.
name|containsAll
argument_list|(
name|disjunctions2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Simplifies a boolean expression.    *    *<p>In particular:</p>    *<ul>    *<li>{@code simplify(x = 1 AND y = 2 AND NOT x = 1)}    * returns {@code y = 2}</li>    *<li>{@code simplify(x = 1 AND FALSE)}    * returns {@code FALSE}</li>    *</ul>    */
specifier|public
specifier|static
name|RexNode
name|simplify
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|disjunctions
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|e
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|notDisjunctions
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|disjunctions
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexNode
name|disjunction
init|=
name|disjunctions
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|SqlKind
name|kind
init|=
name|disjunction
operator|.
name|getKind
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|NOT
case|:
name|notDisjunctions
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|disjunction
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|disjunctions
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
break|break;
case|case
name|LITERAL
case|:
if|if
condition|(
operator|!
name|RexLiteral
operator|.
name|booleanValue
argument_list|(
name|disjunction
argument_list|)
condition|)
block|{
return|return
name|disjunction
return|;
comment|// false
block|}
else|else
block|{
name|disjunctions
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|disjunctions
operator|.
name|isEmpty
argument_list|()
operator|&&
name|notDisjunctions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|// If one of the not-disjunctions is a disjunction that is wholly
comment|// contained in the disjunctions list, the expression is not
comment|// satisfiable.
comment|//
comment|// Example #1. x AND y AND z AND NOT (x AND y)  - not satisfiable
comment|// Example #2. x AND y AND NOT (x AND y)        - not satisfiable
comment|// Example #3. x AND y AND NOT (x AND y AND z)  - may be satisfiable
for|for
control|(
name|RexNode
name|notDisjunction
range|:
name|notDisjunctions
control|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|disjunctions2
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|notDisjunction
argument_list|)
decl_stmt|;
if|if
condition|(
name|disjunctions
operator|.
name|containsAll
argument_list|(
name|disjunctions2
argument_list|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
block|}
comment|// Add the NOT disjunctions back in.
for|for
control|(
name|RexNode
name|notDisjunction
range|:
name|notDisjunctions
control|)
block|{
name|disjunctions
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|notDisjunction
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|disjunctions
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Creates the expression {@code e1 AND NOT e2}.    */
specifier|static
name|RexNode
name|andNot
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e1
parameter_list|,
name|RexNode
name|e2
parameter_list|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|e1
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|e2
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|RelNode
name|go
parameter_list|(
name|RelNode
name|replacement
parameter_list|)
block|{
assert|assert
name|RelOptUtil
operator|.
name|equalType
argument_list|(
literal|"target"
argument_list|,
name|target
argument_list|,
literal|"replacement"
argument_list|,
name|replacement
argument_list|,
literal|true
argument_list|)
assert|;
name|replacementMap
operator|.
name|put
argument_list|(
name|target
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
specifier|final
name|UnifyResult
name|unifyResult
init|=
name|matchRecurse
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|unifyResult
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|RelNode
name|node0
init|=
name|unifyResult
operator|.
name|result
decl_stmt|;
name|RelNode
name|node
init|=
name|replaceAncestors
argument_list|(
name|node0
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Convert: query:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|query
argument_list|)
operator|+
literal|"\nunify.query:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|unifyResult
operator|.
name|call
operator|.
name|query
argument_list|)
operator|+
literal|"\nunify.result:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|unifyResult
operator|.
name|result
argument_list|)
operator|+
literal|"\nunify.target:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|unifyResult
operator|.
name|call
operator|.
name|target
argument_list|)
operator|+
literal|"\nnode0:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|node0
argument_list|)
operator|+
literal|"\nnode:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
specifier|private
name|RelNode
name|replaceAncestors
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|Parentage
name|parentage
init|=
name|parentMap
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentage
operator|==
literal|null
operator|||
name|parentage
operator|.
name|parent
operator|==
literal|null
condition|)
block|{
return|return
name|node
return|;
block|}
name|node
operator|=
name|RelOptUtil
operator|.
name|replaceInput
argument_list|(
name|parentage
operator|.
name|parent
argument_list|,
name|parentage
operator|.
name|ordinal
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|UnifyResult
name|matchRecurse
parameter_list|(
name|RelNode
name|target
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|targetInputs
init|=
name|target
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|RelNode
name|queryParent
init|=
literal|null
decl_stmt|;
for|for
control|(
name|RelNode
name|targetInput
range|:
name|targetInputs
control|)
block|{
name|UnifyResult
name|unifyResult
init|=
name|matchRecurse
argument_list|(
name|targetInput
argument_list|)
decl_stmt|;
if|if
condition|(
name|unifyResult
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Parentage
name|parentage
init|=
name|parentMap
operator|.
name|get
argument_list|(
name|unifyResult
operator|.
name|call
operator|.
name|query
argument_list|)
decl_stmt|;
name|parentMap
operator|.
name|put
argument_list|(
name|unifyResult
operator|.
name|result
argument_list|,
name|parentage
argument_list|)
expr_stmt|;
name|queryParent
operator|=
name|RelOptUtil
operator|.
name|replaceInput
argument_list|(
name|parentage
operator|.
name|parent
argument_list|,
name|parentage
operator|.
name|ordinal
argument_list|,
name|unifyResult
operator|.
name|result
argument_list|)
expr_stmt|;
name|equiv
argument_list|(
name|queryParent
argument_list|,
name|parentage
operator|.
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetInputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|RelNode
name|queryLeaf
range|:
name|queryLeaves
control|)
block|{
for|for
control|(
name|UnifyRule
name|rule
range|:
name|applicableRules
argument_list|(
name|queryLeaf
argument_list|,
name|target
argument_list|)
control|)
block|{
specifier|final
name|UnifyResult
name|x
init|=
name|apply
argument_list|(
name|rule
argument_list|,
name|queryLeaf
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Rule: "
operator|+
name|rule
operator|+
literal|"\nQuery:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|queryParent
argument_list|)
operator|+
operator|(
name|x
operator|.
name|call
operator|.
name|query
operator|!=
name|queryParent
condition|?
literal|"\nQuery (original):\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|queryParent
argument_list|)
else|:
literal|""
operator|)
operator|+
literal|"\nTarget:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|target
argument_list|)
operator|+
literal|"\nResult:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|x
operator|.
name|result
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|UnifyRule
name|rule
range|:
name|applicableRules
argument_list|(
name|queryParent
argument_list|,
name|target
argument_list|)
control|)
block|{
specifier|final
name|UnifyResult
name|x
init|=
name|apply
argument_list|(
name|rule
argument_list|,
name|queryParent
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Rule: "
operator|+
name|rule
operator|+
literal|"\nQuery:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|queryParent
argument_list|)
operator|+
operator|(
name|x
operator|.
name|call
operator|.
name|query
operator|!=
name|queryParent
condition|?
literal|"\nQuery (original):\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|queryParent
argument_list|)
else|:
literal|""
operator|)
operator|+
literal|"\nTarget:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|target
argument_list|)
operator|+
literal|"\nResult:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|x
operator|.
name|result
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
block|}
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Unify failed:"
operator|+
literal|"\nQuery:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|queryParent
argument_list|)
operator|+
literal|"\nTarget:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|target
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRule
name|rule
parameter_list|,
name|RelNode
name|query
parameter_list|,
name|RelNode
name|target
parameter_list|)
block|{
specifier|final
name|UnifyRuleCall
name|call
init|=
operator|new
name|UnifyRuleCall
argument_list|(
name|rule
argument_list|,
name|query
argument_list|,
name|target
argument_list|)
decl_stmt|;
return|return
name|rule
operator|.
name|apply
argument_list|(
name|call
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|UnifyRule
argument_list|>
name|applicableRules
parameter_list|(
name|RelNode
name|query
parameter_list|,
name|RelNode
name|target
parameter_list|)
block|{
specifier|final
name|Class
name|queryClass
init|=
name|query
operator|.
name|getClass
argument_list|()
decl_stmt|;
specifier|final
name|Class
name|targetClass
init|=
name|target
operator|.
name|getClass
argument_list|()
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|Class
argument_list|,
name|Class
argument_list|>
name|key
init|=
name|Pair
operator|.
name|of
argument_list|(
name|queryClass
argument_list|,
name|targetClass
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|UnifyRule
argument_list|>
name|list
init|=
name|RULE_MAP
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|UnifyRule
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|UnifyRule
name|rule
range|:
name|RULES
control|)
block|{
comment|//noinspection unchecked
if|if
condition|(
name|rule
operator|.
name|mightMatch
argument_list|(
name|queryClass
argument_list|,
name|targetClass
argument_list|)
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
name|list
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
name|RULE_MAP
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/** Exception thrown to exit a matcher. Not really an error. */
specifier|private
specifier|static
class|class
name|MatchFailed
extends|extends
name|ControlFlowException
block|{
specifier|static
specifier|final
name|MatchFailed
name|INSTANCE
init|=
operator|new
name|MatchFailed
argument_list|()
decl_stmt|;
block|}
comment|/** Rule that attempts to match a query relational expression    * against a target relational expression.    *    *<p>The rule declares the query and target types; this allows the    * engine to fire only a few rules in a given context.</p>    */
specifier|private
interface|interface
name|UnifyRule
block|{
comment|/**      *<p>Applies this rule to a particular node in a query. The goal is      * to convert {@code query} into {@code target}. Before the rule is      * invoked, Optiq has made sure that query's children are equivalent      * to target's children.      *      *<p>There are 3 possible outcomes:</p>      *      *<ul>      *      *<li>{@code query} already exactly matches {@code target}; returns      * {@code target}</li>      *      *<li>{@code query} is sufficiently close to a match for      * {@code target}; returns {@code target}</li>      *      *<li>{@code query} cannot be made to match {@code target}; returns      * null</li>      *      *</ul>      *      *<p>REVIEW: Is possible that we match query PLUS one or more of its      * ancestors?</p>      *      * @param call Input parameters      */
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
function_decl|;
name|boolean
name|mightMatch
parameter_list|(
name|Class
name|queryClass
parameter_list|,
name|Class
name|targetClass
parameter_list|)
function_decl|;
block|}
comment|/**    * Arguments to an application of a {@link UnifyRule}.    */
specifier|private
class|class
name|UnifyRuleCall
block|{
specifier|final
name|UnifyRule
name|rule
decl_stmt|;
specifier|final
name|RelNode
name|query
decl_stmt|;
specifier|final
name|RelNode
name|target
decl_stmt|;
specifier|public
name|UnifyRuleCall
parameter_list|(
name|UnifyRule
name|rule
parameter_list|,
name|RelNode
name|query
parameter_list|,
name|RelNode
name|target
parameter_list|)
block|{
name|this
operator|.
name|rule
operator|=
name|rule
expr_stmt|;
name|this
operator|.
name|query
operator|=
name|query
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
block|}
comment|/** Returns the parent of a node, which child it is, and a bitmap of which      * columns are used by the parent. */
specifier|public
name|Parentage
name|parent
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
return|return
name|parentMap
operator|.
name|get
argument_list|(
name|node
argument_list|)
return|;
block|}
name|UnifyResult
name|result
parameter_list|(
name|RelNode
name|result
parameter_list|)
block|{
assert|assert
name|RelOptUtil
operator|.
name|contains
argument_list|(
name|result
argument_list|,
name|target
argument_list|)
assert|;
assert|assert
name|RelOptUtil
operator|.
name|equalType
argument_list|(
literal|"result"
argument_list|,
name|result
argument_list|,
literal|"query"
argument_list|,
name|query
argument_list|,
literal|true
argument_list|)
assert|;
name|equiv
argument_list|(
name|result
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|RelNode
name|replace
init|=
name|replacementMap
operator|.
name|get
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|replace
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|RelOptUtil
operator|.
name|replace
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|replace
argument_list|)
expr_stmt|;
block|}
name|register
argument_list|(
name|result
argument_list|,
name|query
argument_list|)
expr_stmt|;
return|return
operator|new
name|UnifyResult
argument_list|(
name|this
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|/**      * Creates a {@link UnifyRuleCall} based on the parent of {@code query}.      */
specifier|public
name|UnifyRuleCall
name|create
parameter_list|(
name|RelNode
name|query
parameter_list|)
block|{
return|return
operator|new
name|UnifyRuleCall
argument_list|(
name|rule
argument_list|,
name|query
argument_list|,
name|target
argument_list|)
return|;
block|}
block|}
comment|/**    * Result of an application of a {@link UnifyRule} indicating that the    * rule successfully matched {@code query} against {@code target} and    * generated a {@code result} that is equivalent to {@code query} and    * contains {@code target}.    */
specifier|private
specifier|static
class|class
name|UnifyResult
block|{
specifier|private
specifier|final
name|UnifyRuleCall
name|call
decl_stmt|;
comment|// equivalent to "query", contains "result"
specifier|private
specifier|final
name|RelNode
name|result
decl_stmt|;
name|UnifyResult
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|,
name|RelNode
name|result
parameter_list|)
block|{
name|this
operator|.
name|call
operator|=
name|call
expr_stmt|;
assert|assert
name|RelOptUtil
operator|.
name|equalType
argument_list|(
literal|"query"
argument_list|,
name|call
operator|.
name|query
argument_list|,
literal|"result"
argument_list|,
name|result
argument_list|,
literal|true
argument_list|)
assert|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
block|}
block|}
comment|/** Abstract base class for implementing {@link UnifyRule}. */
specifier|private
specifier|abstract
specifier|static
class|class
name|AbstractUnifyRule
implements|implements
name|UnifyRule
block|{
specifier|private
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|queryClass
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|targetClass
decl_stmt|;
specifier|public
name|AbstractUnifyRule
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|queryClass
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|targetClass
parameter_list|)
block|{
name|this
operator|.
name|queryClass
operator|=
name|queryClass
expr_stmt|;
name|this
operator|.
name|targetClass
operator|=
name|targetClass
expr_stmt|;
block|}
specifier|public
name|boolean
name|mightMatch
parameter_list|(
name|Class
name|queryClass
parameter_list|,
name|Class
name|targetClass
parameter_list|)
block|{
return|return
name|this
operator|.
name|queryClass
operator|.
name|isAssignableFrom
argument_list|(
name|queryClass
argument_list|)
operator|&&
name|this
operator|.
name|targetClass
operator|.
name|isAssignableFrom
argument_list|(
name|targetClass
argument_list|)
return|;
block|}
block|}
comment|/** Implementation of {@link UnifyRule} that matches if the query is already    * equal to the target (using {@code ==}).    *    *<p>Matches scans to the same table, because these will be canonized to    * the same {@link org.eigenbase.rel.TableAccessRel} instance.</p>    */
specifier|private
specifier|static
class|class
name|TrivialRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|private
specifier|static
specifier|final
name|TrivialRule
name|INSTANCE
init|=
operator|new
name|TrivialRule
argument_list|()
decl_stmt|;
specifier|private
name|TrivialRule
parameter_list|()
block|{
name|super
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
name|RelNode
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|query
operator|==
name|call
operator|.
name|target
condition|)
block|{
return|return
name|call
operator|.
name|result
argument_list|(
name|call
operator|.
name|query
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/** Implementation of {@link UnifyRule} that matches {@link ProjectRel}. */
specifier|private
specifier|static
class|class
name|ProjectToProjectUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|ProjectToProjectUnifyRule
name|INSTANCE
init|=
operator|new
name|ProjectToProjectUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|ProjectToProjectUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|ProjectRel
operator|.
name|class
argument_list|,
name|ProjectRel
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|ProjectRel
name|target
init|=
operator|(
name|ProjectRel
operator|)
name|call
operator|.
name|target
decl_stmt|;
specifier|final
name|ProjectRel
name|query
init|=
operator|(
name|ProjectRel
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|RexShuttle
name|shuttle
init|=
name|getRexShuttle
argument_list|(
name|target
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newProjects
decl_stmt|;
try|try
block|{
name|newProjects
operator|=
name|shuttle
operator|.
name|apply
argument_list|(
name|query
operator|.
name|getProjects
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MatchFailed
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|ProjectRel
name|newProject
init|=
operator|new
name|ProjectRel
argument_list|(
name|target
operator|.
name|getCluster
argument_list|()
argument_list|,
name|target
operator|.
name|getCluster
argument_list|()
operator|.
name|traitSetOf
argument_list|(
name|query
operator|.
name|getCollationList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|RelCollationImpl
operator|.
name|EMPTY
else|:
name|query
operator|.
name|getCollationList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|newProjects
argument_list|,
name|query
operator|.
name|getRowType
argument_list|()
argument_list|,
name|query
operator|.
name|getFlags
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newProject2
init|=
name|RemoveTrivialProjectRule
operator|.
name|strip
argument_list|(
name|newProject
argument_list|)
decl_stmt|;
return|return
name|call
operator|.
name|result
argument_list|(
name|newProject2
argument_list|)
return|;
block|}
block|}
comment|/** Implementation of {@link UnifyRule} that matches a {@link FilterRel}    * to a {@link ProjectRel}. */
specifier|private
specifier|static
class|class
name|FilterToProjectUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|FilterToProjectUnifyRule
name|INSTANCE
init|=
operator|new
name|FilterToProjectUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|FilterToProjectUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|FilterRel
operator|.
name|class
argument_list|,
name|ProjectRel
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
comment|// Child of projectTarget is equivalent to child of filterQuery.
try|try
block|{
comment|// TODO: make sure that constants are ok
specifier|final
name|ProjectRel
name|target
init|=
operator|(
name|ProjectRel
operator|)
name|call
operator|.
name|target
decl_stmt|;
specifier|final
name|RexShuttle
name|shuttle
init|=
name|getRexShuttle
argument_list|(
name|target
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|newCondition
decl_stmt|;
specifier|final
name|FilterRel
name|query
init|=
operator|(
name|FilterRel
operator|)
name|call
operator|.
name|query
decl_stmt|;
try|try
block|{
name|newCondition
operator|=
name|query
operator|.
name|getCondition
argument_list|()
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MatchFailed
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|FilterRel
name|newFilter
init|=
operator|new
name|FilterRel
argument_list|(
name|query
operator|.
name|getCluster
argument_list|()
argument_list|,
name|target
argument_list|,
name|newCondition
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|inverse
init|=
name|invert
argument_list|(
name|query
argument_list|,
name|newFilter
argument_list|,
name|target
argument_list|)
decl_stmt|;
return|return
name|call
operator|.
name|result
argument_list|(
name|inverse
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|MatchFailed
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|RelNode
name|invert
parameter_list|(
name|RelNode
name|model
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|ProjectRel
name|project
parameter_list|)
block|{
if|if
condition|(
name|LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINER
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|finer
argument_list|(
literal|"SubstitutionVisitor: invert:\n"
operator|+
literal|"model: "
operator|+
name|model
operator|+
literal|"\n"
operator|+
literal|"input: "
operator|+
name|input
operator|+
literal|"\n"
operator|+
literal|"project: "
operator|+
name|project
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|model
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|model
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|exprList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeZeroLiteral
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Ord
argument_list|<
name|RexNode
argument_list|>
name|expr
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|expr
operator|.
name|e
operator|instanceof
name|RexInputRef
condition|)
block|{
specifier|final
name|int
name|target
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|expr
operator|.
name|e
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|exprList
operator|.
name|set
argument_list|(
name|expr
operator|.
name|i
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|input
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|ProjectRel
argument_list|(
name|model
operator|.
name|getCluster
argument_list|()
argument_list|,
name|model
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|input
argument_list|,
name|exprList
argument_list|,
name|model
operator|.
name|getRowType
argument_list|()
argument_list|,
name|ProjectRelBase
operator|.
name|Flags
operator|.
name|BOXED
argument_list|)
return|;
block|}
block|}
comment|/** Implementation of {@link UnifyRule} that matches a {@link FilterRel}. */
specifier|private
specifier|static
class|class
name|FilterToFilterUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|FilterToFilterUnifyRule
name|INSTANCE
init|=
operator|new
name|FilterToFilterUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|FilterToFilterUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|FilterRel
operator|.
name|class
argument_list|,
name|FilterRel
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
comment|// in.query can be rewritten in terms of in.target if its condition
comment|// is weaker. For example:
comment|//   query: SELECT * FROM t WHERE x = 1 AND y = 2
comment|//   target: SELECT * FROM t WHERE x = 1
comment|// transforms to
comment|//   result: SELECT * FROM (target) WHERE y = 2
specifier|final
name|FilterRel
name|query
init|=
operator|(
name|FilterRel
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|FilterRel
name|target
init|=
operator|(
name|FilterRel
operator|)
name|call
operator|.
name|target
decl_stmt|;
specifier|final
name|FilterRel
name|newFilter
init|=
name|createFilter
argument_list|(
name|query
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFilter
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|call
operator|.
name|result
argument_list|(
name|newFilter
argument_list|)
return|;
block|}
name|FilterRel
name|createFilter
parameter_list|(
name|FilterRel
name|query
parameter_list|,
name|FilterRel
name|target
parameter_list|)
block|{
specifier|final
name|RelOptCluster
name|cluster
init|=
name|query
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|newCondition
init|=
name|splitFilter
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|query
operator|.
name|getCondition
argument_list|()
argument_list|,
name|target
operator|.
name|getCondition
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newCondition
operator|==
literal|null
condition|)
block|{
comment|// Could not map query onto target.
return|return
literal|null
return|;
block|}
if|if
condition|(
name|newCondition
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return
name|target
return|;
block|}
return|return
operator|new
name|FilterRel
argument_list|(
name|cluster
argument_list|,
name|target
argument_list|,
name|newCondition
argument_list|)
return|;
block|}
block|}
comment|/** Implementation of {@link UnifyRule} that matches a {@link ProjectRel} to    * a {@link FilterRel}. */
specifier|private
specifier|static
class|class
name|ProjectToFilterUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|ProjectToFilterUnifyRule
name|INSTANCE
init|=
operator|new
name|ProjectToFilterUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|ProjectToFilterUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|ProjectRel
operator|.
name|class
argument_list|,
name|FilterRel
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Parentage
name|queryParent
init|=
name|call
operator|.
name|parent
argument_list|(
name|call
operator|.
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryParent
operator|.
name|parent
operator|instanceof
name|FilterRel
condition|)
block|{
specifier|final
name|UnifyRuleCall
name|in2
init|=
name|call
operator|.
name|create
argument_list|(
name|queryParent
operator|.
name|parent
argument_list|)
decl_stmt|;
specifier|final
name|FilterRel
name|query
init|=
operator|(
name|FilterRel
operator|)
name|in2
operator|.
name|query
decl_stmt|;
specifier|final
name|FilterRel
name|target
init|=
operator|(
name|FilterRel
operator|)
name|in2
operator|.
name|target
decl_stmt|;
specifier|final
name|FilterRel
name|newFilter
init|=
name|FilterToFilterUnifyRule
operator|.
name|INSTANCE
operator|.
name|createFilter
argument_list|(
name|query
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFilter
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|in2
operator|.
name|result
argument_list|(
name|call
operator|.
name|query
operator|.
name|copy
argument_list|(
name|call
operator|.
name|query
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RelNode
operator|>
name|of
argument_list|(
name|newFilter
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/** Implementation of {@link UnifyRule} that matches a {@link AggregateRel} to    * a {@link AggregateRel}, provided that they have the same child. */
specifier|private
specifier|static
class|class
name|AggregateToAggregateUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|AggregateToAggregateUnifyRule
name|INSTANCE
init|=
operator|new
name|AggregateToAggregateUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|AggregateToAggregateUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|AggregateRel
operator|.
name|class
argument_list|,
name|AggregateRel
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|AggregateRel
name|query
init|=
operator|(
name|AggregateRel
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|AggregateRel
name|target
init|=
operator|(
name|AggregateRel
operator|)
name|call
operator|.
name|target
decl_stmt|;
assert|assert
name|query
operator|!=
name|target
assert|;
if|if
condition|(
name|query
operator|.
name|getChild
argument_list|()
operator|!=
name|target
operator|.
name|getChild
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// in.query can be rewritten in terms of in.target if its groupSet is
comment|// a subset, and its aggCalls are a superset. For example:
comment|//   query: SELECT x, COUNT(b) FROM t GROUP BY x
comment|//   target: SELECT x, y, SUM(a) AS s, COUNT(b) AS cb FROM t GROUP BY x, y
comment|// transforms to
comment|//   result: SELECT x, SUM(cb) FROM (target) GROUP BY x
if|if
condition|(
operator|!
name|BitSets
operator|.
name|contains
argument_list|(
name|target
operator|.
name|getGroupSet
argument_list|()
argument_list|,
name|query
operator|.
name|getGroupSet
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|RelNode
name|result
init|=
name|unifyAggregates
argument_list|(
name|query
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|call
operator|.
name|result
argument_list|(
name|result
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|AggregateRel
name|permute
parameter_list|(
name|AggregateRel
name|aggregate
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Mapping
name|mapping
parameter_list|)
block|{
name|BitSet
name|groupSet
init|=
name|Mappings
operator|.
name|apply
argument_list|(
name|mapping
argument_list|,
name|aggregate
operator|.
name|getGroupSet
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
init|=
name|apply
argument_list|(
name|mapping
argument_list|,
name|aggregate
operator|.
name|getAggCallList
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|aggregate
operator|.
name|copy
argument_list|(
name|aggregate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|input
argument_list|,
name|groupSet
argument_list|,
name|aggregateCalls
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|apply
parameter_list|(
specifier|final
name|Mapping
name|mapping
parameter_list|,
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCallList
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
name|aggCallList
argument_list|,
operator|new
name|Function
argument_list|<
name|AggregateCall
argument_list|,
name|AggregateCall
argument_list|>
argument_list|()
block|{
specifier|public
name|AggregateCall
name|apply
parameter_list|(
name|AggregateCall
name|call
parameter_list|)
block|{
return|return
operator|new
name|AggregateCall
argument_list|(
name|call
operator|.
name|getAggregation
argument_list|()
argument_list|,
name|call
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|Mappings
operator|.
name|apply2
argument_list|(
name|mapping
argument_list|,
name|call
operator|.
name|getArgList
argument_list|()
argument_list|)
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|call
operator|.
name|name
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RelNode
name|unifyAggregates
parameter_list|(
name|AggregateRel
name|query
parameter_list|,
name|AggregateRel
name|target
parameter_list|)
block|{
name|RelNode
name|result
decl_stmt|;
if|if
condition|(
name|query
operator|.
name|getGroupSet
argument_list|()
operator|.
name|equals
argument_list|(
name|target
operator|.
name|getGroupSet
argument_list|()
argument_list|)
condition|)
block|{
comment|// Same level of aggregation. Generate a project.
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|projects
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|groupCount
init|=
name|query
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|groupCount
condition|;
name|i
operator|++
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|AggregateCall
name|aggregateCall
range|:
name|query
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
name|int
name|i
init|=
name|target
operator|.
name|getAggCallList
argument_list|()
operator|.
name|indexOf
argument_list|(
name|aggregateCall
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|projects
operator|.
name|add
argument_list|(
name|groupCount
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|target
argument_list|,
name|projects
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Target is coarser level of aggregation. Generate an aggregate.
specifier|final
name|BitSet
name|groupSet
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
specifier|final
name|IntList
name|targetGroupList
init|=
name|BitSets
operator|.
name|toList
argument_list|(
name|target
operator|.
name|getGroupSet
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|c
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|query
operator|.
name|getGroupSet
argument_list|()
argument_list|)
control|)
block|{
name|int
name|c2
init|=
name|targetGroupList
operator|.
name|indexOf
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|c2
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|groupSet
operator|.
name|set
argument_list|(
name|c2
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|aggregateCall
range|:
name|query
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
if|if
condition|(
name|aggregateCall
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|i
init|=
name|target
operator|.
name|getAggCallList
argument_list|()
operator|.
name|indexOf
argument_list|(
name|aggregateCall
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|aggregateCalls
operator|.
name|add
argument_list|(
operator|new
name|AggregateCall
argument_list|(
name|getRollup
argument_list|(
name|aggregateCall
operator|.
name|getAggregation
argument_list|()
argument_list|)
argument_list|,
name|aggregateCall
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupSet
operator|.
name|cardinality
argument_list|()
operator|+
name|i
argument_list|)
argument_list|,
name|aggregateCall
operator|.
name|type
argument_list|,
name|aggregateCall
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
operator|new
name|AggregateRel
argument_list|(
name|target
operator|.
name|getCluster
argument_list|()
argument_list|,
name|target
argument_list|,
name|groupSet
argument_list|,
name|aggregateCalls
argument_list|)
expr_stmt|;
block|}
return|return
name|RelOptUtil
operator|.
name|createCastRel
argument_list|(
name|result
argument_list|,
name|query
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Implementation of {@link UnifyRule} that matches a {@link AggregateRel} on    * a {@link ProjectRel} to an {@link AggregateRel} target. */
specifier|private
specifier|static
class|class
name|AggregateOnProjectToAggregateUnifyRule
extends|extends
name|AbstractUnifyRule
block|{
specifier|public
specifier|static
specifier|final
name|AggregateOnProjectToAggregateUnifyRule
name|INSTANCE
init|=
operator|new
name|AggregateOnProjectToAggregateUnifyRule
argument_list|()
decl_stmt|;
specifier|private
name|AggregateOnProjectToAggregateUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|AggregateRel
operator|.
name|class
argument_list|,
name|AggregateRel
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|AggregateRel
name|query
init|=
operator|(
name|AggregateRel
operator|)
name|call
operator|.
name|query
decl_stmt|;
specifier|final
name|AggregateRel
name|target
init|=
operator|(
name|AggregateRel
operator|)
name|call
operator|.
name|target
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|query
operator|.
name|getChild
argument_list|()
operator|instanceof
name|ProjectRel
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|ProjectRel
name|project
init|=
operator|(
name|ProjectRel
operator|)
name|query
operator|.
name|getChild
argument_list|()
decl_stmt|;
if|if
condition|(
name|project
operator|.
name|getChild
argument_list|()
operator|!=
name|target
operator|.
name|getChild
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|project
operator|.
name|getMapping
argument_list|()
decl_stmt|;
if|if
condition|(
name|mapping
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|AggregateRel
name|aggregate2
init|=
name|permute
argument_list|(
name|query
argument_list|,
name|project
operator|.
name|getChild
argument_list|()
argument_list|,
name|mapping
operator|.
name|inverse
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|result
init|=
name|unifyAggregates
argument_list|(
name|aggregate2
argument_list|,
name|target
argument_list|)
decl_stmt|;
return|return
name|result
operator|==
literal|null
condition|?
literal|null
else|:
name|call
operator|.
name|result
argument_list|(
name|result
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|Aggregation
name|getRollup
parameter_list|(
name|Aggregation
name|aggregation
parameter_list|)
block|{
comment|// TODO: count rolls up using sum; etc.
return|return
name|aggregation
return|;
block|}
specifier|private
specifier|static
name|RexShuttle
name|getRexShuttle
parameter_list|(
name|ProjectRel
name|target
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|target
operator|.
name|getProjects
argument_list|()
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|ref
parameter_list|)
block|{
specifier|final
name|Integer
name|integer
init|=
name|map
operator|.
name|get
argument_list|(
name|ref
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|integer
argument_list|,
name|ref
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
throw|throw
name|MatchFailed
operator|.
name|INSTANCE
throw|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
specifier|final
name|Integer
name|integer
init|=
name|map
operator|.
name|get
argument_list|(
name|call
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|integer
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Information about a node's parent and its position among its siblings. */
specifier|private
specifier|static
class|class
name|Parentage
block|{
specifier|final
name|RelNode
name|parent
decl_stmt|;
specifier|final
name|int
name|ordinal
decl_stmt|;
specifier|private
name|Parentage
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End SubstitutionVisitor.java
end_comment

end_unit

