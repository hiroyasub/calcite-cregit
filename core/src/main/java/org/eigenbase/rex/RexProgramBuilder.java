begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|rex
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Workspace for constructing a {@link RexProgram}.  *  *<p>RexProgramBuilder is necessary because a {@link RexProgram} is immutable.  * (The {@link String} class has the same problem: it is immutable, so they  * introduced {@link StringBuffer}.)  */
end_comment

begin_class
specifier|public
class|class
name|RexProgramBuilder
block|{
comment|//~ Instance fields --------------------------------------------------------
specifier|private
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|private
specifier|final
name|RelDataType
name|inputRowType
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RexLocalRef
argument_list|>
name|exprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RexLocalRef
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|localRefList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexLocalRef
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexLocalRef
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|projectNameList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|RexLocalRef
name|conditionRef
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|validating
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a program-builder.    */
specifier|public
name|RexProgramBuilder
parameter_list|(
name|RelDataType
name|inputRowType
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
assert|assert
name|inputRowType
operator|!=
literal|null
assert|;
assert|assert
name|rexBuilder
operator|!=
literal|null
assert|;
name|this
operator|.
name|inputRowType
operator|=
name|inputRowType
expr_stmt|;
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
name|this
operator|.
name|validating
operator|=
name|assertionsAreEnabled
argument_list|()
expr_stmt|;
comment|// Pre-create an expression for each input field.
if|if
condition|(
name|inputRowType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|inputRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|registerInternal
argument_list|(
name|RexInputRef
operator|.
name|of
argument_list|(
name|i
argument_list|,
name|fields
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Creates a program builder with the same contents as a program.    *    * @param rexBuilder     Rex builder    * @param inputRowType   Input row type    * @param exprList       Common expressions    * @param projectRefList Projections    * @param conditionRef   Condition, or null    * @param outputRowType  Output row type    * @param normalize      Whether to normalize    */
specifier|private
name|RexProgramBuilder
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RelDataType
name|inputRowType
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefList
parameter_list|,
specifier|final
name|RexLocalRef
name|conditionRef
parameter_list|,
specifier|final
name|RelDataType
name|outputRowType
parameter_list|,
name|boolean
name|normalize
parameter_list|)
block|{
name|this
argument_list|(
name|inputRowType
argument_list|,
name|rexBuilder
argument_list|)
expr_stmt|;
comment|// Create a shuttle for registering input expressions.
specifier|final
name|RexShuttle
name|shuttle
init|=
operator|new
name|RegisterMidputShuttle
argument_list|(
literal|true
argument_list|,
name|exprList
argument_list|)
decl_stmt|;
comment|// If we are not normalizing, register all internal expressions. If we
comment|// are normalizing, expressions will be registered if and when they are
comment|// first used.
if|if
condition|(
operator|!
name|normalize
condition|)
block|{
for|for
control|(
name|RexNode
name|expr
range|:
name|exprList
control|)
block|{
name|expr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Register project expressions
comment|// and create a named project item.
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fieldList
init|=
name|outputRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RexLocalRef
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|projectRefList
argument_list|,
name|fieldList
argument_list|)
control|)
block|{
specifier|final
name|RexLocalRef
name|projectRef
init|=
name|pair
operator|.
name|left
decl_stmt|;
specifier|final
name|String
name|name
init|=
name|pair
operator|.
name|right
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|int
name|oldIndex
init|=
name|projectRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|expr
init|=
name|exprList
operator|.
name|get
argument_list|(
name|oldIndex
argument_list|)
decl_stmt|;
specifier|final
name|RexLocalRef
name|ref
init|=
operator|(
name|RexLocalRef
operator|)
name|expr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
name|addProject
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|// Register the condition, if there is one.
if|if
condition|(
name|conditionRef
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|exprList
operator|.
name|get
argument_list|(
name|conditionRef
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexLocalRef
name|ref
init|=
operator|(
name|RexLocalRef
operator|)
name|expr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
name|addCondition
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Returns whether assertions are enabled in this class.    */
specifier|private
specifier|static
name|boolean
name|assertionsAreEnabled
parameter_list|()
block|{
name|boolean
name|assertionsEnabled
init|=
literal|false
decl_stmt|;
assert|assert
name|assertionsEnabled
operator|=
literal|true
assert|;
return|return
name|assertionsEnabled
return|;
block|}
specifier|private
name|void
name|validate
parameter_list|(
specifier|final
name|RexNode
name|expr
parameter_list|,
specifier|final
name|int
name|fieldOrdinal
parameter_list|)
block|{
specifier|final
name|RexVisitor
argument_list|<
name|Void
argument_list|>
name|validator
init|=
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|input
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|input
operator|.
name|getIndex
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|inputRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|final
name|RelDataTypeField
name|inputField
init|=
name|fields
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|input
operator|.
name|getType
argument_list|()
operator|!=
name|inputField
operator|.
name|getType
argument_list|()
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"in expression "
operator|+
name|expr
operator|+
literal|", field reference "
operator|+
name|input
operator|+
literal|" has inconsistent type"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|index
operator|>=
name|fieldOrdinal
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"in expression "
operator|+
name|expr
operator|+
literal|", field reference "
operator|+
name|input
operator|+
literal|" is out of bounds"
argument_list|)
throw|;
block|}
name|RexNode
name|refExpr
init|=
name|exprList
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|refExpr
operator|.
name|getType
argument_list|()
operator|!=
name|input
operator|.
name|getType
argument_list|()
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"in expression "
operator|+
name|expr
operator|+
literal|", field reference "
operator|+
name|input
operator|+
literal|" has inconsistent type"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
name|expr
operator|.
name|accept
argument_list|(
name|validator
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds a project expression to the program.    *    *<p>The expression specified in terms of the input fields. If not, call    * {@link #registerOutput(RexNode)} first.    *    * @param expr Expression to add    * @param name Name of field in output row type; if null, a unique name will    *             be generated when the program is created    * @return the ref created    */
specifier|public
name|RexLocalRef
name|addProject
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|String
name|name
parameter_list|)
block|{
specifier|final
name|RexLocalRef
name|ref
init|=
name|registerInput
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
name|addProject
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|,
name|name
argument_list|)
return|;
block|}
comment|/**    * Adds a projection based upon the<code>index</code>th expression.    *    * @param ordinal Index of expression to project    * @param name    Name of field in output row type; if null, a unique name    *                will be generated when the program is created    * @return the ref created    */
specifier|public
name|RexLocalRef
name|addProject
parameter_list|(
name|int
name|ordinal
parameter_list|,
specifier|final
name|String
name|name
parameter_list|)
block|{
specifier|final
name|RexLocalRef
name|ref
init|=
name|localRefList
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
name|projectRefList
operator|.
name|add
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|projectNameList
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
comment|/**    * Adds a project expression to the program at a given position.    *    *<p>The expression specified in terms of the input fields. If not, call    * {@link #registerOutput(RexNode)} first.    *    * @param at   Position in project list to add expression    * @param expr Expression to add    * @param name Name of field in output row type; if null, a unique name will    *             be generated when the program is created    * @return the ref created    */
specifier|public
name|RexLocalRef
name|addProject
parameter_list|(
name|int
name|at
parameter_list|,
name|RexNode
name|expr
parameter_list|,
name|String
name|name
parameter_list|)
block|{
specifier|final
name|RexLocalRef
name|ref
init|=
name|registerInput
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|projectRefList
operator|.
name|add
argument_list|(
name|at
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|projectNameList
operator|.
name|add
argument_list|(
name|at
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
comment|/**    * Adds a projection based upon the<code>index</code>th expression at a    * given position.    *    * @param at      Position in project list to add expression    * @param ordinal Index of expression to project    * @param name    Name of field in output row type; if null, a unique name    *                will be generated when the program is created    * @return the ref created    */
specifier|public
name|RexLocalRef
name|addProject
parameter_list|(
name|int
name|at
parameter_list|,
name|int
name|ordinal
parameter_list|,
specifier|final
name|String
name|name
parameter_list|)
block|{
return|return
name|addProject
argument_list|(
name|at
argument_list|,
name|localRefList
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
comment|/**    * Sets the condition of the program.    *    *<p>The expression must be specified in terms of the input fields. If    * not, call {@link #registerOutput(RexNode)} first.</p>    */
specifier|public
name|void
name|addCondition
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
assert|assert
name|expr
operator|!=
literal|null
assert|;
if|if
condition|(
name|conditionRef
operator|==
literal|null
condition|)
block|{
name|conditionRef
operator|=
name|registerInput
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// AND the new condition with the existing condition.
name|RexLocalRef
name|ref
init|=
name|registerInput
argument_list|(
name|expr
argument_list|)
decl_stmt|;
specifier|final
name|RexLocalRef
name|andRef
init|=
name|registerInput
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|andOperator
argument_list|,
name|conditionRef
argument_list|,
name|ref
argument_list|)
argument_list|)
decl_stmt|;
name|conditionRef
operator|=
name|andRef
expr_stmt|;
block|}
block|}
comment|/**    * Registers an expression in the list of common sub-expressions, and    * returns a reference to that expression.     *<p>The expression must be expressed in terms of the<em>inputs</em> of    * this program.</p>    */
specifier|public
name|RexLocalRef
name|registerInput
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
specifier|final
name|RexShuttle
name|shuttle
init|=
operator|new
name|RegisterInputShuttle
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|expr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
return|return
operator|(
name|RexLocalRef
operator|)
name|ref
return|;
block|}
comment|/**    * Converts an expression expressed in terms of the<em>outputs</em> of this    * program into an expression expressed in terms of the<em>inputs</em>,    * registers it in the list of common sub-expressions, and returns a    * reference to that expression.    *    * @param expr Expression to register    */
specifier|public
name|RexLocalRef
name|registerOutput
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
specifier|final
name|RexShuttle
name|shuttle
init|=
operator|new
name|RegisterOutputShuttle
argument_list|(
name|exprList
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|expr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
return|return
operator|(
name|RexLocalRef
operator|)
name|ref
return|;
block|}
comment|/**    * Registers an expression in the list of common sub-expressions, and    * returns a reference to that expression.    *    *<p>If an equivalent sub-expression already exists, creates another    * expression only if<code>force</code> is true.    *    * @param expr  Expression to register    * @param force Whether to create a new sub-expression if an equivalent    *              sub-expression exists.    */
specifier|private
name|RexLocalRef
name|registerInternal
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
name|String
name|key
init|=
name|RexUtil
operator|.
name|makeKey
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|RexLocalRef
name|ref
init|=
name|exprMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ref
operator|==
literal|null
operator|)
operator|&&
operator|(
name|expr
operator|instanceof
name|RexLocalRef
operator|)
condition|)
block|{
name|ref
operator|=
operator|(
name|RexLocalRef
operator|)
name|expr
expr_stmt|;
block|}
if|if
condition|(
name|ref
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|validating
condition|)
block|{
name|validate
argument_list|(
name|expr
argument_list|,
name|exprList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Add expression to list, and return a new reference to it.
name|ref
operator|=
name|addExpr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|exprMap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|force
condition|)
block|{
comment|// Add expression to list, but return the previous ref.
name|addExpr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|index
init|=
name|ref
operator|.
name|index
decl_stmt|;
specifier|final
name|RexNode
name|expr2
init|=
name|exprList
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr2
operator|instanceof
name|RexLocalRef
condition|)
block|{
name|ref
operator|=
operator|(
name|RexLocalRef
operator|)
name|expr2
expr_stmt|;
block|}
else|else
block|{
return|return
name|ref
return|;
block|}
block|}
block|}
comment|/**    * Adds an expression to the list of common expressions, and returns a    * reference to the expression.<b>DOES NOT CHECK WHETHER THE EXPRESSION    * ALREADY EXISTS</b>.    *    * @param expr Expression    * @return Reference to expression    */
specifier|public
name|RexLocalRef
name|addExpr
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
name|RexLocalRef
name|ref
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|exprList
operator|.
name|size
argument_list|()
decl_stmt|;
name|exprList
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ref
operator|=
operator|new
name|RexLocalRef
argument_list|(
name|index
argument_list|,
name|expr
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|localRefList
operator|.
name|add
argument_list|(
name|ref
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
comment|/**    * Converts the state of the program builder to an immutable program,    * normalizing in the process.    *    *<p>It is OK to call this method, modify the program specification (by    * adding projections, and so forth), and call this method again.    */
specifier|public
name|RexProgram
name|getProgram
parameter_list|()
block|{
return|return
name|getProgram
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|/**    * Converts the state of the program builder to an immutable program.    *    *<p>It is OK to call this method, modify the program specification (by    * adding projections, and so forth), and call this method again.    *    * @param normalize Whether to normalize    */
specifier|public
name|RexProgram
name|getProgram
parameter_list|(
name|boolean
name|normalize
parameter_list|)
block|{
assert|assert
name|projectRefList
operator|.
name|size
argument_list|()
operator|==
name|projectNameList
operator|.
name|size
argument_list|()
assert|;
comment|// Make sure all fields have a name.
name|generateMissingNames
argument_list|()
expr_stmt|;
name|RelDataType
name|outputRowType
init|=
name|computeOutputRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|normalize
condition|)
block|{
return|return
name|create
argument_list|(
name|rexBuilder
argument_list|,
name|inputRowType
argument_list|,
name|exprList
argument_list|,
name|projectRefList
argument_list|,
name|conditionRef
argument_list|,
name|outputRowType
argument_list|,
literal|true
argument_list|)
operator|.
name|getProgram
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|// Clone expressions, so builder can modify them after they have
comment|// been put into the program. The projects and condition do not need
comment|// to be cloned, because RexLocalRef is immutable.
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|exprList
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|expr
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RexProgram
argument_list|(
name|inputRowType
argument_list|,
name|exprs
argument_list|,
name|projectRefList
argument_list|,
name|conditionRef
argument_list|,
name|outputRowType
argument_list|)
return|;
block|}
specifier|private
name|RelDataType
name|computeOutputRowType
parameter_list|()
block|{
return|return
name|RexUtil
operator|.
name|createStructType
argument_list|(
name|rexBuilder
operator|.
name|typeFactory
argument_list|,
name|projectRefList
argument_list|,
name|projectNameList
argument_list|)
return|;
block|}
specifier|private
name|void
name|generateMissingNames
parameter_list|()
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|projectName
range|:
name|projectNameList
control|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|projectName
operator|==
literal|null
condition|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|String
name|candidateName
init|=
literal|"$"
operator|+
name|j
operator|++
decl_stmt|;
if|if
condition|(
operator|!
name|projectNameList
operator|.
name|contains
argument_list|(
name|candidateName
argument_list|)
condition|)
block|{
name|projectNameList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|candidateName
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Creates a program builder and initializes it from an existing program.    *    *<p>Calling {@link #getProgram()} immediately after creation will return a    * program equivalent (in terms of external behavior) to the existing    * program.    *    *<p>The existing program will not be changed. (It cannot: programs are    * immutable.)    *    * @param program    Existing program    * @param rexBuilder Rex builder    * @param normalize  Whether to normalize    * @return A program builder initialized with an equivalent program    */
specifier|public
specifier|static
name|RexProgramBuilder
name|forProgram
parameter_list|(
name|RexProgram
name|program
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|boolean
name|normalize
parameter_list|)
block|{
assert|assert
name|program
operator|.
name|isValid
argument_list|(
literal|true
argument_list|)
assert|;
specifier|final
name|RelDataType
name|inputRowType
init|=
name|program
operator|.
name|getInputRowType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefs
init|=
name|program
operator|.
name|getProjectList
argument_list|()
decl_stmt|;
specifier|final
name|RexLocalRef
name|conditionRef
init|=
name|program
operator|.
name|getCondition
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|program
operator|.
name|getExprList
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|outputRowType
init|=
name|program
operator|.
name|getOutputRowType
argument_list|()
decl_stmt|;
return|return
name|create
argument_list|(
name|rexBuilder
argument_list|,
name|inputRowType
argument_list|,
name|exprs
argument_list|,
name|projectRefs
argument_list|,
name|conditionRef
argument_list|,
name|outputRowType
argument_list|,
name|normalize
argument_list|)
return|;
block|}
comment|/**    * Creates a program builder with the same contents as a program.    *    *<p>If {@code normalize}, converts the program to canonical form. In    * canonical form, in addition to the usual constraints:    *    *<ul>    *<li>The first N internal expressions are {@link RexInputRef}s to the N    * input fields;    *<li>Subsequent internal expressions reference only preceding expressions;    *<li>Arguments to {@link RexCall}s must be {@link RexLocalRef}s (that is,    * expressions must have maximum depth 1)    *</ul>    *    * there are additional constraints:    *    *<ul>    *<li>Expressions appear in the left-deep order they are needed by    * the projections and (if present) the condition. Thus, expression N+1    * is the leftmost argument (literal or or call) in the expansion of    * projection #0.    *<li>There are no duplicate expressions    *<li>There are no unused expressions    *</ul>    *    * @param rexBuilder     Rex builder    * @param inputRowType   Input row type    * @param exprList       Common expressions    * @param projectRefList Projections    * @param conditionRef   Condition, or null    * @param outputRowType  Output row type    * @param normalize      Whether to normalize    * @return A program builder    */
specifier|public
specifier|static
name|RexProgramBuilder
name|create
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RelDataType
name|inputRowType
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefList
parameter_list|,
specifier|final
name|RexLocalRef
name|conditionRef
parameter_list|,
specifier|final
name|RelDataType
name|outputRowType
parameter_list|,
name|boolean
name|normalize
parameter_list|)
block|{
return|return
operator|new
name|RexProgramBuilder
argument_list|(
name|rexBuilder
argument_list|,
name|inputRowType
argument_list|,
name|exprList
argument_list|,
name|projectRefList
argument_list|,
name|conditionRef
argument_list|,
name|outputRowType
argument_list|,
name|normalize
argument_list|)
return|;
block|}
comment|/**    * Creates a program builder with the same contents as a program, applying a    * shuttle first.    *    *<p>TODO: Refactor the above create method in terms of this one.    *    * @param rexBuilder     Rex builder    * @param inputRowType   Input row type    * @param exprList       Common expressions    * @param projectRefList Projections    * @param conditionRef   Condition, or null    * @param outputRowType  Output row type    * @param shuttle        Shuttle to apply to each expression before adding it    *                       to the program builder    * @param updateRefs     Whether to update references that changes as a result    *                       of rewrites made by the shuttle    * @return A program builder    */
specifier|public
specifier|static
name|RexProgramBuilder
name|create
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RelDataType
name|inputRowType
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefList
parameter_list|,
specifier|final
name|RexLocalRef
name|conditionRef
parameter_list|,
specifier|final
name|RelDataType
name|outputRowType
parameter_list|,
specifier|final
name|RexShuttle
name|shuttle
parameter_list|,
specifier|final
name|boolean
name|updateRefs
parameter_list|)
block|{
specifier|final
name|RexProgramBuilder
name|progBuilder
init|=
operator|new
name|RexProgramBuilder
argument_list|(
name|inputRowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|progBuilder
operator|.
name|add
argument_list|(
name|exprList
argument_list|,
name|projectRefList
argument_list|,
name|conditionRef
argument_list|,
name|outputRowType
argument_list|,
name|shuttle
argument_list|,
name|updateRefs
argument_list|)
expr_stmt|;
return|return
name|progBuilder
return|;
block|}
comment|/**    * Normalizes a program.    *    * @param rexBuilder Rex builder    * @param program    Program    * @return Normalized program    */
specifier|public
specifier|static
name|RexProgram
name|normalize
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexProgram
name|program
parameter_list|)
block|{
comment|// Normalize program by creating program builder from the program, then
comment|// converting to a program. getProgram does not need to normalize
comment|// because the builder was normalized on creation.
return|return
name|forProgram
argument_list|(
name|program
argument_list|,
name|rexBuilder
argument_list|,
literal|true
argument_list|)
operator|.
name|getProgram
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/**    * Adds a set of expressions, projections and filters, applying a shuttle    * first.    *    * @param exprList       Common expressions    * @param projectRefList Projections    * @param conditionRef   Condition, or null    * @param outputRowType  Output row type    * @param shuttle        Shuttle to apply to each expression before adding it    *                       to the program builder    * @param updateRefs     Whether to update references that changes as a result    *                       of rewrites made by the shuttle    */
specifier|private
name|void
name|add
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
parameter_list|,
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefList
parameter_list|,
name|RexLocalRef
name|conditionRef
parameter_list|,
specifier|final
name|RelDataType
name|outputRowType
parameter_list|,
name|RexShuttle
name|shuttle
parameter_list|,
name|boolean
name|updateRefs
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|outFields
init|=
name|outputRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|RexShuttle
name|registerInputShuttle
init|=
operator|new
name|RegisterInputShuttle
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// For each common expression, first apply the user's shuttle, then
comment|// register the result.
comment|// REVIEW jpham 28-Apr-2006: if the user shuttle rewrites an input
comment|// expression, then input references may change
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|newRefs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexLocalRef
argument_list|>
argument_list|(
name|exprList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|RexShuttle
name|refShuttle
init|=
operator|new
name|UpdateRefShuttle
argument_list|(
name|newRefs
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|exprList
control|)
block|{
name|RexNode
name|newExpr
init|=
name|expr
decl_stmt|;
if|if
condition|(
name|updateRefs
condition|)
block|{
name|newExpr
operator|=
name|expr
operator|.
name|accept
argument_list|(
name|refShuttle
argument_list|)
expr_stmt|;
block|}
name|newExpr
operator|=
name|newExpr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
expr_stmt|;
name|newRefs
operator|.
name|add
argument_list|(
name|i
operator|++
argument_list|,
operator|(
name|RexLocalRef
operator|)
name|newExpr
operator|.
name|accept
argument_list|(
name|registerInputShuttle
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|RexLocalRef
name|oldRef
range|:
name|projectRefList
control|)
block|{
operator|++
name|i
expr_stmt|;
name|RexLocalRef
name|ref
init|=
name|oldRef
decl_stmt|;
if|if
condition|(
name|updateRefs
condition|)
block|{
name|ref
operator|=
operator|(
name|RexLocalRef
operator|)
name|oldRef
operator|.
name|accept
argument_list|(
name|refShuttle
argument_list|)
expr_stmt|;
block|}
name|ref
operator|=
operator|(
name|RexLocalRef
operator|)
name|ref
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
expr_stmt|;
name|this
operator|.
name|projectRefList
operator|.
name|add
argument_list|(
name|ref
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
name|outFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
assert|assert
name|name
operator|!=
literal|null
assert|;
name|projectNameList
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conditionRef
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|updateRefs
condition|)
block|{
name|conditionRef
operator|=
operator|(
name|RexLocalRef
operator|)
name|conditionRef
operator|.
name|accept
argument_list|(
name|refShuttle
argument_list|)
expr_stmt|;
block|}
name|conditionRef
operator|=
operator|(
name|RexLocalRef
operator|)
name|conditionRef
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
expr_stmt|;
name|addCondition
argument_list|(
name|conditionRef
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Merges two programs together, and normalizes the result.    *    * @param topProgram    Top program. Its expressions are in terms of the    *                      outputs of the bottom program.    * @param bottomProgram Bottom program. Its expressions are in terms of the    *                      result fields of the relational expression's input    * @param rexBuilder    Rex builder    * @return Merged program    * @see #mergePrograms(RexProgram, RexProgram, RexBuilder, boolean)    */
specifier|public
specifier|static
name|RexProgram
name|mergePrograms
parameter_list|(
name|RexProgram
name|topProgram
parameter_list|,
name|RexProgram
name|bottomProgram
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
return|return
name|mergePrograms
argument_list|(
name|topProgram
argument_list|,
name|bottomProgram
argument_list|,
name|rexBuilder
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Merges two programs together.    *    *<p>All expressions become common sub-expressions. For example, the query    *    *<pre>{@code    * SELECT x + 1 AS p, x + y AS q FROM (    *   SELECT a + b AS x, c AS y    *   FROM t    *   WHERE c = 6)}</pre>    *    * would be represented as the programs    *    *<pre>    *   Calc:    *       Projects={$2, $3},    *       Condition=null,    *       Exprs={$0, $1, $0 + 1, $0 + $1})    *   Calc(    *       Projects={$3, $2},    *       Condition={$4}    *       Exprs={$0, $1, $2, $0 + $1, $2 = 6}    *</pre>    *    *<p>The merged program is    *    *<pre>    *   Calc(    *      Projects={$4, $5}    *      Condition=$6    *      Exprs={0: $0       // a    *             1: $1        // b    *             2: $2        // c    *             3: ($0 + $1) // x = a + b    *             4: ($3 + 1)  // p = x + 1    *             5: ($3 + $2) // q = x + y    *             6: ($2 = 6)  // c = 6    *</pre>    *    *<p>Another example:</blockquote>    *    *<pre>SELECT *    * FROM (    *   SELECT a + b AS x, c AS y    *   FROM t    *   WHERE c = 6)    * WHERE x = 5</pre>    *</blockquote>    *    * becomes    *    *<blockquote>    *<pre>SELECT a + b AS x, c AS y    * FROM t    * WHERE c = 6 AND (a + b) = 5</pre>    *</blockquote>    *    * @param topProgram    Top program. Its expressions are in terms of the    *                      outputs of the bottom program.    * @param bottomProgram Bottom program. Its expressions are in terms of the    *                      result fields of the relational expression's input    * @param rexBuilder    Rex builder    * @param normalize     Whether to convert program to canonical form    * @return Merged program    */
specifier|public
specifier|static
name|RexProgram
name|mergePrograms
parameter_list|(
name|RexProgram
name|topProgram
parameter_list|,
name|RexProgram
name|bottomProgram
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|boolean
name|normalize
parameter_list|)
block|{
comment|// Initialize a program builder with the same expressions, outputs
comment|// and condition as the bottom program.
assert|assert
name|bottomProgram
operator|.
name|isValid
argument_list|(
literal|true
argument_list|)
assert|;
assert|assert
name|topProgram
operator|.
name|isValid
argument_list|(
literal|true
argument_list|)
assert|;
specifier|final
name|RexProgramBuilder
name|progBuilder
init|=
name|RexProgramBuilder
operator|.
name|forProgram
argument_list|(
name|bottomProgram
argument_list|,
name|rexBuilder
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Drive from the outputs of the top program. Register each expression
comment|// used as an output.
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefList
init|=
name|progBuilder
operator|.
name|registerProjectsAndCondition
argument_list|(
name|topProgram
argument_list|)
decl_stmt|;
comment|// Switch to the projects needed by the top program. The original
comment|// projects of the bottom program are no longer needed.
name|progBuilder
operator|.
name|clearProjects
argument_list|()
expr_stmt|;
specifier|final
name|RelDataType
name|outputRowType
init|=
name|topProgram
operator|.
name|getOutputRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RexLocalRef
argument_list|,
name|String
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|projectRefList
argument_list|,
name|outputRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|,
literal|true
argument_list|)
control|)
block|{
name|progBuilder
operator|.
name|addProject
argument_list|(
name|pair
operator|.
name|left
argument_list|,
name|pair
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
name|RexProgram
name|mergedProg
init|=
name|progBuilder
operator|.
name|getProgram
argument_list|(
name|normalize
argument_list|)
decl_stmt|;
assert|assert
name|mergedProg
operator|.
name|isValid
argument_list|(
literal|true
argument_list|)
assert|;
assert|assert
name|mergedProg
operator|.
name|getOutputRowType
argument_list|()
operator|==
name|topProgram
operator|.
name|getOutputRowType
argument_list|()
assert|;
return|return
name|mergedProg
return|;
block|}
specifier|private
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|registerProjectsAndCondition
parameter_list|(
name|RexProgram
name|program
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
name|program
operator|.
name|getExprList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexLocalRef
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|RexShuttle
name|shuttle
init|=
operator|new
name|RegisterOutputShuttle
argument_list|(
name|exprList
argument_list|)
decl_stmt|;
comment|// For each project, lookup the expr and expand it so it is in terms of
comment|// bottomCalc's input fields
for|for
control|(
name|RexLocalRef
name|topProject
range|:
name|program
operator|.
name|getProjectList
argument_list|()
control|)
block|{
specifier|final
name|RexNode
name|topExpr
init|=
name|exprList
operator|.
name|get
argument_list|(
name|topProject
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexLocalRef
name|expanded
init|=
operator|(
name|RexLocalRef
operator|)
name|topExpr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
comment|// Remember the expr, but don't add to the project list yet.
name|projectRefList
operator|.
name|add
argument_list|(
name|expanded
argument_list|)
expr_stmt|;
block|}
comment|// Similarly for the condition.
specifier|final
name|RexLocalRef
name|topCondition
init|=
name|program
operator|.
name|getCondition
argument_list|()
decl_stmt|;
if|if
condition|(
name|topCondition
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RexNode
name|topExpr
init|=
name|exprList
operator|.
name|get
argument_list|(
name|topCondition
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexLocalRef
name|expanded
init|=
operator|(
name|RexLocalRef
operator|)
name|topExpr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
name|addCondition
argument_list|(
name|registerInput
argument_list|(
name|expanded
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|projectRefList
return|;
block|}
comment|/**    * Removes all project items.    *    *<p>After calling this method, you may need to re-normalize.</p>    */
specifier|public
name|void
name|clearProjects
parameter_list|()
block|{
name|projectRefList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|projectNameList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Clears the condition.    *    *<p>After calling this method, you may need to re-normalize.</p>    */
specifier|public
name|void
name|clearCondition
parameter_list|()
block|{
name|conditionRef
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Adds a project item for every input field.    *    *<p>You cannot call this method if there are other project items.    *    * @pre projectRefList.isEmpty()    */
specifier|public
name|void
name|addIdentity
parameter_list|()
block|{
assert|assert
name|projectRefList
operator|.
name|isEmpty
argument_list|()
assert|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|inputRowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|addProject
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates a reference to a given input field.    *    * @param index Ordinal of input field, must be less than the number of    *              fields in the input type    * @return Reference to input field    */
specifier|public
name|RexLocalRef
name|makeInputRef
parameter_list|(
name|int
name|index
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|inputRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|index
operator|<
name|fields
operator|.
name|size
argument_list|()
assert|;
specifier|final
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexLocalRef
argument_list|(
name|index
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the rowtype of the input to the program    */
specifier|public
name|RelDataType
name|getInputRowType
parameter_list|()
block|{
return|return
name|inputRowType
return|;
block|}
comment|/**    * Returns the list of project expressions.    */
specifier|public
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|getProjectList
parameter_list|()
block|{
return|return
name|projectRefList
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
specifier|private
specifier|abstract
class|class
name|RegisterShuttle
extends|extends
name|RexShuttle
block|{
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
decl_stmt|;
return|return
name|registerInternal
argument_list|(
name|expr
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitOver
parameter_list|(
name|RexOver
name|over
parameter_list|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|super
operator|.
name|visitOver
argument_list|(
name|over
argument_list|)
decl_stmt|;
return|return
name|registerInternal
argument_list|(
name|expr
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|super
operator|.
name|visitLiteral
argument_list|(
name|literal
argument_list|)
decl_stmt|;
return|return
name|registerInternal
argument_list|(
name|expr
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|super
operator|.
name|visitFieldAccess
argument_list|(
name|fieldAccess
argument_list|)
decl_stmt|;
return|return
name|registerInternal
argument_list|(
name|expr
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitDynamicParam
parameter_list|(
name|RexDynamicParam
name|dynamicParam
parameter_list|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|super
operator|.
name|visitDynamicParam
argument_list|(
name|dynamicParam
argument_list|)
decl_stmt|;
return|return
name|registerInternal
argument_list|(
name|expr
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|variable
parameter_list|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|super
operator|.
name|visitCorrelVariable
argument_list|(
name|variable
argument_list|)
decl_stmt|;
return|return
name|registerInternal
argument_list|(
name|expr
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
comment|/**    * Shuttle which walks over an expression, registering each sub-expression.    * Each {@link RexInputRef} is assumed to refer to an<em>input</em> of the    * program.    */
specifier|private
class|class
name|RegisterInputShuttle
extends|extends
name|RegisterShuttle
block|{
specifier|private
specifier|final
name|boolean
name|valid
decl_stmt|;
specifier|protected
name|RegisterInputShuttle
parameter_list|(
name|boolean
name|valid
parameter_list|)
block|{
name|this
operator|.
name|valid
operator|=
name|valid
expr_stmt|;
block|}
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|input
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|input
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|valid
condition|)
block|{
comment|// The expression should already be valid. Check that its
comment|// index is within bounds.
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
operator|)
condition|)
block|{
assert|assert
literal|false
operator|:
literal|"RexInputRef index "
operator|+
name|index
operator|+
literal|" out of range 0.."
operator|+
operator|(
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
operator|-
literal|1
operator|)
assert|;
block|}
comment|// Check that the type is consistent with the referenced
comment|// field. If it is an object type, the rules are different, so
comment|// skip the check.
assert|assert
name|input
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
operator|||
name|RelOptUtil
operator|.
name|eq
argument_list|(
literal|"type1"
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|,
literal|"type2"
argument_list|,
name|inputRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
assert|;
block|}
comment|// Return a reference to the N'th expression, which should be
comment|// equivalent.
specifier|final
name|RexLocalRef
name|ref
init|=
name|localRefList
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|ref
return|;
block|}
specifier|public
name|RexNode
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|local
parameter_list|)
block|{
if|if
condition|(
name|valid
condition|)
block|{
comment|// The expression should already be valid.
specifier|final
name|int
name|index
init|=
name|local
operator|.
name|getIndex
argument_list|()
decl_stmt|;
assert|assert
name|index
operator|>=
literal|0
operator|:
name|index
assert|;
assert|assert
name|index
operator|<
name|exprList
operator|.
name|size
argument_list|()
operator|:
literal|"index="
operator|+
name|index
operator|+
literal|", exprList="
operator|+
name|exprList
assert|;
assert|assert
name|RelOptUtil
operator|.
name|eq
argument_list|(
literal|"expr type"
argument_list|,
name|exprList
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
literal|"ref type"
argument_list|,
name|local
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
assert|;
block|}
comment|// Resolve the expression to an input.
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|index
init|=
name|local
operator|.
name|getIndex
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|expr
init|=
name|exprList
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|RexLocalRef
condition|)
block|{
name|local
operator|=
operator|(
name|RexLocalRef
operator|)
name|expr
expr_stmt|;
if|if
condition|(
name|local
operator|.
name|index
operator|>=
name|index
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"expr "
operator|+
name|local
operator|+
literal|" references later expr "
operator|+
name|local
operator|.
name|index
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// Add expression to the list, just so that subsequent
comment|// expressions don't get screwed up. This expression is
comment|// unused, so will be eliminated soon.
return|return
name|registerInternal
argument_list|(
name|local
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
block|}
comment|/**    * Extension to {@link RegisterInputShuttle} which allows expressions to be    * in terms of inputs or previous common sub-expressions.    */
specifier|private
class|class
name|RegisterMidputShuttle
extends|extends
name|RegisterInputShuttle
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|localExprList
decl_stmt|;
specifier|protected
name|RegisterMidputShuttle
parameter_list|(
name|boolean
name|valid
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|localExprList
parameter_list|)
block|{
name|super
argument_list|(
name|valid
argument_list|)
expr_stmt|;
name|this
operator|.
name|localExprList
operator|=
name|localExprList
expr_stmt|;
block|}
specifier|public
name|RexNode
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|local
parameter_list|)
block|{
comment|// Convert a local ref into the common-subexpression it references.
specifier|final
name|int
name|index
init|=
name|local
operator|.
name|getIndex
argument_list|()
decl_stmt|;
return|return
name|localExprList
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Shuttle which walks over an expression, registering each sub-expression.    * Each {@link RexInputRef} is assumed to refer to an<em>output</em> of the    * program.    */
specifier|private
class|class
name|RegisterOutputShuttle
extends|extends
name|RegisterShuttle
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|localExprList
decl_stmt|;
specifier|public
name|RegisterOutputShuttle
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|localExprList
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|localExprList
operator|=
name|localExprList
expr_stmt|;
block|}
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|input
parameter_list|)
block|{
comment|// This expression refers to the Nth project column. Lookup that
comment|// column and find out what common sub-expression IT refers to.
specifier|final
name|int
name|index
init|=
name|input
operator|.
name|getIndex
argument_list|()
decl_stmt|;
specifier|final
name|RexLocalRef
name|local
init|=
name|projectRefList
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
assert|assert
name|RelOptUtil
operator|.
name|eq
argument_list|(
literal|"type1"
argument_list|,
name|local
operator|.
name|getType
argument_list|()
argument_list|,
literal|"type2"
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
assert|;
return|return
name|local
return|;
block|}
specifier|public
name|RexNode
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|local
parameter_list|)
block|{
comment|// Convert a local ref into the common-subexpression it references.
specifier|final
name|int
name|index
init|=
name|local
operator|.
name|getIndex
argument_list|()
decl_stmt|;
return|return
name|localExprList
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Shuttle which rewires {@link RexLocalRef} using a list of updated    * references    */
specifier|private
class|class
name|UpdateRefShuttle
extends|extends
name|RexShuttle
block|{
specifier|private
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|newRefs
decl_stmt|;
specifier|private
name|UpdateRefShuttle
parameter_list|(
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|newRefs
parameter_list|)
block|{
name|this
operator|.
name|newRefs
operator|=
name|newRefs
expr_stmt|;
block|}
specifier|public
name|RexNode
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
return|return
name|newRefs
operator|.
name|get
argument_list|(
name|localRef
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End RexProgramBuilder.java
end_comment

end_unit

