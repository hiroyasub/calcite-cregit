begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|validate
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|resgen
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|resource
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|parser
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|trace
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|Linq4j
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_comment
comment|/**  * Default implementation of {@link SqlValidator}.  */
end_comment

begin_class
specifier|public
class|class
name|SqlValidatorImpl
implements|implements
name|SqlValidatorWithHints
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|public
specifier|static
specifier|final
name|Logger
name|TRACER
init|=
name|EigenbaseTrace
operator|.
name|parserTracer
decl_stmt|;
comment|/**    * Alias generated for the source table when rewriting UPDATE to MERGE.    */
specifier|public
specifier|static
specifier|final
name|String
name|UPDATE_SRC_ALIAS
init|=
literal|"SYS$SRC"
decl_stmt|;
comment|/**    * Alias generated for the target table when rewriting UPDATE to MERGE if no    * alias was specified by the user.    */
specifier|public
specifier|static
specifier|final
name|String
name|UPDATE_TGT_ALIAS
init|=
literal|"SYS$TGT"
decl_stmt|;
comment|/**    * Alias prefix generated for source columns when rewriting UPDATE to MERGE.    */
specifier|public
specifier|static
specifier|final
name|String
name|UPDATE_ANON_PREFIX
init|=
literal|"SYS$ANON"
decl_stmt|;
comment|//~ Enums ------------------------------------------------------------------
comment|/**    * Validation status.    */
specifier|public
enum|enum
name|Status
block|{
comment|/**      * Validation has not started for this scope.      */
name|Unvalidated
block|,
comment|/**      * Validation is in progress for this scope.      */
name|InProgress
block|,
comment|/**      * Validation has completed (perhaps unsuccessfully).      */
name|Valid
block|}
comment|//~ Instance fields --------------------------------------------------------
specifier|private
specifier|final
name|SqlOperatorTable
name|opTab
decl_stmt|;
specifier|final
name|SqlValidatorCatalogReader
name|catalogReader
decl_stmt|;
comment|/**    * Maps ParsePosition strings to the {@link SqlIdentifier} identifier    * objects at these positions    */
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|IdInfo
argument_list|>
name|idPositions
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|IdInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Maps {@link SqlNode query node} objects to the {@link SqlValidatorScope}    * scope created from them}.    */
specifier|protected
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|SqlValidatorScope
argument_list|>
name|scopes
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|SqlNode
argument_list|,
name|SqlValidatorScope
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Maps a {@link SqlSelect} node to the scope used by its WHERE and HAVING    * clauses.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlSelect
argument_list|,
name|SqlValidatorScope
argument_list|>
name|whereScopes
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|SqlSelect
argument_list|,
name|SqlValidatorScope
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Maps a {@link SqlSelect} node to the scope used by its SELECT and HAVING    * clauses.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlSelect
argument_list|,
name|SqlValidatorScope
argument_list|>
name|selectScopes
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|SqlSelect
argument_list|,
name|SqlValidatorScope
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Maps a {@link SqlSelect} node to the scope used by its ORDER BY clause.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlSelect
argument_list|,
name|SqlValidatorScope
argument_list|>
name|orderScopes
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|SqlSelect
argument_list|,
name|SqlValidatorScope
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Maps a {@link SqlSelect} node that is the argument to a CURSOR    * constructor to the scope of the result of that select node    */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlSelect
argument_list|,
name|SqlValidatorScope
argument_list|>
name|cursorScopes
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|SqlSelect
argument_list|,
name|SqlValidatorScope
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Maps a {@link SqlNode node} to the {@link SqlValidatorNamespace    * namespace} which describes what columns they contain.    */
specifier|protected
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|SqlValidatorNamespace
argument_list|>
name|namespaces
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|SqlNode
argument_list|,
name|SqlValidatorNamespace
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Set of select expressions used as cursor definitions. In standard SQL,    * only the top-level SELECT is a cursor; Eigenbase extends this with    * cursors as inputs to table functions.    */
specifier|private
specifier|final
name|Set
argument_list|<
name|SqlNode
argument_list|>
name|cursorSet
init|=
operator|new
name|IdentityHashSet
argument_list|<
name|SqlNode
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Stack of objects that maintain information about function calls. A stack    * is needed to handle nested function calls. The function call currently    * being validated is at the top of the stack.    */
specifier|protected
specifier|final
name|Stack
argument_list|<
name|FunctionParamInfo
argument_list|>
name|functionCallStack
init|=
operator|new
name|Stack
argument_list|<
name|FunctionParamInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|int
name|nextGeneratedId
decl_stmt|;
specifier|protected
specifier|final
name|RelDataTypeFactory
name|typeFactory
decl_stmt|;
specifier|protected
specifier|final
name|RelDataType
name|unknownType
decl_stmt|;
specifier|private
specifier|final
name|RelDataType
name|booleanType
decl_stmt|;
comment|/**    * Map of derived RelDataType for each node. This is an IdentityHashMap    * since in some cases (such as null literals) we need to discriminate by    * instance.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|RelDataType
argument_list|>
name|nodeToTypeMap
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|SqlNode
argument_list|,
name|RelDataType
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|AggFinder
name|aggFinder
init|=
operator|new
name|AggFinder
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AggFinder
name|aggOrOverFinder
init|=
operator|new
name|AggFinder
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|SqlConformance
name|conformance
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|SqlNode
argument_list|>
name|originalExprs
init|=
operator|new
name|HashMap
argument_list|<
name|SqlNode
argument_list|,
name|SqlNode
argument_list|>
argument_list|()
decl_stmt|;
comment|// REVIEW jvs 30-June-2006: subclasses may override shouldExpandIdentifiers
comment|// in a way that ignores this; we should probably get rid of the protected
comment|// method and always use this variable (or better, move preferences like
comment|// this to a separate "parameter" class)
specifier|protected
name|boolean
name|expandIdentifiers
decl_stmt|;
specifier|protected
name|boolean
name|expandColumnReferences
decl_stmt|;
specifier|private
name|boolean
name|rewriteCalls
decl_stmt|;
comment|// TODO jvs 11-Dec-2008:  make this local to performUnconditionalRewrites
comment|// if it's OK to expand the signature of that method.
specifier|private
name|boolean
name|validatingSqlMerge
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a validator.    *    * @param opTab         Operator table    * @param catalogReader Catalog reader    * @param typeFactory   Type factory    * @param conformance   Compatibility mode    */
specifier|protected
name|SqlValidatorImpl
parameter_list|(
name|SqlOperatorTable
name|opTab
parameter_list|,
name|SqlValidatorCatalogReader
name|catalogReader
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|SqlConformance
name|conformance
parameter_list|)
block|{
name|Linq4j
operator|.
name|requireNonNull
argument_list|(
name|opTab
argument_list|)
expr_stmt|;
name|Linq4j
operator|.
name|requireNonNull
argument_list|(
name|catalogReader
argument_list|)
expr_stmt|;
name|Linq4j
operator|.
name|requireNonNull
argument_list|(
name|typeFactory
argument_list|)
expr_stmt|;
name|Linq4j
operator|.
name|requireNonNull
argument_list|(
name|conformance
argument_list|)
expr_stmt|;
name|this
operator|.
name|opTab
operator|=
name|opTab
expr_stmt|;
name|this
operator|.
name|catalogReader
operator|=
name|catalogReader
expr_stmt|;
name|this
operator|.
name|typeFactory
operator|=
name|typeFactory
expr_stmt|;
name|this
operator|.
name|conformance
operator|=
name|conformance
expr_stmt|;
comment|// NOTE jvs 23-Dec-2003:  This is used as the type for dynamic
comment|// parameters and null literals until a real type is imposed for them.
name|unknownType
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
expr_stmt|;
name|booleanType
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
expr_stmt|;
name|rewriteCalls
operator|=
literal|true
expr_stmt|;
name|expandColumnReferences
operator|=
literal|true
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|public
name|SqlConformance
name|getConformance
parameter_list|()
block|{
return|return
name|conformance
return|;
block|}
specifier|public
name|SqlValidatorCatalogReader
name|getCatalogReader
parameter_list|()
block|{
return|return
name|catalogReader
return|;
block|}
specifier|public
name|SqlOperatorTable
name|getOperatorTable
parameter_list|()
block|{
return|return
name|opTab
return|;
block|}
specifier|public
name|RelDataTypeFactory
name|getTypeFactory
parameter_list|()
block|{
return|return
name|typeFactory
return|;
block|}
specifier|public
name|RelDataType
name|getUnknownType
parameter_list|()
block|{
return|return
name|unknownType
return|;
block|}
specifier|public
name|SqlNodeList
name|expandStar
parameter_list|(
name|SqlNodeList
name|selectList
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|boolean
name|includeSystemVars
parameter_list|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|SqlNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SqlNode
name|selectItem
init|=
name|selectList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|expandSelectItem
argument_list|(
name|selectItem
argument_list|,
name|select
argument_list|,
name|list
argument_list|,
operator|new
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
name|types
argument_list|,
name|includeSystemVars
argument_list|)
expr_stmt|;
block|}
name|getRawSelectScope
argument_list|(
name|select
argument_list|)
operator|.
name|setExpandedSelectList
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|new
name|SqlNodeList
argument_list|(
name|list
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
comment|// implement SqlValidator
specifier|public
name|void
name|declareCursor
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlValidatorScope
name|parentScope
parameter_list|)
block|{
name|cursorSet
operator|.
name|add
argument_list|(
name|select
argument_list|)
expr_stmt|;
comment|// add the cursor to a map that maps the cursor to its select based on
comment|// the position of the cursor relative to other cursors in that call
name|FunctionParamInfo
name|funcParamInfo
init|=
name|functionCallStack
operator|.
name|peek
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|SqlSelect
argument_list|>
name|cursorMap
init|=
name|funcParamInfo
operator|.
name|cursorPosToSelectMap
decl_stmt|;
name|int
name|numCursors
init|=
name|cursorMap
operator|.
name|size
argument_list|()
decl_stmt|;
name|cursorMap
operator|.
name|put
argument_list|(
name|numCursors
argument_list|,
name|select
argument_list|)
expr_stmt|;
comment|// create a namespace associated with the result of the select
comment|// that is the argument to the cursor constructor; register it
comment|// with a scope corresponding to the cursor
name|SelectScope
name|cursorScope
init|=
operator|new
name|SelectScope
argument_list|(
name|parentScope
argument_list|,
literal|null
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|cursorScopes
operator|.
name|put
argument_list|(
name|select
argument_list|,
name|cursorScope
argument_list|)
expr_stmt|;
specifier|final
name|SelectNamespace
name|selectNs
init|=
name|createSelectNamespace
argument_list|(
name|select
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|deriveAlias
argument_list|(
name|select
argument_list|,
name|nextGeneratedId
operator|++
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|cursorScope
argument_list|,
name|alias
argument_list|,
name|selectNs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// implement SqlValidator
specifier|public
name|void
name|pushFunctionCall
parameter_list|()
block|{
name|FunctionParamInfo
name|funcInfo
init|=
operator|new
name|FunctionParamInfo
argument_list|()
decl_stmt|;
name|functionCallStack
operator|.
name|push
argument_list|(
name|funcInfo
argument_list|)
expr_stmt|;
block|}
comment|// implement SqlValidator
specifier|public
name|void
name|popFunctionCall
parameter_list|()
block|{
name|functionCallStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
comment|// implement SqlValidator
specifier|public
name|String
name|getParentCursor
parameter_list|(
name|String
name|columnListParamName
parameter_list|)
block|{
name|FunctionParamInfo
name|funcParamInfo
init|=
name|functionCallStack
operator|.
name|peek
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|parentCursorMap
init|=
name|funcParamInfo
operator|.
name|columnListParamToParentCursorMap
decl_stmt|;
return|return
name|parentCursorMap
operator|.
name|get
argument_list|(
name|columnListParamName
argument_list|)
return|;
block|}
comment|/**    * If<code>selectItem</code> is "*" or "TABLE.*", expands it and returns    * true; otherwise writes the unexpanded item.    *    * @param selectItem        Select-list item    * @param select            Containing select clause    * @param selectItems       List that expanded items are written to    * @param aliases           Set of aliases    * @param types             List of data types in alias order    * @param includeSystemVars If true include system vars in lists    * @return Whether the node was expanded    */
specifier|private
name|boolean
name|expandSelectItem
parameter_list|(
specifier|final
name|SqlNode
name|selectItem
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectItems
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|,
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|types
parameter_list|,
specifier|final
name|boolean
name|includeSystemVars
parameter_list|)
block|{
specifier|final
name|SelectScope
name|scope
init|=
operator|(
name|SelectScope
operator|)
name|getWhereScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectItem
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|SqlIdentifier
name|identifier
init|=
operator|(
name|SqlIdentifier
operator|)
name|selectItem
decl_stmt|;
if|if
condition|(
operator|(
name|identifier
operator|.
name|names
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|&&
name|identifier
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|SqlParserPos
name|starPosition
init|=
name|identifier
operator|.
name|getParserPosition
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|String
argument_list|,
name|SqlValidatorNamespace
argument_list|>
name|p
range|:
name|scope
operator|.
name|children
control|)
block|{
specifier|final
name|SqlNode
name|from
init|=
name|p
operator|.
name|right
operator|.
name|getNode
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|fromNs
init|=
name|getNamespace
argument_list|(
name|from
argument_list|)
decl_stmt|;
assert|assert
name|fromNs
operator|!=
literal|null
assert|;
specifier|final
name|RelDataType
name|rowType
init|=
name|fromNs
operator|.
name|getRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|String
name|columnName
init|=
name|field
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// TODO: do real implicit collation here
specifier|final
name|SqlNode
name|exp
init|=
operator|new
name|SqlIdentifier
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|p
operator|.
name|left
argument_list|,
name|columnName
argument_list|)
argument_list|,
name|starPosition
argument_list|)
decl_stmt|;
name|addToSelectList
argument_list|(
name|selectItems
argument_list|,
name|aliases
argument_list|,
name|types
argument_list|,
name|exp
argument_list|,
name|scope
argument_list|,
name|includeSystemVars
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
if|else if
condition|(
name|identifier
operator|.
name|names
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|&&
name|identifier
operator|.
name|names
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
specifier|final
name|String
name|tableName
init|=
name|identifier
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|SqlParserPos
name|starPosition
init|=
name|identifier
operator|.
name|getParserPosition
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|childNs
init|=
name|scope
operator|.
name|getChild
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|childNs
operator|==
literal|null
condition|)
block|{
comment|// e.g. "select r.* from e"
throw|throw
name|newValidationError
argument_list|(
name|identifier
operator|.
name|getComponent
argument_list|(
literal|0
argument_list|)
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|UnknownIdentifier
operator|.
name|ex
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
specifier|final
name|SqlNode
name|from
init|=
name|childNs
operator|.
name|getNode
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|fromNs
init|=
name|getNamespace
argument_list|(
name|from
argument_list|)
decl_stmt|;
assert|assert
name|fromNs
operator|!=
literal|null
assert|;
specifier|final
name|RelDataType
name|rowType
init|=
name|fromNs
operator|.
name|getRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|String
name|columnName
init|=
name|field
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// TODO: do real implicit collation here
specifier|final
name|SqlIdentifier
name|exp
init|=
operator|new
name|SqlIdentifier
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|tableName
argument_list|,
name|columnName
argument_list|)
argument_list|,
name|starPosition
argument_list|)
decl_stmt|;
name|addToSelectList
argument_list|(
name|selectItems
argument_list|,
name|aliases
argument_list|,
name|types
argument_list|,
name|exp
argument_list|,
name|scope
argument_list|,
name|includeSystemVars
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|// Expand the select item: fully-qualify columns, and convert
comment|// parentheses-free functions such as LOCALTIME into explicit function
comment|// calls.
name|SqlNode
name|expanded
init|=
name|expand
argument_list|(
name|selectItem
argument_list|,
name|scope
argument_list|)
decl_stmt|;
specifier|final
name|String
name|alias
init|=
name|deriveAlias
argument_list|(
name|selectItem
argument_list|,
name|aliases
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// If expansion has altered the natural alias, supply an explicit 'AS'.
if|if
condition|(
name|expanded
operator|!=
name|selectItem
condition|)
block|{
name|String
name|newAlias
init|=
name|deriveAlias
argument_list|(
name|expanded
argument_list|,
name|aliases
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newAlias
operator|.
name|equals
argument_list|(
name|alias
argument_list|)
condition|)
block|{
name|expanded
operator|=
name|SqlStdOperatorTable
operator|.
name|asOperator
operator|.
name|createCall
argument_list|(
name|selectItem
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|expanded
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|alias
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|deriveTypeImpl
argument_list|(
name|scope
argument_list|,
name|expanded
argument_list|)
expr_stmt|;
block|}
block|}
name|selectItems
operator|.
name|add
argument_list|(
name|expanded
argument_list|)
expr_stmt|;
name|aliases
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|selectItem
argument_list|)
decl_stmt|;
name|setValidatedNodeTypeImpl
argument_list|(
name|selectItem
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|alias
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|public
name|SqlNode
name|validate
parameter_list|(
name|SqlNode
name|topNode
parameter_list|)
block|{
name|SqlValidatorScope
name|scope
init|=
operator|new
name|EmptyScope
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|topNode2
init|=
name|validateScopedExpression
argument_list|(
name|topNode
argument_list|,
name|scope
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|getValidatedNodeType
argument_list|(
name|topNode2
argument_list|)
decl_stmt|;
name|Util
operator|.
name|discard
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|topNode2
return|;
block|}
specifier|public
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|lookupHints
parameter_list|(
name|SqlNode
name|topNode
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
name|SqlValidatorScope
name|scope
init|=
operator|new
name|EmptyScope
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|SqlNode
name|outermostNode
init|=
name|performUnconditionalRewrites
argument_list|(
name|topNode
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|cursorSet
operator|.
name|add
argument_list|(
name|outermostNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|outermostNode
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|TOP_LEVEL
argument_list|)
condition|)
block|{
name|registerQuery
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
name|outermostNode
argument_list|,
name|outermostNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|outermostNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Not a query: "
operator|+
name|outermostNode
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
init|=
operator|new
name|ArrayList
argument_list|<
name|SqlMoniker
argument_list|>
argument_list|()
decl_stmt|;
name|lookupSelectHints
argument_list|(
name|ns
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
return|return
name|hintList
return|;
block|}
specifier|public
name|SqlMoniker
name|lookupQualifiedName
parameter_list|(
name|SqlNode
name|topNode
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
specifier|final
name|String
name|posString
init|=
name|pos
operator|.
name|toString
argument_list|()
decl_stmt|;
name|IdInfo
name|info
init|=
name|idPositions
operator|.
name|get
argument_list|(
name|posString
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|SqlIdentifierMoniker
argument_list|(
name|info
operator|.
name|scope
operator|.
name|fullyQualify
argument_list|(
name|info
operator|.
name|id
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Looks up completion hints for a syntactically correct select SQL that has    * been parsed into an expression tree.    *    * @param select   the Select node of the parsed expression tree    * @param pos      indicates the position in the sql statement we want to get    *                 completion hints for    * @param hintList list of {@link SqlMoniker} (sql identifiers) that can    *                 fill in at the indicated position    */
name|void
name|lookupSelectHints
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
parameter_list|)
block|{
name|IdInfo
name|info
init|=
name|idPositions
operator|.
name|get
argument_list|(
name|pos
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|info
operator|==
literal|null
operator|)
operator|||
operator|(
name|info
operator|.
name|scope
operator|==
literal|null
operator|)
condition|)
block|{
name|SqlNode
name|fromNode
init|=
name|select
operator|.
name|getFrom
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|fromScope
init|=
name|getFromScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|lookupFromHints
argument_list|(
name|fromNode
argument_list|,
name|fromScope
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lookupNameCompletionHints
argument_list|(
name|info
operator|.
name|scope
argument_list|,
name|info
operator|.
name|id
operator|.
name|names
argument_list|,
name|info
operator|.
name|id
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|lookupSelectHints
parameter_list|(
name|SqlValidatorNamespace
name|ns
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
parameter_list|)
block|{
specifier|final
name|SqlNode
name|node
init|=
name|ns
operator|.
name|getNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|SqlSelect
condition|)
block|{
name|lookupSelectHints
argument_list|(
operator|(
name|SqlSelect
operator|)
name|node
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|lookupFromHints
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
parameter_list|)
block|{
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|.
name|isWrapperFor
argument_list|(
name|IdentifierNamespace
operator|.
name|class
argument_list|)
condition|)
block|{
name|IdentifierNamespace
name|idNs
init|=
name|ns
operator|.
name|unwrap
argument_list|(
name|IdentifierNamespace
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|SqlIdentifier
name|id
init|=
name|idNs
operator|.
name|getId
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|id
operator|.
name|names
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pos
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|id
operator|.
name|getComponent
argument_list|(
name|i
argument_list|)
operator|.
name|getParserPosition
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|objNames
init|=
operator|new
name|ArrayList
argument_list|<
name|SqlMoniker
argument_list|>
argument_list|()
decl_stmt|;
name|SqlValidatorUtil
operator|.
name|getSchemaObjectMonikers
argument_list|(
name|getCatalogReader
argument_list|()
argument_list|,
name|id
operator|.
name|names
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|objNames
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlMoniker
name|objName
range|:
name|objNames
control|)
block|{
if|if
condition|(
name|objName
operator|.
name|getType
argument_list|()
operator|!=
name|SqlMonikerType
operator|.
name|Function
condition|)
block|{
name|hintList
operator|.
name|add
argument_list|(
name|objName
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
block|}
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|JOIN
case|:
name|lookupJoinHints
argument_list|(
operator|(
name|SqlJoin
operator|)
name|node
argument_list|,
name|scope
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lookupSelectHints
argument_list|(
name|ns
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
specifier|private
name|void
name|lookupJoinHints
parameter_list|(
name|SqlJoin
name|join
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
parameter_list|)
block|{
name|SqlNode
name|left
init|=
name|join
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|SqlNode
name|right
init|=
name|join
operator|.
name|getRight
argument_list|()
decl_stmt|;
name|SqlNode
name|condition
init|=
name|join
operator|.
name|getCondition
argument_list|()
decl_stmt|;
name|lookupFromHints
argument_list|(
name|left
argument_list|,
name|scope
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
if|if
condition|(
name|hintList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return;
block|}
name|lookupFromHints
argument_list|(
name|right
argument_list|,
name|scope
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
if|if
condition|(
name|hintList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return;
block|}
name|SqlJoinOperator
operator|.
name|ConditionType
name|conditionType
init|=
name|join
operator|.
name|getConditionType
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|joinScope
init|=
name|scopes
operator|.
name|get
argument_list|(
name|join
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|conditionType
condition|)
block|{
case|case
name|On
case|:
name|condition
operator|.
name|findValidOptions
argument_list|(
name|this
argument_list|,
name|joinScope
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|// No suggestions.
comment|// Not supporting hints for other types such as 'Using' yet.
return|return;
block|}
block|}
comment|/**    * Populates a list of all the valid alternatives for an identifier.    *    * @param scope    Validation scope    * @param names    Components of the identifier    * @param pos      position    * @param hintList a list of valid options    */
specifier|public
specifier|final
name|void
name|lookupNameCompletionHints
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
parameter_list|)
block|{
comment|// Remove the last part of name - it is a dummy
name|List
argument_list|<
name|String
argument_list|>
name|subNames
init|=
name|Util
operator|.
name|skipLast
argument_list|(
name|names
argument_list|)
decl_stmt|;
if|if
condition|(
name|subNames
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// If there's a prefix, resolve it to a namespace.
name|SqlValidatorNamespace
name|ns
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|subNames
control|)
block|{
if|if
condition|(
name|ns
operator|==
literal|null
condition|)
block|{
name|ns
operator|=
name|scope
operator|.
name|resolve
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns
operator|=
name|ns
operator|.
name|lookupChild
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ns
operator|==
literal|null
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
name|RelDataType
name|rowType
init|=
name|ns
operator|.
name|getRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|hintList
operator|.
name|add
argument_list|(
operator|new
name|SqlMonikerImpl
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|SqlMonikerType
operator|.
name|Column
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// builtin function names are valid completion hints when the
comment|// identifier has only 1 name part
name|findAllValidFunctionNames
argument_list|(
name|names
argument_list|,
name|this
argument_list|,
name|hintList
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No prefix; use the children of the current scope (that is,
comment|// the aliases in the FROM clause)
name|scope
operator|.
name|findAliases
argument_list|(
name|hintList
argument_list|)
expr_stmt|;
comment|// If there's only one alias, add all child columns
name|SelectScope
name|selectScope
init|=
name|SqlValidatorUtil
operator|.
name|getEnclosingSelectScope
argument_list|(
name|scope
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|selectScope
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|selectScope
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
condition|)
block|{
name|RelDataType
name|rowType
init|=
name|selectScope
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|hintList
operator|.
name|add
argument_list|(
operator|new
name|SqlMonikerImpl
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|SqlMonikerType
operator|.
name|Column
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|findAllValidUdfNames
argument_list|(
name|names
argument_list|,
name|this
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|findAllValidUdfNames
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|,
name|SqlValidator
name|validator
parameter_list|,
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|result
parameter_list|)
block|{
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|objNames
init|=
operator|new
name|ArrayList
argument_list|<
name|SqlMoniker
argument_list|>
argument_list|()
decl_stmt|;
name|SqlValidatorUtil
operator|.
name|getSchemaObjectMonikers
argument_list|(
name|validator
operator|.
name|getCatalogReader
argument_list|()
argument_list|,
name|names
argument_list|,
name|objNames
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlMoniker
name|objName
range|:
name|objNames
control|)
block|{
if|if
condition|(
name|objName
operator|.
name|getType
argument_list|()
operator|==
name|SqlMonikerType
operator|.
name|Function
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|objName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|findAllValidFunctionNames
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|,
name|SqlValidator
name|validator
parameter_list|,
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|result
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
comment|// a function name can only be 1 part
if|if
condition|(
name|names
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
return|return;
block|}
for|for
control|(
name|SqlOperator
name|op
range|:
name|validator
operator|.
name|getOperatorTable
argument_list|()
operator|.
name|getOperatorList
argument_list|()
control|)
block|{
name|SqlIdentifier
name|curOpId
init|=
operator|new
name|SqlIdentifier
argument_list|(
name|op
operator|.
name|getName
argument_list|()
argument_list|,
name|pos
argument_list|)
decl_stmt|;
specifier|final
name|SqlCall
name|call
init|=
name|SqlUtil
operator|.
name|makeCall
argument_list|(
name|validator
operator|.
name|getOperatorTable
argument_list|()
argument_list|,
name|curOpId
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|new
name|SqlMonikerImpl
argument_list|(
name|op
operator|.
name|getName
argument_list|()
argument_list|,
name|SqlMonikerType
operator|.
name|Function
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|op
operator|.
name|getSyntax
argument_list|()
operator|==
name|SqlSyntax
operator|.
name|Function
operator|)
operator|||
operator|(
name|op
operator|.
name|getSyntax
argument_list|()
operator|==
name|SqlSyntax
operator|.
name|Prefix
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getOperandTypeChecker
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|String
name|sig
init|=
name|op
operator|.
name|getAllowedSignatures
argument_list|()
decl_stmt|;
name|sig
operator|=
name|sig
operator|.
name|replaceAll
argument_list|(
literal|"'"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|SqlMonikerImpl
argument_list|(
name|sig
argument_list|,
name|SqlMonikerType
operator|.
name|Function
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|result
operator|.
name|add
argument_list|(
operator|new
name|SqlMonikerImpl
argument_list|(
name|op
operator|.
name|getName
argument_list|()
argument_list|,
name|SqlMonikerType
operator|.
name|Function
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|SqlNode
name|validateParameterizedExpression
parameter_list|(
name|SqlNode
name|topNode
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|nameToTypeMap
parameter_list|)
block|{
name|SqlValidatorScope
name|scope
init|=
operator|new
name|ParameterScope
argument_list|(
name|this
argument_list|,
name|nameToTypeMap
argument_list|)
decl_stmt|;
return|return
name|validateScopedExpression
argument_list|(
name|topNode
argument_list|,
name|scope
argument_list|)
return|;
block|}
specifier|private
name|SqlNode
name|validateScopedExpression
parameter_list|(
name|SqlNode
name|topNode
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|SqlNode
name|outermostNode
init|=
name|performUnconditionalRewrites
argument_list|(
name|topNode
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|cursorSet
operator|.
name|add
argument_list|(
name|outermostNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRACER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINER
argument_list|)
condition|)
block|{
name|TRACER
operator|.
name|finer
argument_list|(
literal|"After unconditional rewrite: "
operator|+
name|outermostNode
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outermostNode
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|TOP_LEVEL
argument_list|)
condition|)
block|{
name|registerQuery
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
name|outermostNode
argument_list|,
name|outermostNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|outermostNode
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outermostNode
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|TOP_LEVEL
argument_list|)
condition|)
block|{
comment|// force type derivation so that we can provide it to the
comment|// caller later without needing the scope
name|deriveType
argument_list|(
name|scope
argument_list|,
name|outermostNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TRACER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINER
argument_list|)
condition|)
block|{
name|TRACER
operator|.
name|finer
argument_list|(
literal|"After validation: "
operator|+
name|outermostNode
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|outermostNode
return|;
block|}
specifier|public
name|void
name|validateQuery
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Not a query: "
operator|+
name|node
argument_list|)
throw|;
block|}
if|if
condition|(
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|TABLESAMPLE
condition|)
block|{
name|SqlNode
index|[]
name|operands
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operands
decl_stmt|;
name|SqlSampleSpec
name|sampleSpec
init|=
name|SqlLiteral
operator|.
name|sampleValue
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|sampleSpec
operator|instanceof
name|SqlSampleSpec
operator|.
name|SqlTableSampleSpec
condition|)
block|{
name|validateFeature
argument_list|(
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|SQLFeature_T613
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|sampleSpec
operator|instanceof
name|SqlSampleSpec
operator|.
name|SqlSubstitutionSampleSpec
condition|)
block|{
name|validateFeature
argument_list|(
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|SQLFeatureExt_T613_Substitution
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|validateNamespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|validateAccess
argument_list|(
name|node
argument_list|,
name|ns
operator|.
name|getTable
argument_list|()
argument_list|,
name|SqlAccessEnum
operator|.
name|SELECT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validates a namespace.    */
specifier|protected
name|void
name|validateNamespace
parameter_list|(
specifier|final
name|SqlValidatorNamespace
name|namespace
parameter_list|)
block|{
name|namespace
operator|.
name|validate
argument_list|()
expr_stmt|;
name|setValidatedNodeType
argument_list|(
name|namespace
operator|.
name|getNode
argument_list|()
argument_list|,
name|namespace
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|SqlValidatorScope
name|getCursorScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
return|return
name|cursorScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getWhereScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
return|return
name|whereScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getSelectScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
return|return
name|selectScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SelectScope
name|getRawSelectScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
name|SqlValidatorScope
name|scope
init|=
name|getSelectScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
if|if
condition|(
name|scope
operator|instanceof
name|AggregatingSelectScope
condition|)
block|{
name|scope
operator|=
operator|(
operator|(
name|AggregatingSelectScope
operator|)
name|scope
operator|)
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|SelectScope
operator|)
name|scope
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getHavingScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
comment|// Yes, it's the same as getSelectScope
return|return
name|selectScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getGroupScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
comment|// Yes, it's the same as getWhereScope
return|return
name|whereScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getFromScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
return|return
name|scopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getOrderScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
return|return
name|orderScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getJoinScope
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
return|return
name|getJoinScope
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
return|;
default|default:
return|return
name|scopes
operator|.
name|get
argument_list|(
name|node
argument_list|)
return|;
block|}
block|}
specifier|public
name|SqlValidatorScope
name|getOverScope
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
return|return
name|scopes
operator|.
name|get
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/**    * Returns the appropriate scope for validating a particular clause of a    * SELECT statement.    *    *<p>Consider SELECT * FROM foo WHERE EXISTS ( SELECT deptno AS x FROM emp,    * dept WHERE emp.deptno = 5 GROUP BY deptno ORDER BY x) In FROM, you can    * only see 'foo'. In WHERE, GROUP BY and SELECT, you can see 'emp', 'dept',    * and 'foo'. In ORDER BY, you can see the column alias 'x', 'emp', 'dept',    * and 'foo'.    */
specifier|public
name|SqlValidatorScope
name|getScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|int
name|operandType
parameter_list|)
block|{
switch|switch
condition|(
name|operandType
condition|)
block|{
case|case
name|SqlSelect
operator|.
name|FROM_OPERAND
case|:
return|return
name|scopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
case|case
name|SqlSelect
operator|.
name|WHERE_OPERAND
case|:
case|case
name|SqlSelect
operator|.
name|GROUP_OPERAND
case|:
return|return
name|whereScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
case|case
name|SqlSelect
operator|.
name|HAVING_OPERAND
case|:
case|case
name|SqlSelect
operator|.
name|SELECT_OPERAND
case|:
return|return
name|selectScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
case|case
name|SqlSelect
operator|.
name|ORDER_OPERAND
case|:
return|return
name|orderScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Unexpected operandType "
operator|+
name|operandType
argument_list|)
throw|;
block|}
block|}
specifier|public
name|SqlValidatorNamespace
name|getNamespace
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
comment|// AS has a namespace if it has a column list 'AS t (c1, c2, ...)'
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|namespaces
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
return|return
name|ns
return|;
block|}
comment|// fall through
case|case
name|OVER
case|:
case|case
name|COLLECTION_TABLE
case|:
case|case
name|ORDER_BY
case|:
case|case
name|TABLESAMPLE
case|:
return|return
name|getNamespace
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
return|;
default|default:
return|return
name|namespaces
operator|.
name|get
argument_list|(
name|node
argument_list|)
return|;
block|}
block|}
comment|/**    * Performs expression rewrites which are always used unconditionally. These    * rewrites massage the expression tree into a standard form so that the    * rest of the validation logic can be simpler.    *    * @param node      expression to be rewritten    * @param underFrom whether node appears directly under a FROM clause    * @return rewritten expression    */
specifier|protected
name|SqlNode
name|performUnconditionalRewrites
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|boolean
name|underFrom
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
name|node
return|;
block|}
name|SqlNode
name|newOperand
decl_stmt|;
comment|// first transform operands and invoke generic call rewrite
if|if
condition|(
name|node
operator|instanceof
name|SqlCall
condition|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlMerge
condition|)
block|{
name|validatingSqlMerge
operator|=
literal|true
expr_stmt|;
block|}
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
specifier|final
name|SqlKind
name|kind
init|=
name|call
operator|.
name|getKind
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|operand
init|=
name|operands
index|[
name|i
index|]
decl_stmt|;
name|boolean
name|childUnderFrom
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|SqlKind
operator|.
name|SELECT
condition|)
block|{
name|childUnderFrom
operator|=
name|i
operator|==
name|SqlSelect
operator|.
name|FROM_OPERAND
expr_stmt|;
block|}
if|else if
condition|(
name|kind
operator|==
name|SqlKind
operator|.
name|AS
operator|&&
operator|(
name|i
operator|==
literal|0
operator|)
condition|)
block|{
comment|// for an aliased expression, it is under FROM if
comment|// the AS expression is under FROM
name|childUnderFrom
operator|=
name|underFrom
expr_stmt|;
block|}
else|else
block|{
name|childUnderFrom
operator|=
literal|false
expr_stmt|;
block|}
name|newOperand
operator|=
name|performUnconditionalRewrites
argument_list|(
name|operand
argument_list|,
name|childUnderFrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|newOperand
operator|!=
literal|null
condition|)
block|{
name|call
operator|.
name|setOperand
argument_list|(
name|i
argument_list|,
name|newOperand
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlFunction
condition|)
block|{
name|SqlFunction
name|function
init|=
operator|(
name|SqlFunction
operator|)
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|function
operator|.
name|getFunctionType
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// This function hasn't been resolved yet.  Perform
comment|// a half-hearted resolution now in case it's a
comment|// builtin function requiring special casing.  If it's
comment|// not, we'll handle it later during overload
comment|// resolution.
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|overloads
init|=
name|opTab
operator|.
name|lookupOperatorOverloads
argument_list|(
name|function
operator|.
name|getNameAsId
argument_list|()
argument_list|,
literal|null
argument_list|,
name|SqlSyntax
operator|.
name|Function
argument_list|)
decl_stmt|;
if|if
condition|(
name|overloads
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|call
operator|.
name|setOperator
argument_list|(
name|overloads
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rewriteCalls
condition|)
block|{
name|node
operator|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|rewriteCall
argument_list|(
name|this
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlNodeList
condition|)
block|{
name|SqlNodeList
name|list
init|=
operator|(
name|SqlNodeList
operator|)
name|node
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|count
init|=
name|list
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|operand
init|=
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newOperand
operator|=
name|performUnconditionalRewrites
argument_list|(
name|operand
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|newOperand
operator|!=
literal|null
condition|)
block|{
name|list
operator|.
name|getList
argument_list|()
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|newOperand
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// now transform node itself
specifier|final
name|SqlKind
name|kind
init|=
name|node
operator|.
name|getKind
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|VALUES
case|:
if|if
condition|(
name|underFrom
operator|||
literal|true
condition|)
block|{
comment|// leave FROM (VALUES(...)) [ AS alias ] clauses alone,
comment|// otherwise they grow cancerously if this rewrite is invoked
comment|// over and over
return|return
name|node
return|;
block|}
else|else
block|{
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
literal|"*"
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|selectOperator
operator|.
name|createCall
argument_list|(
literal|null
argument_list|,
name|selectList
argument_list|,
name|node
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
return|;
block|}
case|case
name|ORDER_BY
case|:
block|{
name|SqlCall
name|orderBy
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|orderBy
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|SqlNode
name|query
init|=
name|operands
index|[
name|SqlOrderByOperator
operator|.
name|QUERY_OPERAND
index|]
decl_stmt|;
name|SqlNodeList
name|orderList
init|=
operator|(
name|SqlNodeList
operator|)
name|operands
index|[
name|SqlOrderByOperator
operator|.
name|ORDER_OPERAND
index|]
decl_stmt|;
name|SqlNode
name|offset
init|=
name|operands
index|[
name|SqlOrderByOperator
operator|.
name|OFFSET_OPERAND
index|]
decl_stmt|;
name|SqlNode
name|fetch
init|=
name|operands
index|[
name|SqlOrderByOperator
operator|.
name|FETCH_OPERAND
index|]
decl_stmt|;
if|if
condition|(
name|query
operator|instanceof
name|SqlSelect
condition|)
block|{
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|query
decl_stmt|;
comment|// Don't clobber existing ORDER BY.  It may be needed for
comment|// an order-sensitive function like RANK.
if|if
condition|(
name|select
operator|.
name|getOrderList
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// push ORDER BY into existing select
name|select
operator|.
name|setOperand
argument_list|(
name|SqlSelect
operator|.
name|ORDER_OPERAND
argument_list|,
name|orderList
argument_list|)
expr_stmt|;
name|select
operator|.
name|setOperand
argument_list|(
name|SqlSelect
operator|.
name|OFFSET_OPERAND
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|select
operator|.
name|setOperand
argument_list|(
name|SqlSelect
operator|.
name|FETCH_OPERAND
argument_list|,
name|fetch
argument_list|)
expr_stmt|;
return|return
name|select
return|;
block|}
block|}
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
literal|"*"
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|selectOperator
operator|.
name|createCall
argument_list|(
literal|null
argument_list|,
name|selectList
argument_list|,
name|query
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|orderList
argument_list|,
name|offset
argument_list|,
name|fetch
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
case|case
name|EXPLICIT_TABLE
case|:
block|{
comment|// (TABLE t) is equivalent to (SELECT * FROM t)
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
literal|"*"
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|selectOperator
operator|.
name|createCall
argument_list|(
literal|null
argument_list|,
name|selectList
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
index|[
literal|0
index|]
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
case|case
name|DELETE
case|:
block|{
name|SqlDelete
name|call
init|=
operator|(
name|SqlDelete
operator|)
name|node
decl_stmt|;
name|SqlSelect
name|select
init|=
name|createSourceSelectForDelete
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|call
operator|.
name|setOperand
argument_list|(
name|SqlDelete
operator|.
name|SOURCE_SELECT_OPERAND
argument_list|,
name|select
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UPDATE
case|:
block|{
name|SqlUpdate
name|call
init|=
operator|(
name|SqlUpdate
operator|)
name|node
decl_stmt|;
name|SqlSelect
name|select
init|=
name|createSourceSelectForUpdate
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|call
operator|.
name|setOperand
argument_list|(
name|SqlUpdate
operator|.
name|SOURCE_SELECT_OPERAND
argument_list|,
name|select
argument_list|)
expr_stmt|;
comment|// See if we're supposed to rewrite UPDATE to MERGE
comment|// (unless this is the UPDATE clause of a MERGE,
comment|// in which case leave it alone).
if|if
condition|(
operator|!
name|validatingSqlMerge
condition|)
block|{
name|SqlNode
name|selfJoinSrcExpr
init|=
name|getSelfJoinExprForUpdate
argument_list|(
name|call
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|UPDATE_SRC_ALIAS
argument_list|)
decl_stmt|;
if|if
condition|(
name|selfJoinSrcExpr
operator|!=
literal|null
condition|)
block|{
name|node
operator|=
name|rewriteUpdateToMerge
argument_list|(
name|call
argument_list|,
name|selfJoinSrcExpr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|MERGE
case|:
block|{
name|SqlMerge
name|call
init|=
operator|(
name|SqlMerge
operator|)
name|node
decl_stmt|;
name|rewriteMerge
argument_list|(
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|node
return|;
block|}
specifier|private
name|void
name|rewriteMerge
parameter_list|(
name|SqlMerge
name|call
parameter_list|)
block|{
name|SqlNodeList
name|selectList
decl_stmt|;
name|SqlUpdate
name|updateStmt
init|=
name|call
operator|.
name|getUpdateCall
argument_list|()
decl_stmt|;
if|if
condition|(
name|updateStmt
operator|!=
literal|null
condition|)
block|{
comment|// if we have an update statement, just clone the select list
comment|// from the update statement's source since it's the same as
comment|// what we want for the select list of the merge source -- '*'
comment|// followed by the update set expressions
name|selectList
operator|=
operator|(
name|SqlNodeList
operator|)
name|updateStmt
operator|.
name|getSourceSelect
argument_list|()
operator|.
name|getSelectList
argument_list|()
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// otherwise, just use select *
name|selectList
operator|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|selectList
operator|.
name|add
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
literal|"*"
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SqlNode
name|targetTable
init|=
name|call
operator|.
name|getTargetTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|targetTable
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|targetTable
argument_list|,
name|call
operator|.
name|getAlias
argument_list|()
operator|.
name|getSimple
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Provided there is an insert substatement, the source select for
comment|// the merge is a left outer join between the source in the USING
comment|// clause and the target table; otherwise, the join is just an
comment|// inner join.  Need to clone the source table reference in order
comment|// for validation to work
name|SqlNode
name|sourceTableRef
init|=
name|call
operator|.
name|getSourceTableRef
argument_list|()
decl_stmt|;
name|SqlInsert
name|insertCall
init|=
name|call
operator|.
name|getInsertCall
argument_list|()
decl_stmt|;
name|SqlJoinOperator
operator|.
name|JoinType
name|joinType
init|=
operator|(
name|insertCall
operator|==
literal|null
operator|)
condition|?
name|SqlJoinOperator
operator|.
name|JoinType
operator|.
name|Inner
else|:
name|SqlJoinOperator
operator|.
name|JoinType
operator|.
name|Left
decl_stmt|;
name|SqlNode
name|leftJoinTerm
init|=
operator|(
name|SqlNode
operator|)
name|sourceTableRef
operator|.
name|clone
argument_list|()
decl_stmt|;
name|SqlNode
name|outerJoin
init|=
name|SqlStdOperatorTable
operator|.
name|joinOperator
operator|.
name|createCall
argument_list|(
name|leftJoinTerm
argument_list|,
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
literal|false
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|,
name|joinType
operator|.
name|symbol
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|,
name|targetTable
argument_list|,
name|SqlJoinOperator
operator|.
name|ConditionType
operator|.
name|On
operator|.
name|symbol
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|,
name|call
operator|.
name|getCondition
argument_list|()
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|SqlSelect
name|select
init|=
name|SqlStdOperatorTable
operator|.
name|selectOperator
operator|.
name|createCall
argument_list|(
literal|null
argument_list|,
name|selectList
argument_list|,
name|outerJoin
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|call
operator|.
name|setOperand
argument_list|(
name|SqlMerge
operator|.
name|SOURCE_SELECT_OPERAND
argument_list|,
name|select
argument_list|)
expr_stmt|;
comment|// Source for the insert call is a select of the source table
comment|// reference with the select list being the value expressions;
comment|// note that the values clause has already been converted to a
comment|// select on the values row constructor; so we need to extract
comment|// that via the from clause on the select
if|if
condition|(
name|insertCall
operator|!=
literal|null
condition|)
block|{
name|SqlSelect
name|valuesSelect
init|=
operator|(
name|SqlSelect
operator|)
name|insertCall
operator|.
name|getSource
argument_list|()
decl_stmt|;
name|SqlCall
name|valuesCall
init|=
operator|(
name|SqlCall
operator|)
name|valuesSelect
operator|.
name|getFrom
argument_list|()
decl_stmt|;
name|SqlCall
name|rowCall
init|=
operator|(
name|SqlCall
operator|)
name|valuesCall
operator|.
name|getOperands
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|selectList
operator|=
operator|new
name|SqlNodeList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|rowCall
operator|.
name|getOperands
argument_list|()
argument_list|)
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|SqlNode
name|insertSource
init|=
operator|(
name|SqlNode
operator|)
name|sourceTableRef
operator|.
name|clone
argument_list|()
decl_stmt|;
name|select
operator|=
name|SqlStdOperatorTable
operator|.
name|selectOperator
operator|.
name|createCall
argument_list|(
literal|null
argument_list|,
name|selectList
argument_list|,
name|insertSource
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|insertCall
operator|.
name|setOperand
argument_list|(
name|SqlInsert
operator|.
name|SOURCE_OPERAND
argument_list|,
name|select
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|SqlNode
name|rewriteUpdateToMerge
parameter_list|(
name|SqlUpdate
name|updateCall
parameter_list|,
name|SqlNode
name|selfJoinSrcExpr
parameter_list|)
block|{
comment|// Make sure target has an alias.
if|if
condition|(
name|updateCall
operator|.
name|getAlias
argument_list|()
operator|==
literal|null
condition|)
block|{
name|updateCall
operator|.
name|setOperand
argument_list|(
name|SqlUpdate
operator|.
name|ALIAS_OPERAND
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|UPDATE_TGT_ALIAS
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SqlNode
name|selfJoinTgtExpr
init|=
name|getSelfJoinExprForUpdate
argument_list|(
name|updateCall
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|updateCall
operator|.
name|getAlias
argument_list|()
operator|.
name|getSimple
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|selfJoinTgtExpr
operator|!=
literal|null
assert|;
comment|// Create join condition between source and target exprs,
comment|// creating a conjunction with the user-level WHERE
comment|// clause if one was supplied
name|SqlNode
name|condition
init|=
name|updateCall
operator|.
name|getCondition
argument_list|()
decl_stmt|;
name|SqlNode
name|selfJoinCond
init|=
name|SqlStdOperatorTable
operator|.
name|equalsOperator
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|selfJoinSrcExpr
argument_list|,
name|selfJoinTgtExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
name|condition
operator|=
name|selfJoinCond
expr_stmt|;
block|}
else|else
block|{
name|condition
operator|=
name|SqlStdOperatorTable
operator|.
name|andOperator
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|selfJoinCond
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
name|SqlIdentifier
name|target
init|=
operator|(
name|SqlIdentifier
operator|)
name|updateCall
operator|.
name|getTargetTable
argument_list|()
operator|.
name|clone
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
comment|// For the source, we need to anonymize the fields, so
comment|// that for a statement like UPDATE T SET I = I + 1,
comment|// there's no ambiguity for the "I" in "I + 1";
comment|// this is OK because the source and target have
comment|// identical values due to the self-join.
comment|// Note that we anonymize the source rather than the
comment|// target because downstream, the optimizer rules
comment|// don't want to see any projection on top of the target.
name|IdentifierNamespace
name|ns
init|=
operator|new
name|IdentifierNamespace
argument_list|(
name|this
argument_list|,
name|target
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|RelDataType
name|rowType
init|=
name|ns
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|SqlNode
name|source
init|=
name|updateCall
operator|.
name|getTargetTable
argument_list|()
operator|.
name|clone
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|SqlIdentifier
name|col
init|=
operator|new
name|SqlIdentifier
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|col
argument_list|,
name|UPDATE_ANON_PREFIX
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|source
operator|=
name|SqlStdOperatorTable
operator|.
name|selectOperator
operator|.
name|createCall
argument_list|(
literal|null
argument_list|,
name|selectList
argument_list|,
name|source
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|source
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|source
argument_list|,
name|UPDATE_SRC_ALIAS
argument_list|)
expr_stmt|;
name|SqlMerge
name|mergeCall
init|=
operator|new
name|SqlMerge
argument_list|(
name|SqlStdOperatorTable
operator|.
name|mergeOperator
argument_list|,
name|target
argument_list|,
name|condition
argument_list|,
name|source
argument_list|,
name|updateCall
argument_list|,
literal|null
argument_list|,
name|updateCall
operator|.
name|getAlias
argument_list|()
argument_list|,
name|updateCall
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
name|rewriteMerge
argument_list|(
name|mergeCall
argument_list|)
expr_stmt|;
return|return
name|mergeCall
return|;
block|}
comment|/**    * Allows a subclass to provide information about how to convert an UPDATE    * into a MERGE via self-join. If this method returns null, then no such    * conversion takes place. Otherwise, this method should return a suitable    * unique identifier expression for the given table.    *    * @param table identifier for table being updated    * @param alias alias to use for qualifying columns in expression, or null    *              for unqualified references; if this is equal to    *              {@value #UPDATE_SRC_ALIAS}, then column references have been    *              anonymized to "SYS$ANONx", where x is the 1-based column    *              number.    * @return expression for unique identifier, or null to prevent conversion    */
specifier|protected
name|SqlNode
name|getSelfJoinExprForUpdate
parameter_list|(
name|SqlIdentifier
name|table
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Creates the SELECT statement that putatively feeds rows into an UPDATE    * statement to be updated.    *    * @param call Call to the UPDATE operator    * @return select statement    */
specifier|protected
name|SqlSelect
name|createSourceSelectForUpdate
parameter_list|(
name|SqlUpdate
name|call
parameter_list|)
block|{
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
literal|"*"
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|ordinal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SqlNode
name|exp
range|:
name|call
operator|.
name|getSourceExpressionList
argument_list|()
control|)
block|{
comment|// Force unique aliases to avoid a duplicate for Y with
comment|// SET X=Y
name|String
name|alias
init|=
name|SqlUtil
operator|.
name|deriveAliasFromOrdinal
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|exp
argument_list|,
name|alias
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|ordinal
expr_stmt|;
block|}
name|SqlNode
name|sourceTable
init|=
name|call
operator|.
name|getTargetTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sourceTable
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|sourceTable
argument_list|,
name|call
operator|.
name|getAlias
argument_list|()
operator|.
name|getSimple
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|SqlStdOperatorTable
operator|.
name|selectOperator
operator|.
name|createCall
argument_list|(
literal|null
argument_list|,
name|selectList
argument_list|,
name|sourceTable
argument_list|,
name|call
operator|.
name|getCondition
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
comment|/**    * Creates the SELECT statement that putatively feeds rows into a DELETE    * statement to be deleted.    *    * @param call Call to the DELETE operator    * @return select statement    */
specifier|protected
name|SqlSelect
name|createSourceSelectForDelete
parameter_list|(
name|SqlDelete
name|call
parameter_list|)
block|{
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
literal|"*"
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|SqlNode
name|sourceTable
init|=
name|call
operator|.
name|getTargetTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sourceTable
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|sourceTable
argument_list|,
name|call
operator|.
name|getAlias
argument_list|()
operator|.
name|getSimple
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|SqlStdOperatorTable
operator|.
name|selectOperator
operator|.
name|createCall
argument_list|(
literal|null
argument_list|,
name|selectList
argument_list|,
name|sourceTable
argument_list|,
name|call
operator|.
name|getCondition
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
comment|/**    * Returns null if there is no common type. E.g. if the rows have a    * different number of columns.    */
name|RelDataType
name|getTableConstructorRowType
parameter_list|(
name|SqlCall
name|values
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
assert|assert
name|values
operator|.
name|getOperands
argument_list|()
operator|.
name|length
operator|>=
literal|1
assert|;
name|List
argument_list|<
name|RelDataType
argument_list|>
name|rowTypes
init|=
operator|new
name|ArrayList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|iRow
init|=
literal|0
init|;
name|iRow
operator|<
name|values
operator|.
name|getOperands
argument_list|()
operator|.
name|length
condition|;
operator|++
name|iRow
control|)
block|{
specifier|final
name|SqlNode
name|operand
init|=
name|values
operator|.
name|getOperands
argument_list|()
index|[
name|iRow
index|]
decl_stmt|;
assert|assert
name|operand
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ROW
assert|;
name|SqlCall
name|rowConstructor
init|=
operator|(
name|SqlCall
operator|)
name|operand
decl_stmt|;
comment|// REVIEW jvs 10-Sept-2003: Once we support single-row queries as
comment|// rows, need to infer aliases from there.
name|SqlNode
index|[]
name|operands
init|=
name|rowConstructor
operator|.
name|getOperands
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|aliasList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
init|=
operator|new
name|ArrayList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|iCol
init|=
literal|0
init|;
name|iCol
operator|<
name|operands
operator|.
name|length
condition|;
operator|++
name|iCol
control|)
block|{
specifier|final
name|String
name|alias
init|=
name|deriveAlias
argument_list|(
name|operands
index|[
name|iCol
index|]
argument_list|,
name|iCol
argument_list|)
decl_stmt|;
name|aliasList
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|operands
index|[
name|iCol
index|]
argument_list|)
decl_stmt|;
name|typeList
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|rowTypes
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|typeList
argument_list|,
name|aliasList
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|values
operator|.
name|getOperands
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
comment|// TODO jvs 10-Oct-2005:  get rid of this workaround once
comment|// leastRestrictive can handle all cases
return|return
name|rowTypes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|typeFactory
operator|.
name|leastRestrictive
argument_list|(
name|rowTypes
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|getValidatedNodeType
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|getValidatedNodeTypeIfKnown
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|node
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|type
return|;
block|}
block|}
specifier|public
name|RelDataType
name|getValidatedNodeTypeIfKnown
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|nodeToTypeMap
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
return|return
name|type
return|;
block|}
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
return|return
name|ns
operator|.
name|getRowType
argument_list|()
return|;
block|}
specifier|final
name|SqlNode
name|original
init|=
name|originalExprs
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|original
operator|!=
literal|null
condition|)
block|{
return|return
name|getValidatedNodeType
argument_list|(
name|original
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|void
name|setValidatedNodeType
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
name|setValidatedNodeTypeImpl
argument_list|(
name|node
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|removeValidatedNodeType
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
name|nodeToTypeMap
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|void
name|setValidatedNodeTypeImpl
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
name|Util
operator|.
name|pre
argument_list|(
name|type
operator|!=
literal|null
argument_list|,
literal|"type != null"
argument_list|)
expr_stmt|;
name|Util
operator|.
name|pre
argument_list|(
name|node
operator|!=
literal|null
argument_list|,
literal|"node != null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|unknownType
argument_list|)
condition|)
block|{
comment|// don't set anything until we know what it is, and don't overwrite
comment|// a known type with the unknown type
return|return;
block|}
name|nodeToTypeMap
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RelDataType
name|deriveType
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNode
name|expr
parameter_list|)
block|{
name|Util
operator|.
name|pre
argument_list|(
name|scope
operator|!=
literal|null
argument_list|,
literal|"scope != null"
argument_list|)
expr_stmt|;
name|Util
operator|.
name|pre
argument_list|(
name|expr
operator|!=
literal|null
argument_list|,
literal|"expr != null"
argument_list|)
expr_stmt|;
comment|// if we already know the type, no need to re-derive
name|RelDataType
name|type
init|=
name|nodeToTypeMap
operator|.
name|get
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
return|return
name|type
return|;
block|}
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
return|return
name|ns
operator|.
name|getRowType
argument_list|()
return|;
block|}
name|type
operator|=
name|deriveTypeImpl
argument_list|(
name|scope
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|Util
operator|.
name|permAssert
argument_list|(
name|type
operator|!=
literal|null
argument_list|,
literal|"SqlValidator.deriveTypeInternal returned null"
argument_list|)
expr_stmt|;
name|setValidatedNodeTypeImpl
argument_list|(
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/**    * Derives the type of a node.    *    * @post return != null    */
name|RelDataType
name|deriveTypeImpl
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNode
name|operand
parameter_list|)
block|{
name|DeriveTypeVisitor
name|v
init|=
operator|new
name|DeriveTypeVisitor
argument_list|(
name|scope
argument_list|)
decl_stmt|;
return|return
name|operand
operator|.
name|accept
argument_list|(
name|v
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|deriveConstructorType
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|SqlFunction
name|unresolvedConstructor
parameter_list|,
name|SqlFunction
name|resolvedConstructor
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|)
block|{
name|SqlIdentifier
name|sqlIdentifier
init|=
name|unresolvedConstructor
operator|.
name|getSqlIdentifier
argument_list|()
decl_stmt|;
assert|assert
name|sqlIdentifier
operator|!=
literal|null
assert|;
name|RelDataType
name|type
init|=
name|catalogReader
operator|.
name|getNamedType
argument_list|(
name|sqlIdentifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
comment|// TODO jvs 12-Feb-2005:  proper type name formatting
throw|throw
name|newValidationError
argument_list|(
name|sqlIdentifier
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|UnknownDatatypeName
operator|.
name|ex
argument_list|(
name|sqlIdentifier
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|resolvedConstructor
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// This is not a default constructor invocation, and
comment|// no user-defined constructor could be found
throw|throw
name|handleUnresolvedFunction
argument_list|(
name|call
argument_list|,
name|unresolvedConstructor
argument_list|,
name|argTypes
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|SqlCall
name|testCall
init|=
name|resolvedConstructor
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
decl_stmt|;
name|RelDataType
name|returnType
init|=
name|resolvedConstructor
operator|.
name|validateOperands
argument_list|(
name|this
argument_list|,
name|scope
argument_list|,
name|testCall
argument_list|)
decl_stmt|;
assert|assert
name|type
operator|==
name|returnType
assert|;
block|}
if|if
condition|(
name|shouldExpandIdentifiers
argument_list|()
condition|)
block|{
if|if
condition|(
name|resolvedConstructor
operator|!=
literal|null
condition|)
block|{
name|call
operator|.
name|setOperator
argument_list|(
name|resolvedConstructor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// fake a fully-qualified call to the default constructor
name|call
operator|.
name|setOperator
argument_list|(
operator|new
name|SqlFunction
argument_list|(
name|type
operator|.
name|getSqlIdentifier
argument_list|()
argument_list|,
name|ExplicitReturnTypeInference
operator|.
name|of
argument_list|(
name|type
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlFunctionCategory
operator|.
name|UserDefinedConstructor
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|type
return|;
block|}
specifier|public
name|EigenbaseException
name|handleUnresolvedFunction
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|SqlFunction
name|unresolvedFunction
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|)
block|{
comment|// For builtins, we can give a better error message
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|overloads
init|=
name|opTab
operator|.
name|lookupOperatorOverloads
argument_list|(
name|unresolvedFunction
operator|.
name|getNameAsId
argument_list|()
argument_list|,
literal|null
argument_list|,
name|SqlSyntax
operator|.
name|Function
argument_list|)
decl_stmt|;
if|if
condition|(
name|overloads
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|SqlFunction
name|fun
init|=
operator|(
name|SqlFunction
operator|)
name|overloads
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|fun
operator|.
name|getSqlIdentifier
argument_list|()
operator|==
literal|null
operator|)
operator|&&
operator|(
name|fun
operator|.
name|getSyntax
argument_list|()
operator|!=
name|SqlSyntax
operator|.
name|FunctionId
operator|)
condition|)
block|{
specifier|final
name|int
name|expectedArgCount
init|=
name|fun
operator|.
name|getOperandCountRange
argument_list|()
operator|.
name|getMin
argument_list|()
decl_stmt|;
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|InvalidArgCount
operator|.
name|ex
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|expectedArgCount
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|AssignableOperandTypeChecker
name|typeChecking
init|=
operator|new
name|AssignableOperandTypeChecker
argument_list|(
name|argTypes
argument_list|)
decl_stmt|;
name|String
name|signature
init|=
name|typeChecking
operator|.
name|getAllowedSignatures
argument_list|(
name|unresolvedFunction
argument_list|,
name|unresolvedFunction
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|ValidatorUnknownFunction
operator|.
name|ex
argument_list|(
name|signature
argument_list|)
argument_list|)
throw|;
block|}
specifier|protected
name|void
name|inferUnknownTypes
parameter_list|(
name|RelDataType
name|inferredType
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNode
name|node
parameter_list|)
block|{
specifier|final
name|SqlValidatorScope
name|newScope
init|=
name|scopes
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|newScope
operator|!=
literal|null
condition|)
block|{
name|scope
operator|=
name|newScope
expr_stmt|;
block|}
name|boolean
name|isNullLiteral
init|=
name|SqlUtil
operator|.
name|isNullLiteral
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|instanceof
name|SqlDynamicParam
operator|)
operator|||
name|isNullLiteral
condition|)
block|{
if|if
condition|(
name|inferredType
operator|.
name|equals
argument_list|(
name|unknownType
argument_list|)
condition|)
block|{
if|if
condition|(
name|isNullLiteral
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|NullIllegal
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|DynamicParamIllegal
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// REVIEW:  should dynamic parameter types always be nullable?
name|RelDataType
name|newInferredType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|inferredType
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|inferredType
argument_list|)
condition|)
block|{
name|newInferredType
operator|=
name|typeFactory
operator|.
name|createTypeWithCharsetAndCollation
argument_list|(
name|newInferredType
argument_list|,
name|inferredType
operator|.
name|getCharset
argument_list|()
argument_list|,
name|inferredType
operator|.
name|getCollation
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|setValidatedNodeTypeImpl
argument_list|(
name|node
argument_list|,
name|newInferredType
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlNodeList
condition|)
block|{
name|SqlNodeList
name|nodeList
init|=
operator|(
name|SqlNodeList
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|inferredType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
name|inferredType
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|nodeList
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// this can happen when we're validating an INSERT
comment|// where the source and target degrees are different;
comment|// bust out, and the error will be detected higher up
return|return;
block|}
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SqlNode
name|child
range|:
name|nodeList
control|)
block|{
name|RelDataType
name|type
decl_stmt|;
if|if
condition|(
name|inferredType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|type
operator|=
name|inferredType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|inferredType
expr_stmt|;
block|}
name|inferUnknownTypes
argument_list|(
name|type
argument_list|,
name|scope
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlCase
condition|)
block|{
comment|// REVIEW wael: can this be done in a paramtypeinference strategy
comment|// object?
name|SqlCase
name|caseCall
init|=
operator|(
name|SqlCase
operator|)
name|node
decl_stmt|;
name|RelDataType
name|returnType
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|SqlNodeList
name|whenList
init|=
name|caseCall
operator|.
name|getWhenOperands
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|whenList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|sqlNode
init|=
name|whenList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|inferUnknownTypes
argument_list|(
name|unknownType
argument_list|,
name|scope
argument_list|,
name|sqlNode
argument_list|)
expr_stmt|;
block|}
name|SqlNodeList
name|thenList
init|=
name|caseCall
operator|.
name|getThenOperands
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|thenList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|sqlNode
init|=
name|thenList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|inferUnknownTypes
argument_list|(
name|returnType
argument_list|,
name|scope
argument_list|,
name|sqlNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SqlUtil
operator|.
name|isNullLiteral
argument_list|(
name|caseCall
operator|.
name|getElseOperand
argument_list|()
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|inferUnknownTypes
argument_list|(
name|returnType
argument_list|,
name|scope
argument_list|,
name|caseCall
operator|.
name|getElseOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setValidatedNodeTypeImpl
argument_list|(
name|caseCall
operator|.
name|getElseOperand
argument_list|()
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlCall
condition|)
block|{
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
name|SqlOperandTypeInference
name|operandTypeInference
init|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getOperandTypeInference
argument_list|()
decl_stmt|;
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RelDataType
index|[]
name|operandTypes
init|=
operator|new
name|RelDataType
index|[
name|operands
operator|.
name|length
index|]
decl_stmt|;
if|if
condition|(
name|operandTypeInference
operator|==
literal|null
condition|)
block|{
comment|// TODO:  eventually should assert(operandTypeInference != null)
comment|// instead; for now just eat it
name|Arrays
operator|.
name|fill
argument_list|(
name|operandTypes
argument_list|,
name|unknownType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|operandTypeInference
operator|.
name|inferOperandTypes
argument_list|(
operator|new
name|SqlCallBinding
argument_list|(
name|this
argument_list|,
name|scope
argument_list|,
name|call
argument_list|)
argument_list|,
name|inferredType
argument_list|,
name|operandTypes
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|inferUnknownTypes
argument_list|(
name|operandTypes
index|[
name|i
index|]
argument_list|,
name|scope
argument_list|,
name|operands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Adds an expression to a select list, ensuring that its alias does not    * clash with any existing expressions on the list.    */
specifier|protected
name|void
name|addToSelectList
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|list
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|,
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|fieldList
parameter_list|,
name|SqlNode
name|exp
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
specifier|final
name|boolean
name|includeSystemVars
parameter_list|)
block|{
name|String
name|alias
init|=
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|exp
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|String
name|uniqueAlias
init|=
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|alias
argument_list|,
name|aliases
argument_list|,
name|SqlValidatorUtil
operator|.
name|EXPR_SUGGESTER
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alias
operator|.
name|equals
argument_list|(
name|uniqueAlias
argument_list|)
condition|)
block|{
name|exp
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|exp
argument_list|,
name|uniqueAlias
argument_list|)
expr_stmt|;
block|}
name|fieldList
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|uniqueAlias
argument_list|,
name|deriveType
argument_list|(
name|scope
argument_list|,
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|deriveAlias
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
return|return
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|)
return|;
block|}
comment|// implement SqlValidator
specifier|public
name|void
name|setIdentifierExpansion
parameter_list|(
name|boolean
name|expandIdentifiers
parameter_list|)
block|{
name|this
operator|.
name|expandIdentifiers
operator|=
name|expandIdentifiers
expr_stmt|;
block|}
comment|// implement SqlValidator
specifier|public
name|void
name|setColumnReferenceExpansion
parameter_list|(
name|boolean
name|expandColumnReferences
parameter_list|)
block|{
name|this
operator|.
name|expandColumnReferences
operator|=
name|expandColumnReferences
expr_stmt|;
block|}
comment|// implement SqlValidator
specifier|public
name|boolean
name|getColumnReferenceExpansion
parameter_list|()
block|{
return|return
name|expandColumnReferences
return|;
block|}
comment|// implement SqlValidator
specifier|public
name|void
name|setCallRewrite
parameter_list|(
name|boolean
name|rewriteCalls
parameter_list|)
block|{
name|this
operator|.
name|rewriteCalls
operator|=
name|rewriteCalls
expr_stmt|;
block|}
specifier|public
name|boolean
name|shouldExpandIdentifiers
parameter_list|()
block|{
return|return
name|expandIdentifiers
return|;
block|}
specifier|protected
name|boolean
name|shouldAllowIntermediateOrderBy
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Registers a new namespace, and adds it as a child of its parent scope.    * Derived class can override this method to tinker with namespaces as they    * are created.    *    * @param usingScope    Parent scope (which will want to look for things in    *                      this namespace)    * @param alias         Alias by which parent will refer to this namespace    * @param ns            Namespace    * @param forceNullable Whether to force the type of namespace to be    */
specifier|protected
name|void
name|registerNamespace
parameter_list|(
name|SqlValidatorScope
name|usingScope
parameter_list|,
name|String
name|alias
parameter_list|,
name|SqlValidatorNamespace
name|ns
parameter_list|,
name|boolean
name|forceNullable
parameter_list|)
block|{
if|if
condition|(
name|forceNullable
condition|)
block|{
name|ns
operator|.
name|makeNullable
argument_list|()
expr_stmt|;
block|}
name|namespaces
operator|.
name|put
argument_list|(
name|ns
operator|.
name|getNode
argument_list|()
argument_list|,
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|usingScope
operator|!=
literal|null
condition|)
block|{
name|usingScope
operator|.
name|addChild
argument_list|(
name|ns
argument_list|,
name|alias
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Registers scopes and namespaces implied a relational expression in the    * FROM clause.    *    *<p>{@code parentScope} and {@code usingScope} are often the same. They    * differ when the namespace are not visible within the parent. (Example    * needed.)    *    *<p>Likewise, {@code enclosingNode} and {@code node} are often the same.    * {@code enclosingNode} is the topmost node within the FROM clause, from    * which any decorations like an alias (<code>AS alias</code>) or a table    * sample clause are stripped away to get {@code node}. Both are recorded in    * the namespace.    *    * @param parentScope   Parent scope which this scope turns to in order to    *                      resolve objects    * @param usingScope    Scope whose child list this scope should add itself to    * @param node          Node which namespace is based on    * @param enclosingNode Outermost node for namespace, including decorations    *                      such as alias and sample clause    * @param alias         Alias    * @param forceNullable Whether to force the type of namespace to be    *                      nullable because it is in an outer join    * @return registered node, usually the same as {@code node}    */
specifier|private
name|SqlNode
name|registerFrom
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlValidatorScope
name|usingScope
parameter_list|,
specifier|final
name|SqlNode
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|String
name|alias
parameter_list|,
name|boolean
name|forceNullable
parameter_list|)
block|{
specifier|final
name|SqlKind
name|kind
init|=
name|node
operator|.
name|getKind
argument_list|()
decl_stmt|;
name|SqlNode
name|expr
decl_stmt|;
name|SqlNode
name|newExpr
decl_stmt|;
comment|// Add an alias if necessary.
name|SqlNode
name|newNode
init|=
name|node
decl_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
condition|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|IDENTIFIER
case|:
case|case
name|OVER
case|:
name|alias
operator|=
name|deriveAlias
argument_list|(
name|node
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
condition|)
block|{
name|alias
operator|=
name|deriveAlias
argument_list|(
name|node
argument_list|,
name|nextGeneratedId
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shouldExpandIdentifiers
argument_list|()
condition|)
block|{
name|newNode
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|node
argument_list|,
name|alias
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SELECT
case|:
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
case|case
name|VALUES
case|:
case|case
name|UNNEST
case|:
case|case
name|OTHER_FUNCTION
case|:
case|case
name|COLLECTION_TABLE
case|:
comment|// give this anonymous construct a name since later
comment|// query processing stages rely on it
name|alias
operator|=
name|deriveAlias
argument_list|(
name|node
argument_list|,
name|nextGeneratedId
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldExpandIdentifiers
argument_list|()
condition|)
block|{
comment|// Since we're expanding identifiers, we should make the
comment|// aliases explicit too, otherwise the expanded query
comment|// will not be consistent if we convert back to SQL, e.g.
comment|// "select EXPR$1.EXPR$2 from values (1)".
name|newNode
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|node
argument_list|,
name|alias
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|SqlCall
name|call
decl_stmt|;
name|SqlNode
name|operand
decl_stmt|;
name|SqlNode
name|newOperand
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|AS
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
condition|)
block|{
name|alias
operator|=
name|call
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|SqlValidatorScope
name|usingScope2
init|=
name|usingScope
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|length
operator|>
literal|2
condition|)
block|{
name|usingScope2
operator|=
literal|null
expr_stmt|;
block|}
name|expr
operator|=
name|call
operator|.
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|newExpr
operator|=
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|usingScope2
argument_list|,
name|expr
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
if|if
condition|(
name|newExpr
operator|!=
name|expr
condition|)
block|{
name|call
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
name|newExpr
argument_list|)
expr_stmt|;
block|}
comment|// If alias has a column list, introduce a namespace to translate
comment|// column names.
if|if
condition|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|length
operator|>
literal|2
condition|)
block|{
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
operator|new
name|AliasNamespace
argument_list|(
name|this
argument_list|,
name|call
argument_list|,
name|enclosingNode
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
case|case
name|TABLESAMPLE
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
name|expr
operator|=
name|call
operator|.
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|newExpr
operator|=
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|expr
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
if|if
condition|(
name|newExpr
operator|!=
name|expr
condition|)
block|{
name|call
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
name|newExpr
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
case|case
name|JOIN
case|:
specifier|final
name|SqlJoin
name|join
init|=
operator|(
name|SqlJoin
operator|)
name|node
decl_stmt|;
specifier|final
name|JoinScope
name|joinScope
init|=
operator|new
name|JoinScope
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|join
argument_list|)
decl_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|join
argument_list|,
name|joinScope
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|left
init|=
name|join
operator|.
name|getLeft
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
name|right
init|=
name|join
operator|.
name|getRight
argument_list|()
decl_stmt|;
name|boolean
name|rightIsLateral
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|right
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LATERAL
operator|||
operator|(
name|right
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AS
operator|&&
operator|(
operator|(
name|SqlCall
operator|)
name|right
operator|)
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LATERAL
operator|)
condition|)
block|{
name|rightIsLateral
operator|=
literal|true
expr_stmt|;
block|}
name|boolean
name|forceLeftNullable
init|=
name|forceNullable
decl_stmt|;
name|boolean
name|forceRightNullable
init|=
name|forceNullable
decl_stmt|;
if|if
condition|(
name|join
operator|.
name|getJoinType
argument_list|()
operator|==
name|SqlJoinOperator
operator|.
name|JoinType
operator|.
name|Left
condition|)
block|{
name|forceRightNullable
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|join
operator|.
name|getJoinType
argument_list|()
operator|==
name|SqlJoinOperator
operator|.
name|JoinType
operator|.
name|Right
condition|)
block|{
name|forceLeftNullable
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|join
operator|.
name|getJoinType
argument_list|()
operator|==
name|SqlJoinOperator
operator|.
name|JoinType
operator|.
name|Full
condition|)
block|{
name|forceLeftNullable
operator|=
literal|true
expr_stmt|;
name|forceRightNullable
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|SqlNode
name|newLeft
init|=
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|joinScope
argument_list|,
name|left
argument_list|,
name|left
argument_list|,
literal|null
argument_list|,
name|forceLeftNullable
argument_list|)
decl_stmt|;
if|if
condition|(
name|newLeft
operator|!=
name|left
condition|)
block|{
name|join
operator|.
name|setOperand
argument_list|(
name|SqlJoin
operator|.
name|LEFT_OPERAND
argument_list|,
name|newLeft
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlValidatorScope
name|rightParentScope
decl_stmt|;
if|if
condition|(
name|rightIsLateral
condition|)
block|{
name|rightParentScope
operator|=
name|joinScope
expr_stmt|;
block|}
else|else
block|{
name|rightParentScope
operator|=
name|parentScope
expr_stmt|;
block|}
specifier|final
name|SqlNode
name|newRight
init|=
name|registerFrom
argument_list|(
name|rightParentScope
argument_list|,
name|joinScope
argument_list|,
name|right
argument_list|,
name|right
argument_list|,
literal|null
argument_list|,
name|forceRightNullable
argument_list|)
decl_stmt|;
if|if
condition|(
name|newRight
operator|!=
name|right
condition|)
block|{
name|join
operator|.
name|setOperand
argument_list|(
name|SqlJoin
operator|.
name|RIGHT_OPERAND
argument_list|,
name|newRight
argument_list|)
expr_stmt|;
block|}
specifier|final
name|JoinNamespace
name|joinNamespace
init|=
operator|new
name|JoinNamespace
argument_list|(
name|this
argument_list|,
name|join
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|joinNamespace
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
return|return
name|join
return|;
case|case
name|IDENTIFIER
case|:
specifier|final
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|node
decl_stmt|;
specifier|final
name|IdentifierNamespace
name|newNs
init|=
operator|new
name|IdentifierNamespace
argument_list|(
name|this
argument_list|,
name|id
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|newNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
return|return
name|newNode
return|;
case|case
name|LATERAL
case|:
return|return
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operands
index|[
literal|0
index|]
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
return|;
case|case
name|COLLECTION_TABLE
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
name|operand
operator|=
name|call
operator|.
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|newOperand
operator|=
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|operand
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
if|if
condition|(
name|newOperand
operator|!=
name|operand
condition|)
block|{
name|call
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
name|newOperand
argument_list|)
expr_stmt|;
block|}
return|return
name|newNode
return|;
case|case
name|SELECT
case|:
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
case|case
name|VALUES
case|:
case|case
name|UNNEST
case|:
case|case
name|OTHER_FUNCTION
case|:
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|node
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
return|return
name|newNode
return|;
case|case
name|OVER
case|:
if|if
condition|(
operator|!
name|shouldAllowOverRelation
argument_list|()
condition|)
block|{
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|kind
argument_list|)
throw|;
block|}
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
specifier|final
name|OverScope
name|overScope
init|=
operator|new
name|OverScope
argument_list|(
name|usingScope
argument_list|,
name|call
argument_list|)
decl_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|call
argument_list|,
name|overScope
argument_list|)
expr_stmt|;
name|operand
operator|=
name|call
operator|.
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|newOperand
operator|=
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|overScope
argument_list|,
name|operand
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
if|if
condition|(
name|newOperand
operator|!=
name|operand
condition|)
block|{
name|call
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
name|newOperand
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|String
argument_list|,
name|SqlValidatorNamespace
argument_list|>
name|p
range|:
name|overScope
operator|.
name|children
control|)
block|{
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|p
operator|.
name|left
argument_list|,
name|p
operator|.
name|right
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
block|}
return|return
name|newNode
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|kind
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|boolean
name|shouldAllowOverRelation
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Creates a namespace for a<code>SELECT</code> node. Derived class may    * override this factory method.    *    * @param select        Select node    * @param enclosingNode Enclosing node    * @return Select namespace    */
specifier|protected
name|SelectNamespace
name|createSelectNamespace
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|)
block|{
return|return
operator|new
name|SelectNamespace
argument_list|(
name|this
argument_list|,
name|select
argument_list|,
name|enclosingNode
argument_list|)
return|;
block|}
comment|/**    * Creates a namespace for a set operation (<code>UNION</code>,<code>    * INTERSECT</code>, or<code>EXCEPT</code>). Derived class may override    * this factory method.    *    * @param call          Call to set operation    * @param enclosingNode Enclosing node    * @return Set operation namespace    */
specifier|protected
name|SetopNamespace
name|createSetopNamespace
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|)
block|{
return|return
operator|new
name|SetopNamespace
argument_list|(
name|this
argument_list|,
name|call
argument_list|,
name|enclosingNode
argument_list|)
return|;
block|}
comment|/**    * Registers a query in a parent scope.    *    * @param parentScope Parent scope which this scope turns to in order to    *                    resolve objects    * @param usingScope  Scope whose child list this scope should add itself to    * @param node        Query node    * @param alias       Name of this query within its parent. Must be specified    *                    if usingScope != null    * @pre usingScope == null || alias != null    */
specifier|private
name|void
name|registerQuery
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlValidatorScope
name|usingScope
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|String
name|alias
parameter_list|,
name|boolean
name|forceNullable
parameter_list|)
block|{
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|node
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Registers a query in a parent scope.    *    * @param parentScope Parent scope which this scope turns to in order to    *                    resolve objects    * @param usingScope  Scope whose child list this scope should add itself to    * @param node        Query node    * @param alias       Name of this query within its parent. Must be specified    *                    if usingScope != null    * @param checkUpdate if true, validate that the update feature is supported    *                    if validating the update statement    * @pre usingScope == null || alias != null    */
specifier|private
name|void
name|registerQuery
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlValidatorScope
name|usingScope
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|String
name|alias
parameter_list|,
name|boolean
name|forceNullable
parameter_list|,
name|boolean
name|checkUpdate
parameter_list|)
block|{
assert|assert
name|node
operator|!=
literal|null
assert|;
assert|assert
name|enclosingNode
operator|!=
literal|null
assert|;
name|Util
operator|.
name|pre
argument_list|(
operator|(
name|usingScope
operator|==
literal|null
operator|)
operator|||
operator|(
name|alias
operator|!=
literal|null
operator|)
argument_list|,
literal|"usingScope == null || alias != null"
argument_list|)
expr_stmt|;
name|SqlCall
name|call
decl_stmt|;
name|SqlNode
index|[]
name|operands
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|SELECT
case|:
specifier|final
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|node
decl_stmt|;
specifier|final
name|SelectNamespace
name|selectNs
init|=
name|createSelectNamespace
argument_list|(
name|select
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|selectNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
specifier|final
name|SqlValidatorScope
name|windowParentScope
init|=
operator|(
name|usingScope
operator|!=
literal|null
operator|)
condition|?
name|usingScope
else|:
name|parentScope
decl_stmt|;
name|SelectScope
name|selectScope
init|=
operator|new
name|SelectScope
argument_list|(
name|parentScope
argument_list|,
name|windowParentScope
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|select
argument_list|,
name|selectScope
argument_list|)
expr_stmt|;
comment|// Start by registering the WHERE clause
name|whereScopes
operator|.
name|put
argument_list|(
name|select
argument_list|,
name|selectScope
argument_list|)
expr_stmt|;
name|registerOperandSubqueries
argument_list|(
name|selectScope
argument_list|,
name|select
argument_list|,
name|SqlSelect
operator|.
name|WHERE_OPERAND
argument_list|)
expr_stmt|;
comment|// Register FROM with the inherited scope 'parentScope', not
comment|// 'selectScope', otherwise tables in the FROM clause would be
comment|// able to see each other.
specifier|final
name|SqlNode
name|from
init|=
name|select
operator|.
name|getFrom
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
name|newFrom
init|=
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|selectScope
argument_list|,
name|from
argument_list|,
name|from
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFrom
operator|!=
name|from
condition|)
block|{
name|select
operator|.
name|setOperand
argument_list|(
name|SqlSelect
operator|.
name|FROM_OPERAND
argument_list|,
name|newFrom
argument_list|)
expr_stmt|;
block|}
comment|// If this is an aggregating query, the SELECT list and HAVING
comment|// clause use a different scope, where you can only reference
comment|// columns which are in the GROUP BY clause.
name|SqlValidatorScope
name|aggScope
init|=
name|selectScope
decl_stmt|;
if|if
condition|(
name|isAggregate
argument_list|(
name|select
argument_list|)
condition|)
block|{
name|aggScope
operator|=
operator|new
name|AggregatingSelectScope
argument_list|(
name|selectScope
argument_list|,
name|select
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|selectScopes
operator|.
name|put
argument_list|(
name|select
argument_list|,
name|aggScope
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selectScopes
operator|.
name|put
argument_list|(
name|select
argument_list|,
name|selectScope
argument_list|)
expr_stmt|;
block|}
name|registerSubqueries
argument_list|(
name|selectScope
argument_list|,
name|select
operator|.
name|getGroup
argument_list|()
argument_list|)
expr_stmt|;
name|registerOperandSubqueries
argument_list|(
name|aggScope
argument_list|,
name|select
argument_list|,
name|SqlSelect
operator|.
name|HAVING_OPERAND
argument_list|)
expr_stmt|;
name|registerSubqueries
argument_list|(
name|aggScope
argument_list|,
name|select
operator|.
name|getSelectList
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|SqlNodeList
name|orderList
init|=
name|select
operator|.
name|getOrderList
argument_list|()
decl_stmt|;
if|if
condition|(
name|orderList
operator|!=
literal|null
condition|)
block|{
comment|// If the query is 'SELECT DISTINCT', restrict the columns
comment|// available to the ORDER BY clause.
if|if
condition|(
name|select
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
name|aggScope
operator|=
operator|new
name|AggregatingSelectScope
argument_list|(
name|selectScope
argument_list|,
name|select
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|OrderByScope
name|orderScope
init|=
operator|new
name|OrderByScope
argument_list|(
name|aggScope
argument_list|,
name|orderList
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|orderScopes
operator|.
name|put
argument_list|(
name|select
argument_list|,
name|orderScope
argument_list|)
expr_stmt|;
name|registerSubqueries
argument_list|(
name|orderScope
argument_list|,
name|orderList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isAggregate
argument_list|(
name|select
argument_list|)
condition|)
block|{
comment|// Since this is not an aggregating query,
comment|// there cannot be any aggregates in the ORDER BY clause.
name|SqlNode
name|agg
init|=
name|aggFinder
operator|.
name|findAgg
argument_list|(
name|orderList
argument_list|)
decl_stmt|;
if|if
condition|(
name|agg
operator|!=
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|agg
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|AggregateIllegalInOrderBy
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
break|break;
case|case
name|INTERSECT
case|:
name|validateFeature
argument_list|(
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|SQLFeature_F302
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
name|registerSetop
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|node
argument_list|,
name|node
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXCEPT
case|:
name|validateFeature
argument_list|(
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|SQLFeature_E071_03
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
name|registerSetop
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|node
argument_list|,
name|node
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION
case|:
name|registerSetop
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|node
argument_list|,
name|node
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
break|break;
case|case
name|VALUES
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|call
argument_list|,
name|parentScope
argument_list|)
expr_stmt|;
specifier|final
name|TableConstructorNamespace
name|tableConstructorNamespace
init|=
operator|new
name|TableConstructorNamespace
argument_list|(
name|this
argument_list|,
name|call
argument_list|,
name|parentScope
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|tableConstructorNamespace
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|operands
operator|=
name|call
operator|.
name|getOperands
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
assert|assert
name|operands
index|[
name|i
index|]
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ROW
assert|;
comment|// FIXME jvs 9-Feb-2005:  Correlation should
comment|// be illegal in these subqueries.  Same goes for
comment|// any non-lateral SELECT in the FROM list.
name|registerOperandSubqueries
argument_list|(
name|parentScope
argument_list|,
name|call
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INSERT
case|:
name|SqlInsert
name|insertCall
init|=
operator|(
name|SqlInsert
operator|)
name|node
decl_stmt|;
name|InsertNamespace
name|insertNs
init|=
operator|new
name|InsertNamespace
argument_list|(
name|this
argument_list|,
name|insertCall
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
literal|null
argument_list|,
name|insertNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|insertCall
operator|.
name|getSource
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|DELETE
case|:
name|SqlDelete
name|deleteCall
init|=
operator|(
name|SqlDelete
operator|)
name|node
decl_stmt|;
name|DeleteNamespace
name|deleteNs
init|=
operator|new
name|DeleteNamespace
argument_list|(
name|this
argument_list|,
name|deleteCall
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
literal|null
argument_list|,
name|deleteNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|deleteCall
operator|.
name|getSourceSelect
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPDATE
case|:
if|if
condition|(
name|checkUpdate
condition|)
block|{
name|validateFeature
argument_list|(
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|SQLFeature_E101_03
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|SqlUpdate
name|updateCall
init|=
operator|(
name|SqlUpdate
operator|)
name|node
decl_stmt|;
name|UpdateNamespace
name|updateNs
init|=
operator|new
name|UpdateNamespace
argument_list|(
name|this
argument_list|,
name|updateCall
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
literal|null
argument_list|,
name|updateNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|updateCall
operator|.
name|getSourceSelect
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE
case|:
name|validateFeature
argument_list|(
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|SQLFeature_F312
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
name|SqlMerge
name|mergeCall
init|=
operator|(
name|SqlMerge
operator|)
name|node
decl_stmt|;
name|MergeNamespace
name|mergeNs
init|=
operator|new
name|MergeNamespace
argument_list|(
name|this
argument_list|,
name|mergeCall
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
literal|null
argument_list|,
name|mergeNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|mergeCall
operator|.
name|getSourceSelect
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// update call can reference either the source table reference
comment|// or the target table, so set its parent scope to the merge's
comment|// source select; when validating the update, skip the feature
comment|// validation check
if|if
condition|(
name|mergeCall
operator|.
name|getUpdateCall
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|registerQuery
argument_list|(
name|whereScopes
operator|.
name|get
argument_list|(
name|mergeCall
operator|.
name|getSourceSelect
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
name|mergeCall
operator|.
name|getUpdateCall
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mergeCall
operator|.
name|getInsertCall
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
literal|null
argument_list|,
name|mergeCall
operator|.
name|getInsertCall
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNNEST
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
specifier|final
name|UnnestNamespace
name|unnestNs
init|=
operator|new
name|UnnestNamespace
argument_list|(
name|this
argument_list|,
name|call
argument_list|,
name|usingScope
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|unnestNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|registerOperandSubqueries
argument_list|(
name|usingScope
argument_list|,
name|call
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OTHER_FUNCTION
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
name|ProcedureNamespace
name|procNs
init|=
operator|new
name|ProcedureNamespace
argument_list|(
name|this
argument_list|,
name|parentScope
argument_list|,
name|call
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|procNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|registerSubqueries
argument_list|(
name|parentScope
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULTISET_QUERY_CONSTRUCTOR
case|:
name|validateFeature
argument_list|(
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|SQLFeature_S271
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
name|CollectScope
name|cs
init|=
operator|new
name|CollectScope
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|call
argument_list|)
decl_stmt|;
specifier|final
name|CollectNamespace
name|ttableConstructorNs
init|=
operator|new
name|CollectNamespace
argument_list|(
name|call
argument_list|,
name|cs
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
specifier|final
name|String
name|alias2
init|=
name|deriveAlias
argument_list|(
name|node
argument_list|,
name|nextGeneratedId
operator|++
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias2
argument_list|,
name|ttableConstructorNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|operands
operator|=
name|call
operator|.
name|getOperands
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|registerOperandSubqueries
argument_list|(
name|parentScope
argument_list|,
name|call
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|node
operator|.
name|getKind
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|registerSetop
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlValidatorScope
name|usingScope
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|String
name|alias
parameter_list|,
name|boolean
name|forceNullable
parameter_list|)
block|{
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
specifier|final
name|SetopNamespace
name|setopNamespace
init|=
name|createSetopNamespace
argument_list|(
name|call
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|setopNamespace
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
comment|// A setop is in the same scope as its parent.
name|scopes
operator|.
name|put
argument_list|(
name|call
argument_list|,
name|parentScope
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|operands
control|)
block|{
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
literal|null
argument_list|,
name|operand
argument_list|,
name|operand
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|isAggregate
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
return|return
operator|(
name|select
operator|.
name|getGroup
argument_list|()
operator|!=
literal|null
operator|)
operator|||
operator|(
name|select
operator|.
name|getHaving
argument_list|()
operator|!=
literal|null
operator|)
operator|||
operator|(
name|aggFinder
operator|.
name|findAgg
argument_list|(
name|select
operator|.
name|getSelectList
argument_list|()
argument_list|)
operator|!=
literal|null
operator|)
return|;
block|}
specifier|public
name|boolean
name|isAggregate
parameter_list|(
name|SqlNode
name|selectNode
parameter_list|)
block|{
return|return
name|aggFinder
operator|.
name|findAgg
argument_list|(
name|selectNode
argument_list|)
operator|!=
literal|null
return|;
block|}
specifier|private
name|void
name|validateNodeFeature
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|MULTISET_VALUE_CONSTRUCTOR
case|:
name|validateFeature
argument_list|(
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|SQLFeature_S271
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
specifier|private
name|void
name|registerSubqueries
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|else if
condition|(
name|node
operator|.
name|getKind
argument_list|()
operator|.
name|belongsTo
argument_list|(
name|SqlKind
operator|.
name|QUERY
argument_list|)
condition|)
block|{
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
literal|null
argument_list|,
name|node
argument_list|,
name|node
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|MULTISET_QUERY_CONSTRUCTOR
condition|)
block|{
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
literal|null
argument_list|,
name|node
argument_list|,
name|node
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlCall
condition|)
block|{
name|validateNodeFeature
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|registerOperandSubqueries
argument_list|(
name|parentScope
argument_list|,
name|call
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlNodeList
condition|)
block|{
name|SqlNodeList
name|list
init|=
operator|(
name|SqlNodeList
operator|)
name|node
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|count
init|=
name|list
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|listNode
init|=
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|listNode
operator|.
name|getKind
argument_list|()
operator|.
name|belongsTo
argument_list|(
name|SqlKind
operator|.
name|QUERY
argument_list|)
condition|)
block|{
name|listNode
operator|=
name|SqlStdOperatorTable
operator|.
name|scalarQueryOperator
operator|.
name|createCall
argument_list|(
name|listNode
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|listNode
argument_list|)
expr_stmt|;
name|list
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|listNode
argument_list|)
expr_stmt|;
block|}
name|registerSubqueries
argument_list|(
name|parentScope
argument_list|,
name|listNode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// atomic node -- can be ignored
block|}
block|}
comment|/**    * Registers any subqueries inside a given call operand, and converts the    * operand to a scalar subquery if the operator requires it.    *    * @param parentScope    Parent scope    * @param call           Call    * @param operandOrdinal Ordinal of operand within call    * @see SqlOperator#argumentMustBeScalar(int)    */
specifier|private
name|void
name|registerOperandSubqueries
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|int
name|operandOrdinal
parameter_list|)
block|{
name|SqlNode
name|operand
init|=
name|call
operator|.
name|getOperands
argument_list|()
index|[
name|operandOrdinal
index|]
decl_stmt|;
if|if
condition|(
name|operand
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|operand
operator|.
name|getKind
argument_list|()
operator|.
name|belongsTo
argument_list|(
name|SqlKind
operator|.
name|QUERY
argument_list|)
operator|&&
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|argumentMustBeScalar
argument_list|(
name|operandOrdinal
argument_list|)
condition|)
block|{
name|operand
operator|=
name|SqlStdOperatorTable
operator|.
name|scalarQueryOperator
operator|.
name|createCall
argument_list|(
name|operand
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|call
operator|.
name|setOperand
argument_list|(
name|operandOrdinal
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
name|registerSubqueries
argument_list|(
name|parentScope
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|validateIdentifier
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
specifier|final
name|SqlIdentifier
name|fqId
init|=
name|scope
operator|.
name|fullyQualify
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|expandColumnReferences
condition|)
block|{
comment|// NOTE jvs 9-Apr-2007: this doesn't cover ORDER BY, which has its
comment|// own ideas about qualification.
name|id
operator|.
name|assignNamesFrom
argument_list|(
name|fqId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Util
operator|.
name|discard
argument_list|(
name|fqId
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|validateLiteral
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
switch|switch
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
condition|)
block|{
case|case
name|DECIMAL
case|:
comment|// Decimal and long have the same precision (as 64-bit integers), so
comment|// the unscaled value of a decimal must fit into a long.
comment|// REVIEW jvs 4-Aug-2004:  This should probably be calling over to
comment|// the available calculator implementations to see what they
comment|// support.  For now use ESP instead.
comment|//
comment|// jhyde 2006/12/21: I think the limits should be baked into the
comment|// type system, not dependent on the calculator implementation.
name|BigDecimal
name|bd
init|=
operator|(
name|BigDecimal
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|BigInteger
name|unscaled
init|=
name|bd
operator|.
name|unscaledValue
argument_list|()
decl_stmt|;
name|long
name|longValue
init|=
name|unscaled
operator|.
name|longValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|longValue
argument_list|)
operator|.
name|equals
argument_list|(
name|unscaled
argument_list|)
condition|)
block|{
comment|// overflow
throw|throw
name|newValidationError
argument_list|(
name|literal
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|NumberLiteralOutOfRange
operator|.
name|ex
argument_list|(
name|bd
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|DOUBLE
case|:
name|validateLiteralAsDouble
argument_list|(
name|literal
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINARY
case|:
specifier|final
name|BitString
name|bitString
init|=
operator|(
name|BitString
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bitString
operator|.
name|getBitCount
argument_list|()
operator|%
literal|8
operator|)
operator|!=
literal|0
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|literal
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|BinaryLiteralOdd
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
break|break;
case|case
name|DATE
case|:
case|case
name|TIME
case|:
case|case
name|TIMESTAMP
case|:
name|Calendar
name|calendar
init|=
operator|(
name|Calendar
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|int
name|year
init|=
name|calendar
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
decl_stmt|;
specifier|final
name|int
name|era
init|=
name|calendar
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|year
operator|<
literal|1
operator|)
operator|||
operator|(
name|era
operator|==
name|GregorianCalendar
operator|.
name|BC
operator|)
operator|||
operator|(
name|year
operator|>
literal|9999
operator|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|literal
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|DateLiteralOutOfRange
operator|.
name|ex
argument_list|(
name|literal
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_DAY_TIME
case|:
if|if
condition|(
name|literal
operator|instanceof
name|SqlIntervalLiteral
condition|)
block|{
name|SqlIntervalLiteral
operator|.
name|IntervalValue
name|interval
init|=
operator|(
name|SqlIntervalLiteral
operator|.
name|IntervalValue
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|SqlIntervalQualifier
name|intervalQualifier
init|=
name|interval
operator|.
name|getIntervalQualifier
argument_list|()
decl_stmt|;
comment|// ensure qualifier is good before attempting to validate
comment|// literal
name|validateIntervalQualifier
argument_list|(
name|intervalQualifier
argument_list|)
expr_stmt|;
name|String
name|intervalStr
init|=
name|interval
operator|.
name|getIntervalLiteral
argument_list|()
decl_stmt|;
try|try
block|{
name|int
index|[]
name|values
init|=
name|intervalQualifier
operator|.
name|evaluateIntervalLiteral
argument_list|(
name|intervalStr
argument_list|)
decl_stmt|;
name|Util
operator|.
name|discard
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SqlValidatorException
name|e
parameter_list|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|literal
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
break|break;
default|default:
comment|// default is to do nothing
block|}
block|}
specifier|private
name|void
name|validateLiteralAsDouble
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
name|BigDecimal
name|bd
init|=
operator|(
name|BigDecimal
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|double
name|d
init|=
name|bd
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|Double
operator|.
name|isInfinite
argument_list|(
name|d
argument_list|)
operator|||
name|Double
operator|.
name|isNaN
argument_list|(
name|d
argument_list|)
condition|)
block|{
comment|// overflow
throw|throw
name|newValidationError
argument_list|(
name|literal
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|NumberLiteralOutOfRange
operator|.
name|ex
argument_list|(
name|Util
operator|.
name|toScientificNotation
argument_list|(
name|bd
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
comment|// REVIEW jvs 4-Aug-2004:  what about underflow?
block|}
specifier|public
name|void
name|validateIntervalQualifier
parameter_list|(
name|SqlIntervalQualifier
name|qualifier
parameter_list|)
block|{
assert|assert
name|qualifier
operator|!=
literal|null
assert|;
name|boolean
name|startPrecisionOutOfRange
init|=
literal|false
decl_stmt|;
name|boolean
name|fractionalSecondPrecisionOutOfRange
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|qualifier
operator|.
name|isYearMonth
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|qualifier
operator|.
name|getStartPrecision
argument_list|()
operator|<
name|SqlTypeName
operator|.
name|INTERVAL_YEAR_MONTH
operator|.
name|getMinPrecision
argument_list|()
operator|)
operator|||
operator|(
name|qualifier
operator|.
name|getStartPrecision
argument_list|()
operator|>
name|SqlTypeName
operator|.
name|INTERVAL_YEAR_MONTH
operator|.
name|getMaxPrecision
argument_list|()
operator|)
condition|)
block|{
name|startPrecisionOutOfRange
operator|=
literal|true
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|qualifier
operator|.
name|getFractionalSecondPrecision
argument_list|()
operator|<
name|SqlTypeName
operator|.
name|INTERVAL_YEAR_MONTH
operator|.
name|getMinScale
argument_list|()
operator|)
operator|||
operator|(
name|qualifier
operator|.
name|getFractionalSecondPrecision
argument_list|()
operator|>
name|SqlTypeName
operator|.
name|INTERVAL_YEAR_MONTH
operator|.
name|getMaxScale
argument_list|()
operator|)
condition|)
block|{
name|fractionalSecondPrecisionOutOfRange
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|qualifier
operator|.
name|getStartPrecision
argument_list|()
operator|<
name|SqlTypeName
operator|.
name|INTERVAL_DAY_TIME
operator|.
name|getMinPrecision
argument_list|()
operator|)
operator|||
operator|(
name|qualifier
operator|.
name|getStartPrecision
argument_list|()
operator|>
name|SqlTypeName
operator|.
name|INTERVAL_DAY_TIME
operator|.
name|getMaxPrecision
argument_list|()
operator|)
condition|)
block|{
name|startPrecisionOutOfRange
operator|=
literal|true
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|qualifier
operator|.
name|getFractionalSecondPrecision
argument_list|()
operator|<
name|SqlTypeName
operator|.
name|INTERVAL_DAY_TIME
operator|.
name|getMinScale
argument_list|()
operator|)
operator|||
operator|(
name|qualifier
operator|.
name|getFractionalSecondPrecision
argument_list|()
operator|>
name|SqlTypeName
operator|.
name|INTERVAL_DAY_TIME
operator|.
name|getMaxScale
argument_list|()
operator|)
condition|)
block|{
name|fractionalSecondPrecisionOutOfRange
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|startPrecisionOutOfRange
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|qualifier
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|IntervalStartPrecisionOutOfRange
operator|.
name|ex
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|qualifier
operator|.
name|getStartPrecision
argument_list|()
argument_list|)
argument_list|,
literal|"INTERVAL "
operator|+
name|qualifier
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|else if
condition|(
name|fractionalSecondPrecisionOutOfRange
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|qualifier
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|IntervalFractionalSecondPrecisionOutOfRange
operator|.
name|ex
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|qualifier
operator|.
name|getFractionalSecondPrecision
argument_list|()
argument_list|)
argument_list|,
literal|"INTERVAL "
operator|+
name|qualifier
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * Validates the FROM clause of a query, or (recursively) a child node of    * the FROM clause: AS, OVER, JOIN, VALUES, or subquery.    *    * @param node          Node in FROM clause, typically a table or derived    *                      table    * @param targetRowType Desired row type of this expression, or    *                      {@link #unknownType} if not fussy. Must not be null.    * @param scope         Scope    */
specifier|protected
name|void
name|validateFrom
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|Util
operator|.
name|pre
argument_list|(
name|targetRowType
operator|!=
literal|null
argument_list|,
literal|"targetRowType != null"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
name|validateFrom
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
index|[
literal|0
index|]
argument_list|,
name|targetRowType
argument_list|,
name|scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|VALUES
case|:
name|validateValues
argument_list|(
operator|(
name|SqlCall
operator|)
name|node
argument_list|,
name|targetRowType
argument_list|,
name|scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|JOIN
case|:
name|validateJoin
argument_list|(
operator|(
name|SqlJoin
operator|)
name|node
argument_list|,
name|scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|OVER
case|:
name|validateOver
argument_list|(
operator|(
name|SqlCall
operator|)
name|node
argument_list|,
name|scope
argument_list|)
expr_stmt|;
break|break;
default|default:
name|validateQuery
argument_list|(
name|node
argument_list|,
name|scope
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Validate the namespace representation of the node, just in case the
comment|// validation did not occur implicitly.
name|getNamespace
argument_list|(
name|node
argument_list|)
operator|.
name|validate
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|void
name|validateOver
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"OVER unexpected in this context"
argument_list|)
throw|;
block|}
specifier|protected
name|void
name|validateJoin
parameter_list|(
name|SqlJoin
name|join
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|SqlNode
name|left
init|=
name|join
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|SqlNode
name|right
init|=
name|join
operator|.
name|getRight
argument_list|()
decl_stmt|;
name|SqlNode
name|condition
init|=
name|join
operator|.
name|getCondition
argument_list|()
decl_stmt|;
name|boolean
name|natural
init|=
name|join
operator|.
name|isNatural
argument_list|()
decl_stmt|;
name|SqlJoinOperator
operator|.
name|JoinType
name|joinType
init|=
name|join
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
name|SqlJoinOperator
operator|.
name|ConditionType
name|conditionType
init|=
name|join
operator|.
name|getConditionType
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|joinScope
init|=
name|scopes
operator|.
name|get
argument_list|(
name|join
argument_list|)
decl_stmt|;
name|validateFrom
argument_list|(
name|left
argument_list|,
name|unknownType
argument_list|,
name|joinScope
argument_list|)
expr_stmt|;
name|validateFrom
argument_list|(
name|right
argument_list|,
name|unknownType
argument_list|,
name|joinScope
argument_list|)
expr_stmt|;
comment|// Validate condition.
switch|switch
condition|(
name|conditionType
condition|)
block|{
case|case
name|None
case|:
name|Util
operator|.
name|permAssert
argument_list|(
name|condition
operator|==
literal|null
argument_list|,
literal|"condition == null"
argument_list|)
expr_stmt|;
break|break;
case|case
name|On
case|:
name|Util
operator|.
name|permAssert
argument_list|(
name|condition
operator|!=
literal|null
argument_list|,
literal|"condition != null"
argument_list|)
expr_stmt|;
name|validateWhereOrOn
argument_list|(
name|joinScope
argument_list|,
name|condition
argument_list|,
literal|"ON"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Using
case|:
name|SqlNodeList
name|list
init|=
operator|(
name|SqlNodeList
operator|)
name|condition
decl_stmt|;
comment|// Parser ensures that using clause is not empty.
name|Util
operator|.
name|permAssert
argument_list|(
name|list
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|,
literal|"Empty USING clause"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|leftColType
init|=
name|validateUsingCol
argument_list|(
name|id
argument_list|,
name|left
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rightColType
init|=
name|validateUsingCol
argument_list|(
name|id
argument_list|,
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|isComparable
argument_list|(
name|leftColType
argument_list|,
name|rightColType
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|NaturalOrUsingColumnNotCompatible
operator|.
name|ex
argument_list|(
name|id
operator|.
name|getSimple
argument_list|()
argument_list|,
name|leftColType
operator|.
name|toString
argument_list|()
argument_list|,
name|rightColType
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|conditionType
argument_list|)
throw|;
block|}
comment|// Validate NATURAL.
if|if
condition|(
name|natural
condition|)
block|{
if|if
condition|(
name|condition
operator|!=
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|condition
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|NaturalDisallowsOnOrUsing
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
comment|// Join on fields that occur exactly once on each side. Ignore
comment|// fields that occur more than once on either side.
specifier|final
name|RelDataType
name|leftRowType
init|=
name|getNamespace
argument_list|(
name|left
argument_list|)
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rightRowType
init|=
name|getNamespace
argument_list|(
name|right
argument_list|)
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|naturalColumnNames
init|=
name|SqlValidatorUtil
operator|.
name|deriveNaturalJoinColumnList
argument_list|(
name|leftRowType
argument_list|,
name|rightRowType
argument_list|)
decl_stmt|;
comment|// Check compatibility of the chosen columns.
for|for
control|(
name|String
name|name
range|:
name|naturalColumnNames
control|)
block|{
specifier|final
name|RelDataType
name|leftColType
init|=
name|catalogReader
operator|.
name|field
argument_list|(
name|leftRowType
argument_list|,
name|name
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rightColType
init|=
name|catalogReader
operator|.
name|field
argument_list|(
name|rightRowType
argument_list|,
name|name
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|isComparable
argument_list|(
name|leftColType
argument_list|,
name|rightColType
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|join
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|NaturalOrUsingColumnNotCompatible
operator|.
name|ex
argument_list|(
name|name
argument_list|,
name|leftColType
operator|.
name|toString
argument_list|()
argument_list|,
name|rightColType
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Which join types require/allow a ON/USING condition, or allow
comment|// a NATURAL keyword?
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|Inner
case|:
case|case
name|Left
case|:
case|case
name|Right
case|:
case|case
name|Full
case|:
if|if
condition|(
operator|(
name|condition
operator|==
literal|null
operator|)
operator|&&
operator|!
name|natural
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|join
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|JoinRequiresCondition
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
break|break;
case|case
name|Comma
case|:
case|case
name|Cross
case|:
if|if
condition|(
name|condition
operator|!=
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|join
operator|.
name|operands
index|[
name|SqlJoin
operator|.
name|CONDITION_TYPE_OPERAND
index|]
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|CrossJoinDisallowsCondition
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|natural
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|join
operator|.
name|operands
index|[
name|SqlJoin
operator|.
name|CONDITION_TYPE_OPERAND
index|]
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|CrossJoinDisallowsCondition
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|joinType
argument_list|)
throw|;
block|}
block|}
comment|/**    * Throws an error if there is an aggregate or windowed aggregate in the    * given clause.    *    * @param condition Parse tree    * @param clause    Name of clause: "WHERE", "GROUP BY", "ON"    */
specifier|private
name|void
name|validateNoAggs
parameter_list|(
name|SqlNode
name|condition
parameter_list|,
name|String
name|clause
parameter_list|)
block|{
specifier|final
name|SqlNode
name|agg
init|=
name|aggOrOverFinder
operator|.
name|findAgg
argument_list|(
name|condition
argument_list|)
decl_stmt|;
if|if
condition|(
name|agg
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|SqlUtil
operator|.
name|isCallTo
argument_list|(
name|agg
argument_list|,
name|SqlStdOperatorTable
operator|.
name|overOperator
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|agg
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|WindowedAggregateIllegalInClause
operator|.
name|ex
argument_list|(
name|clause
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|newValidationError
argument_list|(
name|agg
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|AggregateIllegalInClause
operator|.
name|ex
argument_list|(
name|clause
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|RelDataType
name|validateUsingCol
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|,
name|SqlNode
name|leftOrRight
parameter_list|)
block|{
if|if
condition|(
name|id
operator|.
name|names
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|name
init|=
name|id
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|namespace
init|=
name|getNamespace
argument_list|(
name|leftOrRight
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|namespace
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeField
name|field
init|=
name|catalogReader
operator|.
name|field
argument_list|(
name|rowType
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|Collections
operator|.
name|frequency
argument_list|(
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|,
name|name
argument_list|)
operator|>
literal|1
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|ColumnInUsingNotUnique
operator|.
name|ex
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|field
operator|.
name|getType
argument_list|()
return|;
block|}
block|}
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|ColumnNotFound
operator|.
name|ex
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|/**    * Validates a SELECT statement.    *    * @param select        Select statement    * @param targetRowType Desired row type, must not be null, may be the data    *                      type 'unknown'.    * @pre targetRowType != null    */
specifier|protected
name|void
name|validateSelect
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|)
block|{
assert|assert
name|targetRowType
operator|!=
literal|null
assert|;
comment|// Namespace is either a select namespace or a wrapper around one.
specifier|final
name|SelectNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|select
argument_list|)
operator|.
name|unwrap
argument_list|(
name|SelectNamespace
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Its rowtype is null, meaning it hasn't been validated yet.
comment|// This is important, because we need to take the targetRowType into
comment|// account.
assert|assert
name|ns
operator|.
name|rowType
operator|==
literal|null
assert|;
if|if
condition|(
name|select
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
name|validateFeature
argument_list|(
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|SQLFeature_E051_01
argument_list|,
name|select
operator|.
name|getModifierNode
argument_list|(
name|SqlSelectKeyword
operator|.
name|Distinct
argument_list|)
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlNodeList
name|selectItems
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
name|RelDataType
name|fromType
init|=
name|unknownType
decl_stmt|;
if|if
condition|(
name|selectItems
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
specifier|final
name|SqlNode
name|selectItem
init|=
name|selectItems
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectItem
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|selectItem
decl_stmt|;
if|if
condition|(
name|id
operator|.
name|isStar
argument_list|()
operator|&&
operator|(
name|id
operator|.
name|names
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
condition|)
block|{
comment|// Special case: for INSERT ... VALUES(?,?), the SQL
comment|// standard says we're supposed to propagate the target
comment|// types down.  So iff the select list is an unqualified
comment|// star (as it will be after an INSERT ... VALUES has been
comment|// expanded), then propagate.
name|fromType
operator|=
name|targetRowType
expr_stmt|;
block|}
block|}
block|}
comment|// Make sure that items in FROM clause have distinct aliases.
specifier|final
name|SqlValidatorScope
name|fromScope
init|=
name|getFromScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|SqlValidatorNamespace
argument_list|>
argument_list|>
name|children
init|=
operator|(
operator|(
name|SelectScope
operator|)
name|fromScope
operator|)
operator|.
name|children
decl_stmt|;
name|int
name|duplicateAliasOrdinal
init|=
name|Util
operator|.
name|firstDuplicate
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|children
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|duplicateAliasOrdinal
operator|>=
literal|0
condition|)
block|{
specifier|final
name|Pair
argument_list|<
name|String
argument_list|,
name|SqlValidatorNamespace
argument_list|>
name|child
init|=
name|children
operator|.
name|get
argument_list|(
name|duplicateAliasOrdinal
argument_list|)
decl_stmt|;
throw|throw
name|newValidationError
argument_list|(
name|child
operator|.
name|right
operator|.
name|getEnclosingNode
argument_list|()
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|FromAliasDuplicate
operator|.
name|ex
argument_list|(
name|child
operator|.
name|left
argument_list|)
argument_list|)
throw|;
block|}
name|validateFrom
argument_list|(
name|select
operator|.
name|getFrom
argument_list|()
argument_list|,
name|fromType
argument_list|,
name|fromScope
argument_list|)
expr_stmt|;
name|validateWhereClause
argument_list|(
name|select
argument_list|)
expr_stmt|;
name|validateGroupClause
argument_list|(
name|select
argument_list|)
expr_stmt|;
name|validateHavingClause
argument_list|(
name|select
argument_list|)
expr_stmt|;
name|validateWindowClause
argument_list|(
name|select
argument_list|)
expr_stmt|;
comment|// Validate the SELECT clause late, because a select item might
comment|// depend on the GROUP BY list, or the window function might reference
comment|// window name in the WINDOW clause etc.
specifier|final
name|RelDataType
name|rowType
init|=
name|validateSelectList
argument_list|(
name|selectItems
argument_list|,
name|select
argument_list|,
name|targetRowType
argument_list|)
decl_stmt|;
name|ns
operator|.
name|setRowType
argument_list|(
name|rowType
argument_list|)
expr_stmt|;
comment|// Validate ORDER BY after we have set ns.rowType because in some
comment|// dialects you can refer to columns of the select list, e.g.
comment|// "SELECT empno AS x FROM emp ORDER BY x"
name|validateOrderList
argument_list|(
name|select
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|validateWindowClause
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
specifier|final
name|SqlNodeList
name|windowList
init|=
name|select
operator|.
name|getWindowList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|windowList
operator|==
literal|null
operator|)
operator|||
operator|(
name|windowList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
return|return;
block|}
specifier|final
name|SelectScope
name|windowScope
init|=
operator|(
name|SelectScope
operator|)
name|getFromScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|Util
operator|.
name|permAssert
argument_list|(
name|windowScope
operator|!=
literal|null
argument_list|,
literal|"windowScope != null"
argument_list|)
expr_stmt|;
comment|// 1. ensure window names are simple
comment|// 2. ensure they are unique within this scope
for|for
control|(
name|SqlNode
name|node
range|:
name|windowList
control|)
block|{
specifier|final
name|SqlWindow
name|child
init|=
operator|(
name|SqlWindow
operator|)
name|node
decl_stmt|;
name|SqlIdentifier
name|declName
init|=
name|child
operator|.
name|getDeclName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|declName
operator|.
name|isSimple
argument_list|()
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|declName
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|WindowNameMustBeSimple
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|windowScope
operator|.
name|existingWindowName
argument_list|(
name|declName
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|declName
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|DuplicateWindowName
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|windowScope
operator|.
name|addWindowName
argument_list|(
name|declName
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 7.10 rule 2
comment|// Check for pairs of windows which are equivalent.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windowList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|window1
init|=
name|windowList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|windowList
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|SqlNode
name|window2
init|=
name|windowList
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|window1
operator|.
name|equalsDeep
argument_list|(
name|window2
argument_list|,
literal|false
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|window2
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|DupWindowSpec
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Hand off to validate window spec components
name|windowList
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|windowScope
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validates the ORDER BY clause of a SELECT statement.    *    * @param select Select statement    */
specifier|protected
name|void
name|validateOrderList
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
comment|// ORDER BY is validated in a scope where aliases in the SELECT clause
comment|// are visible. For example, "SELECT empno AS x FROM emp ORDER BY x"
comment|// is valid.
name|SqlNodeList
name|orderList
init|=
name|select
operator|.
name|getOrderList
argument_list|()
decl_stmt|;
if|if
condition|(
name|orderList
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|shouldAllowIntermediateOrderBy
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|cursorSet
operator|.
name|contains
argument_list|(
name|select
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|select
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|InvalidOrderByPos
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|final
name|SqlValidatorScope
name|orderScope
init|=
name|getOrderScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|Util
operator|.
name|permAssert
argument_list|(
name|orderScope
operator|!=
literal|null
argument_list|,
literal|"orderScope != null"
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|orderItem
range|:
name|orderList
control|)
block|{
name|validateOrderItem
argument_list|(
name|select
argument_list|,
name|orderItem
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|validateOrderItem
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlNode
name|orderItem
parameter_list|)
block|{
if|if
condition|(
name|SqlUtil
operator|.
name|isCallTo
argument_list|(
name|orderItem
argument_list|,
name|SqlStdOperatorTable
operator|.
name|descendingOperator
argument_list|)
condition|)
block|{
name|validateFeature
argument_list|(
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|SQLConformance_OrderByDesc
argument_list|,
name|orderItem
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
name|validateOrderItem
argument_list|(
name|select
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|orderItem
operator|)
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|SqlValidatorScope
name|orderScope
init|=
name|getOrderScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|validateExpr
argument_list|(
name|orderItem
argument_list|,
name|orderScope
argument_list|)
expr_stmt|;
block|}
specifier|public
name|SqlNode
name|expandOrderExpr
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlNode
name|orderExpr
parameter_list|)
block|{
return|return
operator|new
name|OrderExpressionExpander
argument_list|(
name|select
argument_list|,
name|orderExpr
argument_list|)
operator|.
name|go
argument_list|()
return|;
block|}
comment|/**    * Validates the GROUP BY clause of a SELECT statement. This method is    * called even if no GROUP BY clause is present.    */
specifier|protected
name|void
name|validateGroupClause
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
name|SqlNodeList
name|groupList
init|=
name|select
operator|.
name|getGroup
argument_list|()
decl_stmt|;
if|if
condition|(
name|groupList
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|validateNoAggs
argument_list|(
name|groupList
argument_list|,
literal|"GROUP BY"
argument_list|)
expr_stmt|;
specifier|final
name|SqlValidatorScope
name|groupScope
init|=
name|getGroupScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|inferUnknownTypes
argument_list|(
name|unknownType
argument_list|,
name|groupScope
argument_list|,
name|groupList
argument_list|)
expr_stmt|;
name|groupList
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|groupScope
argument_list|)
expr_stmt|;
comment|// Derive the type of each GROUP BY item. We don't need the type, but
comment|// it resolves functions, and that is necessary for deducing
comment|// monotonicity.
specifier|final
name|SqlValidatorScope
name|selectScope
init|=
name|getSelectScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|AggregatingSelectScope
name|aggregatingScope
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|selectScope
operator|instanceof
name|AggregatingSelectScope
condition|)
block|{
name|aggregatingScope
operator|=
operator|(
name|AggregatingSelectScope
operator|)
name|selectScope
expr_stmt|;
block|}
for|for
control|(
name|SqlNode
name|groupItem
range|:
name|groupList
control|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|groupScope
argument_list|,
name|groupItem
argument_list|)
decl_stmt|;
name|setValidatedNodeTypeImpl
argument_list|(
name|groupItem
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|aggregatingScope
operator|!=
literal|null
condition|)
block|{
name|aggregatingScope
operator|.
name|addGroupExpr
argument_list|(
name|groupItem
argument_list|)
expr_stmt|;
block|}
block|}
name|SqlNode
name|agg
init|=
name|aggFinder
operator|.
name|findAgg
argument_list|(
name|groupList
argument_list|)
decl_stmt|;
if|if
condition|(
name|agg
operator|!=
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|agg
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|AggregateIllegalInGroupBy
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|void
name|validateWhereClause
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
comment|// validate WHERE clause
specifier|final
name|SqlNode
name|where
init|=
name|select
operator|.
name|getWhere
argument_list|()
decl_stmt|;
if|if
condition|(
name|where
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|SqlValidatorScope
name|whereScope
init|=
name|getWhereScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|validateWhereOrOn
argument_list|(
name|whereScope
argument_list|,
name|where
argument_list|,
literal|"WHERE"
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|validateWhereOrOn
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNode
name|condition
parameter_list|,
name|String
name|keyword
parameter_list|)
block|{
name|validateNoAggs
argument_list|(
name|condition
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|inferUnknownTypes
argument_list|(
name|booleanType
argument_list|,
name|scope
argument_list|,
name|condition
argument_list|)
expr_stmt|;
name|condition
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|condition
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|inBooleanFamily
argument_list|(
name|type
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|condition
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|CondMustBeBoolean
operator|.
name|ex
argument_list|(
name|keyword
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|void
name|validateHavingClause
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
comment|// HAVING is validated in the scope after groups have been created.
comment|// For example, in "SELECT empno FROM emp WHERE empno = 10 GROUP BY
comment|// deptno HAVING empno = 10", the reference to 'empno' in the HAVING
comment|// clause is illegal.
specifier|final
name|SqlNode
name|having
init|=
name|select
operator|.
name|getHaving
argument_list|()
decl_stmt|;
if|if
condition|(
name|having
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|AggregatingScope
name|havingScope
init|=
operator|(
name|AggregatingScope
operator|)
name|getSelectScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|havingScope
operator|.
name|checkAggregateExpr
argument_list|(
name|having
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|inferUnknownTypes
argument_list|(
name|booleanType
argument_list|,
name|havingScope
argument_list|,
name|having
argument_list|)
expr_stmt|;
name|having
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|havingScope
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|havingScope
argument_list|,
name|having
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|inBooleanFamily
argument_list|(
name|type
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|having
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|HavingMustBeBoolean
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|RelDataType
name|validateSelectList
parameter_list|(
specifier|final
name|SqlNodeList
name|selectItems
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|)
block|{
comment|// First pass, ensure that aliases are unique. "*" and "TABLE.*" items
comment|// are ignored.
comment|// Validate SELECT list. Expand terms of the form "*" or "TABLE.*".
specifier|final
name|SqlValidatorScope
name|selectScope
init|=
name|getSelectScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|expandedSelectItems
init|=
operator|new
name|ArrayList
argument_list|<
name|SqlNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|fieldList
init|=
operator|new
name|ArrayList
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectItems
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|selectItem
init|=
name|selectItems
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectItem
operator|instanceof
name|SqlSelect
condition|)
block|{
name|handleScalarSubQuery
argument_list|(
name|select
argument_list|,
operator|(
name|SqlSelect
operator|)
name|selectItem
argument_list|,
name|expandedSelectItems
argument_list|,
name|aliases
argument_list|,
name|fieldList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expandSelectItem
argument_list|(
name|selectItem
argument_list|,
name|select
argument_list|,
name|expandedSelectItems
argument_list|,
name|aliases
argument_list|,
name|fieldList
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Check expanded select list for aggregation.
if|if
condition|(
name|selectScope
operator|instanceof
name|AggregatingScope
condition|)
block|{
name|AggregatingScope
name|aggScope
init|=
operator|(
name|AggregatingScope
operator|)
name|selectScope
decl_stmt|;
for|for
control|(
name|SqlNode
name|selectItem
range|:
name|expandedSelectItems
control|)
block|{
name|boolean
name|matches
init|=
name|aggScope
operator|.
name|checkAggregateExpr
argument_list|(
name|selectItem
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Util
operator|.
name|discard
argument_list|(
name|matches
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Create the new select list with expanded items.  Pass through
comment|// the original parser position so that any overall failures can
comment|// still reference the original input text.
name|SqlNodeList
name|newSelectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|expandedSelectItems
argument_list|,
name|selectItems
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldExpandIdentifiers
argument_list|()
condition|)
block|{
name|select
operator|.
name|setOperand
argument_list|(
name|SqlSelect
operator|.
name|SELECT_OPERAND
argument_list|,
name|newSelectList
argument_list|)
expr_stmt|;
block|}
name|getRawSelectScope
argument_list|(
name|select
argument_list|)
operator|.
name|setExpandedSelectList
argument_list|(
name|expandedSelectItems
argument_list|)
expr_stmt|;
comment|// TODO: when SELECT appears as a value subquery, should be using
comment|// something other than unknownType for targetRowType
name|inferUnknownTypes
argument_list|(
name|targetRowType
argument_list|,
name|selectScope
argument_list|,
name|newSelectList
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|selectItem
range|:
name|expandedSelectItems
control|)
block|{
name|validateExpr
argument_list|(
name|selectItem
argument_list|,
name|selectScope
argument_list|)
expr_stmt|;
block|}
assert|assert
name|fieldList
operator|.
name|size
argument_list|()
operator|>=
name|aliases
operator|.
name|size
argument_list|()
assert|;
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|fieldList
argument_list|)
return|;
block|}
comment|/**    * Validates an expression.    *    * @param expr  Expression    * @param scope Scope in which expression occurs    */
specifier|private
name|void
name|validateExpr
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
comment|// Call on the expression to validate itself.
name|expr
operator|.
name|validateExpr
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
comment|// Perform any validation specific to the scope. For example, an
comment|// aggregating scope requires that expressions are valid aggregations.
name|scope
operator|.
name|validateExpr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/**    * Processes SubQuery found in Select list. Checks that is actually Scalar    * subquery and makes proper entries in each of the 3 lists used to create    * the final rowType entry.    *    * @param parentSelect        base SqlSelect item    * @param selectItem          child SqlSelect from select list    * @param expandedSelectItems Select items after processing    * @param aliasList           built from user or system values    * @param fieldList           Built up entries for each select list entry    */
specifier|private
name|void
name|handleScalarSubQuery
parameter_list|(
name|SqlSelect
name|parentSelect
parameter_list|,
name|SqlSelect
name|selectItem
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|expandedSelectItems
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|aliasList
parameter_list|,
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|fieldList
parameter_list|)
block|{
comment|// A scalar subquery only has one output column.
if|if
condition|(
literal|1
operator|!=
name|selectItem
operator|.
name|getSelectList
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|selectItem
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|OnlyScalarSubqueryAllowed
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
comment|// No expansion in this routine just append to list.
name|expandedSelectItems
operator|.
name|add
argument_list|(
name|selectItem
argument_list|)
expr_stmt|;
comment|// Get or generate alias and add to list.
specifier|final
name|String
name|alias
init|=
name|deriveAlias
argument_list|(
name|selectItem
argument_list|,
name|aliasList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|aliasList
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
specifier|final
name|SelectScope
name|scope
init|=
operator|(
name|SelectScope
operator|)
name|getWhereScope
argument_list|(
name|parentSelect
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|selectItem
argument_list|)
decl_stmt|;
name|setValidatedNodeTypeImpl
argument_list|(
name|selectItem
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|// we do not want to pass on the RelRecordType returned
comment|// by the sub query.  Just the type of the single expression
comment|// in the subquery select list.
assert|assert
name|type
operator|instanceof
name|RelRecordType
assert|;
name|RelRecordType
name|rec
init|=
operator|(
name|RelRecordType
operator|)
name|type
decl_stmt|;
name|RelDataType
name|nodeType
init|=
name|rec
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|nodeType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|nodeType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fieldList
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|alias
argument_list|,
name|nodeType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Derives a row-type for INSERT and UPDATE operations.    *    * @param table            Target table for INSERT/UPDATE    * @param targetColumnList List of target columns, or null if not specified    * @param append           Whether to append fields to those in<code>    *                         baseRowType</code>    * @return Rowtype    */
specifier|protected
name|RelDataType
name|createTargetRowType
parameter_list|(
name|SqlValidatorTable
name|table
parameter_list|,
name|SqlNodeList
name|targetColumnList
parameter_list|,
name|boolean
name|append
parameter_list|)
block|{
name|RelDataType
name|baseRowType
init|=
name|table
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetColumnList
operator|==
literal|null
condition|)
block|{
return|return
name|baseRowType
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|targetFields
init|=
name|baseRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|append
condition|)
block|{
for|for
control|(
name|RelDataTypeField
name|targetField
range|:
name|targetFields
control|)
block|{
name|types
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|SqlUtil
operator|.
name|deriveAliasFromOrdinal
argument_list|(
name|types
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|targetField
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Set
argument_list|<
name|Integer
argument_list|>
name|assignedFields
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|targetColumnList
control|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|node
decl_stmt|;
name|String
name|name
init|=
name|id
operator|.
name|getSimple
argument_list|()
decl_stmt|;
name|RelDataTypeField
name|targetField
init|=
name|catalogReader
operator|.
name|field
argument_list|(
name|baseRowType
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetField
operator|==
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|UnknownTargetColumn
operator|.
name|ex
argument_list|(
name|name
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|assignedFields
operator|.
name|add
argument_list|(
name|targetField
operator|.
name|getIndex
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|DuplicateTargetColumn
operator|.
name|ex
argument_list|(
name|targetField
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|types
operator|.
name|add
argument_list|(
name|targetField
argument_list|)
expr_stmt|;
block|}
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|types
argument_list|)
return|;
block|}
specifier|public
name|void
name|validateInsert
parameter_list|(
name|SqlInsert
name|insert
parameter_list|)
block|{
name|SqlValidatorNamespace
name|targetNamespace
init|=
name|getNamespace
argument_list|(
name|insert
argument_list|)
decl_stmt|;
name|validateNamespace
argument_list|(
name|targetNamespace
argument_list|)
expr_stmt|;
name|SqlValidatorTable
name|table
init|=
name|targetNamespace
operator|.
name|getTable
argument_list|()
decl_stmt|;
comment|// INSERT has an optional column name list.  If present then
comment|// reduce the rowtype to the columns specified.  If not present
comment|// then the entire target rowtype is used.
name|RelDataType
name|targetRowType
init|=
name|createTargetRowType
argument_list|(
name|table
argument_list|,
name|insert
operator|.
name|getTargetColumnList
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|SqlNode
name|source
init|=
name|insert
operator|.
name|getSource
argument_list|()
decl_stmt|;
if|if
condition|(
name|source
operator|instanceof
name|SqlSelect
condition|)
block|{
name|SqlSelect
name|sqlSelect
init|=
operator|(
name|SqlSelect
operator|)
name|source
decl_stmt|;
name|validateSelect
argument_list|(
name|sqlSelect
argument_list|,
name|targetRowType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SqlValidatorScope
name|scope
init|=
name|scopes
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|validateQuery
argument_list|(
name|source
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
comment|// REVIEW jvs 4-Dec-2008: In FRG-365, this namespace row type is
comment|// discarding the type inferred by inferUnknownTypes (which was invoked
comment|// from validateSelect above).  It would be better if that information
comment|// were used here so that we never saw any untyped nulls during
comment|// checkTypeAssignment.
name|RelDataType
name|sourceRowType
init|=
name|getNamespace
argument_list|(
name|source
argument_list|)
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|RelDataType
name|logicalTargetRowType
init|=
name|getLogicalTargetRowType
argument_list|(
name|targetRowType
argument_list|,
name|insert
argument_list|)
decl_stmt|;
name|setValidatedNodeType
argument_list|(
name|insert
argument_list|,
name|logicalTargetRowType
argument_list|)
expr_stmt|;
name|RelDataType
name|logicalSourceRowType
init|=
name|getLogicalSourceRowType
argument_list|(
name|sourceRowType
argument_list|,
name|insert
argument_list|)
decl_stmt|;
name|checkFieldCount
argument_list|(
name|insert
argument_list|,
name|logicalSourceRowType
argument_list|,
name|logicalTargetRowType
argument_list|)
expr_stmt|;
name|checkTypeAssignment
argument_list|(
name|logicalSourceRowType
argument_list|,
name|logicalTargetRowType
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|validateAccess
argument_list|(
name|insert
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|table
argument_list|,
name|SqlAccessEnum
operator|.
name|INSERT
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkFieldCount
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|RelDataType
name|logicalSourceRowType
parameter_list|,
name|RelDataType
name|logicalTargetRowType
parameter_list|)
block|{
specifier|final
name|int
name|sourceFieldCount
init|=
name|logicalSourceRowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|targetFieldCount
init|=
name|logicalTargetRowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|sourceFieldCount
operator|!=
name|targetFieldCount
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|UnmatchInsertColumn
operator|.
name|ex
argument_list|(
name|targetFieldCount
argument_list|,
name|sourceFieldCount
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|RelDataType
name|getLogicalTargetRowType
parameter_list|(
name|RelDataType
name|targetRowType
parameter_list|,
name|SqlInsert
name|insert
parameter_list|)
block|{
return|return
name|targetRowType
return|;
block|}
specifier|protected
name|RelDataType
name|getLogicalSourceRowType
parameter_list|(
name|RelDataType
name|sourceRowType
parameter_list|,
name|SqlInsert
name|insert
parameter_list|)
block|{
return|return
name|sourceRowType
return|;
block|}
specifier|protected
name|void
name|checkTypeAssignment
parameter_list|(
name|RelDataType
name|sourceRowType
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|,
specifier|final
name|SqlNode
name|query
parameter_list|)
block|{
comment|// NOTE jvs 23-Feb-2006: subclasses may allow for extra targets
comment|// representing system-maintained columns, so stop after all sources
comment|// matched
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sourceFields
init|=
name|sourceRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|targetFields
init|=
name|targetRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|sourceCount
init|=
name|sourceFields
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sourceCount
condition|;
operator|++
name|i
control|)
block|{
name|RelDataType
name|sourceType
init|=
name|sourceFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|targetType
init|=
name|targetFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|canAssignFrom
argument_list|(
name|targetType
argument_list|,
name|sourceType
argument_list|)
condition|)
block|{
comment|// FRG-255:  account for UPDATE rewrite; there's
comment|// probably a better way to do this.
name|int
name|iAdjusted
init|=
name|i
decl_stmt|;
if|if
condition|(
name|query
operator|instanceof
name|SqlUpdate
condition|)
block|{
name|int
name|nUpdateColumns
init|=
operator|(
operator|(
name|SqlUpdate
operator|)
name|query
operator|)
operator|.
name|getTargetColumnList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
assert|assert
name|sourceFields
operator|.
name|size
argument_list|()
operator|>=
name|nUpdateColumns
assert|;
name|iAdjusted
operator|-=
name|sourceFields
operator|.
name|size
argument_list|()
operator|-
name|nUpdateColumns
expr_stmt|;
block|}
name|SqlNode
name|node
init|=
name|getNthExpr
argument_list|(
name|query
argument_list|,
name|iAdjusted
argument_list|,
name|sourceCount
argument_list|)
decl_stmt|;
name|String
name|targetTypeString
decl_stmt|;
name|String
name|sourceTypeString
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|areCharacterSetsMismatched
argument_list|(
name|sourceType
argument_list|,
name|targetType
argument_list|)
condition|)
block|{
name|sourceTypeString
operator|=
name|sourceType
operator|.
name|getFullTypeString
argument_list|()
expr_stmt|;
name|targetTypeString
operator|=
name|targetType
operator|.
name|getFullTypeString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sourceTypeString
operator|=
name|sourceType
operator|.
name|toString
argument_list|()
expr_stmt|;
name|targetTypeString
operator|=
name|targetType
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|TypeNotAssignable
operator|.
name|ex
argument_list|(
name|targetFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
name|targetTypeString
argument_list|,
name|sourceFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
name|sourceTypeString
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Locates the n'th expression in an INSERT or UPDATE query.    *    * @param query       Query    * @param ordinal     Ordinal of expression    * @param sourceCount Number of expressions    * @return Ordinal'th expression, never null    */
specifier|private
name|SqlNode
name|getNthExpr
parameter_list|(
name|SqlNode
name|query
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|int
name|sourceCount
parameter_list|)
block|{
if|if
condition|(
name|query
operator|instanceof
name|SqlInsert
condition|)
block|{
name|SqlInsert
name|insert
init|=
operator|(
name|SqlInsert
operator|)
name|query
decl_stmt|;
if|if
condition|(
name|insert
operator|.
name|getTargetColumnList
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|insert
operator|.
name|getTargetColumnList
argument_list|()
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getNthExpr
argument_list|(
name|insert
operator|.
name|getSource
argument_list|()
argument_list|,
name|ordinal
argument_list|,
name|sourceCount
argument_list|)
return|;
block|}
block|}
if|else if
condition|(
name|query
operator|instanceof
name|SqlUpdate
condition|)
block|{
name|SqlUpdate
name|update
init|=
operator|(
name|SqlUpdate
operator|)
name|query
decl_stmt|;
if|if
condition|(
name|update
operator|.
name|getTargetColumnList
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|update
operator|.
name|getTargetColumnList
argument_list|()
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
if|else if
condition|(
name|update
operator|.
name|getSourceExpressionList
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|update
operator|.
name|getSourceExpressionList
argument_list|()
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getNthExpr
argument_list|(
name|update
operator|.
name|getSourceSelect
argument_list|()
argument_list|,
name|ordinal
argument_list|,
name|sourceCount
argument_list|)
return|;
block|}
block|}
if|else if
condition|(
name|query
operator|instanceof
name|SqlSelect
condition|)
block|{
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|query
decl_stmt|;
if|if
condition|(
name|select
operator|.
name|getSelectList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|sourceCount
condition|)
block|{
return|return
name|select
operator|.
name|getSelectList
argument_list|()
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|query
return|;
comment|// give up
block|}
block|}
else|else
block|{
return|return
name|query
return|;
comment|// give up
block|}
block|}
specifier|public
name|void
name|validateDelete
parameter_list|(
name|SqlDelete
name|call
parameter_list|)
block|{
name|SqlSelect
name|sqlSelect
init|=
name|call
operator|.
name|getSourceSelect
argument_list|()
decl_stmt|;
name|validateSelect
argument_list|(
name|sqlSelect
argument_list|,
name|unknownType
argument_list|)
expr_stmt|;
name|IdentifierNamespace
name|targetNamespace
init|=
name|getNamespace
argument_list|(
name|call
operator|.
name|getTargetTable
argument_list|()
argument_list|)
operator|.
name|unwrap
argument_list|(
name|IdentifierNamespace
operator|.
name|class
argument_list|)
decl_stmt|;
name|validateNamespace
argument_list|(
name|targetNamespace
argument_list|)
expr_stmt|;
name|SqlValidatorTable
name|table
init|=
name|targetNamespace
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|validateAccess
argument_list|(
name|call
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|table
argument_list|,
name|SqlAccessEnum
operator|.
name|DELETE
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|validateUpdate
parameter_list|(
name|SqlUpdate
name|call
parameter_list|)
block|{
name|IdentifierNamespace
name|targetNamespace
init|=
name|getNamespace
argument_list|(
name|call
operator|.
name|getTargetTable
argument_list|()
argument_list|)
operator|.
name|unwrap
argument_list|(
name|IdentifierNamespace
operator|.
name|class
argument_list|)
decl_stmt|;
name|validateNamespace
argument_list|(
name|targetNamespace
argument_list|)
expr_stmt|;
name|SqlValidatorTable
name|table
init|=
name|targetNamespace
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|RelDataType
name|targetRowType
init|=
name|createTargetRowType
argument_list|(
name|table
argument_list|,
name|call
operator|.
name|getTargetColumnList
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|SqlSelect
name|select
init|=
name|call
operator|.
name|getSourceSelect
argument_list|()
decl_stmt|;
name|validateSelect
argument_list|(
name|select
argument_list|,
name|targetRowType
argument_list|)
expr_stmt|;
name|RelDataType
name|sourceRowType
init|=
name|getNamespace
argument_list|(
name|select
argument_list|)
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|checkTypeAssignment
argument_list|(
name|sourceRowType
argument_list|,
name|targetRowType
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|validateAccess
argument_list|(
name|call
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|table
argument_list|,
name|SqlAccessEnum
operator|.
name|UPDATE
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|validateMerge
parameter_list|(
name|SqlMerge
name|call
parameter_list|)
block|{
name|SqlSelect
name|sqlSelect
init|=
name|call
operator|.
name|getSourceSelect
argument_list|()
decl_stmt|;
comment|// REVIEW zfong 5/25/06 - Does an actual type have to be passed into
comment|// validateSelect()?
comment|// REVIEW jvs 6-June-2006:  In general, passing unknownType like
comment|// this means we won't be able to correctly infer the types
comment|// for dynamic parameter markers (SET x = ?).  But
comment|// maybe validateUpdate and validateInsert below will do
comment|// the job?
comment|// REVIEW ksecretan 15-July-2011: They didn't get a chance to
comment|// since validateSelect() would bail.
comment|// Let's use the update/insert targetRowType when available.
name|IdentifierNamespace
name|targetNamespace
init|=
operator|(
name|IdentifierNamespace
operator|)
name|getNamespace
argument_list|(
name|call
operator|.
name|getTargetTable
argument_list|()
argument_list|)
decl_stmt|;
name|validateNamespace
argument_list|(
name|targetNamespace
argument_list|)
expr_stmt|;
name|SqlValidatorTable
name|table
init|=
name|targetNamespace
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|validateAccess
argument_list|(
name|call
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|table
argument_list|,
name|SqlAccessEnum
operator|.
name|UPDATE
argument_list|)
expr_stmt|;
name|RelDataType
name|targetRowType
init|=
name|unknownType
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getUpdateCall
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|targetRowType
operator|=
name|createTargetRowType
argument_list|(
name|table
argument_list|,
name|call
operator|.
name|getUpdateCall
argument_list|()
operator|.
name|getTargetColumnList
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|call
operator|.
name|getInsertCall
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|targetRowType
operator|=
name|createTargetRowType
argument_list|(
name|table
argument_list|,
name|call
operator|.
name|getInsertCall
argument_list|()
operator|.
name|getTargetColumnList
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|validateSelect
argument_list|(
name|sqlSelect
argument_list|,
name|targetRowType
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
operator|.
name|getUpdateCall
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|validateUpdate
argument_list|(
name|call
operator|.
name|getUpdateCall
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|call
operator|.
name|getInsertCall
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|validateInsert
argument_list|(
name|call
operator|.
name|getInsertCall
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Validates access to a table.    *    * @param table          Table    * @param requiredAccess Access requested on table    */
specifier|private
name|void
name|validateAccess
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|SqlValidatorTable
name|table
parameter_list|,
name|SqlAccessEnum
name|requiredAccess
parameter_list|)
block|{
if|if
condition|(
name|table
operator|!=
literal|null
condition|)
block|{
name|SqlAccessType
name|access
init|=
name|table
operator|.
name|getAllowedAccess
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|access
operator|.
name|allowsAccess
argument_list|(
name|requiredAccess
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|AccessNotAllowed
operator|.
name|ex
argument_list|(
name|requiredAccess
operator|.
name|name
argument_list|()
argument_list|,
name|table
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Validates a VALUES clause.    *    * @param node          Values clause    * @param targetRowType Row type which expression must conform to    * @param scope         Scope within which clause occurs    */
specifier|protected
name|void
name|validateValues
parameter_list|(
name|SqlCall
name|node
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|,
specifier|final
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
assert|assert
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|VALUES
assert|;
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|node
operator|.
name|getOperands
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|operands
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|operand
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ROW
operator|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|"Values function where operands are scalars"
argument_list|)
throw|;
block|}
name|SqlCall
name|rowConstructor
init|=
operator|(
name|SqlCall
operator|)
name|operand
decl_stmt|;
if|if
condition|(
name|targetRowType
operator|.
name|isStruct
argument_list|()
operator|&&
operator|(
name|rowConstructor
operator|.
name|getOperands
argument_list|()
operator|.
name|length
operator|!=
name|targetRowType
operator|.
name|getFieldCount
argument_list|()
operator|)
condition|)
block|{
return|return;
block|}
name|inferUnknownTypes
argument_list|(
name|targetRowType
argument_list|,
name|scope
argument_list|,
name|rowConstructor
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SqlNode
name|operand
range|:
name|operands
control|)
block|{
name|operand
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
comment|// validate that all row types have the same number of columns
comment|//  and that expressions in each column are compatible.
comment|// A values expression is turned into something that looks like
comment|// ROW(type00, type01,...), ROW(type11,...),...
specifier|final
name|int
name|rowCount
init|=
name|operands
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|rowCount
operator|>=
literal|2
condition|)
block|{
name|SqlCall
name|firstRow
init|=
operator|(
name|SqlCall
operator|)
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|int
name|columnCount
init|=
name|firstRow
operator|.
name|getOperands
argument_list|()
operator|.
name|length
decl_stmt|;
comment|// 1. check that all rows have the same cols length
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|rowCount
condition|;
name|row
operator|++
control|)
block|{
name|SqlCall
name|thisRow
init|=
operator|(
name|SqlCall
operator|)
name|operands
index|[
name|row
index|]
decl_stmt|;
if|if
condition|(
name|columnCount
operator|!=
name|thisRow
operator|.
name|operands
operator|.
name|length
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|IncompatibleValueType
operator|.
name|ex
argument_list|(
name|SqlStdOperatorTable
operator|.
name|valuesOperator
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// 2. check if types at i:th position in each row are compatible
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
name|columnCount
condition|;
name|col
operator|++
control|)
block|{
specifier|final
name|int
name|c
init|=
name|col
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|leastRestrictive
argument_list|(
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|SqlCall
name|thisRow
init|=
operator|(
name|SqlCall
operator|)
name|operands
index|[
name|row
index|]
decl_stmt|;
return|return
name|deriveType
argument_list|(
name|scope
argument_list|,
name|thisRow
operator|.
name|operands
index|[
name|c
index|]
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rowCount
return|;
block|}
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|type
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|IncompatibleValueType
operator|.
name|ex
argument_list|(
name|SqlStdOperatorTable
operator|.
name|valuesOperator
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|public
name|void
name|validateDataType
parameter_list|(
name|SqlDataTypeSpec
name|dataType
parameter_list|)
block|{
block|}
specifier|public
name|void
name|validateDynamicParam
parameter_list|(
name|SqlDynamicParam
name|dynamicParam
parameter_list|)
block|{
block|}
specifier|public
name|EigenbaseException
name|newValidationError
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|SqlValidatorException
name|e
parameter_list|)
block|{
assert|assert
name|node
operator|!=
literal|null
assert|;
specifier|final
name|SqlParserPos
name|pos
init|=
name|node
operator|.
name|getParserPosition
argument_list|()
decl_stmt|;
return|return
name|SqlUtil
operator|.
name|newContextException
argument_list|(
name|pos
argument_list|,
name|e
argument_list|)
return|;
block|}
specifier|protected
name|SqlWindow
name|getWindowByName
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|SqlWindow
name|window
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|id
operator|.
name|isSimple
argument_list|()
condition|)
block|{
specifier|final
name|String
name|name
init|=
name|id
operator|.
name|getSimple
argument_list|()
decl_stmt|;
name|window
operator|=
name|scope
operator|.
name|lookupWindow
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|window
operator|==
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|WindowNotFound
operator|.
name|ex
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|window
return|;
block|}
specifier|public
name|SqlWindow
name|resolveWindow
parameter_list|(
name|SqlNode
name|windowOrRef
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|boolean
name|populateBounds
parameter_list|)
block|{
name|SqlWindow
name|window
decl_stmt|;
if|if
condition|(
name|windowOrRef
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|window
operator|=
name|getWindowByName
argument_list|(
operator|(
name|SqlIdentifier
operator|)
name|windowOrRef
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|window
operator|=
operator|(
name|SqlWindow
operator|)
name|windowOrRef
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|SqlIdentifier
name|refId
init|=
name|window
operator|.
name|getRefName
argument_list|()
decl_stmt|;
if|if
condition|(
name|refId
operator|==
literal|null
condition|)
block|{
break|break;
block|}
specifier|final
name|String
name|refName
init|=
name|refId
operator|.
name|getSimple
argument_list|()
decl_stmt|;
name|SqlWindow
name|refWindow
init|=
name|scope
operator|.
name|lookupWindow
argument_list|(
name|refName
argument_list|)
decl_stmt|;
if|if
condition|(
name|refWindow
operator|==
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|refId
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|WindowNotFound
operator|.
name|ex
argument_list|(
name|refName
argument_list|)
argument_list|)
throw|;
block|}
name|window
operator|=
name|window
operator|.
name|overlay
argument_list|(
name|refWindow
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|// Fill in missing bounds.
if|if
condition|(
name|populateBounds
condition|)
block|{
if|if
condition|(
name|window
operator|.
name|getLowerBound
argument_list|()
operator|==
literal|null
condition|)
block|{
name|window
operator|.
name|setLowerBound
argument_list|(
name|SqlWindowOperator
operator|.
name|createCurrentRow
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|window
operator|.
name|getUpperBound
argument_list|()
operator|==
literal|null
condition|)
block|{
name|window
operator|.
name|setUpperBound
argument_list|(
name|SqlWindowOperator
operator|.
name|createCurrentRow
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|window
return|;
block|}
specifier|public
name|SqlNode
name|getOriginal
parameter_list|(
name|SqlNode
name|expr
parameter_list|)
block|{
name|SqlNode
name|original
init|=
name|originalExprs
operator|.
name|get
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|original
operator|==
literal|null
condition|)
block|{
name|original
operator|=
name|expr
expr_stmt|;
block|}
return|return
name|original
return|;
block|}
specifier|public
name|void
name|setOriginal
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|SqlNode
name|original
parameter_list|)
block|{
comment|// Don't overwrite the original original.
if|if
condition|(
name|originalExprs
operator|.
name|get
argument_list|(
name|expr
argument_list|)
operator|==
literal|null
condition|)
block|{
name|originalExprs
operator|.
name|put
argument_list|(
name|expr
argument_list|,
name|original
argument_list|)
expr_stmt|;
block|}
block|}
name|SqlValidatorNamespace
name|lookupFieldNamespace
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|String
name|name
parameter_list|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|catalogReader
operator|.
name|field
argument_list|(
name|rowType
argument_list|,
name|name
argument_list|)
decl_stmt|;
return|return
operator|new
name|FieldNamespace
argument_list|(
name|this
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|void
name|validateWindow
parameter_list|(
name|SqlNode
name|windowOrId
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlWindow
name|targetWindow
decl_stmt|;
switch|switch
condition|(
name|windowOrId
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|IDENTIFIER
case|:
comment|// Just verify the window exists in this query.  It will validate
comment|// when the definition is processed
name|targetWindow
operator|=
name|getWindowByName
argument_list|(
operator|(
name|SqlIdentifier
operator|)
name|windowOrId
argument_list|,
name|scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|WINDOW
case|:
name|targetWindow
operator|=
operator|(
name|SqlWindow
operator|)
name|windowOrId
expr_stmt|;
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|windowOrId
operator|.
name|getKind
argument_list|()
argument_list|)
throw|;
block|}
name|Util
operator|.
name|pre
argument_list|(
literal|null
operator|==
name|targetWindow
operator|.
name|getWindowCall
argument_list|()
argument_list|,
literal|"(null == targetWindow.getWindowFunctionCall()"
argument_list|)
expr_stmt|;
name|targetWindow
operator|.
name|setWindowCall
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|targetWindow
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|targetWindow
operator|.
name|setWindowCall
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|validateAggregateParams
parameter_list|(
name|SqlCall
name|aggFunction
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
comment|// For agg(expr), expr cannot itself contain aggregate function
comment|// invocations.  For example, SUM(2*MAX(x)) is illegal; when
comment|// we see it, we'll report the error for the SUM (not the MAX).
comment|// For more than one level of nesting, the error which results
comment|// depends on the traversal order for validation.
for|for
control|(
name|SqlNode
name|param
range|:
name|aggFunction
operator|.
name|getOperands
argument_list|()
control|)
block|{
specifier|final
name|SqlNode
name|agg
init|=
name|aggOrOverFinder
operator|.
name|findAgg
argument_list|(
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggOrOverFinder
operator|.
name|findAgg
argument_list|(
name|param
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|aggFunction
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|NestedAggIllegal
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
name|void
name|validateCall
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|operator
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|call
operator|.
name|operands
operator|.
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|operator
operator|.
name|getSyntax
argument_list|()
operator|==
name|SqlSyntax
operator|.
name|FunctionId
operator|)
operator|&&
operator|!
name|call
operator|.
name|isExpanded
argument_list|()
condition|)
block|{
comment|// For example, "LOCALTIME()" is illegal. (It should be
comment|// "LOCALTIME", which would have been handled as a
comment|// SqlIdentifier.)
throw|throw
name|handleUnresolvedFunction
argument_list|(
name|call
argument_list|,
operator|(
name|SqlFunction
operator|)
name|operator
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RelDataType
operator|>
name|of
argument_list|()
argument_list|)
throw|;
block|}
name|SqlValidatorScope
name|operandScope
init|=
name|scope
operator|.
name|getOperandScope
argument_list|(
name|call
argument_list|)
decl_stmt|;
comment|// Delegate validation to the operator.
name|operator
operator|.
name|validateCall
argument_list|(
name|call
argument_list|,
name|this
argument_list|,
name|scope
argument_list|,
name|operandScope
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validates that a particular feature is enabled. By default, all features    * are enabled; subclasses may override this method to be more    * discriminating.    *    * @param feature feature being used, represented as a resource definition    *                from {@link EigenbaseResource}    * @param context parser position context for error reporting, or null if    *                none available    */
specifier|protected
name|void
name|validateFeature
parameter_list|(
name|ResourceDefinition
name|feature
parameter_list|,
name|SqlParserPos
name|context
parameter_list|)
block|{
comment|// By default, do nothing except to verify that the resource
comment|// represents a real feature definition.
assert|assert
name|feature
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
literal|"FeatureDefinition"
argument_list|)
operator|!=
literal|null
assert|;
block|}
specifier|public
name|SqlNode
name|expand
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
specifier|final
name|Expander
name|expander
init|=
operator|new
name|Expander
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
decl_stmt|;
name|SqlNode
name|newExpr
init|=
name|expr
operator|.
name|accept
argument_list|(
name|expander
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|!=
name|newExpr
condition|)
block|{
name|setOriginal
argument_list|(
name|newExpr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|newExpr
return|;
block|}
specifier|public
name|boolean
name|isSystemField
parameter_list|(
name|RelDataTypeField
name|field
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|getFieldOrigins
parameter_list|(
name|SqlNode
name|sqlQuery
parameter_list|)
block|{
if|if
condition|(
name|sqlQuery
operator|instanceof
name|SqlExplain
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
specifier|final
name|RelDataType
name|rowType
init|=
name|getValidatedNodeType
argument_list|(
name|sqlQuery
argument_list|)
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sqlQuery
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|QUERY
argument_list|)
condition|)
block|{
return|return
name|Collections
operator|.
name|nCopies
argument_list|(
name|fieldCount
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|final
name|ArrayList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldCount
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|origin
init|=
name|getFieldOrigin
argument_list|(
name|sqlQuery
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|//            assert origin == null || origin.size()>= 4 : origin;
name|list
operator|.
name|add
argument_list|(
name|origin
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getFieldOrigin
parameter_list|(
name|SqlNode
name|sqlQuery
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|sqlQuery
operator|instanceof
name|SqlSelect
condition|)
block|{
name|SqlSelect
name|sqlSelect
init|=
operator|(
name|SqlSelect
operator|)
name|sqlQuery
decl_stmt|;
specifier|final
name|SelectScope
name|scope
init|=
name|getRawSelectScope
argument_list|(
name|sqlSelect
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
init|=
name|scope
operator|.
name|getExpandedSelectList
argument_list|()
decl_stmt|;
name|SqlNode
name|selectItem
init|=
name|selectList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlUtil
operator|.
name|isCallTo
argument_list|(
name|selectItem
argument_list|,
name|SqlStdOperatorTable
operator|.
name|asOperator
argument_list|)
condition|)
block|{
name|selectItem
operator|=
operator|(
operator|(
name|SqlCall
operator|)
name|selectItem
operator|)
operator|.
name|getOperands
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|selectItem
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|selectItem
decl_stmt|;
name|SqlValidatorNamespace
name|namespace
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|origin
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|id
operator|.
name|names
control|)
block|{
if|if
condition|(
name|namespace
operator|==
literal|null
condition|)
block|{
name|namespace
operator|=
name|scope
operator|.
name|resolve
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
specifier|final
name|SqlValidatorTable
name|table
init|=
name|namespace
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|table
operator|!=
literal|null
condition|)
block|{
name|origin
operator|.
name|addAll
argument_list|(
name|table
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
name|namespace
operator|=
name|namespace
operator|.
name|lookupChild
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|namespace
operator|!=
literal|null
condition|)
block|{
name|origin
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
return|return
name|origin
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|RelDataType
name|getParameterRowType
parameter_list|(
name|SqlNode
name|sqlQuery
parameter_list|)
block|{
comment|// NOTE: We assume that bind variables occur in depth-first tree
comment|// traversal in the same order that they occurred in the SQL text.
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
decl_stmt|;
name|sqlQuery
operator|.
name|accept
argument_list|(
operator|new
name|SqlShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|getValidatedNodeType
argument_list|(
name|param
argument_list|)
decl_stmt|;
name|types
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|param
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|types
argument_list|,
operator|new
name|AbstractList
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
literal|"?"
operator|+
name|index
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|types
operator|.
name|size
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|public
name|void
name|validateColumnListParams
parameter_list|(
name|SqlFunction
name|function
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|,
name|SqlNode
index|[]
name|operands
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Common base class for DML statement namespaces.    */
specifier|public
specifier|static
class|class
name|DmlNamespace
extends|extends
name|IdentifierNamespace
block|{
specifier|protected
name|DmlNamespace
parameter_list|(
name|SqlValidatorImpl
name|validator
parameter_list|,
name|SqlIdentifier
name|id
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|)
block|{
name|super
argument_list|(
name|validator
argument_list|,
name|id
argument_list|,
name|enclosingNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Namespace for an INSERT statement.    */
specifier|private
specifier|static
class|class
name|InsertNamespace
extends|extends
name|DmlNamespace
block|{
specifier|private
specifier|final
name|SqlInsert
name|node
decl_stmt|;
specifier|public
name|InsertNamespace
parameter_list|(
name|SqlValidatorImpl
name|validator
parameter_list|,
name|SqlInsert
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|)
block|{
name|super
argument_list|(
name|validator
argument_list|,
name|node
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|enclosingNode
argument_list|)
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
assert|assert
name|node
operator|!=
literal|null
assert|;
block|}
specifier|public
name|SqlInsert
name|getNode
parameter_list|()
block|{
return|return
name|node
return|;
block|}
block|}
comment|/**    * Namespace for an UPDATE statement.    */
specifier|private
specifier|static
class|class
name|UpdateNamespace
extends|extends
name|DmlNamespace
block|{
specifier|private
specifier|final
name|SqlUpdate
name|node
decl_stmt|;
specifier|public
name|UpdateNamespace
parameter_list|(
name|SqlValidatorImpl
name|validator
parameter_list|,
name|SqlUpdate
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|)
block|{
name|super
argument_list|(
name|validator
argument_list|,
name|node
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|enclosingNode
argument_list|)
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
assert|assert
name|node
operator|!=
literal|null
assert|;
block|}
specifier|public
name|SqlUpdate
name|getNode
parameter_list|()
block|{
return|return
name|node
return|;
block|}
block|}
comment|/**    * Namespace for a DELETE statement.    */
specifier|private
specifier|static
class|class
name|DeleteNamespace
extends|extends
name|DmlNamespace
block|{
specifier|private
specifier|final
name|SqlDelete
name|node
decl_stmt|;
specifier|public
name|DeleteNamespace
parameter_list|(
name|SqlValidatorImpl
name|validator
parameter_list|,
name|SqlDelete
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|)
block|{
name|super
argument_list|(
name|validator
argument_list|,
name|node
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|enclosingNode
argument_list|)
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
assert|assert
name|node
operator|!=
literal|null
assert|;
block|}
specifier|public
name|SqlDelete
name|getNode
parameter_list|()
block|{
return|return
name|node
return|;
block|}
block|}
comment|/**    * Namespace for a MERGE statement.    */
specifier|private
specifier|static
class|class
name|MergeNamespace
extends|extends
name|DmlNamespace
block|{
specifier|private
specifier|final
name|SqlMerge
name|node
decl_stmt|;
specifier|public
name|MergeNamespace
parameter_list|(
name|SqlValidatorImpl
name|validator
parameter_list|,
name|SqlMerge
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|)
block|{
name|super
argument_list|(
name|validator
argument_list|,
name|node
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|enclosingNode
argument_list|)
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
assert|assert
name|node
operator|!=
literal|null
assert|;
block|}
specifier|public
name|SqlMerge
name|getNode
parameter_list|()
block|{
return|return
name|node
return|;
block|}
block|}
comment|/**    * Visitor which derives the type of a given {@link SqlNode}.    *    *<p>Each method must return the derived type. This visitor is basically a    * single-use dispatcher; the visit is never recursive.    */
specifier|private
class|class
name|DeriveTypeVisitor
implements|implements
name|SqlVisitor
argument_list|<
name|RelDataType
argument_list|>
block|{
specifier|private
specifier|final
name|SqlValidatorScope
name|scope
decl_stmt|;
specifier|public
name|DeriveTypeVisitor
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|this
operator|.
name|scope
operator|=
name|scope
expr_stmt|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
return|return
name|literal
operator|.
name|createSqlType
argument_list|(
name|typeFactory
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|operator
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
return|return
name|operator
operator|.
name|deriveType
argument_list|(
name|SqlValidatorImpl
operator|.
name|this
argument_list|,
name|scope
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
comment|// Operand is of a type that we can't derive a type for. If the
comment|// operand is of a peculiar type, such as a SqlNodeList, then you
comment|// should override the operator's validateCall() method so that it
comment|// doesn't try to validate that operand as an expression.
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|nodeList
argument_list|)
throw|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
comment|// First check for builtin functions which don't have parentheses,
comment|// like "LOCALTIME".
name|SqlCall
name|call
init|=
name|SqlUtil
operator|.
name|makeCall
argument_list|(
name|opTab
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
return|return
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|validateOperands
argument_list|(
name|SqlValidatorImpl
operator|.
name|this
argument_list|,
name|scope
argument_list|,
name|call
argument_list|)
return|;
block|}
name|RelDataType
name|type
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|scope
operator|instanceof
name|EmptyScope
operator|)
condition|)
block|{
name|id
operator|=
name|scope
operator|.
name|fullyQualify
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Ord
argument_list|<
name|String
argument_list|>
name|ord
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|id
operator|.
name|names
argument_list|)
control|)
block|{
name|String
name|name
init|=
name|ord
operator|.
name|e
decl_stmt|;
if|if
condition|(
name|ord
operator|.
name|i
operator|==
literal|0
condition|)
block|{
comment|// REVIEW jvs 9-June-2005: The name resolution rules used
comment|// here are supposed to match SQL:2003 Part 2 Section 6.6
comment|// (identifier chain), but we don't currently have enough
comment|// information to get everything right.  In particular,
comment|// routine parameters are currently looked up via resolve;
comment|// we could do a better job if they were looked up via
comment|// resolveColumn.
comment|// TODO jvs 9-June-2005:  Support schema-qualified table
comment|// names here (FRG-140).  This was illegal in SQL-92, but
comment|// became legal in SQL:1999.  (SQL:2003 Part 2 Section
comment|// 6.6 Syntax Rule 8.b.vi)
name|Util
operator|.
name|discard
argument_list|(
name|Bug
operator|.
name|Frg140Fixed
argument_list|)
expr_stmt|;
name|SqlValidatorNamespace
name|resolvedNs
init|=
name|scope
operator|.
name|resolve
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|resolvedNs
operator|!=
literal|null
condition|)
block|{
comment|// There's a namespace with the name we seek.
name|type
operator|=
name|resolvedNs
operator|.
name|getRowType
argument_list|()
expr_stmt|;
block|}
comment|// Give precedence to namespace found, unless there
comment|// are no more identifier components.
if|if
condition|(
name|type
operator|==
literal|null
operator|||
name|id
operator|.
name|names
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// See if there's a column with the name we seek in
comment|// precisely one of the namespaces in this scope.
name|RelDataType
name|colType
init|=
name|scope
operator|.
name|resolveColumn
argument_list|(
name|name
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|colType
operator|!=
literal|null
condition|)
block|{
name|type
operator|=
name|colType
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
operator|.
name|getComponent
argument_list|(
name|ord
operator|.
name|i
argument_list|)
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|UnknownIdentifier
operator|.
name|ex
argument_list|(
name|name
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|catalogReader
operator|.
name|field
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
operator|.
name|getComponent
argument_list|(
name|ord
operator|.
name|i
argument_list|)
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|UnknownField
operator|.
name|ex
argument_list|(
name|name
argument_list|)
argument_list|)
throw|;
block|}
name|type
operator|=
name|field
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
block|}
name|type
operator|=
name|SqlTypeUtil
operator|.
name|addCharsetAndCollation
argument_list|(
name|type
argument_list|,
name|getTypeFactory
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlDataTypeSpec
name|dataType
parameter_list|)
block|{
comment|// Q. How can a data type have a type?
comment|// A. When it appears in an expression. (Say as the 2nd arg to the
comment|//    CAST operator.)
name|validateDataType
argument_list|(
name|dataType
argument_list|)
expr_stmt|;
return|return
name|dataType
operator|.
name|deriveType
argument_list|(
name|SqlValidatorImpl
operator|.
name|this
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
return|return
name|unknownType
return|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createSqlIntervalType
argument_list|(
name|intervalQualifier
argument_list|)
return|;
block|}
block|}
comment|/**    * Converts an expression into canonical form by fully-qualifying any    * identifiers.    */
specifier|private
specifier|static
class|class
name|Expander
extends|extends
name|SqlScopedShuttle
block|{
specifier|private
specifier|final
name|SqlValidatorImpl
name|validator
decl_stmt|;
specifier|public
name|Expander
parameter_list|(
name|SqlValidatorImpl
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|super
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|this
operator|.
name|validator
operator|=
name|validator
expr_stmt|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
comment|// First check for builtin functions which don't have
comment|// parentheses, like "LOCALTIME".
name|SqlCall
name|call
init|=
name|SqlUtil
operator|.
name|makeCall
argument_list|(
name|validator
operator|.
name|getOperatorTable
argument_list|()
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
return|return
name|call
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|final
name|SqlIdentifier
name|fqId
init|=
name|getScope
argument_list|()
operator|.
name|fullyQualify
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|validator
operator|.
name|setOriginal
argument_list|(
name|fqId
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|fqId
return|;
block|}
comment|// implement SqlScopedShuttle
specifier|protected
name|SqlNode
name|visitScoped
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Only visits arguments which are expressions. We don't want to
comment|// qualify non-expressions such as 'x' in 'empno * 5 AS x'.
name|ArgHandler
argument_list|<
name|SqlNode
argument_list|>
name|argHandler
init|=
operator|new
name|CallCopyingArgHandler
argument_list|(
name|call
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|acceptCall
argument_list|(
name|this
argument_list|,
name|call
argument_list|,
literal|true
argument_list|,
name|argHandler
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|result
init|=
name|argHandler
operator|.
name|result
argument_list|()
decl_stmt|;
name|validator
operator|.
name|setOriginal
argument_list|(
name|result
argument_list|,
name|call
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/**    * Shuttle which walks over an expression in the ORDER BY clause, replacing    * usages of aliases with the underlying expression.    */
class|class
name|OrderExpressionExpander
extends|extends
name|SqlScopedShuttle
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|aliasList
decl_stmt|;
specifier|private
specifier|final
name|SqlSelect
name|select
decl_stmt|;
specifier|private
specifier|final
name|SqlNode
name|root
decl_stmt|;
name|OrderExpressionExpander
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlNode
name|root
parameter_list|)
block|{
name|super
argument_list|(
name|getOrderScope
argument_list|(
name|select
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|select
operator|=
name|select
expr_stmt|;
name|this
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|this
operator|.
name|aliasList
operator|=
name|getNamespace
argument_list|(
name|select
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
expr_stmt|;
block|}
specifier|public
name|SqlNode
name|go
parameter_list|()
block|{
return|return
name|root
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
comment|// Ordinal markers, e.g. 'select a, b from t order by 2'.
comment|// Only recognize them if they are the whole expression,
comment|// and if the dialect permits.
if|if
condition|(
operator|(
name|literal
operator|==
name|root
operator|)
operator|&&
name|getConformance
argument_list|()
operator|.
name|isSortByOrdinal
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|DECIMAL
operator|)
operator|||
operator|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|DOUBLE
operator|)
condition|)
block|{
specifier|final
name|int
name|intValue
init|=
name|literal
operator|.
name|intValue
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|intValue
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|intValue
operator|<
literal|1
operator|)
operator|||
operator|(
name|intValue
operator|>
name|aliasList
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|literal
argument_list|,
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|OrderByOrdinalOutOfRange
operator|.
name|ex
argument_list|()
argument_list|)
throw|;
block|}
comment|// SQL ordinals are 1-based, but SortRel's are 0-based
name|int
name|ordinal
init|=
name|intValue
operator|-
literal|1
decl_stmt|;
return|return
name|nthSelectItem
argument_list|(
name|ordinal
argument_list|,
name|literal
operator|.
name|getParserPosition
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|literal
argument_list|)
return|;
block|}
comment|/**      * Returns the<code>ordinal</code>th item in the select list.      */
specifier|private
name|SqlNode
name|nthSelectItem
parameter_list|(
name|int
name|ordinal
parameter_list|,
specifier|final
name|SqlParserPos
name|pos
parameter_list|)
block|{
comment|// TODO: Don't expand the list every time. Maybe keep an expanded
comment|// version of each expression -- select lists and identifiers -- in
comment|// the validator.
name|SqlNodeList
name|expandedSelectList
init|=
name|expandStar
argument_list|(
name|select
operator|.
name|getSelectList
argument_list|()
argument_list|,
name|select
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|SqlNode
name|expr
init|=
name|expandedSelectList
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|SqlCall
condition|)
block|{
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|expr
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|asOperator
condition|)
block|{
name|expr
operator|=
name|call
operator|.
name|operands
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expr
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|expr
operator|=
name|getScope
argument_list|()
operator|.
name|fullyQualify
argument_list|(
operator|(
name|SqlIdentifier
operator|)
name|expr
argument_list|)
expr_stmt|;
block|}
comment|// Create a copy of the expression with the position of the order
comment|// item.
return|return
name|expr
operator|.
name|clone
argument_list|(
name|pos
argument_list|)
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
comment|// Aliases, e.g. 'select a as x, b from t order by x'.
if|if
condition|(
name|id
operator|.
name|isSimple
argument_list|()
operator|&&
name|getConformance
argument_list|()
operator|.
name|isSortByAlias
argument_list|()
condition|)
block|{
name|String
name|alias
init|=
name|id
operator|.
name|getSimple
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|selectNs
init|=
name|getNamespace
argument_list|(
name|select
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|selectNs
operator|.
name|getRowTypeSansSystemColumns
argument_list|()
decl_stmt|;
name|RelDataTypeField
name|field
init|=
name|catalogReader
operator|.
name|field
argument_list|(
name|rowType
argument_list|,
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
return|return
name|nthSelectItem
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|,
name|id
operator|.
name|getParserPosition
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|// No match. Return identifier unchanged.
return|return
name|getScope
argument_list|()
operator|.
name|fullyQualify
argument_list|(
name|id
argument_list|)
return|;
block|}
specifier|protected
name|SqlNode
name|visitScoped
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Don't attempt to expand sub-queries. We haven't implemented
comment|// these yet.
if|if
condition|(
name|call
operator|instanceof
name|SqlSelect
condition|)
block|{
return|return
name|call
return|;
block|}
return|return
name|super
operator|.
name|visitScoped
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
specifier|protected
specifier|static
class|class
name|IdInfo
block|{
specifier|public
specifier|final
name|SqlValidatorScope
name|scope
decl_stmt|;
specifier|public
specifier|final
name|SqlIdentifier
name|id
decl_stmt|;
specifier|public
name|IdInfo
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlIdentifier
name|id
parameter_list|)
block|{
name|this
operator|.
name|scope
operator|=
name|scope
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
block|}
comment|/**    * Utility object used to maintain information about the parameters in a    * function call.    */
specifier|protected
specifier|static
class|class
name|FunctionParamInfo
block|{
comment|/**      * Maps a cursor (based on its position relative to other cursor      * parameters within a function call) to the SELECT associated with the      * cursor.      */
specifier|public
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|SqlSelect
argument_list|>
name|cursorPosToSelectMap
decl_stmt|;
comment|/**      * Maps a column list parameter to the parent cursor parameter it      * references. The parameters are id'd by their names.      */
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|columnListParamToParentCursorMap
decl_stmt|;
specifier|public
name|FunctionParamInfo
parameter_list|()
block|{
name|cursorPosToSelectMap
operator|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|SqlSelect
argument_list|>
argument_list|()
expr_stmt|;
name|columnListParamToParentCursorMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End SqlValidatorImpl.java
end_comment

end_unit

