begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to the Apache Software Foundation (ASF) under one or more // contributor license agreements.  See the NOTICE file distributed with // this work for additional information regarding copyright ownership. // The ASF licenses this file to you under the Apache License, Version 2.0 // (the "License"); you may not use this file except in compliance with // the License.  You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
package|;
end_package

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|parser
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|validate
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util14
operator|.
name|*
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Static
operator|.
name|RESOURCE
import|;
end_import

begin_comment
comment|/**  * Contains utility methods used during SQL validation or type derivation.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|SqlTypeUtil
block|{
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Checks whether two types or more are char comparable.    *    * @return Returns true if all operands are of char type and if they are    * comparable, i.e. of the same charset and collation of same charset    */
specifier|public
specifier|static
name|boolean
name|isCharTypeComparable
parameter_list|(
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|)
block|{
assert|assert
name|argTypes
operator|!=
literal|null
assert|;
assert|assert
name|argTypes
operator|.
name|size
argument_list|()
operator|>=
literal|2
assert|;
comment|// Filter out ANY elements.
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes2
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataType
name|t
range|:
name|argTypes
control|)
block|{
if|if
condition|(
operator|!
name|isAny
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|argTypes2
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Pair
argument_list|<
name|RelDataType
argument_list|,
name|RelDataType
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|adjacents
argument_list|(
name|argTypes2
argument_list|)
control|)
block|{
name|RelDataType
name|t0
init|=
name|pair
operator|.
name|left
decl_stmt|;
name|RelDataType
name|t1
init|=
name|pair
operator|.
name|right
decl_stmt|;
if|if
condition|(
operator|!
name|inCharFamily
argument_list|(
name|t0
argument_list|)
operator|||
operator|!
name|inCharFamily
argument_list|(
name|t1
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|t0
operator|.
name|getCharset
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"RelDataType object should have been assigned a "
operator|+
literal|"(default) charset when calling deriveType"
argument_list|)
throw|;
block|}
if|else if
condition|(
operator|!
name|t0
operator|.
name|getCharset
argument_list|()
operator|.
name|equals
argument_list|(
name|t1
operator|.
name|getCharset
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|t0
operator|.
name|getCollation
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"RelDataType object should have been assigned a "
operator|+
literal|"(default) collation when calling deriveType"
argument_list|)
throw|;
block|}
if|else if
condition|(
operator|!
name|t0
operator|.
name|getCollation
argument_list|()
operator|.
name|getCharset
argument_list|()
operator|.
name|equals
argument_list|(
name|t1
operator|.
name|getCollation
argument_list|()
operator|.
name|getCharset
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether the operands to a call are char type-comparable.    *    * @param binding        Binding of call to operands    * @param operands       Operands to check for compatibility; usually the    *                       operands of the bound call, but not always    * @param throwOnFailure Whether to throw an exception on failure    * @return whether operands are valid    */
specifier|public
specifier|static
name|boolean
name|isCharTypeComparable
parameter_list|(
name|SqlCallBinding
name|binding
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
parameter_list|,
name|boolean
name|throwOnFailure
parameter_list|)
block|{
specifier|final
name|SqlValidator
name|validator
init|=
name|binding
operator|.
name|getValidator
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|scope
init|=
name|binding
operator|.
name|getScope
argument_list|()
decl_stmt|;
assert|assert
name|operands
operator|!=
literal|null
assert|;
assert|assert
name|operands
operator|.
name|size
argument_list|()
operator|>=
literal|2
assert|;
if|if
condition|(
operator|!
name|isCharTypeComparable
argument_list|(
name|deriveAndCollectTypes
argument_list|(
name|validator
argument_list|,
name|scope
argument_list|,
name|operands
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|throwOnFailure
condition|)
block|{
name|String
name|msg
init|=
literal|""
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|msg
operator|+=
literal|", "
expr_stmt|;
block|}
name|msg
operator|+=
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
throw|throw
name|binding
operator|.
name|newError
argument_list|(
name|RESOURCE
operator|.
name|operandNotComparable
argument_list|(
name|msg
argument_list|)
argument_list|)
throw|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Iterates over all operands, derives their types, and collects them into    * a list.    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataType
argument_list|>
name|deriveAndCollectTypes
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
parameter_list|)
block|{
comment|// NOTE: Do not use an AbstractList. Don't want to be lazy. We want
comment|// errors.
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|operands
control|)
block|{
name|types
operator|.
name|add
argument_list|(
name|validator
operator|.
name|deriveType
argument_list|(
name|scope
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|types
return|;
block|}
comment|/**    * Promotes a type to a row type (does nothing if it already is one).    *    * @param type      type to be promoted    * @param fieldName name to give field in row type; null for default of    *                  "ROW_VALUE"    * @return row type    */
specifier|public
specifier|static
name|RelDataType
name|promoteToRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
block|{
name|fieldName
operator|=
literal|"ROW_VALUE"
expr_stmt|;
block|}
name|type
operator|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
name|fieldName
argument_list|,
name|type
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
comment|/**    * Recreates a given RelDataType with nullability iff any of the operands    * of a call are nullable.    */
specifier|public
specifier|static
name|RelDataType
name|makeNullableIfOperandsAre
parameter_list|(
specifier|final
name|SqlValidator
name|validator
parameter_list|,
specifier|final
name|SqlValidatorScope
name|scope
parameter_list|,
specifier|final
name|SqlCall
name|call
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|RelDataType
name|operandType
init|=
name|validator
operator|.
name|deriveType
argument_list|(
name|scope
argument_list|,
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|containsNullable
argument_list|(
name|operandType
argument_list|)
condition|)
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|validator
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|type
return|;
block|}
comment|/**    * Recreates a given RelDataType with nullability iff any of the param    * argTypes are nullable.    */
specifier|public
specifier|static
name|RelDataType
name|makeNullableIfOperandsAre
parameter_list|(
specifier|final
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|containsNullable
argument_list|(
name|argTypes
argument_list|)
condition|)
block|{
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
comment|/**    * Returns whether one or more of an array of types is nullable.    */
specifier|public
specifier|static
name|boolean
name|containsNullable
parameter_list|(
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
parameter_list|)
block|{
for|for
control|(
name|RelDataType
name|type
range|:
name|types
control|)
block|{
if|if
condition|(
name|containsNullable
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Determines whether a type or any of its fields (if a structured type) are    * nullable.    */
specifier|public
specifier|static
name|boolean
name|containsNullable
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|type
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
name|containsNullable
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns typeName.equals(type.getSqlTypeName()). If    * typeName.equals(SqlTypeName.Any) true is always returned.    */
specifier|public
specifier|static
name|boolean
name|isOfSameTypeName
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|SqlTypeName
operator|.
name|ANY
operator|.
name|equals
argument_list|(
name|typeName
argument_list|)
operator|||
name|typeName
operator|.
name|equals
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns true if any element in<code>typeNames</code> matches    * type.getSqlTypeName().    *    * @see #isOfSameTypeName(SqlTypeName, RelDataType)    */
specifier|public
specifier|static
name|boolean
name|isOfSameTypeName
parameter_list|(
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|typeNames
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
for|for
control|(
name|SqlTypeName
name|typeName
range|:
name|typeNames
control|)
block|{
if|if
condition|(
name|isOfSameTypeName
argument_list|(
name|typeName
argument_list|,
name|type
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * @return true if type is DATE, TIME, or TIMESTAMP    */
specifier|public
specifier|static
name|boolean
name|isDatetime
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|SqlTypeFamily
operator|.
name|DATETIME
operator|.
name|contains
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * @return true if type is some kind of INTERVAL    */
specifier|public
specifier|static
name|boolean
name|isInterval
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|SqlTypeFamily
operator|.
name|DATETIME_INTERVAL
operator|.
name|contains
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * @return true if type is in SqlTypeFamily.Character    */
specifier|public
specifier|static
name|boolean
name|inCharFamily
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|type
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
return|;
block|}
comment|/**    * @return true if type is in SqlTypeFamily.Character    */
specifier|public
specifier|static
name|boolean
name|inCharFamily
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|)
block|{
return|return
name|typeName
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
return|;
block|}
comment|/**    * @return true if type is in SqlTypeFamily.Boolean    */
specifier|public
specifier|static
name|boolean
name|inBooleanFamily
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|type
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|BOOLEAN
return|;
block|}
comment|/**    * @return true if two types are in same type family    */
specifier|public
specifier|static
name|boolean
name|inSameFamily
parameter_list|(
name|RelDataType
name|t1
parameter_list|,
name|RelDataType
name|t2
parameter_list|)
block|{
return|return
name|t1
operator|.
name|getFamily
argument_list|()
operator|==
name|t2
operator|.
name|getFamily
argument_list|()
return|;
block|}
comment|/**    * @return true if two types are in same type family, or one or the other is    * of type {@link SqlTypeName#NULL}.    */
specifier|public
specifier|static
name|boolean
name|inSameFamilyOrNull
parameter_list|(
name|RelDataType
name|t1
parameter_list|,
name|RelDataType
name|t2
parameter_list|)
block|{
return|return
operator|(
name|t1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
operator|)
operator|||
operator|(
name|t2
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
operator|)
operator|||
operator|(
name|t1
operator|.
name|getFamily
argument_list|()
operator|==
name|t2
operator|.
name|getFamily
argument_list|()
operator|)
return|;
block|}
comment|/**    * @return true if type family is either character or binary    */
specifier|public
specifier|static
name|boolean
name|inCharOrBinaryFamilies
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
operator|(
name|type
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
operator|)
operator|||
operator|(
name|type
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|BINARY
operator|)
return|;
block|}
comment|/**    * @return true if type is a LOB of some kind    */
specifier|public
specifier|static
name|boolean
name|isLob
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
comment|// TODO jvs 9-Dec-2004:  once we support LOB types
return|return
literal|false
return|;
block|}
comment|/**    * @return true if type is variable width with bounded precision    */
specifier|public
specifier|static
name|boolean
name|isBoundedVariableWidth
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|VARCHAR
case|:
case|case
name|VARBINARY
case|:
comment|// TODO angel 8-June-2005: Multiset should be LOB
case|case
name|MULTISET
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * @return true if type is one of the integer types    */
specifier|public
specifier|static
name|boolean
name|isIntType
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * @return true if type is decimal    */
specifier|public
specifier|static
name|boolean
name|isDecimal
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|typeName
operator|==
name|SqlTypeName
operator|.
name|DECIMAL
return|;
block|}
comment|/**    * @return true if type is bigint    */
specifier|public
specifier|static
name|boolean
name|isBigint
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|typeName
operator|==
name|SqlTypeName
operator|.
name|BIGINT
return|;
block|}
comment|/**    * @return true if type is numeric with exact precision    */
specifier|public
specifier|static
name|boolean
name|isExactNumeric
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Returns the maximum value of an integral type, as a long value    */
specifier|public
specifier|static
name|long
name|maxValue
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
assert|assert
name|SqlTypeUtil
operator|.
name|isIntType
argument_list|(
name|type
argument_list|)
assert|;
switch|switch
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|TINYINT
case|:
return|return
name|Byte
operator|.
name|MAX_VALUE
return|;
case|case
name|SMALLINT
case|:
return|return
name|Short
operator|.
name|MAX_VALUE
return|;
case|case
name|INTEGER
case|:
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
case|case
name|BIGINT
case|:
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return true if type is numeric with approximate precision    */
specifier|public
specifier|static
name|boolean
name|isApproximateNumeric
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|FLOAT
case|:
case|case
name|REAL
case|:
case|case
name|DOUBLE
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * @return true if type is numeric    */
specifier|public
specifier|static
name|boolean
name|isNumeric
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|isExactNumeric
argument_list|(
name|type
argument_list|)
operator|||
name|isApproximateNumeric
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * Tests whether two types have the same name and structure, possibly with    * differing modifiers. For example, VARCHAR(1) and VARCHAR(10) are    * considered the same, while VARCHAR(1) and CHAR(1) are considered    * different. Likewise, VARCHAR(1) MULTISET and VARCHAR(10) MULTISET are    * considered the same.    *    * @return true if types have same name and structure    */
specifier|public
specifier|static
name|boolean
name|sameNamedType
parameter_list|(
name|RelDataType
name|t1
parameter_list|,
name|RelDataType
name|t2
parameter_list|)
block|{
if|if
condition|(
name|t1
operator|.
name|isStruct
argument_list|()
operator|||
name|t2
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|t1
operator|.
name|isStruct
argument_list|()
operator|||
operator|!
name|t2
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|t1
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|t2
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields1
init|=
name|t1
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields2
init|=
name|t2
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields1
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|sameNamedType
argument_list|(
name|fields1
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|fields2
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
name|RelDataType
name|comp1
init|=
name|t1
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
name|RelDataType
name|comp2
init|=
name|t2
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|comp1
operator|!=
literal|null
operator|)
operator|||
operator|(
name|comp2
operator|!=
literal|null
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|comp1
operator|==
literal|null
operator|)
operator|||
operator|(
name|comp2
operator|==
literal|null
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|sameNamedType
argument_list|(
name|comp1
argument_list|,
name|comp2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|t1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|t2
operator|.
name|getSqlTypeName
argument_list|()
return|;
block|}
comment|/**    * Computes the maximum number of bytes required to represent a value of a    * type having user-defined precision. This computation assumes no overhead    * such as length indicators and NUL-terminators. Complex types for which    * multiple representations are possible (e.g. DECIMAL or TIMESTAMP) return    * 0.    *    * @param type type for which to compute storage    * @return maximum bytes, or 0 for a fixed-width type or type with unknown    * maximum    */
specifier|public
specifier|static
name|int
name|getMaxByteSize
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|VARCHAR
case|:
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
operator|(
name|double
operator|)
name|type
operator|.
name|getPrecision
argument_list|()
operator|)
operator|*
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|newEncoder
argument_list|()
operator|.
name|maxBytesPerChar
argument_list|()
argument_list|)
return|;
case|case
name|BINARY
case|:
case|case
name|VARBINARY
case|:
return|return
name|type
operator|.
name|getPrecision
argument_list|()
return|;
case|case
name|MULTISET
case|:
comment|// TODO Wael Jan-24-2005: Need a better way to tell fennel this
comment|// number. This a very generic place and implementation details like
comment|// this doesnt belong here. Waiting to change this once we have blob
comment|// support
return|return
literal|4096
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
comment|/**    * Determines the minimum unscaled value of a numeric type    *    * @param type a numeric type    */
specifier|public
specifier|static
name|long
name|getMinValue
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
return|return
name|Byte
operator|.
name|MIN_VALUE
return|;
case|case
name|SMALLINT
case|:
return|return
name|Short
operator|.
name|MIN_VALUE
return|;
case|case
name|INTEGER
case|:
return|return
name|Integer
operator|.
name|MIN_VALUE
return|;
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
return|return
name|NumberUtil
operator|.
name|getMinUnscaled
argument_list|(
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
default|default:
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"getMinValue("
operator|+
name|typeName
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Determines the maximum unscaled value of a numeric type    *    * @param type a numeric type    */
specifier|public
specifier|static
name|long
name|getMaxValue
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
return|return
name|Byte
operator|.
name|MAX_VALUE
return|;
case|case
name|SMALLINT
case|:
return|return
name|Short
operator|.
name|MAX_VALUE
return|;
case|case
name|INTEGER
case|:
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
return|return
name|NumberUtil
operator|.
name|getMaxUnscaled
argument_list|(
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
default|default:
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"getMaxValue("
operator|+
name|typeName
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return true if type has a representation as a Java primitive (ignoring    * nullability)    */
specifier|public
specifier|static
name|boolean
name|isJavaPrimitive
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|BOOLEAN
case|:
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
case|case
name|FLOAT
case|:
case|case
name|REAL
case|:
case|case
name|DOUBLE
case|:
case|case
name|SYMBOL
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * @return class name of the wrapper for the primitive data type.    */
specifier|public
specifier|static
name|String
name|getPrimitiveWrapperJavaClassName
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|BOOLEAN
case|:
return|return
literal|"Boolean"
return|;
default|default:
return|return
name|getNumericJavaClassName
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
comment|/**    * @return class name of the numeric data type.    */
specifier|public
specifier|static
name|String
name|getNumericJavaClassName
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
return|return
literal|"Byte"
return|;
case|case
name|SMALLINT
case|:
return|return
literal|"Short"
return|;
case|case
name|INTEGER
case|:
return|return
literal|"Integer"
return|;
case|case
name|BIGINT
case|:
return|return
literal|"Long"
return|;
case|case
name|REAL
case|:
return|return
literal|"Float"
return|;
case|case
name|DECIMAL
case|:
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
return|return
literal|"Double"
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isAny
parameter_list|(
name|RelDataType
name|t
parameter_list|)
block|{
return|return
name|t
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|ANY
return|;
block|}
comment|/**    * Tests whether a value can be assigned to a site.    *    * @param toType   type of the target site    * @param fromType type of the source value    * @return true iff assignable    */
specifier|public
specifier|static
name|boolean
name|canAssignFrom
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RelDataType
name|fromType
parameter_list|)
block|{
if|if
condition|(
name|isAny
argument_list|(
name|toType
argument_list|)
operator|||
name|isAny
argument_list|(
name|fromType
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// TODO jvs 2-Jan-2005:  handle all the other cases like
comment|// rows, collections, UDT's
if|if
condition|(
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
condition|)
block|{
comment|// REVIEW jvs 4-Dec-2008: We allow assignment from NULL to any
comment|// type, including NOT NULL types, since in the case where no
comment|// rows are actually processed, the assignment is legal
comment|// (FRG-365).  However, it would be better if the validator's
comment|// NULL type inference guaranteed that we had already
comment|// assigned a real (nullable) type to every NULL literal.
return|return
literal|true
return|;
block|}
if|if
condition|(
name|areCharacterSetsMismatched
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|toType
operator|.
name|getFamily
argument_list|()
operator|==
name|fromType
operator|.
name|getFamily
argument_list|()
return|;
block|}
comment|/**    * Determines whether two types both have different character sets. If one    * or the other type has no character set (e.g. in cast from INT to    * VARCHAR), that is not a mismatch.    *    * @param t1 first type    * @param t2 second type    * @return true iff mismatched    */
specifier|public
specifier|static
name|boolean
name|areCharacterSetsMismatched
parameter_list|(
name|RelDataType
name|t1
parameter_list|,
name|RelDataType
name|t2
parameter_list|)
block|{
if|if
condition|(
name|isAny
argument_list|(
name|t1
argument_list|)
operator|||
name|isAny
argument_list|(
name|t2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Charset
name|cs1
init|=
name|t1
operator|.
name|getCharset
argument_list|()
decl_stmt|;
name|Charset
name|cs2
init|=
name|t2
operator|.
name|getCharset
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|cs1
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|cs2
operator|!=
literal|null
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|cs1
operator|.
name|equals
argument_list|(
name|cs2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Compares two types and returns true if fromType can be cast to toType.    *    *<p>REVIEW jvs 17-Dec-2004: the coerce param below shouldn't really be    * necessary. We're using it as a hack because {@link    * SqlTypeFactoryImpl#leastRestrictiveSqlType} isn't complete enough yet.    * Once it is, this param (and the non-coerce rules of {@link    * SqlTypeAssignmentRules}) should go away.    *    * @param toType   target of assignment    * @param fromType source of assignment    * @param coerce   if true, the SQL rules for CAST are used; if false, the    *                 rules are similar to Java; e.g. you can't assign short x =    *                 (int) y, and you can't assign int x = (String) z.    * @return true iff cast is legal    */
specifier|public
specifier|static
name|boolean
name|canCastFrom
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RelDataType
name|fromType
parameter_list|,
name|boolean
name|coerce
parameter_list|)
block|{
if|if
condition|(
name|toType
operator|==
name|fromType
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|isAny
argument_list|(
name|toType
argument_list|)
operator|||
name|isAny
argument_list|(
name|fromType
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|final
name|SqlTypeName
name|fromTypeName
init|=
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
specifier|final
name|SqlTypeName
name|toTypeName
init|=
name|toType
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|toType
operator|.
name|isStruct
argument_list|()
operator|||
name|fromType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
name|toTypeName
operator|==
name|SqlTypeName
operator|.
name|DISTINCT
condition|)
block|{
if|if
condition|(
name|fromTypeName
operator|==
name|SqlTypeName
operator|.
name|DISTINCT
condition|)
block|{
comment|// can't cast between different distinct types
return|return
literal|false
return|;
block|}
return|return
name|canCastFrom
argument_list|(
name|toType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|fromType
argument_list|,
name|coerce
argument_list|)
return|;
block|}
if|else if
condition|(
name|fromTypeName
operator|==
name|SqlTypeName
operator|.
name|DISTINCT
condition|)
block|{
return|return
name|canCastFrom
argument_list|(
name|toType
argument_list|,
name|fromType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|coerce
argument_list|)
return|;
block|}
if|else if
condition|(
name|toTypeName
operator|==
name|SqlTypeName
operator|.
name|ROW
condition|)
block|{
if|if
condition|(
name|fromTypeName
operator|!=
name|SqlTypeName
operator|.
name|ROW
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|n
init|=
name|toType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|fromType
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|n
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|RelDataTypeField
name|toField
init|=
name|toType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RelDataTypeField
name|fromField
init|=
name|fromType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|canCastFrom
argument_list|(
name|toField
operator|.
name|getType
argument_list|()
argument_list|,
name|fromField
operator|.
name|getType
argument_list|()
argument_list|,
name|coerce
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
if|else if
condition|(
name|toTypeName
operator|==
name|SqlTypeName
operator|.
name|MULTISET
condition|)
block|{
if|if
condition|(
operator|!
name|fromType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fromTypeName
operator|!=
name|SqlTypeName
operator|.
name|MULTISET
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|canCastFrom
argument_list|(
name|toType
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|fromType
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|coerce
argument_list|)
return|;
block|}
if|else if
condition|(
name|fromTypeName
operator|==
name|SqlTypeName
operator|.
name|MULTISET
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|toType
operator|.
name|getFamily
argument_list|()
operator|==
name|fromType
operator|.
name|getFamily
argument_list|()
return|;
block|}
block|}
name|RelDataType
name|c1
init|=
name|toType
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|c1
operator|!=
literal|null
condition|)
block|{
name|RelDataType
name|c2
init|=
name|fromType
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|c2
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|canCastFrom
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|coerce
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|isInterval
argument_list|(
name|fromType
argument_list|)
operator|&&
name|isExactNumeric
argument_list|(
name|toType
argument_list|)
operator|)
operator|||
operator|(
name|isInterval
argument_list|(
name|toType
argument_list|)
operator|&&
name|isExactNumeric
argument_list|(
name|fromType
argument_list|)
operator|)
condition|)
block|{
name|IntervalSqlType
name|intervalType
init|=
operator|(
name|IntervalSqlType
operator|)
operator|(
name|isInterval
argument_list|(
name|fromType
argument_list|)
condition|?
name|fromType
else|:
name|toType
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|isSingleDatetimeField
argument_list|()
condition|)
block|{
comment|// Casts between intervals and exact numerics must involve
comment|// intervals with a single datetime field.
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|toTypeName
operator|==
literal|null
operator|||
name|fromTypeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// REVIEW jvs 9-Feb-2009: we don't impose SQL rules for character sets
comment|// here; instead, we do that in SqlCastFunction.  The reason is that
comment|// this method is called from at least one place (MedJdbcNameDirectory)
comment|// where internally a cast across character repertoires is OK.  Should
comment|// probably clean that up.
name|SqlTypeAssignmentRules
name|rules
init|=
name|SqlTypeAssignmentRules
operator|.
name|instance
argument_list|()
decl_stmt|;
return|return
name|rules
operator|.
name|canCastFrom
argument_list|(
name|toTypeName
argument_list|,
name|fromTypeName
argument_list|,
name|coerce
argument_list|)
return|;
block|}
comment|/**    * Flattens a record type by recursively expanding any fields which are    * themselves record types. For each record type, a representative null    * value field is also prepended (with state NULL for a null value and FALSE    * for non-null), and all component types are asserted to be nullable, since    * SQL doesn't allow NOT NULL to be specified on attributes.    *    * @param typeFactory   factory which should produced flattened type    * @param recordType    type with possible nesting    * @param flatteningMap if non-null, receives map from unflattened ordinal    *                      to flattened ordinal (must have length at least    *                      recordType.getFieldList().size())    * @return flattened equivalent    */
specifier|public
specifier|static
name|RelDataType
name|flattenRecordType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|recordType
parameter_list|,
name|int
index|[]
name|flatteningMap
parameter_list|)
block|{
if|if
condition|(
operator|!
name|recordType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
name|recordType
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fieldList
init|=
operator|new
name|ArrayList
argument_list|<
name|RelDataTypeField
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|nested
init|=
name|flattenFields
argument_list|(
name|typeFactory
argument_list|,
name|recordType
argument_list|,
name|fieldList
argument_list|,
name|flatteningMap
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nested
condition|)
block|{
return|return
name|recordType
return|;
block|}
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|fieldList
control|)
block|{
operator|++
name|i
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
operator|+
literal|"_"
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|types
argument_list|,
name|fieldNames
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|needsNullIndicator
parameter_list|(
name|RelDataType
name|recordType
parameter_list|)
block|{
comment|// NOTE jvs 9-Mar-2005: It would be more storage-efficient to say that
comment|// no null indicator is required for structured type columns declared
comment|// as NOT NULL.  However, the uniformity of always having a null
comment|// indicator makes things cleaner in many places.
return|return
name|recordType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|STRUCTURED
return|;
block|}
specifier|private
specifier|static
name|boolean
name|flattenFields
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|list
parameter_list|,
name|int
index|[]
name|flatteningMap
parameter_list|)
block|{
name|boolean
name|nested
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|needsNullIndicator
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|// NOTE jvs 9-Mar-2005:  other code
comment|// (e.g. RelStructuredTypeFlattener) relies on the
comment|// null indicator field coming first.
name|RelDataType
name|indicatorType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|indicatorType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|indicatorType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|RelDataTypeField
name|nullIndicatorField
init|=
operator|new
name|RelDataTypeFieldImpl
argument_list|(
literal|"NULL_VALUE"
argument_list|,
literal|0
argument_list|,
name|indicatorType
argument_list|)
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|nullIndicatorField
argument_list|)
expr_stmt|;
name|nested
operator|=
literal|true
expr_stmt|;
block|}
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|type
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
name|flatteningMap
operator|!=
literal|null
condition|)
block|{
name|flatteningMap
index|[
name|field
operator|.
name|getIndex
argument_list|()
index|]
operator|=
name|list
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|nested
operator|=
literal|true
expr_stmt|;
name|flattenFields
argument_list|(
name|typeFactory
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|list
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|nested
operator|=
literal|true
expr_stmt|;
comment|// TODO jvs 14-Feb-2005:  generalize to any kind of
comment|// collection type
name|RelDataType
name|flattenedCollectionType
init|=
name|typeFactory
operator|.
name|createMultisetType
argument_list|(
name|flattenRecordType
argument_list|(
name|typeFactory
argument_list|,
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|field
operator|=
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
argument_list|,
name|flattenedCollectionType
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nested
return|;
block|}
comment|/**    * Converts an instance of RelDataType to an instance of SqlDataTypeSpec.    *    * @param type type descriptor    * @return corresponding parse representation    */
specifier|public
specifier|static
name|SqlDataTypeSpec
name|convertTypeToSpec
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
comment|// TODO jvs 28-Dec-2004:  support row types, user-defined types,
comment|// interval types, multiset types, etc
assert|assert
name|typeName
operator|!=
literal|null
assert|;
name|SqlIdentifier
name|typeIdentifier
init|=
operator|new
name|SqlIdentifier
argument_list|(
name|typeName
operator|.
name|name
argument_list|()
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|String
name|charSetName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|inCharFamily
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|charSetName
operator|=
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|name
argument_list|()
expr_stmt|;
comment|// TODO jvs 28-Dec-2004:  collation
block|}
comment|// REVIEW jvs 28-Dec-2004:  discriminate between precision/scale
comment|// zero and unspecified?
comment|// REVIEW angel 11-Jan-2006:
comment|// Use neg numbers to indicate unspecified precision/scale
if|if
condition|(
name|typeName
operator|.
name|allowsScale
argument_list|()
condition|)
block|{
return|return
operator|new
name|SqlDataTypeSpec
argument_list|(
name|typeIdentifier
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|type
operator|.
name|getScale
argument_list|()
argument_list|,
name|charSetName
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
if|else if
condition|(
name|typeName
operator|.
name|allowsPrec
argument_list|()
condition|)
block|{
return|return
operator|new
name|SqlDataTypeSpec
argument_list|(
name|typeIdentifier
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|charSetName
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|SqlDataTypeSpec
argument_list|(
name|typeIdentifier
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|charSetName
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|RelDataType
name|createMultisetType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|boolean
name|nullable
parameter_list|)
block|{
name|RelDataType
name|ret
init|=
name|typeFactory
operator|.
name|createMultisetType
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|ret
argument_list|,
name|nullable
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RelDataType
name|createArrayType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|boolean
name|nullable
parameter_list|)
block|{
name|RelDataType
name|ret
init|=
name|typeFactory
operator|.
name|createArrayType
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|ret
argument_list|,
name|nullable
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RelDataType
name|createMapType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|keyType
parameter_list|,
name|RelDataType
name|valueType
parameter_list|,
name|boolean
name|nullable
parameter_list|)
block|{
name|RelDataType
name|ret
init|=
name|typeFactory
operator|.
name|createMapType
argument_list|(
name|keyType
argument_list|,
name|valueType
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|ret
argument_list|,
name|nullable
argument_list|)
return|;
block|}
comment|/**    * Adds collation and charset to a character type, returns other types    * unchanged.    *    * @param type        Type    * @param typeFactory Type factory    * @return Type with added charset and collation, or unchanged type if it is    * not a char type.    */
specifier|public
specifier|static
name|RelDataType
name|addCharsetAndCollation
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inCharFamily
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|type
return|;
block|}
name|Charset
name|charset
init|=
name|type
operator|.
name|getCharset
argument_list|()
decl_stmt|;
if|if
condition|(
name|charset
operator|==
literal|null
condition|)
block|{
name|charset
operator|=
name|typeFactory
operator|.
name|getDefaultCharset
argument_list|()
expr_stmt|;
block|}
name|SqlCollation
name|collation
init|=
name|type
operator|.
name|getCollation
argument_list|()
decl_stmt|;
if|if
condition|(
name|collation
operator|==
literal|null
condition|)
block|{
name|collation
operator|=
name|SqlCollation
operator|.
name|IMPLICIT
expr_stmt|;
block|}
comment|// todo: should get the implicit collation from repository
comment|//   instead of null
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithCharsetAndCollation
argument_list|(
name|type
argument_list|,
name|charset
argument_list|,
name|collation
argument_list|)
expr_stmt|;
name|SqlValidatorUtil
operator|.
name|checkCharsetAndCollateConsistentIfCharType
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/**    * Returns whether two types are equal, ignoring nullability.    *    *<p>They need not come from the same factory.    *    * @param factory Type factory    * @param type1   First type    * @param type2   Second type    * @return whether types are equal, ignoring nullability    */
specifier|public
specifier|static
name|boolean
name|equalSansNullability
parameter_list|(
name|RelDataTypeFactory
name|factory
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
if|if
condition|(
name|type1
operator|.
name|equals
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|isAny
argument_list|(
name|type1
argument_list|)
operator|||
name|isAny
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|type1
operator|.
name|isNullable
argument_list|()
operator|==
name|type2
operator|.
name|isNullable
argument_list|()
condition|)
block|{
comment|// If types have the same nullability and they weren't equal above,
comment|// they must be different.
return|return
literal|false
return|;
block|}
return|return
name|type1
operator|.
name|equals
argument_list|(
name|factory
operator|.
name|createTypeWithNullability
argument_list|(
name|type2
argument_list|,
name|type1
operator|.
name|isNullable
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns the ordinal of a given field in a record type, or -1 if the field    * is not found.    *    * @param type      Record type    * @param fieldName Name of field    * @return Ordinal of field    */
specifier|public
specifier|static
name|int
name|findField
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|type
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Selects data types of the specified fields from an input row type.    * This is useful when identifying data types of a function that is going    * to operate on inputs that are specified as field ordinals (e.g.    * aggregate calls).    *    * @param rowType input row type    * @param requiredFields ordinals of the projected fields    * @return list of data types that are requested by requiredFields    */
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataType
argument_list|>
name|projectTypes
parameter_list|(
specifier|final
name|RelDataType
name|rowType
parameter_list|,
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|Number
argument_list|>
name|requiredFields
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
return|return
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|fields
operator|.
name|get
argument_list|(
name|requiredFields
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
operator|.
name|getType
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|requiredFields
operator|.
name|size
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Records a struct type with no fields.    *    * @param typeFactory Type factory    * @return Struct type with no fields    */
specifier|public
specifier|static
name|RelDataType
name|createEmptyStructType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|ImmutableList
operator|.
expr|<
name|RelDataType
operator|>
name|of
argument_list|()
argument_list|,
name|ImmutableList
operator|.
expr|<
name|String
operator|>
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns whether two types are comparable. They need to be scalar types of    * the same family, or struct types whose fields are pairwise comparable.    *    * @param type1 First type    * @param type2 Second type    * @return Whether types are comparable    */
specifier|public
specifier|static
name|boolean
name|isComparable
parameter_list|(
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
if|if
condition|(
name|type1
operator|.
name|isStruct
argument_list|()
operator|!=
name|type2
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|type1
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|int
name|n
init|=
name|type1
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|!=
name|type2
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|RelDataTypeField
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|type1
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|type2
operator|.
name|getFieldList
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|isComparable
argument_list|(
name|pair
operator|.
name|left
operator|.
name|getType
argument_list|()
argument_list|,
name|pair
operator|.
name|right
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
name|RelDataTypeFamily
name|family1
init|=
literal|null
decl_stmt|;
name|RelDataTypeFamily
name|family2
init|=
literal|null
decl_stmt|;
comment|// REVIEW jvs 2-June-2005:  This is needed to keep
comment|// the Saffron type system happy.
if|if
condition|(
name|type1
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|family1
operator|=
name|type1
operator|.
name|getSqlTypeName
argument_list|()
operator|.
name|getFamily
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type2
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|family2
operator|=
name|type2
operator|.
name|getSqlTypeName
argument_list|()
operator|.
name|getFamily
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|family1
operator|==
literal|null
condition|)
block|{
name|family1
operator|=
name|type1
operator|.
name|getFamily
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|family2
operator|==
literal|null
condition|)
block|{
name|family2
operator|=
name|type2
operator|.
name|getFamily
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|family1
operator|==
name|family2
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// If one of the operators is of type 'ANY', return true.
if|if
condition|(
name|family1
operator|==
name|SqlTypeFamily
operator|.
name|ANY
operator|||
name|family2
operator|==
name|SqlTypeFamily
operator|.
name|ANY
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Checks whether a type represents Unicode character data.    *    * @param type type to test    * @return whether type represents Unicode character data    */
specifier|public
specifier|static
name|boolean
name|isUnicode
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|Charset
name|charset
init|=
name|type
operator|.
name|getCharset
argument_list|()
decl_stmt|;
if|if
condition|(
name|charset
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|charset
operator|.
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"UTF"
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|// End SqlTypeUtil.java
end_comment

end_unit

