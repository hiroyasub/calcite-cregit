begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|resource
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_comment
comment|/**  * SqlTypeStrategies defines singleton instances of strategy objects for operand  * type checking (member prefix<code>otc</code>), operand type inference  * (member prefix<code>oti</code>), and operator return type inference (member  * prefix<code>rti</code>). For otc members, the convention<code>  * otcSometypeX2</code> means two operands of type<code>Sometype</code>. The  * convention<code>otcSometypeLit</code> means a literal operand of type<code>  * Sometype</code>.  *  *<p>NOTE: avoid anonymous inner classes here except for unique,  * non-generalizable strategies; anything else belongs in a reusable top-level  * class. If you find yourself copying and pasting an existing strategy's  * anonymous inner class, you're making a mistake.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|SqlTypeStrategies
block|{
comment|/**    * Creates a checker that passes if each operand is a member of a    * corresponding family.    */
specifier|public
specifier|static
name|FamilyOperandTypeChecker
name|family
parameter_list|(
name|SqlTypeFamily
modifier|...
name|families
parameter_list|)
block|{
return|return
operator|new
name|FamilyOperandTypeChecker
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|families
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a checker that passes if each operand is a member of a    * corresponding family.    */
specifier|public
specifier|static
name|FamilyOperandTypeChecker
name|family
parameter_list|(
name|List
argument_list|<
name|SqlTypeFamily
argument_list|>
name|families
parameter_list|)
block|{
return|return
operator|new
name|FamilyOperandTypeChecker
argument_list|(
name|families
argument_list|)
return|;
block|}
comment|/**    * Creates a checker that passes if any one of the rules passes.    */
specifier|public
specifier|static
name|SqlSingleOperandTypeChecker
name|or
parameter_list|(
name|SqlSingleOperandTypeChecker
modifier|...
name|rules
parameter_list|)
block|{
return|return
operator|new
name|CompositeOperandTypeChecker
argument_list|(
name|CompositeOperandTypeChecker
operator|.
name|Composition
operator|.
name|OR
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|rules
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a checker that passes if any one of the rules passes.    */
specifier|public
specifier|static
name|SqlSingleOperandTypeChecker
name|and
parameter_list|(
name|SqlSingleOperandTypeChecker
modifier|...
name|rules
parameter_list|)
block|{
return|return
operator|new
name|CompositeOperandTypeChecker
argument_list|(
name|CompositeOperandTypeChecker
operator|.
name|Composition
operator|.
name|AND
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|rules
argument_list|)
argument_list|)
return|;
block|}
comment|// ----------------------------------------------------------------------
comment|// SqlOperandTypeChecker definitions
comment|// ----------------------------------------------------------------------
comment|//~ Static fields/initializers ---------------------------------------------
comment|/**    * Operand type-checking strategy for an operator which takes no operands.    */
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcNiladic
init|=
name|family
argument_list|()
decl_stmt|;
comment|/**    * Operand type-checking strategy for an operator with no restrictions on    * number or type of operands.    */
specifier|public
specifier|static
specifier|final
name|SqlOperandTypeChecker
name|otcVariadic
init|=
operator|new
name|SqlOperandTypeChecker
argument_list|()
block|{
specifier|public
name|boolean
name|checkOperandTypes
parameter_list|(
name|SqlCallBinding
name|callBinding
parameter_list|,
name|boolean
name|throwOnFailure
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|SqlOperandCountRange
name|getOperandCountRange
parameter_list|()
block|{
return|return
name|SqlOperandCountRanges
operator|.
name|any
argument_list|()
return|;
block|}
specifier|public
name|String
name|getAllowedSignatures
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|String
name|opName
parameter_list|)
block|{
return|return
name|opName
operator|+
literal|"(...)"
return|;
block|}
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcBool
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcBoolX2
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|BOOLEAN
argument_list|,
name|SqlTypeFamily
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcNumeric
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcNumericX2
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|,
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcExactNumeric
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|EXACT_NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcExactNumericX2
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|EXACT_NUMERIC
argument_list|,
name|SqlTypeFamily
operator|.
name|EXACT_NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcBinary
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|BINARY
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcString
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|STRING
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcCharString
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|CHARACTER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcDatetime
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|DATETIME
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcInterval
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|DATETIME_INTERVAL
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcMultiset
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|MULTISET
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcCollection
init|=
name|or
argument_list|(
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|MULTISET
argument_list|)
argument_list|,
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|ARRAY
argument_list|)
argument_list|,
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|MAP
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * Operand type-checking strategy where type must be a literal or NULL.    */
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcNullableLit
init|=
operator|new
name|LiteralOperandTypeChecker
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|/**    * Operand type-checking strategy type must be a non-NULL literal.    */
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcNotNullLit
init|=
operator|new
name|LiteralOperandTypeChecker
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/**    * Operand type-checking strategy type must be a positive integer non-NULL    * literal.    */
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcPositiveIntLit
init|=
operator|new
name|FamilyOperandTypeChecker
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|SqlTypeFamily
operator|.
name|INTEGER
argument_list|)
argument_list|)
block|{
specifier|public
name|boolean
name|checkSingleOperandType
parameter_list|(
name|SqlCallBinding
name|callBinding
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|int
name|iFormalOperand
parameter_list|,
name|boolean
name|throwOnFailure
parameter_list|)
block|{
if|if
condition|(
operator|!
name|otcNotNullLit
operator|.
name|checkSingleOperandType
argument_list|(
name|callBinding
argument_list|,
name|node
argument_list|,
name|iFormalOperand
argument_list|,
name|throwOnFailure
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|super
operator|.
name|checkSingleOperandType
argument_list|(
name|callBinding
argument_list|,
name|node
argument_list|,
name|iFormalOperand
argument_list|,
name|throwOnFailure
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|SqlLiteral
name|arg
init|=
operator|(
name|SqlLiteral
operator|)
name|node
decl_stmt|;
specifier|final
name|int
name|value
init|=
name|arg
operator|.
name|intValue
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|throwOnFailure
condition|)
block|{
throw|throw
name|callBinding
operator|.
name|newError
argument_list|(
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|ArgumentMustBePositiveInteger
operator|.
name|ex
argument_list|(
name|callBinding
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Operand type-checking strategy where two operands must both be in the    * same type family.    */
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcSameX2
init|=
operator|new
name|SameOperandTypeChecker
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|/**    * Operand type-checking strategy where three operands must all be in the    * same type family.    */
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcSameX3
init|=
operator|new
name|SameOperandTypeChecker
argument_list|(
literal|3
argument_list|)
decl_stmt|;
comment|/**    * Operand type-checking strategy where any number of operands must all be    * in the same type family.    */
specifier|public
specifier|static
specifier|final
name|SqlOperandTypeChecker
name|otcSameVariadic
init|=
operator|new
name|SameOperandTypeChecker
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|/**    * Operand type-checking strategy where operand types must allow ordered    * comparisons.    */
specifier|public
specifier|static
specifier|final
name|SqlOperandTypeChecker
name|otcComparableOrderedX2
init|=
operator|new
name|ComparableOperandTypeChecker
argument_list|(
literal|2
argument_list|,
name|RelDataTypeComparability
operator|.
name|All
argument_list|)
decl_stmt|;
comment|/**    * Operand type-checking strategy where operand type must allow ordered    * comparisons. Used when instance comparisons are made on single operand    * functions    */
specifier|public
specifier|static
specifier|final
name|SqlOperandTypeChecker
name|otcComparableOrdered
init|=
operator|new
name|ComparableOperandTypeChecker
argument_list|(
literal|1
argument_list|,
name|RelDataTypeComparability
operator|.
name|All
argument_list|)
decl_stmt|;
comment|/**    * Operand type-checking strategy where operand types must allow unordered    * comparisons.    */
specifier|public
specifier|static
specifier|final
name|SqlOperandTypeChecker
name|otcComparableUnorderedX2
init|=
operator|new
name|ComparableOperandTypeChecker
argument_list|(
literal|2
argument_list|,
name|RelDataTypeComparability
operator|.
name|Unordered
argument_list|)
decl_stmt|;
comment|/**    * Operand type-checking strategy where two operands must both be in the    * same string type family.    */
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcStringSameX2
init|=
name|SqlTypeStrategies
operator|.
name|and
argument_list|(
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|STRING
argument_list|,
name|SqlTypeFamily
operator|.
name|STRING
argument_list|)
argument_list|,
name|otcSameX2
argument_list|)
decl_stmt|;
comment|/**    * Operand type-checking strategy where three operands must all be in the    * same string type family.    */
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcStringSameX3
init|=
name|SqlTypeStrategies
operator|.
name|and
argument_list|(
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|STRING
argument_list|,
name|SqlTypeFamily
operator|.
name|STRING
argument_list|,
name|SqlTypeFamily
operator|.
name|STRING
argument_list|)
argument_list|,
name|otcSameX3
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcStringX2Int
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|STRING
argument_list|,
name|SqlTypeFamily
operator|.
name|STRING
argument_list|,
name|SqlTypeFamily
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcStringX2IntX2
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|STRING
argument_list|,
name|SqlTypeFamily
operator|.
name|STRING
argument_list|,
name|SqlTypeFamily
operator|.
name|INTEGER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcAny
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|ANY
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcAnyX2
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|ANY
argument_list|,
name|SqlTypeFamily
operator|.
name|ANY
argument_list|)
decl_stmt|;
comment|/**    * Parameter type-checking strategy type must a nullable time interval,    * nullable time interval    */
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcIntervalSameX2
init|=
name|SqlTypeStrategies
operator|.
name|and
argument_list|(
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|DATETIME_INTERVAL
argument_list|,
name|SqlTypeFamily
operator|.
name|DATETIME_INTERVAL
argument_list|)
argument_list|,
name|otcSameX2
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcNumericInterval
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|,
name|SqlTypeFamily
operator|.
name|DATETIME_INTERVAL
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcIntervalNumeric
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|DATETIME_INTERVAL
argument_list|,
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcDatetimeInterval
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|DATETIME
argument_list|,
name|SqlTypeFamily
operator|.
name|DATETIME_INTERVAL
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcIntervalDatetime
init|=
name|family
argument_list|(
name|SqlTypeFamily
operator|.
name|DATETIME_INTERVAL
argument_list|,
name|SqlTypeFamily
operator|.
name|DATETIME
argument_list|)
decl_stmt|;
comment|// TODO: datetime+interval checking missing
comment|// TODO: interval+datetime checking missing
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcPlusOperator
init|=
name|SqlTypeStrategies
operator|.
name|or
argument_list|(
name|otcNumericX2
argument_list|,
name|otcIntervalSameX2
argument_list|,
name|otcDatetimeInterval
argument_list|,
name|otcIntervalDatetime
argument_list|)
decl_stmt|;
comment|/**    * Type checking strategy for the "*" operator    */
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcMultiplyOperator
init|=
name|SqlTypeStrategies
operator|.
name|or
argument_list|(
name|otcNumericX2
argument_list|,
name|otcIntervalNumeric
argument_list|,
name|otcNumericInterval
argument_list|)
decl_stmt|;
comment|/**    * Type checking strategy for the "/" operator    */
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcDivisionOperator
init|=
name|SqlTypeStrategies
operator|.
name|or
argument_list|(
name|otcNumericX2
argument_list|,
name|otcIntervalNumeric
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcMinusOperator
init|=
name|SqlTypeStrategies
operator|.
name|or
argument_list|(
comment|// TODO:  compatibility check
name|otcNumericX2
argument_list|,
name|otcIntervalSameX2
argument_list|,
name|otcDatetimeInterval
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcMinusDateOperator
init|=
operator|new
name|FamilyOperandTypeChecker
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|SqlTypeFamily
operator|.
name|DATETIME
argument_list|,
name|SqlTypeFamily
operator|.
name|DATETIME
argument_list|,
name|SqlTypeFamily
operator|.
name|DATETIME_INTERVAL
argument_list|)
argument_list|)
block|{
specifier|public
name|boolean
name|checkOperandTypes
parameter_list|(
name|SqlCallBinding
name|callBinding
parameter_list|,
name|boolean
name|throwOnFailure
parameter_list|)
block|{
if|if
condition|(
operator|!
name|super
operator|.
name|checkOperandTypes
argument_list|(
name|callBinding
argument_list|,
name|throwOnFailure
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|otcSameX2
operator|.
name|checkOperandTypes
argument_list|(
name|callBinding
argument_list|,
name|throwOnFailure
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcNumericOrInterval
init|=
name|SqlTypeStrategies
operator|.
name|or
argument_list|(
name|otcNumeric
argument_list|,
name|otcInterval
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcNumericOrString
init|=
name|SqlTypeStrategies
operator|.
name|or
argument_list|(
name|otcNumeric
argument_list|,
name|otcString
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcRecordMultiset
init|=
operator|new
name|SqlSingleOperandTypeChecker
argument_list|()
block|{
specifier|public
name|boolean
name|checkSingleOperandType
parameter_list|(
name|SqlCallBinding
name|callBinding
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|int
name|iFormalOperand
parameter_list|,
name|boolean
name|throwOnFailure
parameter_list|)
block|{
assert|assert
operator|(
literal|0
operator|==
name|iFormalOperand
operator|)
assert|;
name|RelDataType
name|type
init|=
name|callBinding
operator|.
name|getValidator
argument_list|()
operator|.
name|deriveType
argument_list|(
name|callBinding
operator|.
name|getScope
argument_list|()
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|boolean
name|validationError
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|validationError
operator|=
literal|true
expr_stmt|;
block|}
if|else if
condition|(
name|type
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|validationError
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|!=
name|SqlTypeName
operator|.
name|MULTISET
condition|)
block|{
name|validationError
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|validationError
operator|&&
name|throwOnFailure
condition|)
block|{
throw|throw
name|callBinding
operator|.
name|newValidationSignatureError
argument_list|()
throw|;
block|}
return|return
operator|!
name|validationError
return|;
block|}
specifier|public
name|boolean
name|checkOperandTypes
parameter_list|(
name|SqlCallBinding
name|callBinding
parameter_list|,
name|boolean
name|throwOnFailure
parameter_list|)
block|{
return|return
name|checkSingleOperandType
argument_list|(
name|callBinding
argument_list|,
name|callBinding
operator|.
name|getCall
argument_list|()
operator|.
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|throwOnFailure
argument_list|)
return|;
block|}
specifier|public
name|SqlOperandCountRange
name|getOperandCountRange
parameter_list|()
block|{
return|return
name|SqlOperandCountRanges
operator|.
name|of
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|public
name|String
name|getAllowedSignatures
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|String
name|opName
parameter_list|)
block|{
return|return
literal|"UNNEST(<MULTISET>)"
return|;
block|}
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSingleOperandTypeChecker
name|otcMultisetOrRecordTypeMultiset
init|=
name|SqlTypeStrategies
operator|.
name|or
argument_list|(
name|otcMultiset
argument_list|,
name|otcRecordMultiset
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlOperandTypeChecker
name|otcMultisetX2
init|=
operator|new
name|MultisetOperandTypeChecker
argument_list|()
decl_stmt|;
comment|/**    * Operand type-checking strategy for a set operator (UNION, INTERSECT,    * EXCEPT).    */
specifier|public
specifier|static
specifier|final
name|SqlOperandTypeChecker
name|otcSetop
init|=
operator|new
name|SetopOperandTypeChecker
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlOperandTypeChecker
name|otcRecordToScalarType
init|=
operator|new
name|SqlSingleOperandTypeChecker
argument_list|()
block|{
specifier|public
name|boolean
name|checkSingleOperandType
parameter_list|(
name|SqlCallBinding
name|callBinding
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|int
name|iFormalOperand
parameter_list|,
name|boolean
name|throwOnFailure
parameter_list|)
block|{
assert|assert
operator|(
literal|0
operator|==
name|iFormalOperand
operator|)
assert|;
name|RelDataType
name|type
init|=
name|callBinding
operator|.
name|getValidator
argument_list|()
operator|.
name|deriveType
argument_list|(
name|callBinding
operator|.
name|getScope
argument_list|()
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|boolean
name|validationError
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|validationError
operator|=
literal|true
expr_stmt|;
block|}
if|else if
condition|(
name|type
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|validationError
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|validationError
operator|&&
name|throwOnFailure
condition|)
block|{
throw|throw
name|callBinding
operator|.
name|newValidationSignatureError
argument_list|()
throw|;
block|}
return|return
operator|!
name|validationError
return|;
block|}
specifier|public
name|boolean
name|checkOperandTypes
parameter_list|(
name|SqlCallBinding
name|callBinding
parameter_list|,
name|boolean
name|throwOnFailure
parameter_list|)
block|{
return|return
name|checkSingleOperandType
argument_list|(
name|callBinding
argument_list|,
name|callBinding
operator|.
name|getCall
argument_list|()
operator|.
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|throwOnFailure
argument_list|)
return|;
block|}
specifier|public
name|SqlOperandCountRange
name|getOperandCountRange
parameter_list|()
block|{
return|return
name|SqlOperandCountRanges
operator|.
name|of
argument_list|(
literal|1
argument_list|)
return|;
block|}
specifier|public
name|String
name|getAllowedSignatures
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|String
name|opName
parameter_list|)
block|{
return|return
name|SqlUtil
operator|.
name|getAliasedSignature
argument_list|(
name|op
argument_list|,
name|opName
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"RECORDTYPE(SINGLE FIELD)"
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|// ----------------------------------------------------------------------
comment|// SqlReturnTypeInference definitions
comment|// ----------------------------------------------------------------------
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the first operand.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiFirstArgType
init|=
operator|new
name|OrdinalReturnTypeInference
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the first operand, with nulls always allowed.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiFirstArgTypeForceNullable
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiFirstArgType
argument_list|,
name|SqlTypeTransforms
operator|.
name|forceNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the first operand. If any of the other operands are nullable the returned    * type will also be nullable.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableFirstArgType
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiFirstArgType
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiFirstInterval
init|=
operator|new
name|MatchReturnTypeInference
argument_list|(
literal|0
argument_list|,
name|SqlTypeFamily
operator|.
name|DATETIME_INTERVAL
operator|.
name|getTypeNames
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableFirstInterval
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiFirstInterval
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is VARYING the    * type of the first argument. The length returned is the same as length of    * the first argument. If any of the other operands are nullable the    * returned type will also be nullable. First Arg must be of string type.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableVaryingFirstArgType
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiFirstArgType
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|,
name|SqlTypeTransforms
operator|.
name|toVarying
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the second operand.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiSecondArgType
init|=
operator|new
name|OrdinalReturnTypeInference
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the second operand. If any of the other operands are nullable the    * returned type will also be nullable.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableSecondArgType
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiSecondArgType
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the third operand.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiThirdArgType
init|=
operator|new
name|OrdinalReturnTypeInference
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the type of    * the third operand. If any of the other operands are nullable the returned    * type will also be nullable.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableThirdArgType
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiThirdArgType
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Boolean.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiBoolean
init|=
name|ExplicitReturnTypeInference
operator|.
name|of
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Boolean    * not null.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiBooleanNotNull
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiBoolean
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNotNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Boolean,    * with nulls allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableBoolean
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiBoolean
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Date.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiDate
init|=
name|ExplicitReturnTypeInference
operator|.
name|of
argument_list|(
name|SqlTypeName
operator|.
name|DATE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Time(0).    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiTime
init|=
name|ExplicitReturnTypeInference
operator|.
name|of
argument_list|(
name|SqlTypeName
operator|.
name|TIME
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is nullable    * Time(0).    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableTime
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiTime
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Double.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiDouble
init|=
name|ExplicitReturnTypeInference
operator|.
name|of
argument_list|(
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is Double with    * nulls allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableDouble
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiDouble
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is an Integer.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiInteger
init|=
name|ExplicitReturnTypeInference
operator|.
name|of
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is a Bigint    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiBigint
init|=
name|ExplicitReturnTypeInference
operator|.
name|of
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is an Bigint    * with nulls allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableBigint
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiBigint
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is a nullable    * Bigint    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiAlwaysNullableBigint
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiBigint
argument_list|,
name|SqlTypeTransforms
operator|.
name|forceNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is an Integer    * with nulls allowed if any of the operands allow nulls.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableInteger
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiInteger
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy which always returns "VARCHAR(2000)".    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiVarchar2000
init|=
name|ExplicitReturnTypeInference
operator|.
name|of
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|2000
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy for Histogram agg support    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiHistogram
init|=
name|ExplicitReturnTypeInference
operator|.
name|of
argument_list|(
name|SqlTypeName
operator|.
name|VARBINARY
argument_list|,
literal|8
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy which always returns "CURSOR".    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiCursor
init|=
name|ExplicitReturnTypeInference
operator|.
name|of
argument_list|(
name|SqlTypeName
operator|.
name|CURSOR
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy which always returns "COLUMN_LIST".    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiColumnList
init|=
name|ExplicitReturnTypeInference
operator|.
name|of
argument_list|(
name|SqlTypeName
operator|.
name|COLUMN_LIST
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is using its    * operands biggest type, using the SQL:1999 rules described in "Data types    * of results of aggregations". These rules are used in union, except,    * intersect, case and other places.    *    * @sql.99 Part 2 Section 9.3    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiLeastRestrictive
init|=
operator|new
name|SqlReturnTypeInference
argument_list|()
block|{
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|leastRestrictive
argument_list|(
name|opBinding
operator|.
name|collectOperandTypes
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Type-inference strategy for a call where the first argument is a decimal.    * The result type of a call is a decimal with a scale of 0, and the same    * precision and nullibility as the first argument    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiDecimalNoScale
init|=
operator|new
name|SqlReturnTypeInference
argument_list|()
block|{
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
name|RelDataType
name|type1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|type1
argument_list|)
condition|)
block|{
if|if
condition|(
name|type1
operator|.
name|getScale
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|type1
return|;
block|}
else|else
block|{
name|int
name|p
init|=
name|type1
operator|.
name|getPrecision
argument_list|()
decl_stmt|;
name|RelDataType
name|ret
decl_stmt|;
name|ret
operator|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|ret
operator|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|ret
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is {@link    * #rtiDecimalNoScale} with a fallback to {@link #rtiFirstArgType} This rule    * is used for floor, ceiling.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiFirstArgTypeOrExactNoScale
init|=
operator|new
name|SqlReturnTypeInferenceChain
argument_list|(
operator|new
name|SqlReturnTypeInference
index|[]
block|{
name|rtiDecimalNoScale
block|,
name|rtiFirstArgType
block|}
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the decimal    * product of two exact numeric operands where at least one of the operands    * is a decimal.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiDecimalProduct
init|=
operator|new
name|SqlReturnTypeInference
argument_list|()
block|{
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|RelDataType
name|type1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|type2
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createDecimalProduct
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Same as {@link #rtiDecimalProduct} but returns with nullablity if any of    * the operands is nullable by using {@link SqlTypeTransforms#toNullable}    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableDecimalProduct
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiDecimalProduct
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is {@link    * #rtiNullableDecimalProduct} with a fallback to {@link    * #rtiNullableFirstInterval} and {@link #rtiLeastRestrictive} These rules    * are used for multiplication.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableProduct
init|=
operator|new
name|SqlReturnTypeInferenceChain
argument_list|(
operator|new
name|SqlReturnTypeInference
index|[]
block|{
name|rtiNullableDecimalProduct
block|,
name|rtiNullableFirstInterval
block|,
name|rtiLeastRestrictive
block|}
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the decimal    * product of two exact numeric operands where at least one of the operands    * is a decimal.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiDecimalQuotient
init|=
operator|new
name|SqlReturnTypeInference
argument_list|()
block|{
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|RelDataType
name|type1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|type2
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createDecimalQuotient
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Same as {@link #rtiDecimalQuotient} but returns with nullablity if any of    * the operands is nullable by using {@link SqlTypeTransforms#toNullable}    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableDecimalQuotient
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiDecimalQuotient
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is {@link    * #rtiNullableDecimalQuotient} with a fallback to {@link    * #rtiNullableFirstInterval} and {@link #rtiLeastRestrictive} These rules    * are used for division.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableQuotient
init|=
operator|new
name|SqlReturnTypeInferenceChain
argument_list|(
operator|new
name|SqlReturnTypeInference
index|[]
block|{
name|rtiNullableDecimalQuotient
block|,
name|rtiNullableFirstInterval
block|,
name|rtiLeastRestrictive
block|}
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is {@link    * #rtiNullableFirstInterval} and {@link #rtiLeastRestrictive}. These rules    * are used for integer division.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableIntegerQuotient
init|=
operator|new
name|SqlReturnTypeInferenceChain
argument_list|(
operator|new
name|SqlReturnTypeInference
index|[]
block|{
name|rtiNullableFirstInterval
block|,
name|rtiLeastRestrictive
block|}
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is the decimal    * sum of two exact numeric operands where at least one of the operands is a    * decimal. Let p1, s1 be the precision and scale of the first operand Let    * p2, s2 be the precision and scale of the second operand Let p, s be the    * precision and scale of the result, Then the result type is a decimal    * with:    *    *<ul>    *<li>s = max(s1, s2)</li>    *<li>p = max(p1 - s1, p2 - s2) + s + 1</li>    *</ul>    *    * p and s are capped at their maximum values    *    * @sql.2003 Part 2 Section 6.26    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiDecimalSum
init|=
operator|new
name|SqlReturnTypeInference
argument_list|()
block|{
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
name|RelDataType
name|type1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|type2
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type1
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|type1
argument_list|)
operator|||
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|int
name|p1
init|=
name|type1
operator|.
name|getPrecision
argument_list|()
decl_stmt|;
name|int
name|p2
init|=
name|type2
operator|.
name|getPrecision
argument_list|()
decl_stmt|;
name|int
name|s1
init|=
name|type1
operator|.
name|getScale
argument_list|()
decl_stmt|;
name|int
name|s2
init|=
name|type2
operator|.
name|getScale
argument_list|()
decl_stmt|;
name|int
name|scale
init|=
name|Math
operator|.
name|max
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|scale
operator|<=
name|SqlTypeName
operator|.
name|MAX_NUMERIC_SCALE
operator|)
assert|;
name|int
name|precision
init|=
name|Math
operator|.
name|max
argument_list|(
name|p1
operator|-
name|s1
argument_list|,
name|p2
operator|-
name|s2
argument_list|)
operator|+
name|scale
operator|+
literal|1
decl_stmt|;
name|precision
operator|=
name|Math
operator|.
name|min
argument_list|(
name|precision
argument_list|,
name|SqlTypeName
operator|.
name|MAX_NUMERIC_PRECISION
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|precision
operator|>
literal|0
operator|)
assert|;
name|RelDataType
name|ret
decl_stmt|;
name|ret
operator|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
name|precision
argument_list|,
name|scale
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Same as {@link #rtiDecimalSum} but returns with nullablity if any    * of the operands is nullable by using {@link SqlTypeTransforms#toNullable}    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableDecimalSum
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiDecimalSum
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is {@link    * #rtiNullableDecimalSum} with a fallback to {@link #rtiLeastRestrictive}    * These rules are used for addition and subtraction.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableSum
init|=
operator|new
name|SqlReturnTypeInferenceChain
argument_list|(
name|rtiNullableDecimalSum
argument_list|,
name|rtiLeastRestrictive
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy whereby the result type of a call is    *    *<ul>    *<li>the same type as the input types but with the combined length of the    * two first types</li>    *<li>if types are of char type the type with the highest coercibility will    * be used</li>    *<li>result is varying if either input is; otherwise fixed    *</ul>    *    * Pre-requisites:    *    *<ul>    *<li>input types must be of the same string type    *<li>types must be comparable without casting    *</ul>    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiDyadicStringSumPrecision
init|=
operator|new
name|SqlReturnTypeInference
argument_list|()
block|{
comment|/**          * @pre SqlTypeUtil.sameNamedType(argTypes[0], (argTypes[1]))          */
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
specifier|final
name|RelDataType
name|argType0
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|argType1
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|SqlTypeUtil
operator|.
name|inCharOrBinaryFamilies
argument_list|(
name|argType0
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|inCharOrBinaryFamilies
argument_list|(
name|argType1
argument_list|)
operator|)
condition|)
block|{
name|Util
operator|.
name|pre
argument_list|(
name|SqlTypeUtil
operator|.
name|sameNamedType
argument_list|(
name|argType0
argument_list|,
name|argType1
argument_list|)
argument_list|,
literal|"SqlTypeUtil.sameNamedType(argTypes[0], argTypes[1])"
argument_list|)
expr_stmt|;
block|}
name|SqlCollation
name|pickedCollation
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|argType0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|isCharTypeComparable
argument_list|(
name|opBinding
operator|.
name|collectOperandTypes
argument_list|()
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
name|opBinding
operator|.
name|newError
argument_list|(
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|TypeNotComparable
operator|.
name|ex
argument_list|(
name|argType0
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|argType1
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|pickedCollation
operator|=
name|SqlCollation
operator|.
name|getCoercibilityDyadicOperator
argument_list|(
name|argType0
operator|.
name|getCollation
argument_list|()
argument_list|,
name|argType1
operator|.
name|getCollation
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
operator|(
literal|null
operator|!=
name|pickedCollation
operator|)
assert|;
block|}
comment|// Determine whether result is variable-length
name|SqlTypeName
name|typeName
init|=
name|argType0
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isBoundedVariableWidth
argument_list|(
name|argType1
argument_list|)
condition|)
block|{
name|typeName
operator|=
name|argType1
operator|.
name|getSqlTypeName
argument_list|()
expr_stmt|;
block|}
name|RelDataType
name|ret
decl_stmt|;
name|ret
operator|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|,
name|argType0
operator|.
name|getPrecision
argument_list|()
operator|+
name|argType1
operator|.
name|getPrecision
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|pickedCollation
condition|)
block|{
name|RelDataType
name|pickedType
decl_stmt|;
if|if
condition|(
name|argType0
operator|.
name|getCollation
argument_list|()
operator|.
name|equals
argument_list|(
name|pickedCollation
argument_list|)
condition|)
block|{
name|pickedType
operator|=
name|argType0
expr_stmt|;
block|}
if|else if
condition|(
name|argType1
operator|.
name|getCollation
argument_list|()
operator|.
name|equals
argument_list|(
name|pickedCollation
argument_list|)
condition|)
block|{
name|pickedType
operator|=
name|argType1
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"should never come here"
argument_list|)
throw|;
block|}
name|ret
operator|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithCharsetAndCollation
argument_list|(
name|ret
argument_list|,
name|pickedType
operator|.
name|getCharset
argument_list|()
argument_list|,
name|pickedType
operator|.
name|getCollation
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Same as {@link #rtiDyadicStringSumPrecision} and using {@link    * SqlTypeTransforms#toNullable}    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableDyadicStringSumPrecision
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiDyadicStringSumPrecision
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
comment|/**    * Same as {@link #rtiDyadicStringSumPrecision} and using {@link    * SqlTypeTransforms#toNullable}, {@link SqlTypeTransforms#toVarying}.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableVaryingDyadicStringSumPrecision
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiDyadicStringSumPrecision
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|,
name|SqlTypeTransforms
operator|.
name|toVarying
argument_list|)
decl_stmt|;
comment|/**    * Type-inference strategy where the expression is assumed to be registered    * as a {@link org.eigenbase.sql.validate.SqlValidatorNamespace}, and    * therefore the result type of the call is the type of that namespace.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiScope
init|=
operator|new
name|SqlReturnTypeInference
argument_list|()
block|{
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
name|SqlCallBinding
name|callBinding
init|=
operator|(
name|SqlCallBinding
operator|)
name|opBinding
decl_stmt|;
return|return
name|callBinding
operator|.
name|getValidator
argument_list|()
operator|.
name|getNamespace
argument_list|(
name|callBinding
operator|.
name|getCall
argument_list|()
argument_list|)
operator|.
name|getRowType
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Returns the same type as the multiset carries. The multiset type returned    * is the least restrictive of the call's multiset operands    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiMultiset
init|=
operator|new
name|SqlReturnTypeInference
argument_list|()
block|{
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
specifier|final
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
name|ExplicitOperatorBinding
name|newBinding
init|=
operator|new
name|ExplicitOperatorBinding
argument_list|(
name|opBinding
argument_list|,
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
name|index
argument_list|)
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
assert|assert
name|type
operator|!=
literal|null
assert|;
return|return
name|type
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|opBinding
operator|.
name|getOperandCount
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|RelDataType
name|biggestElementType
init|=
name|rtiLeastRestrictive
operator|.
name|inferReturnType
argument_list|(
name|newBinding
argument_list|)
decl_stmt|;
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createMultisetType
argument_list|(
name|biggestElementType
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Returns a multiset of the first column of a multiset. For example, given    *<code>RECORD(x INTEGER, y DATE) MULTISET</code>, returns<code>INTEGER    * MULTISET</code>.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiMultisetFirstColumnMultiset
init|=
operator|new
name|SqlReturnTypeInference
argument_list|()
block|{
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
assert|assert
name|opBinding
operator|.
name|getOperandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|RelDataType
name|recordMultisetType
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|multisetType
init|=
name|recordMultisetType
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
assert|assert
name|multisetType
operator|!=
literal|null
operator|:
literal|"expected a multiset type: "
operator|+
name|recordMultisetType
assert|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|multisetType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
assert|assert
name|fields
operator|.
name|size
argument_list|()
operator|>
literal|0
assert|;
specifier|final
name|RelDataType
name|firstColType
init|=
name|fields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createMultisetType
argument_list|(
name|firstColType
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Returns a multiset of the first column of a multiset. For example, given    *<code>INTEGER MULTISET</code>, returns<code>RECORD(x INTEGER)    * MULTISET</code>.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiMultisetRecordMultiset
init|=
operator|new
name|SqlReturnTypeInference
argument_list|()
block|{
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
assert|assert
name|opBinding
operator|.
name|getOperandCount
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|RelDataType
name|multisetType
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelDataType
name|componentType
init|=
name|multisetType
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
assert|assert
name|componentType
operator|!=
literal|null
operator|:
literal|"expected a multiset type: "
operator|+
name|multisetType
assert|;
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createMultisetType
argument_list|(
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createStructType
argument_list|(
operator|new
name|RelDataType
index|[]
block|{
name|componentType
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
name|SqlUtil
operator|.
name|deriveAliasFromOrdinal
argument_list|(
literal|0
argument_list|)
block|}
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Returns the type of the only column of a multiset.    *    *<p>For example, given<code>RECORD(x INTEGER) MULTISET</code>, returns    *<code>INTEGER MULTISET</code>.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiMultisetOnlyColumn
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiMultiset
argument_list|,
name|SqlTypeTransforms
operator|.
name|onlyColumn
argument_list|)
decl_stmt|;
comment|/**    * Same as {@link #rtiMultiset} but returns with nullablity if any of the    * operands is nullable    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableMultiset
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiMultiset
argument_list|,
name|SqlTypeTransforms
operator|.
name|toNullable
argument_list|)
decl_stmt|;
comment|/**    * Returns the element type of a multiset    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiNullableMultisetElementType
init|=
operator|new
name|SqlTypeTransformCascade
argument_list|(
name|rtiMultiset
argument_list|,
name|SqlTypeTransforms
operator|.
name|toMultisetElementType
argument_list|)
decl_stmt|;
comment|/**    * Returns the field type of a structured type which has only one field. For    * example, given<code>RECORD(x INTEGER)</code> returns<code>    * INTEGER</code>.    */
specifier|public
specifier|static
specifier|final
name|SqlReturnTypeInference
name|rtiRecordToScalarType
init|=
operator|new
name|SqlReturnTypeInference
argument_list|()
block|{
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
assert|assert
operator|(
name|opBinding
operator|.
name|getOperandCount
argument_list|()
operator|==
literal|1
operator|)
assert|;
specifier|final
name|RelDataType
name|recordType
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|boolean
name|isStruct
init|=
name|recordType
operator|.
name|isStruct
argument_list|()
decl_stmt|;
name|int
name|fieldCount
init|=
name|recordType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|isStruct
operator|&&
operator|(
name|fieldCount
operator|==
literal|1
operator|)
operator|)
assert|;
name|RelDataTypeField
name|fieldType
init|=
name|recordType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|fieldType
operator|!=
literal|null
operator|:
literal|"expected a record type with one field: "
operator|+
name|recordType
assert|;
specifier|final
name|RelDataType
name|firstColType
init|=
name|fieldType
operator|.
name|getType
argument_list|()
decl_stmt|;
return|return
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|firstColType
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|// ----------------------------------------------------------------------
comment|// SqlOperandTypeInference definitions
comment|// ----------------------------------------------------------------------
comment|/**    * Operand type-inference strategy where an unknown operand type is derived    * from the first operand with a known type.    */
specifier|public
specifier|static
specifier|final
name|SqlOperandTypeInference
name|otiFirstKnown
init|=
operator|new
name|SqlOperandTypeInference
argument_list|()
block|{
specifier|public
name|void
name|inferOperandTypes
parameter_list|(
name|SqlCallBinding
name|callBinding
parameter_list|,
name|RelDataType
name|returnType
parameter_list|,
name|RelDataType
index|[]
name|operandTypes
parameter_list|)
block|{
name|SqlNode
index|[]
name|operands
init|=
name|callBinding
operator|.
name|getCall
argument_list|()
operator|.
name|getOperands
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|unknownType
init|=
name|callBinding
operator|.
name|getValidator
argument_list|()
operator|.
name|getUnknownType
argument_list|()
decl_stmt|;
name|RelDataType
name|knownType
init|=
name|unknownType
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|operands
control|)
block|{
name|knownType
operator|=
name|callBinding
operator|.
name|getValidator
argument_list|()
operator|.
name|deriveType
argument_list|(
name|callBinding
operator|.
name|getScope
argument_list|()
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|knownType
operator|.
name|equals
argument_list|(
name|unknownType
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
comment|// REVIEW jvs 11-Nov-2008:  We can't assert this
comment|// because SqlAdvisorValidator produces
comment|// unknown types for incomplete expressions.
comment|// Maybe we need to distinguish the two kinds of unknown.
comment|//assert !knownType.equals(unknownType);
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operandTypes
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|operandTypes
index|[
name|i
index|]
operator|=
name|knownType
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
comment|/**    * Operand type-inference strategy where an unknown operand type is derived    * from the call's return type. If the return type is a record, it must have    * the same number of fields as the number of operands.    */
specifier|public
specifier|static
specifier|final
name|SqlOperandTypeInference
name|otiReturnType
init|=
operator|new
name|SqlOperandTypeInference
argument_list|()
block|{
specifier|public
name|void
name|inferOperandTypes
parameter_list|(
name|SqlCallBinding
name|callBinding
parameter_list|,
name|RelDataType
name|returnType
parameter_list|,
name|RelDataType
index|[]
name|operandTypes
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operandTypes
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|operandTypes
index|[
name|i
index|]
operator|=
name|returnType
operator|.
name|isStruct
argument_list|()
condition|?
name|returnType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
else|:
name|returnType
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
comment|/**    * Operand type-inference strategy where an unknown operand type is assumed    * to be boolean.    */
specifier|public
specifier|static
specifier|final
name|SqlOperandTypeInference
name|otiBoolean
init|=
operator|new
name|SqlOperandTypeInference
argument_list|()
block|{
specifier|public
name|void
name|inferOperandTypes
parameter_list|(
name|SqlCallBinding
name|callBinding
parameter_list|,
name|RelDataType
name|returnType
parameter_list|,
name|RelDataType
index|[]
name|operandTypes
parameter_list|)
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|callBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operandTypes
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|operandTypes
index|[
name|i
index|]
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
comment|/**    * Operand type-inference strategy where an unknown operand type is assumed    * to be VARCHAR(1024).  This is not something which should be used in most    * cases (especially since the precision is arbitrary), but for IS [NOT]    * NULL, we don't really care about the type at all, so it's reasonable to    * use something that every other type can be cast to.    */
specifier|public
specifier|static
specifier|final
name|SqlOperandTypeInference
name|otiVarchar1024
init|=
operator|new
name|SqlOperandTypeInference
argument_list|()
block|{
specifier|public
name|void
name|inferOperandTypes
parameter_list|(
name|SqlCallBinding
name|callBinding
parameter_list|,
name|RelDataType
name|returnType
parameter_list|,
name|RelDataType
index|[]
name|operandTypes
parameter_list|)
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|callBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operandTypes
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|operandTypes
index|[
name|i
index|]
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
block|}
end_class

begin_comment
comment|// End SqlTypeStrategies.java
end_comment

end_unit

