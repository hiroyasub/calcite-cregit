begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|resource
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Retention
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|RetentionPolicy
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|EigenbaseContextException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|BuiltinMethod
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_comment
comment|/**  * Defining wrapper classes around resources that allow the compiler to check  * whether the resources exist and have the argument types that your code  * expects.  */
end_comment

begin_class
specifier|public
class|class
name|Resources
block|{
specifier|private
name|Resources
parameter_list|()
block|{
block|}
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|create
parameter_list|(
specifier|final
name|String
name|base
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|T
operator|)
name|Proxy
operator|.
name|newProxyInstance
argument_list|(
name|clazz
operator|.
name|getClassLoader
argument_list|()
argument_list|,
operator|new
name|Class
index|[]
block|{
name|clazz
block|}
argument_list|,
operator|new
name|InvocationHandler
argument_list|()
block|{
specifier|public
name|Object
name|invoke
parameter_list|(
name|Object
name|proxy
parameter_list|,
name|Method
name|method
parameter_list|,
name|Object
index|[]
name|args
parameter_list|)
throws|throws
name|Throwable
block|{
if|if
condition|(
name|method
operator|.
name|equals
argument_list|(
name|BuiltinMethod
operator|.
name|OBJECT_TO_STRING
operator|.
name|method
argument_list|)
condition|)
block|{
return|return
name|toString
argument_list|()
return|;
block|}
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|returnType
init|=
name|method
operator|.
name|getReturnType
argument_list|()
decl_stmt|;
specifier|final
name|Class
index|[]
name|types
init|=
block|{
name|String
operator|.
name|class
block|,
name|Locale
operator|.
name|class
block|,
name|Method
operator|.
name|class
block|,
name|Object
index|[]
operator|.
expr|class
block|}
decl_stmt|;
specifier|final
name|Constructor
argument_list|<
name|?
argument_list|>
name|constructor
init|=
name|returnType
operator|.
name|getConstructor
argument_list|(
name|types
argument_list|)
decl_stmt|;
return|return
name|constructor
operator|.
name|newInstance
argument_list|(
name|base
argument_list|,
name|ShadowResourceBundle
operator|.
name|getThreadOrDefaultLocale
argument_list|()
argument_list|,
name|method
argument_list|,
name|args
operator|!=
literal|null
condition|?
name|args
else|:
operator|new
name|Object
index|[
literal|0
index|]
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/** Applies all validations to all resource methods in the given    * resource object. */
specifier|public
specifier|static
name|void
name|validate
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|validate
argument_list|(
name|o
argument_list|,
name|EnumSet
operator|.
name|allOf
argument_list|(
name|Validation
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Applies the given validations to all resource methods in the given    * resource object. */
specifier|public
specifier|static
name|void
name|validate
parameter_list|(
name|Object
name|o
parameter_list|,
name|EnumSet
argument_list|<
name|Validation
argument_list|>
name|validations
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Method
name|method
range|:
name|o
operator|.
name|getClass
argument_list|()
operator|.
name|getMethods
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|Modifier
operator|.
name|isStatic
argument_list|(
name|method
operator|.
name|getModifiers
argument_list|()
argument_list|)
operator|&&
name|Inst
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|method
operator|.
name|getReturnType
argument_list|()
argument_list|)
condition|)
block|{
operator|++
name|count
expr_stmt|;
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|parameterTypes
init|=
name|method
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
name|Object
index|[]
name|args
init|=
operator|new
name|Object
index|[
name|parameterTypes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parameterTypes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|=
name|zero
argument_list|(
name|parameterTypes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Inst
name|inst
init|=
operator|(
name|Inst
operator|)
name|method
operator|.
name|invoke
argument_list|(
name|o
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|inst
operator|.
name|validate
argument_list|(
name|validations
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"in "
operator|+
name|method
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"in "
operator|+
name|method
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|validations
operator|.
name|contains
argument_list|(
name|Validation
operator|.
name|AT_LEAST_ONE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"resource object "
operator|+
name|o
operator|+
literal|" contains no resources"
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|Object
name|zero
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
name|clazz
operator|==
name|String
operator|.
name|class
condition|?
literal|""
else|:
name|clazz
operator|==
name|byte
operator|.
name|class
condition|?
operator|(
name|byte
operator|)
literal|0
else|:
name|clazz
operator|==
name|char
operator|.
name|class
condition|?
operator|(
name|char
operator|)
literal|0
else|:
name|clazz
operator|==
name|short
operator|.
name|class
condition|?
operator|(
name|short
operator|)
literal|0
else|:
name|clazz
operator|==
name|int
operator|.
name|class
condition|?
literal|0
else|:
name|clazz
operator|==
name|long
operator|.
name|class
condition|?
literal|0L
else|:
name|clazz
operator|==
name|float
operator|.
name|class
condition|?
literal|0F
else|:
name|clazz
operator|==
name|double
operator|.
name|class
condition|?
literal|0D
else|:
name|clazz
operator|==
name|boolean
operator|.
name|class
condition|?
literal|false
else|:
literal|null
return|;
block|}
comment|/** Resource instance. It contains the resource method (which    * serves to identify the resource), the locale with which we    * expect to render the resource, and any arguments. */
specifier|public
specifier|static
class|class
name|Inst
block|{
specifier|protected
specifier|final
name|String
name|base
decl_stmt|;
specifier|private
specifier|final
name|Locale
name|locale
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|method
decl_stmt|;
specifier|protected
specifier|final
name|Object
index|[]
name|args
decl_stmt|;
specifier|public
name|Inst
parameter_list|(
name|String
name|base
parameter_list|,
name|Locale
name|locale
parameter_list|,
name|Method
name|method
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|this
operator|.
name|base
operator|=
name|base
expr_stmt|;
name|this
operator|.
name|locale
operator|=
name|locale
expr_stmt|;
name|this
operator|.
name|method
operator|=
name|method
expr_stmt|;
name|this
operator|.
name|args
operator|=
name|args
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|this
operator|==
name|obj
operator|||
name|obj
operator|!=
literal|null
operator|&&
name|obj
operator|.
name|getClass
argument_list|()
operator|==
name|this
operator|.
name|getClass
argument_list|()
operator|&&
name|locale
operator|==
operator|(
operator|(
name|Inst
operator|)
name|obj
operator|)
operator|.
name|locale
operator|&&
name|method
operator|==
operator|(
operator|(
name|Inst
operator|)
name|obj
operator|)
operator|.
name|method
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|args
argument_list|,
operator|(
operator|(
name|Inst
operator|)
name|obj
operator|)
operator|.
name|args
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Util
operator|.
name|hashV
argument_list|(
name|locale
argument_list|,
name|method
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|args
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|ResourceBundle
name|bundle
parameter_list|()
block|{
return|return
name|ResourceBundle
operator|.
name|getBundle
argument_list|(
name|base
argument_list|,
name|locale
argument_list|)
return|;
block|}
specifier|public
name|Inst
name|localize
parameter_list|(
name|Locale
name|locale
parameter_list|)
block|{
return|return
operator|new
name|Inst
argument_list|(
name|base
argument_list|,
name|locale
argument_list|,
name|method
argument_list|,
name|args
argument_list|)
return|;
block|}
specifier|public
name|void
name|validate
parameter_list|(
name|EnumSet
argument_list|<
name|Validation
argument_list|>
name|validations
parameter_list|)
block|{
specifier|final
name|ResourceBundle
name|bundle
init|=
name|bundle
argument_list|()
decl_stmt|;
for|for
control|(
name|Validation
name|validation
range|:
name|validations
control|)
block|{
specifier|final
name|String
name|key
init|=
name|key
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|validation
condition|)
block|{
case|case
name|BUNDLE_HAS_RESOURCE
case|:
if|if
condition|(
operator|!
name|bundle
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"key '"
operator|+
name|key
operator|+
literal|"' not found for resource '"
operator|+
name|method
operator|.
name|getName
argument_list|()
operator|+
literal|"' in bundle '"
operator|+
name|bundle
operator|+
literal|"'"
argument_list|)
throw|;
block|}
break|break;
case|case
name|RETURN_TYPE
case|:
specifier|final
name|ExceptionClass
name|annotation
init|=
name|method
operator|.
name|getAnnotation
argument_list|(
name|ExceptionClass
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|annotation
operator|!=
literal|null
operator|&&
operator|!
name|ExInst
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"resource '"
operator|+
name|method
operator|.
name|getName
argument_list|()
operator|+
literal|"' has ExceptionClass, so return should be ExInst<"
operator|+
name|annotation
operator|.
name|value
argument_list|()
operator|+
literal|">"
argument_list|)
throw|;
block|}
break|break;
case|case
name|MESSAGE_SPECIFIED
case|:
specifier|final
name|BaseMessage
name|annotation1
init|=
name|method
operator|.
name|getAnnotation
argument_list|(
name|BaseMessage
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|annotation1
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"resource '"
operator|+
name|method
operator|.
name|getName
argument_list|()
operator|+
literal|"' must specify BaseMessage"
argument_list|)
throw|;
block|}
break|break;
case|case
name|MESSAGE_MATCH
case|:
specifier|final
name|BaseMessage
name|annotation2
init|=
name|method
operator|.
name|getAnnotation
argument_list|(
name|BaseMessage
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|annotation2
operator|!=
literal|null
condition|)
block|{
specifier|final
name|String
name|value
init|=
name|annotation2
operator|.
name|value
argument_list|()
decl_stmt|;
specifier|final
name|String
name|value2
init|=
name|bundle
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|?
name|bundle
operator|.
name|getString
argument_list|(
name|key
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|Util
operator|.
name|equal
argument_list|(
name|value
argument_list|,
name|value2
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"message for resource '"
operator|+
name|method
operator|.
name|getName
argument_list|()
operator|+
literal|"' is different between class and resource file"
argument_list|)
throw|;
block|}
block|}
break|break;
case|case
name|EXCEPTION_CLASS_SPECIFIED
case|:
if|if
condition|(
name|this
operator|instanceof
name|ExInst
condition|)
block|{
specifier|final
name|ExceptionClass
name|annotation5
init|=
name|method
operator|.
name|getAnnotation
argument_list|(
name|ExceptionClass
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|annotation5
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"resource '"
operator|+
name|method
operator|.
name|getName
argument_list|()
operator|+
literal|"' returns ExInst so must specify ExceptionClass"
argument_list|)
throw|;
block|}
block|}
break|break;
case|case
name|CREATE_EXCEPTION
case|:
if|if
condition|(
name|this
operator|instanceof
name|ExInst
condition|)
block|{
specifier|final
name|ExceptionClass
name|annotation4
init|=
name|method
operator|.
name|getAnnotation
argument_list|(
name|ExceptionClass
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|annotation4
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|Throwable
name|cause
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|annotation4
operator|.
name|causeRequired
argument_list|()
condition|)
block|{
comment|//noinspection ThrowableResultOfMethodCallIgnored
specifier|final
name|Exception
name|ex
init|=
operator|(
operator|(
name|ExInst
operator|)
name|this
operator|)
operator|.
name|ex
argument_list|()
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
name|cause
operator|=
operator|new
name|NullPointerException
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|annotation4
operator|.
name|causeAllowed
argument_list|()
condition|)
block|{
comment|//noinspection ThrowableResultOfMethodCallIgnored
specifier|final
name|Exception
name|ex2
init|=
operator|(
operator|(
name|ExInst
operator|)
name|this
operator|)
operator|.
name|ex
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|ex2
operator|==
literal|null
condition|)
block|{
name|cause
operator|=
operator|new
name|NullPointerException
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|annotation4
operator|.
name|causeAllowed
argument_list|()
operator|&&
name|annotation4
operator|.
name|causeRequired
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"cause required and not allowed?!"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{
name|cause
operator|=
name|e
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|cause
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
name|AssertionError
name|assertionError
init|=
operator|new
name|AssertionError
argument_list|(
literal|"error instantiating exception for resource '"
operator|+
name|method
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
decl_stmt|;
name|assertionError
operator|.
name|initCause
argument_list|(
name|cause
argument_list|)
expr_stmt|;
throw|throw
name|assertionError
throw|;
block|}
block|}
break|break;
case|case
name|ARGUMENT_MATCH
case|:
name|String
name|raw
init|=
name|raw
argument_list|()
decl_stmt|;
name|MessageFormat
name|format
init|=
operator|new
name|MessageFormat
argument_list|(
name|raw
argument_list|)
decl_stmt|;
specifier|final
name|Format
index|[]
name|formats
init|=
name|format
operator|.
name|getFormatsByArgumentIndex
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Class
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<
name|Class
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|parameterTypes
init|=
name|method
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|formats
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Format
name|format1
init|=
name|formats
index|[
name|i
index|]
decl_stmt|;
name|Class
name|parameterType
init|=
name|parameterTypes
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|e
decl_stmt|;
if|if
condition|(
name|format1
operator|instanceof
name|NumberFormat
condition|)
block|{
name|e
operator|=
name|parameterType
operator|==
name|short
operator|.
name|class
operator|||
name|parameterType
operator|==
name|int
operator|.
name|class
operator|||
name|parameterType
operator|==
name|long
operator|.
name|class
operator|||
name|parameterType
operator|==
name|float
operator|.
name|class
operator|||
name|parameterType
operator|==
name|double
operator|.
name|class
operator|||
name|Number
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|parameterType
argument_list|)
condition|?
name|parameterType
else|:
name|Number
operator|.
name|class
expr_stmt|;
block|}
if|else if
condition|(
name|format1
operator|instanceof
name|DateFormat
condition|)
block|{
name|e
operator|=
name|Date
operator|.
name|class
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|String
operator|.
name|class
expr_stmt|;
block|}
name|types
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|parameterTypeList
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|parameterTypes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|types
operator|.
name|equals
argument_list|(
name|parameterTypeList
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"type mismatch in method '"
operator|+
name|method
operator|.
name|getName
argument_list|()
operator|+
literal|"' between message format elements "
operator|+
name|types
operator|+
literal|" and method parameters "
operator|+
name|parameterTypeList
argument_list|)
throw|;
block|}
break|break;
block|}
block|}
block|}
specifier|public
name|String
name|str
parameter_list|()
block|{
name|String
name|message
init|=
name|raw
argument_list|()
decl_stmt|;
name|MessageFormat
name|format
init|=
operator|new
name|MessageFormat
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|format
operator|.
name|setLocale
argument_list|(
name|locale
argument_list|)
expr_stmt|;
return|return
name|format
operator|.
name|format
argument_list|(
name|args
argument_list|)
return|;
block|}
specifier|public
name|String
name|raw
parameter_list|()
block|{
try|try
block|{
return|return
name|bundle
argument_list|()
operator|.
name|getString
argument_list|(
name|key
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|MissingResourceException
name|e
parameter_list|)
block|{
comment|// Resource is not in the bundle. (It is probably missing from the
comment|// .properties file.) Fall back to the base message.
return|return
name|method
operator|.
name|getAnnotation
argument_list|(
name|BaseMessage
operator|.
name|class
argument_list|)
operator|.
name|value
argument_list|()
return|;
block|}
block|}
specifier|private
name|String
name|key
parameter_list|()
block|{
specifier|final
name|Resource
name|resource
init|=
name|method
operator|.
name|getAnnotation
argument_list|(
name|Resource
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|resource
operator|!=
literal|null
condition|)
block|{
return|return
name|resource
operator|.
name|value
argument_list|()
return|;
block|}
else|else
block|{
specifier|final
name|String
name|name
init|=
name|method
operator|.
name|getName
argument_list|()
decl_stmt|;
return|return
name|Character
operator|.
name|toUpperCase
argument_list|(
name|name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
name|name
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
return|;
block|}
block|}
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getProperties
parameter_list|()
block|{
comment|// At present, annotations allow at most one property per resource. We
comment|// could design new annotations if any resource needed more.
specifier|final
name|Property
name|property
init|=
name|method
operator|.
name|getAnnotation
argument_list|(
name|Property
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
return|return
name|ImmutableMap
operator|.
name|of
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|ImmutableMap
operator|.
name|of
argument_list|(
name|property
operator|.
name|name
argument_list|()
argument_list|,
name|property
operator|.
name|value
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Sub-class of {@link Inst} that can throw an exception. */
specifier|public
specifier|static
class|class
name|ExInst
parameter_list|<
name|T
extends|extends
name|Exception
parameter_list|>
extends|extends
name|Inst
block|{
specifier|public
name|ExInst
parameter_list|(
name|String
name|base
parameter_list|,
name|Locale
name|locale
parameter_list|,
name|Method
name|method
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|super
argument_list|(
name|base
argument_list|,
name|locale
argument_list|,
name|method
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Inst
name|localize
parameter_list|(
name|Locale
name|locale
parameter_list|)
block|{
return|return
operator|new
name|ExInst
argument_list|<
name|T
argument_list|>
argument_list|(
name|base
argument_list|,
name|locale
argument_list|,
name|method
argument_list|,
name|args
argument_list|)
return|;
block|}
specifier|public
name|T
name|ex
parameter_list|()
block|{
return|return
name|ex
argument_list|(
literal|null
argument_list|)
return|;
block|}
specifier|public
name|T
name|ex
parameter_list|(
name|Throwable
name|cause
parameter_list|)
block|{
try|try
block|{
comment|//noinspection unchecked
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
name|exceptionClass
init|=
name|getExceptionClass
argument_list|()
decl_stmt|;
specifier|final
name|Constructor
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
name|constructor
init|=
name|exceptionClass
operator|.
name|getConstructor
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|Throwable
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|String
name|str
init|=
name|str
argument_list|()
decl_stmt|;
comment|//noinspection unchecked,ThrowableResultOfMethodCallIgnored
return|return
operator|(
name|T
operator|)
name|constructor
operator|.
name|newInstance
argument_list|(
name|str
argument_list|,
name|cause
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|e
operator|.
name|getCause
argument_list|()
throw|;
block|}
if|else if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|e
operator|.
name|getCause
argument_list|()
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
name|getExceptionClass
parameter_list|()
block|{
specifier|final
name|ExceptionClass
name|exceptionClass
init|=
name|method
operator|.
name|getAnnotation
argument_list|(
name|ExceptionClass
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|exceptionClass
operator|.
name|value
argument_list|()
return|;
block|}
block|}
comment|/** SQL language feature. Expressed as the exception that would be    * thrown if it were used while disabled. */
specifier|public
specifier|static
class|class
name|Feature
extends|extends
name|ExInst
argument_list|<
name|EigenbaseContextException
argument_list|>
block|{
specifier|public
name|Feature
parameter_list|(
name|String
name|base
parameter_list|,
name|Locale
name|locale
parameter_list|,
name|Method
name|method
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|super
argument_list|(
name|base
argument_list|,
name|locale
argument_list|,
name|method
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Types of validation that can be performed on a resource. */
specifier|public
enum|enum
name|Validation
block|{
comment|/** Checks that each method's resource key corresponds to a resource in the      * bundle. */
name|BUNDLE_HAS_RESOURCE
block|,
comment|/** Checks that there is at least one resource in the bundle. */
name|AT_LEAST_ONE
block|,
comment|/** Checks that the value returned from the method is correct.      * Every resource method should return an {@link Inst} or subtype.      * If {@link ExceptionClass} is specified, it should return {@link ExInst}.      */
name|RETURN_TYPE
block|,
comment|/** Checks that the base message annotation is on every resource. */
name|MESSAGE_SPECIFIED
block|,
comment|/** Checks that the base message matches the message in the bundle. */
name|MESSAGE_MATCH
block|,
comment|/** Checks that if a resource returns ExInst the {@link ExceptionClass}      * must be specified. */
name|EXCEPTION_CLASS_SPECIFIED
block|,
comment|/** Checks that it is possible to create an exception. */
name|CREATE_EXCEPTION
block|,
comment|/** Checks that the parameters of the method are consistent with the      * format elements in the base message. */
name|ARGUMENT_MATCH
block|,   }
comment|/** The message in the default locale. */
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
specifier|public
annotation_defn|@interface
name|BaseMessage
block|{
name|String
name|value
parameter_list|()
function_decl|;
block|}
comment|/** The name of the property in the resource file. */
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
specifier|public
annotation_defn|@interface
name|Resource
block|{
name|String
name|value
parameter_list|()
function_decl|;
block|}
comment|/** The name of the class of exception to throw. */
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
specifier|public
annotation_defn|@interface
name|ExceptionClass
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
name|value
parameter_list|()
function_decl|;
name|boolean
name|causeAllowed
parameter_list|()
default|default
literal|true
function_decl|;
name|boolean
name|causeRequired
parameter_list|()
default|default
literal|false
function_decl|;
block|}
comment|/** Property of a resource. */
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
specifier|public
annotation_defn|@interface
name|Property
block|{
name|String
name|name
parameter_list|()
function_decl|;
name|String
name|value
parameter_list|()
function_decl|;
block|}
block|}
end_class

begin_comment
comment|// End Resources.java
end_comment

end_unit

