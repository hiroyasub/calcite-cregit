begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|metadata
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|rules
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util14
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|util
operator|.
name|BitSets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_comment
comment|/**  * RelMdUtil provides utility methods used by the metadata provider methods.  */
end_comment

begin_class
specifier|public
class|class
name|RelMdUtil
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|ARTIFICIAL_SELECTIVITY_FUNC
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"ARTIFICIAL_SELECTIVITY"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN
argument_list|,
comment|// returns boolean since we'll AND it
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
comment|// takes a numeric param
name|SqlFunctionCategory
operator|.
name|SYSTEM
argument_list|)
decl_stmt|;
comment|//~ Methods ----------------------------------------------------------------
specifier|private
name|RelMdUtil
parameter_list|()
block|{
block|}
comment|/**    * Creates a RexNode that stores a selectivity value corresponding to the    * selectivity of a semijoin. This can be added to a filter to simulate the    * effect of the semijoin during costing, but should never appear in a real    * plan since it has no physical implementation.    *    * @param rel the semijoin of interest    * @return constructed rexnode    */
specifier|public
specifier|static
name|RexNode
name|makeSemiJoinSelectivityRexNode
parameter_list|(
name|SemiJoinRel
name|rel
parameter_list|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|double
name|selectivity
init|=
name|computeSemiJoinSelectivity
argument_list|(
name|rel
operator|.
name|getLeft
argument_list|()
argument_list|,
name|rel
operator|.
name|getRight
argument_list|()
argument_list|,
name|rel
argument_list|)
decl_stmt|;
name|RexNode
name|selec
init|=
name|rexBuilder
operator|.
name|makeApproxLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
name|selectivity
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|ARTIFICIAL_SELECTIVITY_FUNC
argument_list|,
name|selec
argument_list|)
return|;
block|}
comment|/**    * Returns the selectivity value stored in the rexnode    *    * @param artificialSelecFuncNode rexnode containing the selectivity value    * @return selectivity value    */
specifier|public
specifier|static
name|double
name|getSelectivityValue
parameter_list|(
name|RexNode
name|artificialSelecFuncNode
parameter_list|)
block|{
assert|assert
name|artificialSelecFuncNode
operator|instanceof
name|RexCall
assert|;
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|artificialSelecFuncNode
decl_stmt|;
assert|assert
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|ARTIFICIAL_SELECTIVITY_FUNC
assert|;
name|RexNode
name|operand
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|BigDecimal
name|bd
init|=
operator|(
name|BigDecimal
operator|)
operator|(
operator|(
name|RexLiteral
operator|)
name|operand
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
return|return
name|bd
operator|.
name|doubleValue
argument_list|()
return|;
block|}
comment|/**    * Computes the selectivity of a semijoin filter if it is applied on a fact    * table. The computation is based on the selectivity of the dimension    * table/columns and the number of distinct values in the fact table    * columns.    *    * @param rel semijoin rel    * @return calculated selectivity    */
specifier|public
specifier|static
name|double
name|computeSemiJoinSelectivity
parameter_list|(
name|SemiJoinRel
name|rel
parameter_list|)
block|{
return|return
name|computeSemiJoinSelectivity
argument_list|(
name|rel
operator|.
name|getLeft
argument_list|()
argument_list|,
name|rel
operator|.
name|getRight
argument_list|()
argument_list|,
name|rel
operator|.
name|getLeftKeys
argument_list|()
argument_list|,
name|rel
operator|.
name|getRightKeys
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Computes the selectivity of a semijoin filter if it is applied on a fact    * table. The computation is based on the selectivity of the dimension    * table/columns and the number of distinct values in the fact table    * columns.    *    * @param factRel fact table participating in the semijoin    * @param dimRel  dimension table participating in the semijoin    * @param rel     semijoin rel    * @return calculated selectivity    */
specifier|public
specifier|static
name|double
name|computeSemiJoinSelectivity
parameter_list|(
name|RelNode
name|factRel
parameter_list|,
name|RelNode
name|dimRel
parameter_list|,
name|SemiJoinRel
name|rel
parameter_list|)
block|{
return|return
name|computeSemiJoinSelectivity
argument_list|(
name|factRel
argument_list|,
name|dimRel
argument_list|,
name|rel
operator|.
name|getLeftKeys
argument_list|()
argument_list|,
name|rel
operator|.
name|getRightKeys
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Computes the selectivity of a semijoin filter if it is applied on a fact    * table. The computation is based on the selectivity of the dimension    * table/columns and the number of distinct values in the fact table    * columns.    *    * @param factRel     fact table participating in the semijoin    * @param dimRel      dimension table participating in the semijoin    * @param factKeyList LHS keys used in the filter    * @param dimKeyList  RHS keys used in the filter    * @return calculated selectivity    */
specifier|public
specifier|static
name|double
name|computeSemiJoinSelectivity
parameter_list|(
name|RelNode
name|factRel
parameter_list|,
name|RelNode
name|dimRel
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|factKeyList
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|dimKeyList
parameter_list|)
block|{
name|BitSet
name|factKeys
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|factCol
range|:
name|factKeyList
control|)
block|{
name|factKeys
operator|.
name|set
argument_list|(
name|factCol
argument_list|)
expr_stmt|;
block|}
name|BitSet
name|dimKeys
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|dimCol
range|:
name|dimKeyList
control|)
block|{
name|dimKeys
operator|.
name|set
argument_list|(
name|dimCol
argument_list|)
expr_stmt|;
block|}
name|Double
name|factPop
init|=
name|RelMetadataQuery
operator|.
name|getPopulationSize
argument_list|(
name|factRel
argument_list|,
name|factKeys
argument_list|)
decl_stmt|;
if|if
condition|(
name|factPop
operator|==
literal|null
condition|)
block|{
comment|// use the dimension population if the fact population is
comment|// unavailable; since we're filtering the fact table, that's
comment|// the population we ideally want to use
name|factPop
operator|=
name|RelMetadataQuery
operator|.
name|getPopulationSize
argument_list|(
name|dimRel
argument_list|,
name|dimKeys
argument_list|)
expr_stmt|;
block|}
comment|// if cardinality and population are available, use them; otherwise
comment|// use percentage original rows
name|Double
name|selectivity
decl_stmt|;
name|Double
name|dimCard
init|=
name|RelMetadataQuery
operator|.
name|getDistinctRowCount
argument_list|(
name|dimRel
argument_list|,
name|dimKeys
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dimCard
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|factPop
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// to avoid division by zero
if|if
condition|(
name|factPop
operator|<
literal|1.0
condition|)
block|{
name|factPop
operator|=
literal|1.0
expr_stmt|;
block|}
name|selectivity
operator|=
name|dimCard
operator|/
name|factPop
expr_stmt|;
block|}
else|else
block|{
name|selectivity
operator|=
name|RelMetadataQuery
operator|.
name|getPercentageOriginalRows
argument_list|(
name|dimRel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|selectivity
operator|==
literal|null
condition|)
block|{
comment|// set a default selectivity based on the number of semijoin keys
name|selectivity
operator|=
name|Math
operator|.
name|pow
argument_list|(
literal|0.1
argument_list|,
name|dimKeys
operator|.
name|cardinality
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|selectivity
operator|>
literal|1.0
condition|)
block|{
name|selectivity
operator|=
literal|1.0
expr_stmt|;
block|}
return|return
name|selectivity
return|;
block|}
comment|/**    * Returns true if the columns represented in a bit mask are definitely    * known to form a unique column set.    *    * @param rel     the relational expression that the column mask corresponds    *                to    * @param colMask bit mask containing columns that will be tested for    *                uniqueness    * @return true if bit mask represents a unique column set; false if not (or    * if no metadata is available)    */
specifier|public
specifier|static
name|boolean
name|areColumnsDefinitelyUnique
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|BitSet
name|colMask
parameter_list|)
block|{
name|Boolean
name|b
init|=
name|RelMetadataQuery
operator|.
name|areColumnsUnique
argument_list|(
name|rel
argument_list|,
name|colMask
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|b
operator|!=
literal|null
operator|&&
name|b
return|;
block|}
specifier|public
specifier|static
name|Boolean
name|areColumnsUnique
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|columnRefs
parameter_list|)
block|{
name|BitSet
name|colMask
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|RexInputRef
name|columnRef
range|:
name|columnRefs
control|)
block|{
name|colMask
operator|.
name|set
argument_list|(
name|columnRef
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|RelMetadataQuery
operator|.
name|areColumnsUnique
argument_list|(
name|rel
argument_list|,
name|colMask
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|areColumnsDefinitelyUnique
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|columnRefs
parameter_list|)
block|{
name|Boolean
name|b
init|=
name|areColumnsUnique
argument_list|(
name|rel
argument_list|,
name|columnRefs
argument_list|)
decl_stmt|;
return|return
name|b
operator|!=
literal|null
operator|&&
name|b
return|;
block|}
comment|/**    * Returns true if the columns represented in a bit mask are definitely    * known to form a unique column set, when nulls have been filtered from    * the columns.    *    * @param rel     the relational expression that the column mask corresponds    *                to    * @param colMask bit mask containing columns that will be tested for    *                uniqueness    * @return true if bit mask represents a unique column set; false if not (or    * if no metadata is available)    */
specifier|public
specifier|static
name|boolean
name|areColumnsDefinitelyUniqueWhenNullsFiltered
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|BitSet
name|colMask
parameter_list|)
block|{
name|Boolean
name|b
init|=
name|RelMetadataQuery
operator|.
name|areColumnsUnique
argument_list|(
name|rel
argument_list|,
name|colMask
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|b
return|;
block|}
specifier|public
specifier|static
name|Boolean
name|areColumnsUniqueWhenNullsFiltered
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|columnRefs
parameter_list|)
block|{
name|BitSet
name|colMask
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|RexInputRef
name|columnRef
range|:
name|columnRefs
control|)
block|{
name|colMask
operator|.
name|set
argument_list|(
name|columnRef
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|RelMetadataQuery
operator|.
name|areColumnsUnique
argument_list|(
name|rel
argument_list|,
name|colMask
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|areColumnsDefinitelyUniqueWhenNullsFiltered
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|columnRefs
parameter_list|)
block|{
name|Boolean
name|b
init|=
name|areColumnsUniqueWhenNullsFiltered
argument_list|(
name|rel
argument_list|,
name|columnRefs
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|b
return|;
block|}
comment|/**    * Separates a bit-mask representing a join into masks representing the left    * and right inputs into the join    *    * @param groupKey      original bit-mask    * @param leftMask      left bit-mask to be set    * @param rightMask     right bit-mask to be set    * @param nFieldsOnLeft number of fields in the left input    */
specifier|public
specifier|static
name|void
name|setLeftRightBitmaps
parameter_list|(
name|BitSet
name|groupKey
parameter_list|,
name|BitSet
name|leftMask
parameter_list|,
name|BitSet
name|rightMask
parameter_list|,
name|int
name|nFieldsOnLeft
parameter_list|)
block|{
for|for
control|(
name|int
name|bit
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|groupKey
argument_list|)
control|)
block|{
if|if
condition|(
name|bit
operator|<
name|nFieldsOnLeft
condition|)
block|{
name|leftMask
operator|.
name|set
argument_list|(
name|bit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rightMask
operator|.
name|set
argument_list|(
name|bit
operator|-
name|nFieldsOnLeft
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the number of distinct values provided numSelected are selected    * where there are domainSize distinct values.    *    *<p>Note that in the case where domainSize == numSelected, it's not true    * that the return value should be domainSize. If you pick 100 random values    * between 1 and 100, you'll most likely end up with fewer than 100 distinct    * values, because you'll pick some values more than once.    *    * @param domainSize  number of distinct values in the domain    * @param numSelected number selected from the domain    * @return number of distinct values for subset selected    */
specifier|public
specifier|static
name|Double
name|numDistinctVals
parameter_list|(
name|Double
name|domainSize
parameter_list|,
name|Double
name|numSelected
parameter_list|)
block|{
if|if
condition|(
operator|(
name|domainSize
operator|==
literal|null
operator|)
operator|||
operator|(
name|numSelected
operator|==
literal|null
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Cap the input sizes at MAX_VALUE to ensure that the calculations
comment|// using these values return meaningful values
name|double
name|dSize
init|=
name|capInfinity
argument_list|(
name|domainSize
argument_list|)
decl_stmt|;
name|double
name|numSel
init|=
name|capInfinity
argument_list|(
name|numSelected
argument_list|)
decl_stmt|;
comment|// The formula for this is:
comment|// 1. Assume we pick 80 random values between 1 and 100.
comment|// 2. The chance we skip any given value is .99 ^ 80
comment|// 3. Thus on average we will skip .99 ^ 80 percent of the values
comment|//    in the domain
comment|// 4. Generalized, we skip ( (n-1)/n ) ^ k values where n is the
comment|//    number of possible values and k is the number we are selecting
comment|// 5. This can be rewritten via approximation (if you want to
comment|//    know why approximation is called for here, ask Bill Keese):
comment|//  ((n-1)/n) ^ k
comment|//  = e ^ ln( ((n-1)/n) ^ k )
comment|//  = e ^ (k * ln ((n-1)/n))
comment|//  = e ^ (k * ln (1-1/n))
comment|// ~= e ^ (k * (-1/n))  because ln(1+x) ~= x for small x
comment|//  = e ^ (-k/n)
comment|// 6. Flipping it from number skipped to number visited, we get:
name|double
name|res
init|=
operator|(
name|dSize
operator|>
literal|0
operator|)
condition|?
operator|(
operator|(
literal|1.0
operator|-
name|Math
operator|.
name|exp
argument_list|(
operator|-
literal|1
operator|*
name|numSel
operator|/
name|dSize
argument_list|)
operator|)
operator|*
name|dSize
operator|)
else|:
literal|0
decl_stmt|;
comment|// fix the boundary cases
if|if
condition|(
name|res
operator|>
name|dSize
condition|)
block|{
name|res
operator|=
name|dSize
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|>
name|numSel
condition|)
block|{
name|res
operator|=
name|numSel
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|res
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/**    * Caps a double value at Double.MAX_VALUE if it's currently infinity    *    * @param d the Double object    * @return the double value if it's not infinity; else Double.MAX_VALUE    */
specifier|public
specifier|static
name|double
name|capInfinity
parameter_list|(
name|Double
name|d
parameter_list|)
block|{
return|return
name|d
operator|.
name|isInfinite
argument_list|()
condition|?
name|Double
operator|.
name|MAX_VALUE
else|:
name|d
return|;
block|}
comment|/**    * Returns default estimates for selectivities, in the absence of stats.    *    * @param predicate predicate for which selectivity will be computed; null    *                  means true, so gives selectity of 1.0    * @return estimated selectivity    */
specifier|public
specifier|static
name|double
name|guessSelectivity
parameter_list|(
name|RexNode
name|predicate
parameter_list|)
block|{
return|return
name|guessSelectivity
argument_list|(
name|predicate
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns default estimates for selectivities, in the absence of stats.    *    * @param predicate      predicate for which selectivity will be computed;    *                       null means true, so gives selectity of 1.0    * @param artificialOnly return only the selectivity contribution from    *                       artificial nodes    * @return estimated selectivity    */
specifier|public
specifier|static
name|double
name|guessSelectivity
parameter_list|(
name|RexNode
name|predicate
parameter_list|,
name|boolean
name|artificialOnly
parameter_list|)
block|{
name|double
name|sel
init|=
literal|1.0
decl_stmt|;
if|if
condition|(
operator|(
name|predicate
operator|==
literal|null
operator|)
operator|||
name|predicate
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return
name|sel
return|;
block|}
name|double
name|artificialSel
init|=
literal|1.0
decl_stmt|;
for|for
control|(
name|RexNode
name|pred
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|predicate
argument_list|)
control|)
block|{
if|if
condition|(
name|pred
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|IS_NOT_NULL
condition|)
block|{
name|sel
operator|*=
literal|.9
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|pred
operator|instanceof
name|RexCall
operator|)
operator|&&
operator|(
operator|(
operator|(
name|RexCall
operator|)
name|pred
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|RelMdUtil
operator|.
name|ARTIFICIAL_SELECTIVITY_FUNC
operator|)
condition|)
block|{
name|artificialSel
operator|*=
name|RelMdUtil
operator|.
name|getSelectivityValue
argument_list|(
name|pred
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|pred
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|EQUALS
argument_list|)
condition|)
block|{
name|sel
operator|*=
literal|.15
expr_stmt|;
block|}
if|else if
condition|(
name|pred
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|COMPARISON
argument_list|)
condition|)
block|{
name|sel
operator|*=
literal|.5
expr_stmt|;
block|}
else|else
block|{
name|sel
operator|*=
literal|.25
expr_stmt|;
block|}
block|}
if|if
condition|(
name|artificialOnly
condition|)
block|{
return|return
name|artificialSel
return|;
block|}
else|else
block|{
return|return
name|sel
operator|*
name|artificialSel
return|;
block|}
block|}
comment|/**    * Locates the columns corresponding to equijoins within a joinrel.    *    * @param leftChild     left input into the join    * @param rightChild    right input into the join    * @param predicate     join predicate    * @param leftJoinCols  bitmap that will be set with the columns on the LHS    *                      of the join that participate in equijoins    * @param rightJoinCols bitmap that will be set with the columns on the RHS    *                      of the join that participate in equijoins    * @return remaining join filters that are not equijoins; may return a    * {@link RexLiteral} true, but never null    */
specifier|public
specifier|static
name|RexNode
name|findEquiJoinCols
parameter_list|(
name|RelNode
name|leftChild
parameter_list|,
name|RelNode
name|rightChild
parameter_list|,
name|RexNode
name|predicate
parameter_list|,
name|BitSet
name|leftJoinCols
parameter_list|,
name|BitSet
name|rightJoinCols
parameter_list|)
block|{
comment|// locate the equijoin conditions
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|RexNode
name|nonEquiJoin
init|=
name|RelOptUtil
operator|.
name|splitJoinCondition
argument_list|(
name|leftChild
argument_list|,
name|rightChild
argument_list|,
name|predicate
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|)
decl_stmt|;
assert|assert
name|nonEquiJoin
operator|!=
literal|null
assert|;
comment|// mark the columns referenced on each side of the equijoin filters
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftKeys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|leftJoinCols
operator|.
name|set
argument_list|(
name|leftKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|rightJoinCols
operator|.
name|set
argument_list|(
name|rightKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|nonEquiJoin
return|;
block|}
comment|/**    * AND's two predicates together, either of which may be null, removing    * redundant filters.    *    * @param rexBuilder rexBuilder used to construct AND'd RexNode    * @param pred1      first predicate    * @param pred2      second predicate    * @return AND'd predicate or individual predicates if one is null    */
specifier|public
specifier|static
name|RexNode
name|unionPreds
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|pred1
parameter_list|,
name|RexNode
name|pred2
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|unionList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|strings
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|rex
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|pred1
argument_list|)
control|)
block|{
if|if
condition|(
name|strings
operator|.
name|add
argument_list|(
name|rex
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|unionList
operator|.
name|add
argument_list|(
name|rex
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|RexNode
name|rex2
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|pred2
argument_list|)
control|)
block|{
if|if
condition|(
name|strings
operator|.
name|add
argument_list|(
name|rex2
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|unionList
operator|.
name|add
argument_list|(
name|rex2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|unionList
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Takes the difference between two predicates, removing from the first any    * predicates also in the second    *    * @param rexBuilder rexBuilder used to construct AND'd RexNode    * @param pred1      first predicate    * @param pred2      second predicate    * @return MINUS'd predicate list    */
specifier|public
specifier|static
name|RexNode
name|minusPreds
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|pred1
parameter_list|,
name|RexNode
name|pred2
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|list1
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|pred1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|list2
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|pred2
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|minusList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|rex1
range|:
name|list1
control|)
block|{
name|boolean
name|add
init|=
literal|true
decl_stmt|;
for|for
control|(
name|RexNode
name|rex2
range|:
name|list2
control|)
block|{
if|if
condition|(
name|rex2
operator|.
name|toString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|rex1
operator|.
name|toString
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|add
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|add
condition|)
block|{
name|minusList
operator|.
name|add
argument_list|(
name|rex1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|minusList
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Takes a bitmap representing a set of input references and extracts the    * ones that reference the group by columns in an aggregate    *    * @param groupKey the original bitmap    * @param aggRel   the aggregate    * @param childKey sets bits from groupKey corresponding to group by columns    */
specifier|public
specifier|static
name|void
name|setAggChildKeys
parameter_list|(
name|BitSet
name|groupKey
parameter_list|,
name|AggregateRelBase
name|aggRel
parameter_list|,
name|BitSet
name|childKey
parameter_list|)
block|{
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
init|=
name|aggRel
operator|.
name|getAggCallList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|bit
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|groupKey
argument_list|)
control|)
block|{
if|if
condition|(
name|bit
operator|<
name|aggRel
operator|.
name|getGroupCount
argument_list|()
condition|)
block|{
comment|// group by column
name|childKey
operator|.
name|set
argument_list|(
name|bit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// aggregate column -- set a bit for each argument being
comment|// aggregated
name|AggregateCall
name|agg
init|=
name|aggCalls
operator|.
name|get
argument_list|(
name|bit
operator|-
name|aggRel
operator|.
name|getGroupCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Integer
name|arg
range|:
name|agg
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|childKey
operator|.
name|set
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Forms two bitmaps by splitting the columns in a bitmap according to    * whether or not the column references the child input or is an expression    *    * @param projExprs Project expressions    * @param groupKey  Bitmap whose columns will be split    * @param baseCols  Bitmap representing columns from the child input    * @param projCols  Bitmap representing non-child columns    */
specifier|public
specifier|static
name|void
name|splitCols
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|projExprs
parameter_list|,
name|BitSet
name|groupKey
parameter_list|,
name|BitSet
name|baseCols
parameter_list|,
name|BitSet
name|projCols
parameter_list|)
block|{
for|for
control|(
name|int
name|bit
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|groupKey
argument_list|)
control|)
block|{
specifier|final
name|RexNode
name|e
init|=
name|projExprs
operator|.
name|get
argument_list|(
name|bit
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|RexInputRef
condition|)
block|{
name|baseCols
operator|.
name|set
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|e
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|projCols
operator|.
name|set
argument_list|(
name|bit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Computes the cardinality of a particular expression from the projection    * list    *    * @param rel  RelNode corresponding to the project    * @param expr projection expression    * @return cardinality    */
specifier|public
specifier|static
name|Double
name|cardOfProjExpr
parameter_list|(
name|ProjectRelBase
name|rel
parameter_list|,
name|RexNode
name|expr
parameter_list|)
block|{
return|return
name|expr
operator|.
name|accept
argument_list|(
operator|new
name|CardOfProjExpr
argument_list|(
name|rel
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Computes the population size for a set of keys returned from a join    *    * @param joinRel  the join rel    * @param groupKey keys to compute the population for    * @return computed population size    */
specifier|public
specifier|static
name|Double
name|getJoinPopulationSize
parameter_list|(
name|RelNode
name|joinRel
parameter_list|,
name|BitSet
name|groupKey
parameter_list|)
block|{
name|BitSet
name|leftMask
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|BitSet
name|rightMask
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|RelNode
name|left
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|right
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// separate the mask into masks for the left and right
name|RelMdUtil
operator|.
name|setLeftRightBitmaps
argument_list|(
name|groupKey
argument_list|,
name|leftMask
argument_list|,
name|rightMask
argument_list|,
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
expr_stmt|;
name|Double
name|population
init|=
name|NumberUtil
operator|.
name|multiply
argument_list|(
name|RelMetadataQuery
operator|.
name|getPopulationSize
argument_list|(
name|left
argument_list|,
name|leftMask
argument_list|)
argument_list|,
name|RelMetadataQuery
operator|.
name|getPopulationSize
argument_list|(
name|right
argument_list|,
name|rightMask
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|RelMdUtil
operator|.
name|numDistinctVals
argument_list|(
name|population
argument_list|,
name|RelMetadataQuery
operator|.
name|getRowCount
argument_list|(
name|joinRel
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Computes the number of distinct rows for a set of keys returned from a    * join. Also known as NDV (number of distinct values).    *    * @param joinRel   RelNode representing the join    * @param joinType  type of join    * @param groupKey  keys that the distinct row count will be computed for    * @param predicate join predicate    * @param useMaxNdv If true use formula<code>max(left NDV, right NDV)</code>,    *                  otherwise use<code>left NDV * right NDV</code>.    * @return number of distinct rows    */
specifier|public
specifier|static
name|Double
name|getJoinDistinctRowCount
parameter_list|(
name|RelNode
name|joinRel
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|,
name|BitSet
name|groupKey
parameter_list|,
name|RexNode
name|predicate
parameter_list|,
name|boolean
name|useMaxNdv
parameter_list|)
block|{
name|Double
name|distRowCount
decl_stmt|;
name|BitSet
name|leftMask
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|BitSet
name|rightMask
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|RelNode
name|left
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|right
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|RelMdUtil
operator|.
name|setLeftRightBitmaps
argument_list|(
name|groupKey
argument_list|,
name|leftMask
argument_list|,
name|rightMask
argument_list|,
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// determine which filters apply to the left vs right
name|RexNode
name|leftPred
init|=
literal|null
decl_stmt|;
name|RexNode
name|rightPred
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|predicate
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftFilters
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightFilters
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilters
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|predList
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|predicate
argument_list|)
decl_stmt|;
name|RelOptUtil
operator|.
name|classifyFilters
argument_list|(
name|joinRel
argument_list|,
name|predList
argument_list|,
name|joinType
operator|==
name|JoinRelType
operator|.
name|INNER
argument_list|,
operator|!
name|joinType
operator|.
name|generatesNullsOnLeft
argument_list|()
argument_list|,
operator|!
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
argument_list|,
name|joinFilters
argument_list|,
name|leftFilters
argument_list|,
name|rightFilters
argument_list|)
expr_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|leftPred
operator|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|leftFilters
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|rightPred
operator|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|rightFilters
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useMaxNdv
condition|)
block|{
name|distRowCount
operator|=
name|Math
operator|.
name|max
argument_list|(
name|RelMetadataQuery
operator|.
name|getDistinctRowCount
argument_list|(
name|left
argument_list|,
name|leftMask
argument_list|,
name|leftPred
argument_list|)
argument_list|,
name|RelMetadataQuery
operator|.
name|getDistinctRowCount
argument_list|(
name|right
argument_list|,
name|rightMask
argument_list|,
name|rightPred
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|distRowCount
operator|=
name|NumberUtil
operator|.
name|multiply
argument_list|(
name|RelMetadataQuery
operator|.
name|getDistinctRowCount
argument_list|(
name|left
argument_list|,
name|leftMask
argument_list|,
name|leftPred
argument_list|)
argument_list|,
name|RelMetadataQuery
operator|.
name|getDistinctRowCount
argument_list|(
name|right
argument_list|,
name|rightMask
argument_list|,
name|rightPred
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|RelMdUtil
operator|.
name|numDistinctVals
argument_list|(
name|distRowCount
argument_list|,
name|RelMetadataQuery
operator|.
name|getRowCount
argument_list|(
name|joinRel
argument_list|)
argument_list|)
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/** Visitor that walks over a scalar expression and computes the    * cardinality of its result. */
specifier|private
specifier|static
class|class
name|CardOfProjExpr
extends|extends
name|RexVisitorImpl
argument_list|<
name|Double
argument_list|>
block|{
specifier|private
name|ProjectRelBase
name|rel
decl_stmt|;
specifier|public
name|CardOfProjExpr
parameter_list|(
name|ProjectRelBase
name|rel
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|rel
operator|=
name|rel
expr_stmt|;
block|}
specifier|public
name|Double
name|visitInputRef
parameter_list|(
name|RexInputRef
name|var
parameter_list|)
block|{
name|int
name|index
init|=
name|var
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|BitSet
name|col
init|=
operator|new
name|BitSet
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|col
operator|.
name|set
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|Double
name|distinctRowCount
init|=
name|RelMetadataQuery
operator|.
name|getDistinctRowCount
argument_list|(
name|rel
operator|.
name|getChild
argument_list|()
argument_list|,
name|col
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|distinctRowCount
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|RelMdUtil
operator|.
name|numDistinctVals
argument_list|(
name|distinctRowCount
argument_list|,
name|RelMetadataQuery
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|public
name|Double
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
return|return
name|RelMdUtil
operator|.
name|numDistinctVals
argument_list|(
literal|1.0
argument_list|,
name|RelMetadataQuery
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|Double
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|Double
name|distinctRowCount
decl_stmt|;
name|Double
name|rowCount
init|=
name|RelMetadataQuery
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|MINUS_PREFIX
argument_list|)
condition|)
block|{
name|distinctRowCount
operator|=
name|cardOfProjExpr
argument_list|(
name|rel
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|call
operator|.
name|isA
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlKind
operator|.
name|PLUS
argument_list|,
name|SqlKind
operator|.
name|MINUS
argument_list|)
argument_list|)
condition|)
block|{
name|Double
name|card0
init|=
name|cardOfProjExpr
argument_list|(
name|rel
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|card0
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Double
name|card1
init|=
name|cardOfProjExpr
argument_list|(
name|rel
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|card1
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|distinctRowCount
operator|=
name|Math
operator|.
name|max
argument_list|(
name|card0
argument_list|,
name|card1
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|call
operator|.
name|isA
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlKind
operator|.
name|TIMES
argument_list|,
name|SqlKind
operator|.
name|DIVIDE
argument_list|)
argument_list|)
condition|)
block|{
name|distinctRowCount
operator|=
name|NumberUtil
operator|.
name|multiply
argument_list|(
name|cardOfProjExpr
argument_list|(
name|rel
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|cardOfProjExpr
argument_list|(
name|rel
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO zfong 6/21/06 - Broadbase has code to handle date
comment|// functions like year, month, day; E.g., cardinality of Month()
comment|// is 12
block|}
else|else
block|{
if|if
condition|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|distinctRowCount
operator|=
name|cardOfProjExpr
argument_list|(
name|rel
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|distinctRowCount
operator|=
name|rowCount
operator|/
literal|10
expr_stmt|;
block|}
block|}
return|return
name|numDistinctVals
argument_list|(
name|distinctRowCount
argument_list|,
name|rowCount
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End RelMdUtil.java
end_comment

end_unit

