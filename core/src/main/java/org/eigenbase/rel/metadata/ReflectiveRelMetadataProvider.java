begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to the Apache Software Foundation (ASF) under one or more // contributor license agreements.  See the NOTICE file distributed with // this work for additional information regarding copyright ownership. // The ASF licenses this file to you under the Apache License, Version 2.0 // (the "License"); you may not use this file except in compliance with // the License.  You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|metadata
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|BuiltinMethod
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Implementation of the {@link RelMetadataProvider} interface that dispatches  * metadata methods to methods on a given object via reflection.  *  *<p>The methods on the target object must be public and non-static, and have  * the same signature as the implemented metadata method except for an  * additional first parameter of type {@link RelNode} or a sub-class. That  * parameter gives this provider an indication of that relational expressions it  * can handle.</p>  *  *<p>For an example, see {@link RelMdColumnOrigins#SOURCE}.  */
end_comment

begin_class
specifier|public
class|class
name|ReflectiveRelMetadataProvider
implements|implements
name|RelMetadataProvider
implements|,
name|ReflectiveVisitor
block|{
comment|/** Comparator that sorts derived classes before their base classes. */
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Class
argument_list|<
name|RelNode
argument_list|>
argument_list|>
name|SUPERCLASS_COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|Class
argument_list|<
name|RelNode
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Class
argument_list|<
name|RelNode
argument_list|>
name|c1
parameter_list|,
name|Class
argument_list|<
name|RelNode
argument_list|>
name|c2
parameter_list|)
block|{
return|return
name|c1
operator|==
name|c2
condition|?
literal|0
else|:
name|c2
operator|.
name|isAssignableFrom
argument_list|(
name|c1
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
block|}
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|private
specifier|final
name|ImmutableMap
argument_list|<
name|Class
argument_list|<
name|RelNode
argument_list|>
argument_list|,
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Metadata
argument_list|>
argument_list|>
name|map
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|metadataClass0
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a ReflectiveRelMetadataProvider.    *    * @param map Map    * @param metadataClass0 Metadata class    */
specifier|protected
name|ReflectiveRelMetadataProvider
parameter_list|(
name|ImmutableMap
argument_list|<
name|Class
argument_list|<
name|RelNode
argument_list|>
argument_list|,
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Metadata
argument_list|>
argument_list|>
name|map
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|metadataClass0
parameter_list|)
block|{
assert|assert
operator|!
name|map
operator|.
name|isEmpty
argument_list|()
operator|:
literal|"are your methods named wrong?"
assert|;
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
name|this
operator|.
name|metadataClass0
operator|=
name|metadataClass0
expr_stmt|;
block|}
comment|/** Returns an implementation of {@link RelMetadataProvider} that scans for    * methods with a preceding argument.    *    *<p>For example, {@link BuiltInMetadata.Selectivity} has a method    * {@link BuiltInMetadata.Selectivity#getSelectivity(org.eigenbase.rex.RexNode)}.    * A class</p>    *    *<blockquote><pre><code>    * class RelMdSelectivity {    *   public Double getSelectivity(UnionRel rel, RexNode predicate) { ... }    *   public Double getSelectivity(FilterRel rel, RexNode predicate) { ... }    *</code></pre></blockquote>    *    *<p>provides implementations of selectivity for relational expressions    * that extend {@link UnionRel} or {@link FilterRel}.</p>    */
specifier|public
specifier|static
name|RelMetadataProvider
name|reflectiveSource
parameter_list|(
name|Method
name|method
parameter_list|,
specifier|final
name|Object
name|target
parameter_list|)
block|{
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|metadataClass0
init|=
name|method
operator|.
name|getDeclaringClass
argument_list|()
decl_stmt|;
assert|assert
name|Metadata
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|metadataClass0
argument_list|)
assert|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|RelNode
argument_list|>
argument_list|,
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Metadata
argument_list|>
argument_list|>
name|treeMap
init|=
name|Maps
operator|.
expr|<
name|Class
argument_list|<
name|RelNode
argument_list|>
decl_stmt|,
name|Class
argument_list|<
name|RelNode
argument_list|>
decl_stmt|,
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Metadata
argument_list|>
decl|>
name|newTreeMap
argument_list|(
name|SUPERCLASS_COMPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Method
name|method1
range|:
name|target
operator|.
name|getClass
argument_list|()
operator|.
name|getMethods
argument_list|()
control|)
block|{
if|if
condition|(
name|method1
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|method
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
operator|(
name|method1
operator|.
name|getModifiers
argument_list|()
operator|&
name|Modifier
operator|.
name|STATIC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|method1
operator|.
name|getModifiers
argument_list|()
operator|&
name|Modifier
operator|.
name|PUBLIC
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|parameterTypes1
init|=
name|method1
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|parameterTypes
init|=
name|method
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|parameterTypes1
operator|.
name|length
operator|==
name|parameterTypes
operator|.
name|length
operator|+
literal|1
operator|&&
name|RelNode
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|parameterTypes1
index|[
literal|0
index|]
argument_list|)
operator|&&
name|Util
operator|.
name|skip
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|parameterTypes1
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|parameterTypes
argument_list|)
argument_list|)
condition|)
block|{
comment|//noinspection unchecked
specifier|final
name|Class
argument_list|<
name|RelNode
argument_list|>
name|key
init|=
operator|(
name|Class
operator|)
name|parameterTypes1
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Metadata
argument_list|>
name|function
init|=
operator|new
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Metadata
argument_list|>
argument_list|()
block|{
specifier|public
name|Metadata
name|apply
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|)
block|{
return|return
operator|(
name|Metadata
operator|)
name|Proxy
operator|.
name|newProxyInstance
argument_list|(
name|metadataClass0
operator|.
name|getClassLoader
argument_list|()
argument_list|,
operator|new
name|Class
index|[]
block|{
name|metadataClass0
block|}
argument_list|,
operator|new
name|InvocationHandler
argument_list|()
block|{
specifier|public
name|Object
name|invoke
parameter_list|(
name|Object
name|proxy
parameter_list|,
name|Method
name|method
parameter_list|,
name|Object
index|[]
name|args
parameter_list|)
throws|throws
name|Throwable
block|{
comment|// Suppose we are an implementation of Selectivity
comment|// that wraps "filter", a FilterRel, Then we implement
comment|//   Selectivity.selectivity(rex)
comment|// by calling method
comment|//   new SelectivityImpl().selectivity(filter, rex)
if|if
condition|(
name|method
operator|.
name|equals
argument_list|(
name|BuiltinMethod
operator|.
name|METADATA_REL
operator|.
name|method
argument_list|)
condition|)
block|{
return|return
name|rel
return|;
block|}
if|if
condition|(
name|method
operator|.
name|equals
argument_list|(
name|BuiltinMethod
operator|.
name|OBJECT_TO_STRING
operator|.
name|method
argument_list|)
condition|)
block|{
return|return
name|metadataClass0
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"("
operator|+
name|rel
operator|+
literal|")"
return|;
block|}
specifier|final
name|Object
index|[]
name|args1
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|null
condition|)
block|{
name|args1
operator|=
operator|new
name|Object
index|[]
block|{
name|rel
block|}
expr_stmt|;
block|}
else|else
block|{
name|args1
operator|=
operator|new
name|Object
index|[
name|args
operator|.
name|length
operator|+
literal|1
index|]
expr_stmt|;
name|args1
index|[
literal|0
index|]
operator|=
name|rel
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
name|args1
argument_list|,
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|method1
operator|.
name|invoke
argument_list|(
name|target
argument_list|,
name|args1
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|treeMap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Due to the comparator, the TreeMap is sorted such that any derived class
comment|// will occur before its base class. The immutable map is not a sorted map,
comment|// but it retains the traversal order, and that is sufficient.
specifier|final
name|ImmutableMap
argument_list|<
name|Class
argument_list|<
name|RelNode
argument_list|>
argument_list|,
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Metadata
argument_list|>
argument_list|>
name|map
init|=
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|treeMap
argument_list|)
decl_stmt|;
return|return
operator|new
name|ReflectiveRelMetadataProvider
argument_list|(
name|map
argument_list|,
name|metadataClass0
argument_list|)
return|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|public
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Metadata
argument_list|>
name|apply
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|relClass
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Metadata
argument_list|>
name|metadataClass
parameter_list|)
block|{
if|if
condition|(
name|metadataClass
operator|==
name|metadataClass0
condition|)
block|{
comment|//noinspection SuspiciousMethodCalls
specifier|final
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Metadata
argument_list|>
name|function
init|=
name|map
operator|.
name|get
argument_list|(
name|relClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
operator|!=
literal|null
condition|)
block|{
return|return
name|function
return|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Class
argument_list|<
name|RelNode
argument_list|>
argument_list|,
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Metadata
argument_list|>
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|isAssignableFrom
argument_list|(
name|relClass
argument_list|)
condition|)
block|{
comment|// REVIEW: We are assuming that the first we find is the "best".
return|return
name|entry
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
end_class

begin_comment
comment|// End ReflectiveRelMetadataProvider.java
end_comment

end_unit

