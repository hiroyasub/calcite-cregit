begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|AggregateRelBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|Aggregation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|FilterRelBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|SubstitutionVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|util
operator|.
name|BitSets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * Planner rule that matches an {@link org.eigenbase.rel.AggregateRelBase}  * on a {@link org.eigenbase.rel.FilterRelBase} and transposes them,  * pushing the aggregate below the filter.  *  *<p>In some cases, it is necessary to split the aggregate.  *  *<p>This rule does not directly improve performance. The aggregate will  * have to process more rows, to produce aggregated rows that will be thrown  * away. The rule might be beneficial if the predicate is very expensive to  * evaluate. The main use of the rule is to match a query that has a filter  * under an aggregate to an existing aggregate table.  *  * @see org.eigenbase.rel.rules.FilterAggregateTransposeRule  */
end_comment

begin_class
specifier|public
class|class
name|AggregateFilterTransposeRule
extends|extends
name|RelOptRule
block|{
specifier|public
specifier|static
specifier|final
name|AggregateFilterTransposeRule
name|INSTANCE
init|=
operator|new
name|AggregateFilterTransposeRule
argument_list|()
decl_stmt|;
specifier|private
name|AggregateFilterTransposeRule
parameter_list|()
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|AggregateRelBase
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|FilterRelBase
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|AggregateRelBase
name|aggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|FilterRelBase
name|filter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// Do the columns used by the filter appear in the output of the aggregate?
specifier|final
name|BitSet
name|filterColumns
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|BitSet
name|newGroupSet
init|=
name|BitSets
operator|.
name|union
argument_list|(
name|aggregate
operator|.
name|getGroupSet
argument_list|()
argument_list|,
name|filterColumns
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|filter
operator|.
name|getChild
argument_list|()
decl_stmt|;
specifier|final
name|Boolean
name|unique
init|=
name|RelMetadataQuery
operator|.
name|areColumnsUnique
argument_list|(
name|input
argument_list|,
name|newGroupSet
argument_list|)
decl_stmt|;
if|if
condition|(
name|unique
operator|!=
literal|null
operator|&&
name|unique
condition|)
block|{
comment|// The input is already unique on the grouping columns, so there's little
comment|// advantage of aggregating again. More important, without this check,
comment|// the rule fires forever: A-F => A-F-A => A-A-F-A => A-A-A-F-A => ...
return|return;
block|}
specifier|final
name|AggregateRelBase
name|newAggregate
init|=
name|aggregate
operator|.
name|copy
argument_list|(
name|aggregate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|input
argument_list|,
name|newGroupSet
argument_list|,
name|aggregate
operator|.
name|getAggCallList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Mappings
operator|.
name|target
argument_list|(
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|Integer
name|apply
parameter_list|(
name|Integer
name|a0
parameter_list|)
block|{
return|return
name|BitSets
operator|.
name|toList
argument_list|(
name|newGroupSet
argument_list|)
operator|.
name|indexOf
argument_list|(
name|a0
argument_list|)
return|;
block|}
block|}
argument_list|,
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|newGroupSet
operator|.
name|cardinality
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|newCondition
init|=
name|RexUtil
operator|.
name|apply
argument_list|(
name|mapping
argument_list|,
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|FilterRelBase
name|newFilter
init|=
name|filter
operator|.
name|copy
argument_list|(
name|filter
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newAggregate
argument_list|,
name|newCondition
argument_list|)
decl_stmt|;
if|if
condition|(
name|BitSets
operator|.
name|contains
argument_list|(
name|aggregate
operator|.
name|getGroupSet
argument_list|()
argument_list|,
name|filterColumns
argument_list|)
condition|)
block|{
comment|// Everything needed by the filter is returned by the aggregate.
assert|assert
name|newGroupSet
operator|.
name|equals
argument_list|(
name|aggregate
operator|.
name|getGroupSet
argument_list|()
argument_list|)
assert|;
name|call
operator|.
name|transformTo
argument_list|(
name|newFilter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The filter needs at least one extra column.
comment|// Now aggregate it away.
specifier|final
name|BitSet
name|topGroupSet
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|c
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|aggregate
operator|.
name|getGroupSet
argument_list|()
argument_list|)
control|)
block|{
name|topGroupSet
operator|.
name|set
argument_list|(
name|BitSets
operator|.
name|toList
argument_list|(
name|newGroupSet
argument_list|)
operator|.
name|indexOf
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|topAggCallList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|newGroupSet
operator|.
name|cardinality
argument_list|()
operator|-
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
decl_stmt|;
assert|assert
name|offset
operator|>
literal|0
assert|;
for|for
control|(
name|AggregateCall
name|aggregateCall
range|:
name|aggregate
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|args
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|arg
range|:
name|aggregateCall
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|args
operator|.
name|add
argument_list|(
name|arg
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Aggregation
name|rollup
init|=
name|SubstitutionVisitor
operator|.
name|getRollup
argument_list|(
name|aggregateCall
operator|.
name|getAggregation
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rollup
operator|==
literal|null
condition|)
block|{
comment|// This aggregate cannot be rolled up.
return|return;
block|}
if|if
condition|(
name|aggregateCall
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
comment|// Cannot roll up distinct.
return|return;
block|}
name|topAggCallList
operator|.
name|add
argument_list|(
operator|new
name|AggregateCall
argument_list|(
name|rollup
argument_list|,
name|aggregateCall
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|args
argument_list|,
name|aggregateCall
operator|.
name|type
argument_list|,
name|aggregateCall
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|AggregateRelBase
name|topAggregate
init|=
name|aggregate
operator|.
name|copy
argument_list|(
name|aggregate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newFilter
argument_list|,
name|topGroupSet
argument_list|,
name|topAggCallList
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|topAggregate
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End AggregateFilterTransposeRule.java
end_comment

end_unit

