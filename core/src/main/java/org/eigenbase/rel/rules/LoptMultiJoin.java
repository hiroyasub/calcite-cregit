begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to DynamoBI Corporation (DynamoBI) under one // or more contributor license agreements.  See the NOTICE file // distributed with this work for additional information // regarding copyright ownership.  DynamoBI licenses this file // to you under the Apache License, Version 2.0 (the // "License"); you may not use this file except in compliance // with the License.  You may obtain a copy of the License at  //   http://www.apache.org/licenses/LICENSE-2.0  // Unless required by applicable law or agreed to in writing, // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied.  See the License for the // specific language governing permissions and limitations // under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|luciddb
operator|.
name|optimizer
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|metadata
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|rules
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * LoptMultiJoin is a utility class used to keep track of the join factors that  * make up a MultiJoinRel.  *  * @author Zelaine Fong  * @version $Id$  */
end_comment

begin_class
specifier|public
class|class
name|LoptMultiJoin
block|{
comment|//~ Instance fields --------------------------------------------------------
comment|/**      * The MultiJoinRel being optimized      */
name|MultiJoinRel
name|multiJoin
decl_stmt|;
comment|/**      * Join filters associated with the MultiJoinRel, decomposed into a list.      * Excludes left/right outer join filters.      */
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilters
decl_stmt|;
comment|/**      * All join filters associated with the MultiJoinRel, decomposed into a      * list. Includes left/right outer join filters.      */
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|allJoinFilters
decl_stmt|;
comment|/**      * Number of factors into the MultiJoinRel      */
specifier|private
name|int
name|nJoinFactors
decl_stmt|;
comment|/**      * Total number of fields in the MultiJoinRel      */
specifier|private
name|int
name|nTotalFields
decl_stmt|;
comment|/**      * Original inputs into the MultiJoinRel      */
specifier|private
name|RelNode
index|[]
name|joinFactors
decl_stmt|;
comment|/**      * If a join factor is null generating in a left or right outer join,      * joinTypes indicates the join type corresponding to the factor. Otherwise,      * it is set to INNER.      */
specifier|private
name|JoinRelType
index|[]
name|joinTypes
decl_stmt|;
comment|/**      * If a join factor is null generating in a left or right outer join, the      * bitmap contains the non-null generating factors that the null generating      * factor is dependent upon      */
specifier|private
name|BitSet
index|[]
name|outerJoinFactors
decl_stmt|;
comment|/**      * Bitmap corresponding to the fields projected from each join factor, after      * row scan processing has completed. This excludes fields referenced in      * join conditions, unless the field appears in the final projection list.      */
specifier|private
name|BitSet
index|[]
name|projFields
decl_stmt|;
comment|/**      * Map containing reference counts of the fields referenced in join      * conditions for each join factor. If a field is only required for a      * semijoin, then it is removed from the reference count. (Hence the need      * for reference counts instead of simply a bitmap.) The map is indexed by      * the factor number.      */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|int
index|[]
argument_list|>
name|joinFieldRefCountsMap
decl_stmt|;
comment|/**      * For each join filter, associates a bitmap indicating all factors      * referenced by the filter      */
specifier|private
name|Map
argument_list|<
name|RexNode
argument_list|,
name|BitSet
argument_list|>
name|factorsRefByJoinFilter
decl_stmt|;
comment|/**      * For each join filter, associates a bitmap indicating all fields      * referenced by the filter      */
specifier|private
name|Map
argument_list|<
name|RexNode
argument_list|,
name|BitSet
argument_list|>
name|fieldsRefByJoinFilter
decl_stmt|;
comment|/**      * Starting RexInputRef index corresponding to each join factor      */
name|int
index|[]
name|joinStart
decl_stmt|;
comment|/**      * Number of fields in each join factor      */
name|int
index|[]
name|nFieldsInJoinFactor
decl_stmt|;
comment|/**      * Bitmap indicating which factors each factor references in join filters      * that correspond to comparisons      */
name|BitSet
index|[]
name|factorsRefByFactor
decl_stmt|;
comment|/**      * Weights of each factor combination      */
name|int
index|[]
index|[]
name|factorWeights
decl_stmt|;
comment|/**      * Type factory      */
name|RelDataTypeFactory
name|factory
decl_stmt|;
comment|/**      * Indicates for each factor whether its join can be removed because it is      * the dimension table in a semijoin. If it can be, the entry indicates the      * factor id of the fact table (corresponding to the dimension table) in the      * semijoin that allows the factor to be removed. If the factor cannot be      * removed, the entry corresponding to the factor is null.      */
name|Integer
index|[]
name|joinRemovalFactors
decl_stmt|;
comment|/**      * The semijoins that allow the join of a dimension table to be removed      */
name|SemiJoinRel
index|[]
name|joinRemovalSemiJoins
decl_stmt|;
comment|/**      * Set of null-generating factors whose corresponding outer join can be      * removed from the query plan      */
name|Set
argument_list|<
name|Integer
argument_list|>
name|removableOuterJoinFactors
decl_stmt|;
comment|/**      * Map consisting of all pairs of self-joins where the self-join can be      * removed because the join between the identical factors is an equality      * join on the same set of unique keys. The map is keyed by either factor in      * the self join.      */
name|Map
argument_list|<
name|Integer
argument_list|,
name|RemovableSelfJoin
argument_list|>
name|removableSelfJoinPairs
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|public
name|LoptMultiJoin
parameter_list|(
name|MultiJoinRel
name|multiJoin
parameter_list|)
block|{
name|this
operator|.
name|multiJoin
operator|=
name|multiJoin
expr_stmt|;
name|joinFactors
operator|=
name|multiJoin
operator|.
name|getInputs
argument_list|()
expr_stmt|;
name|nJoinFactors
operator|=
name|joinFactors
operator|.
name|length
expr_stmt|;
name|projFields
operator|=
name|multiJoin
operator|.
name|getProjFields
argument_list|()
expr_stmt|;
name|joinFieldRefCountsMap
operator|=
name|multiJoin
operator|.
name|getCopyJoinFieldRefCountsMap
argument_list|()
expr_stmt|;
name|joinFilters
operator|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
expr_stmt|;
name|RelOptUtil
operator|.
name|decomposeConjunction
argument_list|(
name|multiJoin
operator|.
name|getJoinFilter
argument_list|()
argument_list|,
name|joinFilters
argument_list|)
expr_stmt|;
name|allJoinFilters
operator|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|(
name|joinFilters
argument_list|)
expr_stmt|;
name|RexNode
index|[]
name|outerJoinFilters
init|=
name|multiJoin
operator|.
name|getOuterJoinConditions
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nJoinFactors
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|ojFilters
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|RelOptUtil
operator|.
name|decomposeConjunction
argument_list|(
name|outerJoinFilters
index|[
name|i
index|]
argument_list|,
name|ojFilters
argument_list|)
expr_stmt|;
name|allJoinFilters
operator|.
name|addAll
argument_list|(
name|ojFilters
argument_list|)
expr_stmt|;
block|}
name|int
name|start
init|=
literal|0
decl_stmt|;
name|nTotalFields
operator|=
name|multiJoin
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
operator|.
name|length
expr_stmt|;
name|joinStart
operator|=
operator|new
name|int
index|[
name|nJoinFactors
index|]
expr_stmt|;
name|nFieldsInJoinFactor
operator|=
operator|new
name|int
index|[
name|nJoinFactors
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nJoinFactors
condition|;
name|i
operator|++
control|)
block|{
name|joinStart
index|[
name|i
index|]
operator|=
name|start
expr_stmt|;
name|nFieldsInJoinFactor
index|[
name|i
index|]
operator|=
name|joinFactors
index|[
name|i
index|]
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
operator|.
name|length
expr_stmt|;
name|start
operator|+=
name|nFieldsInJoinFactor
index|[
name|i
index|]
expr_stmt|;
block|}
name|setOuterJoinInfo
argument_list|()
expr_stmt|;
comment|// determine which join factors each join filter references
name|setJoinFilterRefs
argument_list|()
expr_stmt|;
name|factory
operator|=
name|multiJoin
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
expr_stmt|;
name|joinRemovalFactors
operator|=
operator|new
name|Integer
index|[
name|nJoinFactors
index|]
expr_stmt|;
name|joinRemovalSemiJoins
operator|=
operator|new
name|SemiJoinRel
index|[
name|nJoinFactors
index|]
expr_stmt|;
name|removableOuterJoinFactors
operator|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|removableSelfJoinPairs
operator|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|RemovableSelfJoin
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**      * @return the MultiJoinRel corresponding to this multijoin      */
specifier|public
name|MultiJoinRel
name|getMultiJoinRel
parameter_list|()
block|{
return|return
name|multiJoin
return|;
block|}
comment|/**      * @return number of factors in this multijoin      */
specifier|public
name|int
name|getNumJoinFactors
parameter_list|()
block|{
return|return
name|nJoinFactors
return|;
block|}
comment|/**      * @param factIdx factor to be returned      *      * @return factor corresponding to the factor index passed in      */
specifier|public
name|RelNode
name|getJoinFactor
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|joinFactors
index|[
name|factIdx
index|]
return|;
block|}
comment|/**      * @return total number of fields in the multijoin      */
specifier|public
name|int
name|getNumTotalFields
parameter_list|()
block|{
return|return
name|nTotalFields
return|;
block|}
comment|/**      * @param factIdx desired factor      *      * @return number of fields in the specified factor      */
specifier|public
name|int
name|getNumFieldsInJoinFactor
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|nFieldsInJoinFactor
index|[
name|factIdx
index|]
return|;
block|}
comment|/**      * @return all non-outer join filters in this multijoin      */
specifier|public
name|List
argument_list|<
name|RexNode
argument_list|>
name|getJoinFilters
parameter_list|()
block|{
return|return
name|joinFilters
return|;
block|}
comment|/**      * @param joinFilter filter for which information will be returned      *      * @return bitmap corresponding to the factors referenced within the      * specified join filter      */
specifier|public
name|BitSet
name|getFactorsRefByJoinFilter
parameter_list|(
name|RexNode
name|joinFilter
parameter_list|)
block|{
return|return
name|factorsRefByJoinFilter
operator|.
name|get
argument_list|(
name|joinFilter
argument_list|)
return|;
block|}
comment|/**      * @return array of fields contained within the multijoin      */
specifier|public
name|RelDataTypeField
index|[]
name|getMultiJoinFields
parameter_list|()
block|{
return|return
name|multiJoin
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
return|;
block|}
comment|/**      * @param joinFilter the filter for which information will be returned      *      * @return bitmap corresponding to the fields referenced by a join filter      */
specifier|public
name|BitSet
name|getFieldsRefByJoinFilter
parameter_list|(
name|RexNode
name|joinFilter
parameter_list|)
block|{
return|return
name|fieldsRefByJoinFilter
operator|.
name|get
argument_list|(
name|joinFilter
argument_list|)
return|;
block|}
comment|/**      * @return weights of the different factors relative to one another      */
specifier|public
name|int
index|[]
index|[]
name|getFactorWeights
parameter_list|()
block|{
return|return
name|factorWeights
return|;
block|}
comment|/**      * @param factIdx factor for which information will be returned      *      * @return bitmap corresponding to the factors referenced by the specified      * factor in the various join filters that correspond to comparisons      */
specifier|public
name|BitSet
name|getFactorsRefByFactor
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|factorsRefByFactor
index|[
name|factIdx
index|]
return|;
block|}
comment|/**      * @param factIdx factor for which information will be returned      *      * @return starting offset within the multijoin for the specified factor      */
specifier|public
name|int
name|getJoinStart
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|joinStart
index|[
name|factIdx
index|]
return|;
block|}
comment|/**      * @param factIdx factor for which information will be returned      *      * @return whether or not the factor corresponds to a null-generating factor      * in a left or right outer join      */
specifier|public
name|boolean
name|isNullGenerating
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|joinTypes
index|[
name|factIdx
index|]
operator|!=
name|JoinRelType
operator|.
name|INNER
return|;
block|}
comment|/**      * @param factIdx factor for which information will be returned      *      * @return bitmap containing the factors that a null generating factor is      * dependent upon, if the factor is null generating in a left or right outer      * join; otherwise null is returned      */
specifier|public
name|BitSet
name|getOuterJoinFactors
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|outerJoinFactors
index|[
name|factIdx
index|]
return|;
block|}
comment|/**      * @param factIdx factor for which information will be returned      *      * @return outer join conditions associated with the specified null      * generating factor      */
specifier|public
name|RexNode
name|getOuterJoinCond
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|multiJoin
operator|.
name|getOuterJoinConditions
argument_list|()
index|[
name|factIdx
index|]
return|;
block|}
comment|/**      * @param factIdx factor for which information will be returned      *      * @return bitmap containing the fields that are projected from a factor      */
specifier|public
name|BitSet
name|getProjFields
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|projFields
index|[
name|factIdx
index|]
return|;
block|}
comment|/**      * @param factIdx factor for which information will be returned      *      * @return the join field reference counts for a factor      */
specifier|public
name|int
index|[]
name|getJoinFieldRefCounts
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|joinFieldRefCountsMap
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
return|;
block|}
comment|/**      * @param dimIdx the dimension factor for which information will be returned      *      * @return the factor id of the fact table corresponding to a dimension      * table in a semijoin, in the case where the join with the dimension table      * can be removed      */
specifier|public
name|Integer
name|getJoinRemovalFactor
parameter_list|(
name|int
name|dimIdx
parameter_list|)
block|{
return|return
name|joinRemovalFactors
index|[
name|dimIdx
index|]
return|;
block|}
comment|/**      * @param dimIdx the dimension factor for which information will be returned      *      * @return the semijoin that allows the join of a dimension table to be      * removed      */
specifier|public
name|SemiJoinRel
name|getJoinRemovalSemiJoin
parameter_list|(
name|int
name|dimIdx
parameter_list|)
block|{
return|return
name|joinRemovalSemiJoins
index|[
name|dimIdx
index|]
return|;
block|}
comment|/**      * Indicates that a dimension factor's join can be removed because of a      * semijoin with a fact table.      *      * @param dimIdx id of the dimension factor      * @param factIdx id of the fact factor      */
specifier|public
name|void
name|setJoinRemovalFactor
parameter_list|(
name|int
name|dimIdx
parameter_list|,
name|int
name|factIdx
parameter_list|)
block|{
name|joinRemovalFactors
index|[
name|dimIdx
index|]
operator|=
name|factIdx
expr_stmt|;
block|}
comment|/**      * Indicates the semijoin that allows the join of a dimension table to be      * removed      *      * @param dimIdx id of the dimension factor      * @param semiJoin the semijoin      */
specifier|public
name|void
name|setJoinRemovalSemiJoin
parameter_list|(
name|int
name|dimIdx
parameter_list|,
name|SemiJoinRel
name|semiJoin
parameter_list|)
block|{
name|joinRemovalSemiJoins
index|[
name|dimIdx
index|]
operator|=
name|semiJoin
expr_stmt|;
block|}
comment|/**      * Extracts outer join information from the join factors, including the type      * of outer join and the factors that a null-generating factor is dependent      * upon.      */
specifier|private
name|void
name|setOuterJoinInfo
parameter_list|()
block|{
name|joinTypes
operator|=
name|multiJoin
operator|.
name|getJoinTypes
argument_list|()
expr_stmt|;
name|RexNode
index|[]
name|outerJoinConds
init|=
name|multiJoin
operator|.
name|getOuterJoinConditions
argument_list|()
decl_stmt|;
name|outerJoinFactors
operator|=
operator|new
name|BitSet
index|[
name|nJoinFactors
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nJoinFactors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|outerJoinConds
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
comment|// set a bitmap containing the factors referenced in the
comment|// ON condition of the outer join; mask off the factor
comment|// corresponding to the factor itself
name|BitSet
name|dependentFactors
init|=
name|getJoinFilterFactorBitmap
argument_list|(
name|outerJoinConds
index|[
name|i
index|]
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|dependentFactors
operator|.
name|clear
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|outerJoinFactors
index|[
name|i
index|]
operator|=
name|dependentFactors
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Returns a bitmap representing the factors referenced in a join filter      *      * @param joinFilter the join filter      * @param setFields if true, add the fields referenced by the join filter      * into a map      *      * @return the bitmap containing the factor references      */
specifier|private
name|BitSet
name|getJoinFilterFactorBitmap
parameter_list|(
name|RexNode
name|joinFilter
parameter_list|,
name|boolean
name|setFields
parameter_list|)
block|{
name|BitSet
name|fieldRefBitmap
init|=
operator|new
name|BitSet
argument_list|(
name|nTotalFields
argument_list|)
decl_stmt|;
name|joinFilter
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
name|fieldRefBitmap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setFields
condition|)
block|{
name|fieldsRefByJoinFilter
operator|.
name|put
argument_list|(
name|joinFilter
argument_list|,
name|fieldRefBitmap
argument_list|)
expr_stmt|;
block|}
name|BitSet
name|factorRefBitmap
init|=
operator|new
name|BitSet
argument_list|(
name|nJoinFactors
argument_list|)
decl_stmt|;
name|setFactorBitmap
argument_list|(
name|factorRefBitmap
argument_list|,
name|fieldRefBitmap
argument_list|)
expr_stmt|;
return|return
name|factorRefBitmap
return|;
block|}
comment|/**      * Sets bitmaps indicating which factors and fields each join filter      * references      */
specifier|private
name|void
name|setJoinFilterRefs
parameter_list|()
block|{
name|fieldsRefByJoinFilter
operator|=
operator|new
name|HashMap
argument_list|<
name|RexNode
argument_list|,
name|BitSet
argument_list|>
argument_list|()
expr_stmt|;
name|factorsRefByJoinFilter
operator|=
operator|new
name|HashMap
argument_list|<
name|RexNode
argument_list|,
name|BitSet
argument_list|>
argument_list|()
expr_stmt|;
name|ListIterator
argument_list|<
name|RexNode
argument_list|>
name|filterIter
init|=
name|allJoinFilters
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|filterIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RexNode
name|joinFilter
init|=
name|filterIter
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// ignore the literal filter; if necessary, we'll add it back
comment|// later
if|if
condition|(
name|joinFilter
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|filterIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|BitSet
name|factorRefBitmap
init|=
name|getJoinFilterFactorBitmap
argument_list|(
name|joinFilter
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|factorsRefByJoinFilter
operator|.
name|put
argument_list|(
name|joinFilter
argument_list|,
name|factorRefBitmap
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Sets the bitmap indicating which factors a filter references based on      * which fields it references      *      * @param factorRefBitmap bitmap representing factors referenced that will      * be set by this method      * @param fieldRefBitmap bitmap representing fields referenced      */
specifier|private
name|void
name|setFactorBitmap
parameter_list|(
name|BitSet
name|factorRefBitmap
parameter_list|,
name|BitSet
name|fieldRefBitmap
parameter_list|)
block|{
for|for
control|(
name|int
name|field
init|=
name|fieldRefBitmap
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|;
name|field
operator|>=
literal|0
condition|;
name|field
operator|=
name|fieldRefBitmap
operator|.
name|nextSetBit
argument_list|(
name|field
operator|+
literal|1
argument_list|)
control|)
block|{
name|int
name|factor
init|=
name|findRef
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|factorRefBitmap
operator|.
name|set
argument_list|(
name|factor
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Determines the join factor corresponding to a RexInputRef      *      * @param rexInputRef rexInputRef index      *      * @return index corresponding to join factor      */
specifier|public
name|int
name|findRef
parameter_list|(
name|int
name|rexInputRef
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nJoinFactors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rexInputRef
operator|>=
name|joinStart
index|[
name|i
index|]
operator|)
operator|&&
operator|(
name|rexInputRef
operator|<
operator|(
name|joinStart
index|[
name|i
index|]
operator|+
name|nFieldsInJoinFactor
index|[
name|i
index|]
operator|)
operator|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
assert|assert
operator|(
literal|false
operator|)
assert|;
return|return
literal|0
return|;
block|}
comment|/**      * Sets weighting for each combination of factors, depending on which join      * filters reference which factors. Greater weight is given to equality      * conditions. Also, sets bitmaps indicating which factors are referenced by      * each factor within join filters that are comparisons.      */
specifier|public
name|void
name|setFactorWeights
parameter_list|()
block|{
name|factorWeights
operator|=
operator|new
name|int
index|[
name|nJoinFactors
index|]
index|[
name|nJoinFactors
index|]
expr_stmt|;
name|factorsRefByFactor
operator|=
operator|new
name|BitSet
index|[
name|nJoinFactors
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nJoinFactors
condition|;
name|i
operator|++
control|)
block|{
name|factorsRefByFactor
index|[
name|i
index|]
operator|=
operator|new
name|BitSet
argument_list|(
name|nJoinFactors
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RexNode
name|joinFilter
range|:
name|allJoinFilters
control|)
block|{
name|BitSet
name|factorRefs
init|=
name|factorsRefByJoinFilter
operator|.
name|get
argument_list|(
name|joinFilter
argument_list|)
decl_stmt|;
comment|// don't give weights to non-comparison expressions
if|if
condition|(
operator|!
operator|(
name|joinFilter
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|joinFilter
operator|.
name|isA
argument_list|(
name|RexKind
operator|.
name|Comparison
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// OR the factors referenced in this join filter into the
comment|// bitmaps corresponding to each of the factors; however,
comment|// exclude the bit corresponding to the factor itself
for|for
control|(
name|int
name|factor
init|=
name|factorRefs
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|;
name|factor
operator|>=
literal|0
condition|;
name|factor
operator|=
name|factorRefs
operator|.
name|nextSetBit
argument_list|(
name|factor
operator|+
literal|1
argument_list|)
control|)
block|{
name|factorsRefByFactor
index|[
name|factor
index|]
operator|.
name|or
argument_list|(
name|factorRefs
argument_list|)
expr_stmt|;
name|factorsRefByFactor
index|[
name|factor
index|]
operator|.
name|clear
argument_list|(
name|factor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|factorRefs
operator|.
name|cardinality
argument_list|()
operator|==
literal|2
condition|)
block|{
name|int
name|leftFactor
init|=
name|factorRefs
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|rightFactor
init|=
name|factorRefs
operator|.
name|nextSetBit
argument_list|(
name|leftFactor
operator|+
literal|1
argument_list|)
decl_stmt|;
name|BitSet
name|leftFields
init|=
operator|new
name|BitSet
argument_list|(
name|nTotalFields
argument_list|)
decl_stmt|;
name|RexNode
index|[]
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|joinFilter
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|operands
index|[
literal|0
index|]
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
name|leftFields
argument_list|)
argument_list|)
expr_stmt|;
name|BitSet
name|leftBitmap
init|=
operator|new
name|BitSet
argument_list|(
name|nJoinFactors
argument_list|)
decl_stmt|;
name|setFactorBitmap
argument_list|(
name|leftBitmap
argument_list|,
name|leftFields
argument_list|)
expr_stmt|;
comment|// filter contains only two factor references, one on each
comment|// side of the operator
if|if
condition|(
name|leftBitmap
operator|.
name|cardinality
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// give higher weight to equijoins
if|if
condition|(
operator|(
operator|(
name|RexCall
operator|)
name|joinFilter
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|equalsOperator
condition|)
block|{
name|setFactorWeight
argument_list|(
literal|3
argument_list|,
name|leftFactor
argument_list|,
name|rightFactor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setFactorWeight
argument_list|(
literal|2
argument_list|,
name|leftFactor
argument_list|,
name|rightFactor
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// cross product of two tables
name|setFactorWeight
argument_list|(
literal|1
argument_list|,
name|leftFactor
argument_list|,
name|rightFactor
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// multiple factor references -- set a weight for each
comment|// combination of factors referenced within the filter
for|for
control|(
name|int
name|outer
init|=
name|factorRefs
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|;
name|outer
operator|>=
literal|0
condition|;
name|outer
operator|=
name|factorRefs
operator|.
name|nextSetBit
argument_list|(
name|outer
operator|+
literal|1
argument_list|)
control|)
block|{
for|for
control|(
name|int
name|inner
init|=
name|factorRefs
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|;
name|inner
operator|>=
literal|0
condition|;
name|inner
operator|=
name|factorRefs
operator|.
name|nextSetBit
argument_list|(
name|inner
operator|+
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|outer
operator|!=
name|inner
condition|)
block|{
name|setFactorWeight
argument_list|(
literal|1
argument_list|,
name|outer
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**      * Sets an individual weight if the new weight is better than the current      * one      *      * @param weight weight to be set      * @param leftFactor index of left factor      * @param rightFactor index of right factor      */
specifier|private
name|void
name|setFactorWeight
parameter_list|(
name|int
name|weight
parameter_list|,
name|int
name|leftFactor
parameter_list|,
name|int
name|rightFactor
parameter_list|)
block|{
if|if
condition|(
name|factorWeights
index|[
name|leftFactor
index|]
index|[
name|rightFactor
index|]
operator|<
name|weight
condition|)
block|{
name|factorWeights
index|[
name|leftFactor
index|]
index|[
name|rightFactor
index|]
operator|=
name|weight
expr_stmt|;
name|factorWeights
index|[
name|rightFactor
index|]
index|[
name|leftFactor
index|]
operator|=
name|weight
expr_stmt|;
block|}
block|}
comment|/**      * Returns true if a join tree contains all factors required      *      * @param joinTree join tree to be examined      * @param factorsNeeded bitmap of factors required      *      * @return true if join tree contains all required factors      */
specifier|public
name|boolean
name|hasAllFactors
parameter_list|(
name|LoptJoinTree
name|joinTree
parameter_list|,
name|BitSet
name|factorsNeeded
parameter_list|)
block|{
name|BitSet
name|childFactors
init|=
operator|new
name|BitSet
argument_list|(
name|nJoinFactors
argument_list|)
decl_stmt|;
name|getChildFactors
argument_list|(
name|joinTree
argument_list|,
name|childFactors
argument_list|)
expr_stmt|;
return|return
name|RelOptUtil
operator|.
name|contains
argument_list|(
name|childFactors
argument_list|,
name|factorsNeeded
argument_list|)
return|;
block|}
comment|/**      * Sets a bitmap representing all fields corresponding to a RelNode      *      * @param rel relnode for which fields will be set      * @param fields bitmap containing set bits for each field in a RelNode      */
specifier|public
name|void
name|setFieldBitmap
parameter_list|(
name|LoptJoinTree
name|rel
parameter_list|,
name|BitSet
name|fields
parameter_list|)
block|{
comment|// iterate through all factors within the RelNode
name|BitSet
name|factors
init|=
operator|new
name|BitSet
argument_list|(
name|nJoinFactors
argument_list|)
decl_stmt|;
name|getChildFactors
argument_list|(
name|rel
argument_list|,
name|factors
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|factor
init|=
name|factors
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|;
name|factor
operator|>=
literal|0
condition|;
name|factor
operator|=
name|factors
operator|.
name|nextSetBit
argument_list|(
name|factor
operator|+
literal|1
argument_list|)
control|)
block|{
comment|// set a bit for each field
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nFieldsInJoinFactor
index|[
name|factor
index|]
condition|;
name|i
operator|++
control|)
block|{
name|fields
operator|.
name|set
argument_list|(
name|joinStart
index|[
name|factor
index|]
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Sets a bitmap indicating all child RelNodes in a join tree      *      * @param joinTree join tree to be examined      * @param childFactors bitmap to be set      */
specifier|public
name|void
name|getChildFactors
parameter_list|(
name|LoptJoinTree
name|joinTree
parameter_list|,
name|BitSet
name|childFactors
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|joinTree
operator|.
name|getTreeOrder
argument_list|(
name|children
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|child
range|:
name|children
control|)
block|{
name|childFactors
operator|.
name|set
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Retrieves the fields corresponding to a join between a left and right      * tree      *      * @param left left hand side of the join      * @param right right hand side of the join      *      * @return fields of the join      */
specifier|public
name|RelDataTypeField
index|[]
name|getJoinFields
parameter_list|(
name|LoptJoinTree
name|left
parameter_list|,
name|LoptJoinTree
name|right
parameter_list|)
block|{
name|RelDataType
name|rowType
init|=
name|factory
operator|.
name|createJoinType
argument_list|(
operator|new
name|RelDataType
index|[]
block|{
name|left
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
block|,
name|right
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
block|}
argument_list|)
decl_stmt|;
return|return
name|rowType
operator|.
name|getFields
argument_list|()
return|;
block|}
comment|/**      * Adds a join factor to the set of factors that can be removed because the      * factor is the null generating factor in an outer join, its join keys are      * unique, and the factor is not projected in the query      *      * @param factIdx join factor      */
specifier|public
name|void
name|addRemovableOuterJoinFactor
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
name|removableOuterJoinFactors
operator|.
name|add
argument_list|(
name|factIdx
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param factIdx factor in question      *      * @return true if the factor corresponds to the null generating factor in      * an outer join that can be removed      */
specifier|public
name|boolean
name|isRemovableOuterJoinFactor
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|removableOuterJoinFactors
operator|.
name|contains
argument_list|(
name|factIdx
argument_list|)
return|;
block|}
comment|/**      * Adds to a map that keeps track of removable self-join pairs.      *      * @param factor1 one of the factors in the self-join      * @param factor2 the second factor in the self-join      */
specifier|public
name|void
name|addRemovableSelfJoinPair
parameter_list|(
name|int
name|factor1
parameter_list|,
name|int
name|factor2
parameter_list|)
block|{
name|int
name|leftFactor
decl_stmt|;
name|int
name|rightFactor
decl_stmt|;
comment|// Put the factor with more fields on the left so it will be
comment|// preserved after the self-join is removed.
if|if
condition|(
name|getNumFieldsInJoinFactor
argument_list|(
name|factor1
argument_list|)
operator|>
name|getNumFieldsInJoinFactor
argument_list|(
name|factor2
argument_list|)
condition|)
block|{
name|leftFactor
operator|=
name|factor1
expr_stmt|;
name|rightFactor
operator|=
name|factor2
expr_stmt|;
block|}
else|else
block|{
name|leftFactor
operator|=
name|factor2
expr_stmt|;
name|rightFactor
operator|=
name|factor1
expr_stmt|;
block|}
comment|// Compute a column mapping such that if a column from the right
comment|// factor is also referenced in the left factor, we will map the
comment|// right reference to the left to avoid redundant references.
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|columnMapping
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// First, locate the originating column for all simple column
comment|// references in the left factor.
name|RelNode
name|left
init|=
name|getJoinFactor
argument_list|(
name|leftFactor
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|leftFactorColMapping
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelColumnOrigin
name|colOrigin
init|=
name|LoptMetadataProvider
operator|.
name|getSimpleColumnOrigin
argument_list|(
name|left
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|colOrigin
operator|!=
literal|null
condition|)
block|{
name|leftFactorColMapping
operator|.
name|put
argument_list|(
name|colOrigin
operator|.
name|getOriginColumnOrdinal
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Then, see if the right factor references any of the same columns
comment|// by locating their originating columns.  If there are matches,
comment|// then we want to store the corresponding offset into the left
comment|// factor.
name|RelNode
name|right
init|=
name|getJoinFactor
argument_list|(
name|rightFactor
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|right
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelColumnOrigin
name|colOrigin
init|=
name|LoptMetadataProvider
operator|.
name|getSimpleColumnOrigin
argument_list|(
name|right
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|colOrigin
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|Integer
name|leftOffset
init|=
name|leftFactorColMapping
operator|.
name|get
argument_list|(
name|colOrigin
operator|.
name|getOriginColumnOrdinal
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftOffset
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|columnMapping
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|leftOffset
argument_list|)
expr_stmt|;
block|}
name|RemovableSelfJoin
name|selfJoin
init|=
operator|new
name|RemovableSelfJoin
argument_list|(
name|leftFactor
argument_list|,
name|rightFactor
argument_list|,
name|columnMapping
argument_list|)
decl_stmt|;
name|removableSelfJoinPairs
operator|.
name|put
argument_list|(
name|leftFactor
argument_list|,
name|selfJoin
argument_list|)
expr_stmt|;
name|removableSelfJoinPairs
operator|.
name|put
argument_list|(
name|rightFactor
argument_list|,
name|selfJoin
argument_list|)
expr_stmt|;
block|}
comment|/*      * @param factIdx one of the factors in a self-join pair      *      * @return the other factor in a self-join pair if the factor passed in is      * a factor in a removable self-join; otherwise, returns null      */
specifier|public
name|Integer
name|getOtherSelfJoinFactor
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
name|RemovableSelfJoin
name|selfJoin
init|=
name|removableSelfJoinPairs
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|selfJoin
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|else if
condition|(
name|selfJoin
operator|.
name|getRightFactor
argument_list|()
operator|==
name|factIdx
condition|)
block|{
return|return
name|selfJoin
operator|.
name|getLeftFactor
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|selfJoin
operator|.
name|getRightFactor
argument_list|()
return|;
block|}
block|}
comment|/**      * @param factIdx factor in a self-join      *      * @return true if the factor is the left factor in a self-join      */
specifier|public
name|boolean
name|isLeftFactorInRemovableSelfJoin
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
name|RemovableSelfJoin
name|selfJoin
init|=
name|removableSelfJoinPairs
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|selfJoin
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|(
name|selfJoin
operator|.
name|getLeftFactor
argument_list|()
operator|==
name|factIdx
operator|)
return|;
block|}
comment|/**      * @param factIdx factor in a self-join      *      * @return true if the factor is the right factor in a self-join      */
specifier|public
name|boolean
name|isRightFactorInRemovableSelfJoin
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
name|RemovableSelfJoin
name|selfJoin
init|=
name|removableSelfJoinPairs
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|selfJoin
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|(
name|selfJoin
operator|.
name|getRightFactor
argument_list|()
operator|==
name|factIdx
operator|)
return|;
block|}
comment|/**      * Determines whether there is a mapping from a column in the right factor      * of a self-join to a column from the left factor. Assumes that the right      * factor is a part of a self-join.      *      * @param rightFactor the index of the right factor      * @param rightOffset the column offset of the right factor      *      * @return the offset of the corresponding column in the left factor, if      * such a column mapping exists; otherwise, null is returned      */
specifier|public
name|Integer
name|getRightColumnMapping
parameter_list|(
name|int
name|rightFactor
parameter_list|,
name|int
name|rightOffset
parameter_list|)
block|{
name|RemovableSelfJoin
name|selfJoin
init|=
name|removableSelfJoinPairs
operator|.
name|get
argument_list|(
name|rightFactor
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|selfJoin
operator|.
name|getRightFactor
argument_list|()
operator|==
name|rightFactor
operator|)
assert|;
return|return
name|selfJoin
operator|.
name|getColumnMapping
argument_list|()
operator|.
name|get
argument_list|(
name|rightOffset
argument_list|)
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**      * Utility class used to keep track of the factors in a removable self-join.      * The right factor in the self-join is the one that will be removed.      */
specifier|private
class|class
name|RemovableSelfJoin
block|{
comment|/**          * The left factor in a removable self-join          */
specifier|private
name|int
name|leftFactor
decl_stmt|;
comment|/**          * The right factor in a removable self-join, namely the factor that          * will be removed          */
specifier|private
name|int
name|rightFactor
decl_stmt|;
comment|/**          * A mapping that maps references to columns from the right factor to          * columns in the left factor, if the column is referenced in both          * factors          */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|columnMapping
decl_stmt|;
name|RemovableSelfJoin
parameter_list|(
name|int
name|leftFactor
parameter_list|,
name|int
name|rightFactor
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|columnMapping
parameter_list|)
block|{
name|this
operator|.
name|leftFactor
operator|=
name|leftFactor
expr_stmt|;
name|this
operator|.
name|rightFactor
operator|=
name|rightFactor
expr_stmt|;
name|this
operator|.
name|columnMapping
operator|=
name|columnMapping
expr_stmt|;
block|}
specifier|public
name|int
name|getLeftFactor
parameter_list|()
block|{
return|return
name|leftFactor
return|;
block|}
specifier|public
name|int
name|getRightFactor
parameter_list|()
block|{
return|return
name|rightFactor
return|;
block|}
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|getColumnMapping
parameter_list|()
block|{
return|return
name|columnMapping
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End LoptMultiJoin.java
end_comment

end_unit

