begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * ArrayQueue is a queue implementation backed by an array. Grows by doubling  * the existing size, but never shrinks. Queue entries are allowed to wrap  * around array boundaries. ArrayQueue does not allow<code>null</code> entries.  *  *<p>Contains the necessary methods to implement JDK 1.5's Queue interface.  * Also, some methods can be removed by extending JDK 1.5's AbstractQueue class.  *  *<p>{@link #offer(Object) Offering} (adding) items to the queue, {@link  * #poll() polling} (removing) items from the queue, and {@link #peek() peeking}  * at the head of the queue are normally constant time operations. The exception  * is that growing the queue is an O(N) operation and can occur when offering an  * item to the queue.  *  *<p>The {@link Iterator} returned by {@link #iterator()} behaves somewhat  * inconsistently with the general contract of Iterator. Read the documentation  * for that method carefully.  */
end_comment

begin_class
specifier|public
class|class
name|ArrayQueue
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractCollection
argument_list|<
name|E
argument_list|>
implements|implements
name|Collection
argument_list|<
name|E
argument_list|>
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CAPACITY
init|=
literal|10
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|/**    * The current capacity (not size) of this queue. Equal to<code>{link    * #queue}.length</code>.    */
specifier|private
name|int
name|capacity
decl_stmt|;
comment|/**    * The queue contents. Treated as a circular buffer.    */
specifier|private
name|E
index|[]
name|queue
decl_stmt|;
comment|/**    * The current position of the head element of the queue.    */
specifier|private
name|int
name|start
decl_stmt|;
comment|/**    * The current position for the next element added to the queue.    */
specifier|private
name|int
name|end
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Constructs an empty ArrayQueue with the specified initial capacity.    *    * @param capacity the initial capacity of this queue    */
specifier|public
name|ArrayQueue
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
if|if
condition|(
name|capacity
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|this
operator|.
name|capacity
operator|=
name|capacity
expr_stmt|;
name|this
operator|.
name|queue
operator|=
operator|(
name|E
index|[]
operator|)
operator|new
name|Object
index|[
name|capacity
index|]
expr_stmt|;
name|this
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|end
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * Constructs an empty ArrayQueue with the default initial capacity of    * DEFAULT_CAPACITY.    */
specifier|public
name|ArrayQueue
parameter_list|()
block|{
name|this
argument_list|(
name|DEFAULT_CAPACITY
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an ArrayQueue with the given contents. The initial capacity of    * the queue is {@link #DEFAULT_CAPACITY 10} or {@link Collection#size()    * c.size()} whichever is larger. The queue is populated with the elements    * of<code>c</code> in the order in which<code>c</code>'s iterator returns    * them.    *    * @param c a collection to use as the default contents of the queue    * @throws NullPointerException if c or any of its elements are null    */
specifier|public
name|ArrayQueue
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|this
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|DEFAULT_CAPACITY
argument_list|,
name|c
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|addAll
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an ArrayQueue with the given contents and initial capacity. If    *<code>capacity</code> is smaller than {@link Collection#size() c.size()},    * the initial capacity will be<code>c.size()</code>. The queue is    * populated with the elements of<code>c</code> in the order in which    *<code>c</code>'s iterator returns them.    *    * @param capacity the initial capacity of this queue    * @param c        a collection to use as the default contents of the queue    * @throws NullPointerException if c or any of its elements are null    */
specifier|public
name|ArrayQueue
parameter_list|(
name|int
name|capacity
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|this
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|capacity
argument_list|,
name|c
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|addAll
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Inserts the specified element into this queue. The queue's capacity may    * grow as a result of this call.    *    * @param o the element to insert    * @return<code>false</code> if o is<code>null</code>, otherwise<code>    * true</code> since it's always possible to add an element to this queue.    */
specifier|public
name|boolean
name|offer
parameter_list|(
name|E
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|newEnd
init|=
name|increment
argument_list|(
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|newEnd
operator|==
name|start
condition|)
block|{
comment|// queue is full, allocate more space
name|grow
argument_list|()
expr_stmt|;
name|queue
index|[
name|end
index|]
operator|=
name|o
expr_stmt|;
name|end
operator|=
name|increment
argument_list|(
name|end
argument_list|)
expr_stmt|;
comment|// cannot assume end is the same after grow()
block|}
else|else
block|{
name|queue
index|[
name|end
index|]
operator|=
name|o
expr_stmt|;
name|end
operator|=
name|newEnd
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Retrieves, but does not remove the head of this queue, returning<code>    * null</code> if this queue is empty.    *    * @return the head of the queue or<code>null</code> if the queue is empty    */
specifier|public
name|E
name|peek
parameter_list|()
block|{
if|if
condition|(
name|start
operator|==
name|end
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|queue
index|[
name|start
index|]
return|;
block|}
comment|/**    * Retrieves and removes the head of this queue, returning<code>null</code>    * if this queue is empty.    *    * @return the head of the queue or<code>null</code> if the queue is empty    */
specifier|public
name|E
name|poll
parameter_list|()
block|{
if|if
condition|(
name|start
operator|==
name|end
condition|)
block|{
return|return
literal|null
return|;
block|}
name|E
name|result
init|=
name|queue
index|[
name|start
index|]
decl_stmt|;
name|queue
index|[
name|start
index|]
operator|=
literal|null
expr_stmt|;
comment|// Let the "result" be GCed as soon as possible
name|start
operator|=
name|increment
argument_list|(
name|start
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Returns the number of elements currently in the queue.    *    * @return the number of elements currently in the queue    */
specifier|public
name|int
name|size
parameter_list|()
block|{
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
return|return
operator|(
name|capacity
operator|-
name|start
operator|)
operator|+
name|end
return|;
block|}
else|else
block|{
return|return
name|end
operator|-
name|start
return|;
block|}
block|}
comment|/**    * Returns an iterator over the elements in the queue in proper sequence.    * The returned<code>Iterator</code> is a "weakly consistent" iterator. It    * will never throw<code>ConcurrentModificationException</code> and    * guarantees to traverse elements as they existed upon construction of the    * iterator, but will never reflect any modifications subsequent to    * construction.    *    * @return an iterator over the elements in this queue in proper order    */
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
name|E
index|[]
name|contents
init|=
operator|(
name|E
index|[]
operator|)
operator|new
name|Object
index|[
name|size
argument_list|()
index|]
decl_stmt|;
name|copyQueueToArray
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|contents
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/**    * Unsupported operation.    */
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**    * Unsupported operation.    */
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
name|c
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**    * Unsupported operation.    */
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**    * Grows the queue to twice the current capacity.    */
specifier|private
name|void
name|grow
parameter_list|()
block|{
name|int
name|size
init|=
name|size
argument_list|()
decl_stmt|;
name|int
name|largerCapacity
init|=
name|capacity
operator|*
literal|2
decl_stmt|;
name|E
index|[]
name|largerQueue
init|=
operator|(
name|E
index|[]
operator|)
operator|new
name|Object
index|[
name|largerCapacity
index|]
decl_stmt|;
name|copyQueueToArray
argument_list|(
name|largerQueue
argument_list|)
expr_stmt|;
name|queue
operator|=
name|largerQueue
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|size
expr_stmt|;
name|capacity
operator|=
name|largerCapacity
expr_stmt|;
block|}
comment|/**    * Compares two queues for equality. The queues are not modified by this    * method. Concurrent modification of either this queue or the one being    * compared to has undefined results. Each element, in the proper order,    * must match in the two queues using the elements'<code>equals</code>    * method.    *    * @param o the queue to compare this queue to    * @return true if the queues have the same elements in the same order,    * false otherwise    * @throws ClassCastException if<code>o</code> is not an ArrayQueue.    */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|ArrayQueue
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ArrayQueue
argument_list|<
name|E
argument_list|>
name|oq
init|=
operator|(
name|ArrayQueue
argument_list|<
name|E
argument_list|>
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|!=
name|oq
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|s
init|=
name|start
decl_stmt|;
name|int
name|os
init|=
name|oq
operator|.
name|start
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|!=
name|end
operator|)
operator|&&
operator|(
name|os
operator|!=
name|oq
operator|.
name|end
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|queue
index|[
name|s
index|]
operator|.
name|equals
argument_list|(
name|oq
operator|.
name|queue
index|[
name|os
index|]
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|s
operator|=
name|increment
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|os
operator|=
name|oq
operator|.
name|increment
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Copies the contents of the queue into an array. The elements are copied    * such that the first element of the queue ends up in<code>    * otherQueue[0]</code>. Elements are copied in order.    *    * @param otherQueue the array to copy data into,<code>    *                   otherQueue.length</code> must be greater than or equal to {@link    *                   #size()}.    */
specifier|private
name|void
name|copyQueueToArray
parameter_list|(
name|E
index|[]
name|otherQueue
parameter_list|)
block|{
assert|assert
name|otherQueue
operator|.
name|length
operator|>=
name|size
argument_list|()
assert|;
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|queue
argument_list|,
name|start
argument_list|,
name|otherQueue
argument_list|,
literal|0
argument_list|,
name|capacity
operator|-
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|queue
argument_list|,
literal|0
argument_list|,
name|otherQueue
argument_list|,
name|capacity
operator|-
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|queue
argument_list|,
name|start
argument_list|,
name|otherQueue
argument_list|,
literal|0
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Increments the given index by one modulo the queue's capacity.    *    * @param index the index value to increment    * @return the index mod {@link #capacity}    */
specifier|private
name|int
name|increment
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|capacity
condition|)
block|{
name|index
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
comment|/**    * Adds the specified element to this queue. This implementation returns    * true if offer succeeds, else throws an IllegalStateException.    *    * @param o the element    * @return true (as per the general contract of {@link    * Collection#add(Object)}).    * @throws NullPointerException  if o is<code>null</code>    * @throws IllegalStateException if the call to {@link #offer(Object)} fails    */
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
if|if
condition|(
name|offer
argument_list|(
name|o
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
comment|/**    * Adds all of the elements in the specified collection to this queue.    * Attempts to addAll of a queue to itself result in    * IllegalArgumentException. Further, the behavior of this operation is    * undefined if the specified collection is modified while the operation is    * in progress.    *    *<p>This implementation iterates over the specified collection, and adds    * each element returned by the iterator to this collection, in turn. A    * runtime exception encountered while trying to add an element (including,    * in particular, a<code>null</code> element) may result in only some of    * the elements having been successfully added when the associated exception    * is thrown.    *    * @param c collection to add to the queue    * @return true if this queue changed as a result of the call    * @throws IllegalArgumentException if<code>this == c</code>    * @throws NullPointerException     if<code>c</code> or any of its elements are    *<code>null</code>.    * @throws IllegalStateException    if the call to {@link #add(Object)} does    */
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
name|this
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|boolean
name|result
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|i
init|=
name|c
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|result
operator|=
name|add
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Removes all elements from the queue. The queue will be empty and contain    * no references to its previous contents after this call returns. This    * method calls {@link #poll()} repeatedly until it returns<code>    * null</code>.    */
specifier|public
name|void
name|clear
parameter_list|()
block|{
while|while
condition|(
name|poll
argument_list|()
operator|!=
literal|null
condition|)
block|{
empty_stmt|;
block|}
block|}
comment|/**    * Retrieves, but does not remove, the head of the queue. Returns the result    * of {@link #peek()} unless the queue is empty.    *    * @return the head of this queue    * @throws NoSuchElementException if the queue is empty    */
specifier|public
name|Object
name|element
parameter_list|()
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
return|return
name|peek
argument_list|()
return|;
block|}
comment|/**    * Retrieves and removes the head of the queue. Returns the result of {@link    * #poll()} unless the queue is empty.    *    * @return the head of the queue    * @throws NoSuchElementException if the queue is empty    */
specifier|public
name|E
name|remove
parameter_list|()
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
return|return
name|poll
argument_list|()
return|;
block|}
block|}
end_class

begin_comment
comment|// End ArrayQueue.java
end_comment

end_unit

