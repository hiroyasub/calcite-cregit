begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Toolkit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|Iterable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|validate
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_comment
comment|/**  * Miscellaneous utility functions.  */
end_comment

begin_class
specifier|public
class|class
name|Util
block|{
comment|//~ Static fields/initializers ---------------------------------------------
comment|/**      * Name of the system property that controls whether the AWT work-around is      * enabled. This workaround allows Farrago to load its native libraries      * despite a conflict with AWT and allows applications that use AWT to      * function normally.      *      * @see #loadLibrary(String)      */
specifier|public
specifier|static
specifier|final
name|String
name|awtWorkaroundProperty
init|=
literal|"org.eigenbase.util.AWT_WORKAROUND"
decl_stmt|;
comment|/**      * System-dependent newline character.      */
specifier|public
specifier|static
specifier|final
name|String
name|lineSeparator
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
comment|/**      * System-dependent file separator, for example, "/" or "\."      */
specifier|public
specifier|static
specifier|final
name|String
name|fileSeparator
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
decl_stmt|;
comment|/**      * Datetime format string for generating a timestamp string to be used as      * part of a filename. Conforms to SimpleDateFormat conventions.      */
specifier|public
specifier|static
specifier|final
name|String
name|fileTimestampFormat
init|=
literal|"yyyy-MM-dd_HH_mm_ss"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Object
index|[]
name|emptyObjectArray
init|=
operator|new
name|Object
index|[
literal|0
index|]
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|emptyStringArray
init|=
operator|new
name|String
index|[
literal|0
index|]
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlMoniker
index|[]
name|emptySqlMonikerArray
init|=
operator|new
name|SqlMoniker
index|[
literal|0
index|]
decl_stmt|;
specifier|private
specifier|static
name|boolean
name|driversLoaded
init|=
literal|false
decl_stmt|;
comment|/**      * Regular expression for a valid java identifier which contains no      * underscores and can therefore be returned intact by {@link #toJavaId}.      */
specifier|private
specifier|static
specifier|final
name|Pattern
name|javaIdPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[a-zA-Z_$][a-zA-Z0-9$]*"
argument_list|)
decl_stmt|;
comment|/**      * @see #loadLibrary(String)      */
specifier|private
specifier|static
name|Toolkit
name|awtToolkit
decl_stmt|;
comment|/**      * Maps classes to the map of their enum values. Uses a weak map so that      * classes are not prevented from being unloaded.      */
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Class
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
extends|extends
name|Enum
argument_list|>
argument_list|>
name|mapClazzToMapNameToEnum
init|=
operator|new
name|WeakHashMap
argument_list|<
name|Class
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
extends|extends
name|Enum
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|spaces
init|=
block|{
literal|""
block|,
literal|" "
block|,
literal|"  "
block|,
literal|"   "
block|,
literal|"    "
block|,
literal|"     "
block|,
literal|"      "
block|,
literal|"       "
block|,
literal|"        "
block|,             }
decl_stmt|;
comment|//~ Methods ----------------------------------------------------------------
comment|/**      * Does nothing with its argument. Call this method when you have a value      * you are not interested in, but you don't want the compiler to warn that      * you are not using it.      */
specifier|public
specifier|static
specifier|final
name|void
name|discard
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
name|discard
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Does nothing with its argument. Call this method when you have a value      * you are not interested in, but you don't want the compiler to warn that      * you are not using it.      */
specifier|public
specifier|static
specifier|final
name|void
name|discard
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
name|discard
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Does nothing with its argument. Call this method when you have a value      * you are not interested in, but you don't want the compiler to warn that      * you are not using it.      */
specifier|public
specifier|static
specifier|final
name|void
name|discard
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
name|discard
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Does nothing with its argument. Call this method when you have a value      * you are not interested in, but you don't want the compiler to warn that      * you are not using it.      */
specifier|public
specifier|static
specifier|final
name|void
name|discard
parameter_list|(
name|double
name|d
parameter_list|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
name|discard
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Records that an exception has been caught but will not be re-thrown. If      * the tracer is not null, logs the exception to the tracer.      *      * @param e Exception      * @param logger If not null, logs exception to this logger      */
specifier|public
specifier|static
specifier|final
name|void
name|swallow
parameter_list|(
name|Throwable
name|e
parameter_list|,
name|Logger
name|logger
parameter_list|)
block|{
if|if
condition|(
name|logger
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINER
argument_list|,
literal|"Discarding exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns whether two objects are equal or are both null.      */
specifier|public
specifier|static
specifier|final
name|boolean
name|equal
parameter_list|(
name|Object
name|s0
parameter_list|,
name|Object
name|s1
parameter_list|)
block|{
if|if
condition|(
name|s0
operator|==
name|s1
condition|)
block|{
return|return
literal|true
return|;
block|}
if|else if
condition|(
name|s0
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|s0
operator|.
name|equals
argument_list|(
name|s1
argument_list|)
return|;
block|}
block|}
comment|/**      * Returns a sub-list from a given position to the end.      */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|subList
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|fromIndex
parameter_list|)
block|{
return|return
name|list
operator|.
name|subList
argument_list|(
name|fromIndex
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns whether two lists are equal to each other using shallow      * comparisons.      *      * @param list0 First list      * @param list1 Second list      * @return Whether lists are same length and all of their elements are      *   equal using {@code ==} (may be null).      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|equalShallow
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|list0
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|list1
parameter_list|)
block|{
if|if
condition|(
name|list0
operator|.
name|size
argument_list|()
operator|!=
name|list1
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list0
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list0
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
name|list1
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Combines two integers into a hash code.      */
specifier|public
specifier|static
name|int
name|hash
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
return|return
operator|(
name|i
operator|<<
literal|4
operator|)
operator|^
name|j
return|;
block|}
comment|/**      * Computes a hash code from an existing hash code and an object (which may      * be null).      */
specifier|public
specifier|static
name|int
name|hash
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
name|int
name|k
init|=
operator|(
name|o
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|o
operator|.
name|hashCode
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|h
operator|<<
literal|4
operator|)
operator||
name|h
operator|)
operator|^
name|k
return|;
block|}
comment|/**      * Computes a hash code from an existing hash code and an array of objects      * (which may be null).      */
specifier|public
specifier|static
name|int
name|hashArray
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
index|[]
name|a
parameter_list|)
block|{
comment|// The hashcode for a null array and an empty array should be different
comment|// than h, so use magic numbers.
if|if
condition|(
name|a
operator|==
literal|null
condition|)
block|{
return|return
name|hash
argument_list|(
name|h
argument_list|,
literal|19690429
argument_list|)
return|;
block|}
if|if
condition|(
name|a
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|hash
argument_list|(
name|h
argument_list|,
literal|19690721
argument_list|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|a
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|h
operator|=
name|hash
argument_list|(
name|h
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
comment|/**      * Computes a hash code over var args.      */
specifier|public
specifier|static
name|int
name|hashV
parameter_list|(
name|Object
modifier|...
name|a
parameter_list|)
block|{
name|int
name|h
init|=
literal|19690721
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|a
control|)
block|{
name|h
operator|=
name|hash
argument_list|(
name|h
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
comment|/**      * Returns a set of the elements which are in<code>set1</code> but not in      *<code>set2</code>, without modifying either.      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|T
argument_list|>
name|minus
parameter_list|(
name|Set
argument_list|<
name|T
argument_list|>
name|set1
parameter_list|,
name|Set
argument_list|<
name|T
argument_list|>
name|set2
parameter_list|)
block|{
if|if
condition|(
name|set1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|set1
return|;
block|}
if|else if
condition|(
name|set2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|set1
return|;
block|}
else|else
block|{
name|Set
argument_list|<
name|T
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|T
argument_list|>
argument_list|(
name|set1
argument_list|)
decl_stmt|;
name|set
operator|.
name|removeAll
argument_list|(
name|set2
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
block|}
comment|/**      * Computes<code>nlogn(n)</code> using the natural logarithm (or<code>      * n</code> if<code>n<{@link Math#E}</code>, so the result is never      * negative.      */
specifier|public
specifier|static
name|double
name|nLogN
parameter_list|(
name|double
name|d
parameter_list|)
block|{
return|return
operator|(
name|d
operator|<
name|Math
operator|.
name|E
operator|)
condition|?
name|d
else|:
operator|(
name|d
operator|*
name|Math
operator|.
name|log
argument_list|(
name|d
argument_list|)
operator|)
return|;
block|}
comment|/**      * Prints an object using reflection. We can handle<code>null</code>;      * arrays of objects and primitive values; for regular objects, we print all      * public fields.      */
specifier|public
specifier|static
name|void
name|print
parameter_list|(
name|PrintWriter
name|pw
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
name|print
argument_list|(
name|pw
argument_list|,
name|o
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|print
parameter_list|(
name|PrintWriter
name|pw
parameter_list|,
name|Object
name|o
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Class
name|clazz
init|=
name|o
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|String
condition|)
block|{
name|printJavaString
argument_list|(
name|pw
argument_list|,
operator|(
name|String
operator|)
name|o
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|clazz
operator|==
name|Integer
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Boolean
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Character
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Byte
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Short
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Long
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Float
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Double
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Void
operator|.
name|class
operator|)
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|clazz
operator|.
name|isArray
argument_list|()
condition|)
block|{
comment|// o is an array, but we can't cast to Object[] because it may be
comment|// an array of primitives.
name|Object
index|[]
name|a
decl_stmt|;
comment|// for debug
if|if
condition|(
name|o
operator|instanceof
name|Object
index|[]
condition|)
block|{
name|a
operator|=
operator|(
name|Object
index|[]
operator|)
name|o
expr_stmt|;
name|discard
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|int
name|n
init|=
name|Array
operator|.
name|getLength
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|indent
condition|;
name|j
operator|++
control|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
name|print
argument_list|(
name|pw
argument_list|,
name|Array
operator|.
name|get
argument_list|(
name|o
argument_list|,
name|i
argument_list|)
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|o
operator|instanceof
name|Iterator
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
name|iter
init|=
operator|(
name|Iterator
operator|)
name|o
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" {"
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|print
argument_list|(
name|pw
argument_list|,
name|iter
operator|.
name|next
argument_list|()
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|o
operator|instanceof
name|Enumeration
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Enumeration
name|e
init|=
operator|(
name|Enumeration
operator|)
name|o
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" {"
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|print
argument_list|(
name|pw
argument_list|,
name|e
operator|.
name|nextElement
argument_list|()
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pw
operator|.
name|print
argument_list|(
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" {"
argument_list|)
expr_stmt|;
name|Field
index|[]
name|fields
init|=
name|clazz
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|int
name|printed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isStatic
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|printed
operator|++
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|indent
condition|;
name|j
operator|++
control|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
name|fields
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
name|Object
name|val
init|=
literal|null
decl_stmt|;
try|try
block|{
name|val
operator|=
name|fields
index|[
name|i
index|]
operator|.
name|get
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
name|newInternal
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|print
argument_list|(
name|pw
argument_list|,
name|val
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Prints a string, enclosing in double quotes (") and escaping if      * necessary. For examples,<code>printDoubleQuoted(w,"x\"y",false)</code>      * prints<code>"x\"y"</code>.      */
specifier|public
specifier|static
specifier|final
name|void
name|printJavaString
parameter_list|(
name|PrintWriter
name|pw
parameter_list|,
name|String
name|s
parameter_list|,
name|boolean
name|nullMeansNull
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|nullMeansNull
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//pw.print("");
block|}
block|}
else|else
block|{
name|String
name|s1
init|=
name|replace
argument_list|(
name|s
argument_list|,
literal|"\\"
argument_list|,
literal|"\\\\"
argument_list|)
decl_stmt|;
name|String
name|s2
init|=
name|replace
argument_list|(
name|s1
argument_list|,
literal|"\""
argument_list|,
literal|"\\\""
argument_list|)
decl_stmt|;
name|String
name|s3
init|=
name|replace
argument_list|(
name|s2
argument_list|,
literal|"\n\r"
argument_list|,
literal|"\\n"
argument_list|)
decl_stmt|;
name|String
name|s4
init|=
name|replace
argument_list|(
name|s3
argument_list|,
literal|"\n"
argument_list|,
literal|"\\n"
argument_list|)
decl_stmt|;
name|String
name|s5
init|=
name|replace
argument_list|(
name|s4
argument_list|,
literal|"\r"
argument_list|,
literal|"\\r"
argument_list|)
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|s5
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|void
name|println
parameter_list|(
name|PrintWriter
name|pw
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
name|print
argument_list|(
name|pw
argument_list|,
name|o
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|/**      * Formats a {@link BigDecimal} value to a string in scientific notation For      * example<br>      *      *<ul>      *<li>A value of 0.00001234 would be formated as<code>1.234E-5</code></li>      *<li>A value of 100000.00 would be formated as<code>1.00E5</code></li>      *<li>A value of 100 (scale zero) would be formated as<code>      * 1E2</code></li><br>      * If<code>bd</code> has a precision higher than 20, this method will      * truncate the output string to have a precision of 20 (no rounding will be      * done, just a truncate).      */
specifier|public
specifier|static
name|String
name|toScientificNotation
parameter_list|(
name|BigDecimal
name|bd
parameter_list|)
block|{
specifier|final
name|int
name|truncateAt
init|=
literal|20
decl_stmt|;
name|String
name|unscaled
init|=
name|bd
operator|.
name|unscaledValue
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|bd
operator|.
name|signum
argument_list|()
operator|<
literal|0
condition|)
block|{
name|unscaled
operator|=
name|unscaled
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|len
init|=
name|unscaled
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|scale
init|=
name|bd
operator|.
name|scale
argument_list|()
decl_stmt|;
name|int
name|e
init|=
name|len
operator|-
name|scale
operator|-
literal|1
decl_stmt|;
name|StringBuilder
name|ret
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|bd
operator|.
name|signum
argument_list|()
operator|<
literal|0
condition|)
block|{
name|ret
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
comment|// do truncation
name|unscaled
operator|=
name|unscaled
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|truncateAt
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|unscaled
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
comment|// trim trailing zeroes since they aren't significant
name|int
name|i
init|=
name|unscaled
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|unscaled
operator|.
name|charAt
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|!=
literal|'0'
condition|)
block|{
break|break;
block|}
operator|--
name|i
expr_stmt|;
block|}
name|unscaled
operator|=
name|unscaled
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unscaled
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ret
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|unscaled
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|.
name|append
argument_list|(
literal|"E"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|ret
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Replaces every occurrence of<code>find</code> in<code>s</code> with      *<code>replace</code>.      */
specifier|public
specifier|static
specifier|final
name|String
name|replace
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|find
parameter_list|,
name|String
name|replace
parameter_list|)
block|{
comment|// let's be optimistic
name|int
name|found
init|=
name|s
operator|.
name|indexOf
argument_list|(
name|find
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|s
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|s
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
name|start
operator|<
name|found
condition|;
name|start
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
name|replace
argument_list|)
expr_stmt|;
name|start
operator|+=
name|find
operator|.
name|length
argument_list|()
expr_stmt|;
name|found
operator|=
name|s
operator|.
name|indexOf
argument_list|(
name|find
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
operator|-
literal|1
condition|)
block|{
name|found
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Creates a file-protocol URL for the given file.      */
specifier|public
specifier|static
name|URL
name|toURL
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|MalformedURLException
block|{
name|String
name|path
init|=
name|file
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
comment|// This is a bunch of weird code that is required to
comment|// make a valid URL on the Windows platform, due
comment|// to inconsistencies in what getAbsolutePath returns.
name|String
name|fs
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|)
block|{
name|char
name|sep
init|=
name|fs
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|'/'
condition|)
block|{
name|path
operator|=
name|path
operator|.
name|replace
argument_list|(
name|sep
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'/'
condition|)
block|{
name|path
operator|=
literal|'/'
operator|+
name|path
expr_stmt|;
block|}
block|}
name|path
operator|=
literal|"file://"
operator|+
name|path
expr_stmt|;
return|return
operator|new
name|URL
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/**      * Gets a timestamp string for use in file names. The generated timestamp      * string reflects the current time.      */
specifier|public
specifier|static
name|String
name|getFileTimestamp
parameter_list|()
block|{
name|SimpleDateFormat
name|sdf
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|fileTimestampFormat
argument_list|)
decl_stmt|;
return|return
name|sdf
operator|.
name|format
argument_list|(
operator|new
name|java
operator|.
name|util
operator|.
name|Date
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Converts double-quoted Java strings to their contents. For example,      *<code>"foo\"bar"</code> becomes<code>foo"bar</code>.      */
specifier|public
specifier|static
name|String
name|stripDoubleQuotes
parameter_list|(
name|String
name|value
parameter_list|)
block|{
assert|assert
operator|(
name|value
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'"'
operator|)
assert|;
assert|assert
operator|(
name|value
operator|.
name|charAt
argument_list|(
name|value
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'"'
operator|)
assert|;
name|String
name|s5
init|=
name|value
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|value
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|String
name|s4
init|=
name|Util
operator|.
name|replace
argument_list|(
name|s5
argument_list|,
literal|"\\r"
argument_list|,
literal|"\r"
argument_list|)
decl_stmt|;
name|String
name|s3
init|=
name|Util
operator|.
name|replace
argument_list|(
name|s4
argument_list|,
literal|"\\n"
argument_list|,
literal|"\n"
argument_list|)
decl_stmt|;
name|String
name|s2
init|=
name|Util
operator|.
name|replace
argument_list|(
name|s3
argument_list|,
literal|"\\\""
argument_list|,
literal|"\""
argument_list|)
decl_stmt|;
name|String
name|s1
init|=
name|Util
operator|.
name|replace
argument_list|(
name|s2
argument_list|,
literal|"\\\\"
argument_list|,
literal|"\\"
argument_list|)
decl_stmt|;
return|return
name|s1
return|;
block|}
comment|/**      * Converts an arbitrary string into a string suitable for use as a Java      * identifier.      *      *<p>The mapping is one-to-one (that is, distinct strings will produce      * distinct java identifiers). The mapping is also reversible, but the      * inverse mapping is not implemented.</p>      *      *<p>A valid Java identifier must start with a Unicode letter, underscore,      * or dollar sign ($). The other characters, if any, can be a Unicode      * letter, underscore, dollar sign, or digit.</p>      *      *<p>This method uses an algorithm similar to URL encoding. Valid      * characters are unchanged; invalid characters are converted to an      * underscore followed by the hex code of the character; and underscores are      * doubled.</p>      *      * Examples:      *      *<ul>      *<li><code>toJavaId("foo")</code> returns<code>"foo"</code>      *<li><code>toJavaId("foo bar")</code> returns<code>"foo_20_bar"</code>      *<li><code>toJavaId("foo_bar")</code> returns<code>"foo__bar"</code>      *<li><code>toJavaId("0bar")</code> returns<code>"_40_bar"</code> (digits      * are illegal as a prefix)      *<li><code>toJavaId("foo0bar")</code> returns<code>"foo0bar"</code>      *</ul>      *      * @testcase      */
specifier|public
specifier|static
name|String
name|toJavaId
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
comment|// If it's already a valid Java id (and doesn't contain any
comment|// underscores), return it unchanged.
if|if
condition|(
name|javaIdPattern
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
comment|// prepend "ID$" to string so it doesn't clash with java keywords
return|return
literal|"ID$"
operator|+
name|ordinal
operator|+
literal|"$"
operator|+
name|s
return|;
block|}
comment|// Escape underscores and other undesirables.
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|s
operator|.
name|length
argument_list|()
operator|+
literal|10
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"ID$"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|ordinal
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"__"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|c
operator|<
literal|0x7F
operator|)
comment|/* Normal ascii character */
operator|&&
operator|!
name|Character
operator|.
name|isISOControl
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|Character
operator|.
name|isJavaIdentifierStart
argument_list|(
name|c
argument_list|)
else|:
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|c
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Materializes the results of a {@link java.util.Iterator} as a {@link      * java.util.List}.      *      * @param iter iterator to materialize      *      * @return materialized list      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|toList
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iter
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
specifier|static
name|boolean
name|isStatic
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Member
name|member
parameter_list|)
block|{
name|int
name|modifiers
init|=
name|member
operator|.
name|getModifiers
argument_list|()
decl_stmt|;
return|return
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isStatic
argument_list|(
name|modifiers
argument_list|)
return|;
block|}
comment|/**      * @return true if s==null or if s.length()==0      */
specifier|public
specifier|static
name|boolean
name|isNullOrEmpty
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
operator|(
literal|null
operator|==
name|s
operator|)
operator|||
operator|(
name|s
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
return|;
block|}
comment|/**      * Converts a list of a string, with commas between elements.      *      * For example,      *<code>commaList(Arrays.asList({"a", "b"}))</code>      * returns "a, b".      *      * @param list List      * @return String representation of string      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|String
name|commaList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|k
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|list
control|)
block|{
if|if
condition|(
operator|++
name|k
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Returns the connect string with which to connect to the 'Sales' test      * database. In the process, it loads the necessary drivers.      */
specifier|public
specifier|static
name|String
name|getSalesConnectString
parameter_list|()
block|{
name|loadDrivers
argument_list|()
expr_stmt|;
return|return
name|SaffronProperties
operator|.
name|instance
argument_list|()
operator|.
name|testJdbcUrl
operator|.
name|get
argument_list|()
return|;
block|}
specifier|private
specifier|static
specifier|synchronized
name|void
name|loadDrivers
parameter_list|()
block|{
if|if
condition|(
name|driversLoaded
condition|)
block|{
return|return;
block|}
name|String
name|jdbcDrivers
init|=
name|SaffronProperties
operator|.
name|instance
argument_list|()
operator|.
name|testJdbcDrivers
operator|.
name|get
argument_list|()
decl_stmt|;
name|StringTokenizer
name|tok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|jdbcDrivers
argument_list|,
literal|","
argument_list|)
decl_stmt|;
while|while
condition|(
name|tok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|jdbcDriver
init|=
name|tok
operator|.
name|nextToken
argument_list|()
decl_stmt|;
try|try
block|{
name|Class
operator|.
name|forName
argument_list|(
name|jdbcDriver
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Warning: could not find driver "
operator|+
name|jdbcDriver
argument_list|)
expr_stmt|;
block|}
block|}
name|driversLoaded
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Returns the {@link Charset} object representing the value of {@link      * SaffronProperties#defaultCharset}      *      * @throws java.nio.charset.IllegalCharsetNameException If the given charset      * name is illegal      * @throws java.nio.charset.UnsupportedCharsetException If no support for      * the named charset is available in this instance of the Java virtual      * machine      */
specifier|public
specifier|static
name|Charset
name|getDefaultCharset
parameter_list|()
block|{
return|return
name|Charset
operator|.
name|forName
argument_list|(
name|SaffronProperties
operator|.
name|instance
argument_list|()
operator|.
name|defaultCharset
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|()
block|{
return|return
name|newInternal
argument_list|(
literal|"(unknown cause)"
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
operator|new
name|AssertionError
argument_list|(
literal|"Internal error: "
operator|+
name|s
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
return|return
name|newInternal
argument_list|(
name|e
argument_list|,
literal|"(unknown cause)"
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|(
name|Throwable
name|e
parameter_list|,
name|String
name|s
parameter_list|)
block|{
name|String
name|message
init|=
literal|"Internal error: "
operator|+
name|s
decl_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
comment|// TODO re-enable this code when we're no longer throwing spurious
comment|//   internal errors (which should be parse errors, for example)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
name|AssertionError
name|ae
init|=
operator|new
name|AssertionError
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|ae
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|ae
return|;
block|}
comment|/**      * Retrieves messages in a exception and writes them to a string. In the      * string returned, each message will appear on a different line.      *      * @return a non-null string containing all messages of the exception      */
specifier|public
specifier|static
name|String
name|getMessages
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Throwable
name|curr
init|=
name|t
init|;
name|curr
operator|!=
literal|null
condition|;
name|curr
operator|=
name|curr
operator|.
name|getCause
argument_list|()
control|)
block|{
name|String
name|msg
init|=
operator|(
operator|(
name|curr
operator|instanceof
name|EigenbaseException
operator|)
operator|||
operator|(
name|curr
operator|instanceof
name|SQLException
operator|)
operator|)
condition|?
name|curr
operator|.
name|getMessage
argument_list|()
else|:
name|curr
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Returns the stack trace of a throwable. Called from native code.      *      * @param t Throwable      *      * @return Stack trace      */
specifier|public
specifier|static
name|String
name|getStackTrace
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
specifier|final
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|t
operator|.
name|printStackTrace
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Checks a pre-condition.      *      *<p>For example,      *      *<pre>      * /**      *   * @ pre x != 0      *   * /      * void foo(int x) {      *     Util.pre(x != 0, "x != 0");      * }</pre>      *      * @param b Result of evaluating the pre-condition.      * @param description Description of the pre-condition.      */
specifier|public
specifier|static
name|void
name|pre
parameter_list|(
name|boolean
name|b
parameter_list|,
name|String
name|description
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
block|{
throw|throw
name|newInternal
argument_list|(
literal|"pre-condition failed: "
operator|+
name|description
argument_list|)
throw|;
block|}
block|}
comment|/**      * Checks a post-condition.      *      *<p>For example,      *      *<pre>      * /**      *   * @ post return != 0      *   * /      * void foo(int x) {      *     int res = bar(x);      *     Util.post(res != 0, "return != 0");      * }</pre>      *      * @param b Result of evaluating the pre-condition.      * @param description Description of the pre-condition.      */
specifier|public
specifier|static
name|void
name|post
parameter_list|(
name|boolean
name|b
parameter_list|,
name|String
name|description
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
block|{
throw|throw
name|newInternal
argument_list|(
literal|"post-condition failed: "
operator|+
name|description
argument_list|)
throw|;
block|}
block|}
comment|/**      * Checks an invariant.      *      *<p>This is similar to<code>assert</code> keyword, except that the      * condition is always evaluated even if asserts are disabled.      */
specifier|public
specifier|static
name|void
name|permAssert
parameter_list|(
name|boolean
name|b
parameter_list|,
name|String
name|description
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
block|{
throw|throw
name|newInternal
argument_list|(
literal|"invariant violated: "
operator|+
name|description
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a {@link java.lang.RuntimeException} indicating that a particular      * feature has not been implemented, but should be.      *      *<p>If every 'hole' in our functionality uses this method, it will be      * easier for us to identity the holes. Throwing a {@link      * java.lang.UnsupportedOperationException} isn't as good, because sometimes      * we actually want to partially implement an API.      *      *<p>Example usage:      *      *<blockquote>      *<pre><code>class MyVisitor extends BaseVisitor {      *     void accept(Foo foo) {      *         // Exception will identify which subclass forgot to override      *         // this method      *         throw Util.needToImplement(this);      *     }      * }</pre>      *</blockquote>      *      * @param o The object which was the target of the call, or null. Passing      * the object gives crucial information if a method needs to be overridden      * and a subclass forgot to do so.      *      * @return an {@link UnsupportedOperationException}.      */
specifier|public
specifier|static
name|RuntimeException
name|needToImplement
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|String
name|description
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|description
operator|=
name|o
operator|.
name|getClass
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|o
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|description
argument_list|)
throw|;
block|}
comment|/**      * Flags a piece of code as needing to be cleaned up before you check in.      *      *<p>Introduce a call to this method to indicate that a piece of code, or a      * javadoc comment, needs work before you check in. If you have an IDE which      * can easily trace references, this is an easy way to maintain a to-do      * list.      *      *<p><strong>Checked-in code must never call this method</strong>: you must      * remove all calls/references to this method before you check in.      *      *<p>The<code>argument</code> has generic type and determines the type of      * the result. This allows you to use the method inside an expression, for      * example      *      *<blockquote>      *<pre><code>int x = Util.deprecated(0, false);</code></pre>      *</blockquote>      *      * but the usual usage is to pass in a descriptive string.      *      *<h3>Examples</h3>      *      *<h4>Example #1: Using<code>deprecated</code> to fail if a piece of      * supposedly dead code is reached</h4>      *      *<blockquote>      *<pre><code>void foo(int x) {      *     if (x&lt; 0) {      *         // If this code is executed, an error will be thrown.      *         Util.deprecated(      *             "no longer need to handle negative numbers", true);      *         bar(x);      *     } else {      *         baz(x);      *     }      * }</code></pre>      *</blockquote>      *      *<h4>Example #2: Using<code>deprecated</code> to comment out dead      * code</h4>      *      *<blockquote>      *<pre>if (Util.deprecated(false, false)) {      *     // This code will not be executed, but an error will not be thrown.      *     baz();      * }</pre>      *</blockquote>      *      * @param argument Arbitrary argument to the method.      * @param fail Whether to throw an exception if this method is called      *      * @return The value of the<code>argument</code>.      *      * @deprecated If a piece of code calls this method, it indicates that the      * code needs to be cleaned up.      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|deprecated
parameter_list|(
name|T
name|argument
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
if|if
condition|(
name|fail
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
return|return
name|argument
return|;
block|}
comment|/**      * Uses {@link System#loadLibrary(String)} to load a native library      * correctly under mingw (Windows/Cygwin) and Linux environments.      *      *<p>This method also implements a work-around for applications that wish      * to load AWT. AWT conflicts with some native libraries in a way that      * requires AWT to be loaded first. This method checks the system property      * named {@link #awtWorkaroundProperty} and if it is set to "on" (default;      * case-insensitive) it pre-loads AWT to avoid the conflict.      *      * @param libName the name of the library to load, as in {@link      * System#loadLibrary(String)}.      */
specifier|public
specifier|static
name|void
name|loadLibrary
parameter_list|(
name|String
name|libName
parameter_list|)
block|{
name|String
name|awtSetting
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|awtWorkaroundProperty
argument_list|,
literal|"on"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|awtToolkit
operator|==
literal|null
operator|)
operator|&&
name|awtSetting
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"on"
argument_list|)
condition|)
block|{
comment|// REVIEW jvs 8-Sept-2006:  workaround upon workaround.  This
comment|// is required because in native code, we sometimes (see Farrago)
comment|// have to use dlopen("libfoo.so", RTLD_GLOBAL) in order for native
comment|// plugins to load correctly.  But the RTLD_GLOBAL causes trouble
comment|// later if someone tries to use AWT from within the same JVM.
comment|// So... preload AWT here unless someone configured explicitly
comment|// not to do so.
try|try
block|{
name|awtToolkit
operator|=
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|// Suppress problems so that a headless server doesn't fail on
comment|// startup.  If AWT is actually needed, the same exception will
comment|// show up later, which is fine.
comment|// NOTE jvs 27-Mar-2007: If this exception occurs, we'll
comment|// retry the AWT load on each loadLibrary call.  That's okay,
comment|// since there are only a few libraries and they're loaded
comment|// via static initializers.
block|}
block|}
name|System
operator|.
name|loadLibrary
argument_list|(
name|libName
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns whether an array of strings contains a given string among the      * first<code>length</code> entries.      *      * @param a Array of strings      * @param length Number of entries to search      * @param s String to seek      *      * @return Whether array contains the name      */
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|String
index|[]
name|a
parameter_list|,
name|int
name|length
parameter_list|,
name|String
name|s
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Reads all remaining contents from a {@link java.io.Reader} and returns      * them as a string.      *      * @param reader reader to read from      *      * @return reader contents as string      */
specifier|public
specifier|static
name|String
name|readAllAsString
parameter_list|(
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|char
index|[]
name|buf
init|=
operator|new
name|char
index|[
literal|4096
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|n
init|=
name|reader
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Closes a Jar, ignoring any I/O exception. This should only be      * used in finally blocks when it's necessary to avoid throwing an exception      * which might mask a real exception.      *      * @param jar jar to close      */
specifier|public
specifier|static
name|void
name|squelchJar
parameter_list|(
name|JarFile
name|jar
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|jar
operator|!=
literal|null
condition|)
block|{
name|jar
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**      * Closes an InputStream, ignoring any I/O exception. This should only be      * used in finally blocks when it's necessary to avoid throwing an exception      * which might mask a real exception.      *      * @param stream stream to close      */
specifier|public
specifier|static
name|void
name|squelchStream
parameter_list|(
name|InputStream
name|stream
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|stream
operator|!=
literal|null
condition|)
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**      * Closes an OutputStream, ignoring any I/O exception. This should only be      * used in finally blocks when it's necessary to avoid throwing an exception      * which might mask a real exception. If you want to make sure that data has      * been successfully flushed, do NOT use this anywhere else; use      * stream.close() instead.      *      * @param stream stream to close      */
specifier|public
specifier|static
name|void
name|squelchStream
parameter_list|(
name|OutputStream
name|stream
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|stream
operator|!=
literal|null
condition|)
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**      * Closes a Reader, ignoring any I/O exception. This should only be used in      * finally blocks when it's necessary to avoid throwing an exception which      * might mask a real exception.      *      * @param reader reader to close      */
specifier|public
specifier|static
name|void
name|squelchReader
parameter_list|(
name|Reader
name|reader
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**      * Closes a Writer, ignoring any I/O exception. This should only be used in      * finally blocks when it's necessary to avoid throwing an exception which      * might mask a real exception. If you want to make sure that data has been      * successfully flushed, do NOT use this anywhere else; use writer.close()      * instead.      *      * @param writer writer to close      */
specifier|public
specifier|static
name|void
name|squelchWriter
parameter_list|(
name|Writer
name|writer
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**      * Closes a Statement, ignoring any SQL exception. This should only be used      * in finally blocks when it's necessary to avoid throwing an exception      * which might mask a real exception.      *      * @param stmt stmt to close      */
specifier|public
specifier|static
name|void
name|squelchStmt
parameter_list|(
name|Statement
name|stmt
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|stmt
operator|!=
literal|null
condition|)
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**      * Closes a Connection, ignoring any SQL exception. This should only be used      * in finally blocks when it's necessary to avoid throwing an exception      * which might mask a real exception.      *      * @param connection connection to close      */
specifier|public
specifier|static
name|void
name|squelchConnection
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**      * Trims trailing spaces from a string.      *      * @param s string to be trimmed      *      * @return trimmed string      */
specifier|public
specifier|static
name|String
name|rtrim
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|int
name|n
init|=
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
operator|!=
literal|' '
condition|)
block|{
return|return
name|s
return|;
block|}
while|while
condition|(
operator|(
operator|--
name|n
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
operator|!=
literal|' '
condition|)
block|{
return|return
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|n
operator|+
literal|1
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|""
return|;
block|}
comment|/**      * Pads a string with spaces up to a given length.      *      * @param s string to be padded      * @param len desired length      *      * @return padded string      */
specifier|public
specifier|static
name|String
name|rpad
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>=
name|len
condition|)
block|{
return|return
name|s
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|<
name|len
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Converts an iterable to a string. */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|String
name|toString
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|String
name|start
parameter_list|,
name|String
name|sep
parameter_list|,
name|String
name|end
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|T
argument_list|>
name|ord
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|iterable
argument_list|)
control|)
block|{
if|if
condition|(
name|ord
operator|.
name|i
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|sep
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|ord
operator|.
name|e
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|end
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Converts a Java timezone to POSIX format, so that the boost C++ library      * can instantiate timezone objects.      *      *<p><a      * href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap08.html">POSIX      * IEEE 1003.1</a> defines a format for timezone specifications.      *      *<p>The boost C++ library can read these specifications and instantiate<a      * href="http://www.boost.org/doc/html/date_time/local_time.html#date_time.local_time.posix_time_zone">      * posix_time_zone</a> objects from them. The purpose of this method,      * therefore, is to allow the C++ code such as the fennel calculator to use      * the same notion of timezone as Java code.      *      *<p>The format is as follows:      *      *<blockquote>"std offset dst [offset],start[/time],end[/time]"      *</blockquote>      *      * where:      *      *<ul>      *<li>'std' specifies the abbrev of the time zone.      *<li>'offset' is the offset from UTC, and takes the form<code>      * [+|-]hh[:mm[:ss]] {h=0-23, m/s=0-59}</code>      *<li>'dst' specifies the abbrev of the time zone during daylight savings      * time      *<li>The second offset is how many hours changed during DST. Default=1      *<li>'start'& 'end' are the dates when DST goes into (and out of) effect.      * They can each be one of three forms:      *      *<ol>      *<li>Mm.w.d {month=1-12, week=1-5 (5 is always last), day=0-6}      *<li>Jn {n=1-365 Feb29 is never counted}      *<li>n {n=0-365 Feb29 is counted in leap years}      *</ol>      *<li>'time' has the same format as 'offset', and defaults to 02:00:00      *      *<p>For example:      *      *<ul>      *<li>"PST-8PDT01:00:00,M4.1.0/02:00:00,M10.1.0/02:00:00"; or more tersely      *<li>"PST-8PDT,M4.1.0,M10.1.0"      *</ul>      *      *<p>(Real format strings do not contain spaces; they are in the above      * template only for readability.)      *      *<p>Boost apparently diverges from the POSIX standard in how it treats the      * sign of timezone offsets. The POSIX standard states '<i>If preceded by a      * '-', the timezone shall be east of the Prime Meridian; otherwise, it      * shall be west</i>', yet boost requires the opposite. For instance, PST      * has offset '-8' above. This method generates timezone strings consistent      * with boost's expectations.      *      * @param tz Timezone      * @param verbose Whether to include fields which can be omitted because      * they have their default values      *      * @return Timezone in POSIX format (offset sign reversed, per boost's      * idiosyncracies)      */
specifier|public
specifier|static
name|String
name|toPosix
parameter_list|(
name|TimeZone
name|tz
parameter_list|,
name|boolean
name|verbose
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|tz
operator|.
name|getDisplayName
argument_list|(
literal|false
argument_list|,
name|TimeZone
operator|.
name|SHORT
argument_list|)
argument_list|)
expr_stmt|;
name|appendPosixTime
argument_list|(
name|buf
argument_list|,
name|tz
operator|.
name|getRawOffset
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|dstSavings
init|=
name|tz
operator|.
name|getDSTSavings
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstSavings
operator|==
literal|0
condition|)
block|{
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|tz
operator|.
name|getDisplayName
argument_list|(
literal|true
argument_list|,
name|TimeZone
operator|.
name|SHORT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
operator|(
name|dstSavings
operator|!=
literal|3600000
operator|)
condition|)
block|{
comment|// POSIX allows us to omit DST offset if it is 1:00:00
name|appendPosixTime
argument_list|(
name|buf
argument_list|,
name|dstSavings
argument_list|)
expr_stmt|;
block|}
name|String
name|patternString
init|=
literal|".*,"
operator|+
literal|"startMode=([0-9]*),"
operator|+
literal|"startMonth=([0-9]*),"
operator|+
literal|"startDay=([-0-9]*),"
operator|+
literal|"startDayOfWeek=([0-9]*),"
operator|+
literal|"startTime=([0-9]*),"
operator|+
literal|"startTimeMode=([0-9]*),"
operator|+
literal|"endMode=([0-9]*),"
operator|+
literal|"endMonth=([0-9]*),"
operator|+
literal|"endDay=([-0-9]*),"
operator|+
literal|"endDayOfWeek=([0-9]*),"
operator|+
literal|"endTime=([0-9]*),"
operator|+
literal|"endTimeMode=([0-9]*).*"
decl_stmt|;
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|patternString
argument_list|)
decl_stmt|;
name|String
name|tzString
init|=
name|tz
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Matcher
name|matcher
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|tzString
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matcher
operator|.
name|matches
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"tz.toString not of expected format: "
operator|+
name|tzString
argument_list|)
throw|;
block|}
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|startMode
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|startMonth
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|startDay
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|startDayOfWeek
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|startTime
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|startTimeMode
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endMode
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endMonth
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endDay
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endDayOfWeek
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endTime
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endTimeMode
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|appendPosixDaylightTransition
argument_list|(
name|tz
argument_list|,
name|buf
argument_list|,
name|startMode
argument_list|,
name|startDay
argument_list|,
name|startMonth
argument_list|,
name|startDayOfWeek
argument_list|,
name|startTime
argument_list|,
name|startTimeMode
argument_list|,
name|verbose
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|appendPosixDaylightTransition
argument_list|(
name|tz
argument_list|,
name|buf
argument_list|,
name|endMode
argument_list|,
name|endDay
argument_list|,
name|endMonth
argument_list|,
name|endDayOfWeek
argument_list|,
name|endTime
argument_list|,
name|endTimeMode
argument_list|,
name|verbose
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Writes a daylight savings time transition to a POSIX timezone      * description.      *      * @param tz Timezone      * @param buf Buffer to append to      * @param mode Transition mode      * @param day Day of transition      * @param month Month of transition      * @param dayOfWeek Day of week of transition      * @param time Time of transition in millis      * @param timeMode Mode of time transition      * @param verbose Verbose      * @param isEnd Whether this transition is leaving DST      */
specifier|private
specifier|static
name|void
name|appendPosixDaylightTransition
parameter_list|(
name|TimeZone
name|tz
parameter_list|,
name|StringBuilder
name|buf
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|day
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|dayOfWeek
parameter_list|,
name|int
name|time
parameter_list|,
name|int
name|timeMode
parameter_list|,
name|boolean
name|verbose
parameter_list|,
name|boolean
name|isEnd
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|int
name|week
init|=
name|day
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|1
case|:
comment|// SimpleTimeZone.DOM_MODE
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|0
argument_list|)
throw|;
case|case
literal|3
case|:
comment|// SimpleTimeZone.DOW_GE_DOM_MODE
comment|// If the day is 1, 8, 15, 22, we can translate this to case 2.
switch|switch
condition|(
name|day
condition|)
block|{
case|case
literal|1
case|:
name|week
operator|=
literal|1
expr_stmt|;
comment|// 1st week of month
break|break;
case|case
literal|8
case|:
name|week
operator|=
literal|2
expr_stmt|;
comment|// 2nd week of month
break|break;
case|case
literal|15
case|:
name|week
operator|=
literal|3
expr_stmt|;
comment|// 3rd week of month
break|break;
case|case
literal|22
case|:
name|week
operator|=
literal|4
expr_stmt|;
comment|// 4th week of month
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"POSIX timezone format cannot represent "
operator|+
name|tz
argument_list|)
throw|;
block|}
comment|// fall through
case|case
literal|2
case|:
comment|// SimpleTimeZone.DOW_IN_MONTH_MODE
name|buf
operator|.
name|append
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|month
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// 1<= m<= 12
name|buf
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|week
operator|==
operator|-
literal|1
condition|)
block|{
comment|// java represents 'last week' differently from POSIX
name|week
operator|=
literal|5
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|week
argument_list|)
expr_stmt|;
comment|// 1<= n<= 5, 5 means 'last'
name|buf
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|dayOfWeek
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// 0<= d<= 6, 0=Sunday
break|break;
case|case
literal|4
case|:
comment|// SimpleTimeZone.DOW_LE_DOM_MODE
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|0
argument_list|)
throw|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected value: "
operator|+
name|mode
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|timeMode
condition|)
block|{
case|case
literal|0
case|:
comment|// SimpleTimeZone.WALL_TIME
break|break;
case|case
literal|1
case|:
comment|// SimpleTimeZone.STANDARD_TIME, e.g. Australia/Sydney
if|if
condition|(
name|isEnd
condition|)
block|{
name|time
operator|+=
name|tz
operator|.
name|getDSTSavings
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|// SimpleTimeZone.UTC_TIME, e.g. Europe/Paris
name|time
operator|+=
name|tz
operator|.
name|getRawOffset
argument_list|()
expr_stmt|;
if|if
condition|(
name|isEnd
condition|)
block|{
name|time
operator|+=
name|tz
operator|.
name|getDSTSavings
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|verbose
operator|||
operator|(
name|time
operator|!=
literal|7200000
operator|)
condition|)
block|{
comment|// POSIX allows us to omit the time if it is 2am (the default)
name|buf
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|appendPosixTime
argument_list|(
name|buf
argument_list|,
name|time
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Given a time expressed in milliseconds, append the time formatted as      * "hh[:mm[:ss]]".      *      * @param buf Buffer to append to      * @param millis Milliseconds      */
specifier|private
specifier|static
name|void
name|appendPosixTime
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|int
name|millis
parameter_list|)
block|{
if|if
condition|(
name|millis
operator|<
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|millis
operator|=
operator|-
name|millis
expr_stmt|;
block|}
name|int
name|hours
init|=
name|millis
operator|/
literal|3600000
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|hours
argument_list|)
expr_stmt|;
name|millis
operator|-=
operator|(
name|hours
operator|*
literal|3600000
operator|)
expr_stmt|;
if|if
condition|(
name|millis
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|int
name|minutes
init|=
name|millis
operator|/
literal|60000
decl_stmt|;
if|if
condition|(
name|minutes
operator|<
literal|10
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|minutes
argument_list|)
expr_stmt|;
name|millis
operator|-=
operator|(
name|minutes
operator|*
literal|60000
operator|)
expr_stmt|;
if|if
condition|(
name|millis
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|int
name|seconds
init|=
name|millis
operator|/
literal|1000
decl_stmt|;
if|if
condition|(
name|seconds
operator|<
literal|10
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|seconds
argument_list|)
expr_stmt|;
block|}
comment|/**      * Parses a locale string.      *      *<p>The inverse operation of {@link java.util.Locale#toString()}.      *      * @param localeString Locale string, e.g. "en" or "en_US"      * @return Java locale object      */
specifier|public
specifier|static
name|Locale
name|parseLocale
parameter_list|(
name|String
name|localeString
parameter_list|)
block|{
name|String
index|[]
name|strings
init|=
name|localeString
operator|.
name|split
argument_list|(
literal|"_"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|strings
operator|.
name|length
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|new
name|Locale
argument_list|(
name|strings
index|[
literal|0
index|]
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|new
name|Locale
argument_list|(
name|strings
index|[
literal|0
index|]
argument_list|,
name|strings
index|[
literal|1
index|]
argument_list|)
return|;
case|case
literal|3
case|:
return|return
operator|new
name|Locale
argument_list|(
name|strings
index|[
literal|0
index|]
argument_list|,
name|strings
index|[
literal|1
index|]
argument_list|,
name|strings
index|[
literal|2
index|]
argument_list|)
return|;
default|default:
throw|throw
name|newInternal
argument_list|(
literal|"bad locale string '"
operator|+
name|localeString
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Runs an external application.      *      * @param cmdarray command and arguments, see {@link ProcessBuilder}      * @param logger if not null, command and exit status will be logged      * @param appInput if not null, data will be copied to application's stdin      * @param appOutput if not null, data will be captured from application's      * stdout and stderr      *      * @return application process exit value      *      * @throws IOException      * @throws InterruptedException      */
specifier|public
specifier|static
name|int
name|runApplication
parameter_list|(
name|String
index|[]
name|cmdarray
parameter_list|,
name|Logger
name|logger
parameter_list|,
name|Reader
name|appInput
parameter_list|,
name|Writer
name|appOutput
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|runAppProcess
argument_list|(
name|newAppProcess
argument_list|(
name|cmdarray
argument_list|)
argument_list|,
name|logger
argument_list|,
name|appInput
argument_list|,
name|appOutput
argument_list|)
return|;
block|}
comment|/**      * Constructs a {@link ProcessBuilder} to run an external application.      *      * @param cmdarray command and arguments.      * @return a ProcessBuilder.      */
specifier|public
specifier|static
name|ProcessBuilder
name|newAppProcess
parameter_list|(
name|String
index|[]
name|cmdarray
parameter_list|)
block|{
comment|// Concatenate quoted words from cmdarray.
comment|// REVIEW mb 2/24/09 Why is this needed?
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cmdarray
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|cmdarray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
name|String
name|fullcmd
init|=
name|buf
operator|.
name|toString
argument_list|()
decl_stmt|;
name|buf
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|new
name|ProcessBuilder
argument_list|(
name|cmdarray
argument_list|)
return|;
block|}
comment|/**      * Runs an external application process.      *      * @param pb {@link ProcessBuilder} for the application; might be returned by {@link #newAppProcess}.      * @param logger if not null, command and exit status will be logged here      * @param appInput if not null, data will be copied to application's stdin      * @param appOutput if not null, data will be captured from application's      * stdout and stderr      *      * @return application process exit value      * @throws IOException      * @throws InterruptedException      */
specifier|public
specifier|static
name|int
name|runAppProcess
parameter_list|(
name|ProcessBuilder
name|pb
parameter_list|,
name|Logger
name|logger
parameter_list|,
name|Reader
name|appInput
parameter_list|,
name|Writer
name|appOutput
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|pb
operator|.
name|redirectErrorStream
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"start process: "
operator|+
name|pb
operator|.
name|command
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Process
name|p
init|=
name|pb
operator|.
name|start
argument_list|()
decl_stmt|;
comment|// Setup the input/output streams to the subprocess.
comment|// The buffering here is arbitrary. Javadocs strongly encourage
comment|// buffering, but the size needed is very dependent on the
comment|// specific application being run, the size of the input
comment|// provided by the caller, and the amount of output expected.
comment|// Since this method is currently used only by unit tests,
comment|// large-ish fixed buffer sizes have been chosen. If this
comment|// method becomes used for something in production, it might
comment|// be better to have the caller provide them as arguments.
if|if
condition|(
name|appInput
operator|!=
literal|null
condition|)
block|{
name|OutputStream
name|out
init|=
operator|new
name|BufferedOutputStream
argument_list|(
name|p
operator|.
name|getOutputStream
argument_list|()
argument_list|,
literal|100
operator|*
literal|1024
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|appInput
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|appOutput
operator|!=
literal|null
condition|)
block|{
name|InputStream
name|in
init|=
operator|new
name|BufferedInputStream
argument_list|(
name|p
operator|.
name|getInputStream
argument_list|()
argument_list|,
literal|100
operator|*
literal|1024
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|in
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|appOutput
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|appOutput
operator|.
name|flush
argument_list|()
expr_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|p
operator|.
name|waitFor
argument_list|()
expr_stmt|;
name|int
name|status
init|=
name|p
operator|.
name|exitValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"exit status="
operator|+
name|status
operator|+
literal|" from "
operator|+
name|pb
operator|.
name|command
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
comment|/**      * Converts a list whose members are automatically down-cast to a given      * type.      *      *<p>If a member of the backing list is not an instanceof<code>E</code>,      * the accessing method (such as {@link List#get}) will throw a {@link      * ClassCastException}.      *      *<p>All modifications are automatically written to the backing list. Not      * synchronized.      *      * @param list Backing list.      * @param clazz Class to cast to.      *      * @return A list whose members are of the desired type.      */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|cast
parameter_list|(
name|List
argument_list|<
name|?
super|super
name|E
argument_list|>
name|list
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
operator|new
name|CastingList
argument_list|<
name|E
argument_list|>
argument_list|(
name|list
argument_list|,
name|clazz
argument_list|)
return|;
block|}
comment|/**      * Converts a iterator whose members are automatically down-cast to a given      * type.      *      *<p>If a member of the backing iterator is not an instanceof<code>      * E</code>, {@link Iterator#next()}) will throw a {@link      * ClassCastException}.      *      *<p>All modifications are automatically written to the backing iterator.      * Not synchronized.      *      * @param iter Backing iterator.      * @param clazz Class to cast to.      *      * @return An iterator whose members are of the desired type.      */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Iterator
argument_list|<
name|E
argument_list|>
name|cast
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iter
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|E
name|next
parameter_list|()
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**      * Converts an {@link Iterable} whose members are automatically down-cast to      * a given type.      *      *<p>All modifications are automatically written to the backing iterator.      * Not synchronized.      *      * @param iterable Backing iterable      * @param clazz Class to cast to      *      * @return An iterable whose members are of the desired type.      */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Iterable
argument_list|<
name|E
argument_list|>
name|cast
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
super|super
name|E
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|cast
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|clazz
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**      * Makes a collection of untyped elements appear as a list of strictly typed      * elements, by filtering out those which are not of the correct type.      *      *<p>The returned object is an {@link Iterable},      * which makes it ideal for use with the 'foreach' construct. For example,      *      *<blockquote><code>List&lt;Number&gt; numbers = Arrays.asList(1, 2, 3.14,      * 4, null, 6E23);<br/>      * for (int myInt : filter(numbers, Integer.class)) {<br/>      *&nbsp;&nbsp;&nbsp;&nbsp;print(i);<br/>      * }</code></blockquote>      *      * will print 1, 2, 4.      *      * @param iterable Iterable      * @param includeFilter Class whose instances to include      */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Iterable
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|includeFilter
parameter_list|)
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Filterator
argument_list|<
name|E
argument_list|>
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|includeFilter
argument_list|)
return|;
block|}
block|}
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Collection
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|includeFilter
parameter_list|)
block|{
return|return
operator|new
name|AbstractCollection
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Filterator
argument_list|<
name|E
argument_list|>
argument_list|(
name|collection
operator|.
name|iterator
argument_list|()
argument_list|,
name|includeFilter
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Compute size.  This is expensive, but the value
comment|// collection.size() is not correct since we're
comment|// filtering values.  (Some java.util algorithms
comment|// call next() on the result of iterator() size() times.)
name|int
name|s
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|E
argument_list|>
name|iter
init|=
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|size
operator|=
name|s
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
block|}
return|;
block|}
comment|/**      * Returns a subset of a list containing only elements of a given type.      *      *<p>Modifications to the list are NOT written back to the source list.      *      * @param list List of objects      * @param includeFilter Class to filter for      *      * @return List of objects of given class (or a subtype)      */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
argument_list|>
name|list
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|includeFilter
parameter_list|)
block|{
name|List
argument_list|<
name|E
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|list
control|)
block|{
if|if
condition|(
name|includeFilter
operator|.
name|isInstance
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|includeFilter
operator|.
name|cast
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * Converts a {@link Properties} object to a<code>{@link Map}&lt;String,      * String&gt;</code>.      *      *<p>This is necessary because {@link Properties} is a dinosaur class. It      * ought to extend<code>Map&lt;String,String&gt;</code>, but instead      * extends<code>{@link Hashtable}&lt;Object,Object&gt;</code>.      *      *<p>Typical usage, to iterate over a {@link Properties}:      *      *<blockquote>      *<code>      * Properties properties;<br/>      * for (Map.Entry&lt;String, String&gt; entry =      * Util.toMap(properties).entrySet()) {<br/>      *   println("key=" + entry.getKey() + ", value=" + entry.getValue());<br/>      * }      *</code>      *</blockquote>      */
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|toMap
parameter_list|(
specifier|final
name|Properties
name|properties
parameter_list|)
block|{
return|return
operator|(
name|Map
operator|)
name|properties
return|;
block|}
comment|/**      * Returns a hashmap with given contents.      *      *<p>Use this method in initializers. Type parameters are inferred from      * context, and the contents are initialized declaratively. For example,      *      *<blockquote><code>Map&lt;String, Integer&gt; population =<br/>      *&nbsp;&nbsp;Olap4jUtil.mapOf(<br/>      *&nbsp;&nbsp;&nbsp;&nbsp;"UK", 65000000,<br/>      *&nbsp;&nbsp;&nbsp;&nbsp;"USA", 300000000);</code></blockquote>      *      * @param key First key      * @param value First value      * @param keyValues Second and sequent key/value pairs      * @param<K> Key type      * @param<V> Value type      * @return Map with given contents      */
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|mapOf
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|Object
modifier|...
name|keyValues
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|1
operator|+
name|keyValues
operator|.
name|length
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyValues
operator|.
name|length
condition|;
control|)
block|{
comment|//noinspection unchecked
name|map
operator|.
name|put
argument_list|(
operator|(
name|K
operator|)
name|keyValues
index|[
name|i
operator|++
index|]
argument_list|,
operator|(
name|V
operator|)
name|keyValues
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
comment|/**      * Returns an exception indicating that we didn't expect to find this      * enumeration here.      *      * @param value Enumeration value which was not expected      *      * @return an error, to be thrown      */
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|Error
name|unexpected
parameter_list|(
name|E
name|value
parameter_list|)
block|{
return|return
operator|new
name|AssertionError
argument_list|(
literal|"Was not expecting value '"
operator|+
name|value
operator|+
literal|"' for enumeration '"
operator|+
name|value
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' in this context"
argument_list|)
return|;
block|}
comment|/**      * Creates a map of the values of an enumeration by name.      *      * @param clazz Enumeration class      *      * @return map of values      */
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|Enum
argument_list|<
name|T
argument_list|>
parameter_list|>
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|enumConstants
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
block|{
specifier|final
name|T
index|[]
name|ts
init|=
name|clazz
operator|.
name|getEnumConstants
argument_list|()
decl_stmt|;
if|if
condition|(
name|ts
operator|==
literal|null
condition|)
block|{
comment|// not an enum type
return|return
literal|null
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
argument_list|(
name|ts
operator|.
name|length
operator|*
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|ts
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|t
operator|.
name|name
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**      * Returns the value of an enumeration with a particular name.      *      *<p>Similar to {@link Enum#valueOf(Class, String)}, but returns {@code      * null} rather than throwing {@link IllegalArgumentException}.      *      * @param clazz Enum class      * @param name Name of enum constant      * @param<T> Enum class type      *      * @return Enum constant or null      */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|}
argument_list|)
specifier|public
specifier|static
specifier|synchronized
parameter_list|<
name|T
extends|extends
name|Enum
argument_list|<
name|T
argument_list|>
parameter_list|>
name|T
name|enumVal
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|mapNameToEnum
init|=
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
operator|)
name|mapClazzToMapNameToEnum
operator|.
name|get
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapNameToEnum
operator|==
literal|null
condition|)
block|{
name|mapNameToEnum
operator|=
name|enumConstants
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
name|mapClazzToMapNameToEnum
operator|.
name|put
argument_list|(
name|clazz
argument_list|,
name|mapNameToEnum
argument_list|)
expr_stmt|;
block|}
return|return
name|mapNameToEnum
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**      * Returns an iterable over the bits in a bitmap that are set to '1'.      *      *<p>This allows you to iterate over a bit set using a 'foreach' construct.      * For instance:      *      *<blockquote><code>      * BitSet bitSet;<br/>      * for (int i : Util.toIter(bitSet)) {<br/>      *&nbsp;&nbsp;print(i);<br/>      * }<br/></code></blockquote>      *      * @param bitSet Bit set      * @return Iterable      */
specifier|public
specifier|static
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|toIter
parameter_list|(
specifier|final
name|BitSet
name|bitSet
parameter_list|)
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
name|int
name|i
init|=
name|bitSet
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|i
operator|>=
literal|0
return|;
block|}
specifier|public
name|Integer
name|next
parameter_list|()
block|{
name|int
name|prev
init|=
name|i
decl_stmt|;
name|i
operator|=
name|bitSet
operator|.
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|prev
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**      * Converts a bitset to a list.      *      *<p>The list is mutable, and future changes to the list do not affect the      * contents of the bit set.      *      * @param bitSet Bit set      * @return List of set bits      */
specifier|public
specifier|static
name|IntList
name|toList
parameter_list|(
specifier|final
name|BitSet
name|bitSet
parameter_list|)
block|{
specifier|final
name|IntList
name|list
init|=
operator|new
name|IntList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|bitSet
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|bitSet
operator|.
name|nextSetBit
argument_list|(
name|i
operator|+
literal|1
argument_list|)
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**      * Converts a bitset to an array.      *      * @param bitSet Bit set      * @return List of set bits      */
specifier|public
specifier|static
name|Integer
index|[]
name|toArray
parameter_list|(
specifier|final
name|BitSet
name|bitSet
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|toList
argument_list|(
name|bitSet
argument_list|)
decl_stmt|;
return|return
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
name|list
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Creates a bitset with given bits set.      *      *<p>For example, {@code bitSetOf(0, 3)} returns a bit set with bits {0, 3}      * set.      *      * @param bits Array of bits to set      * @return Bit set      */
specifier|public
specifier|static
name|BitSet
name|bitSetOf
parameter_list|(
name|int
modifier|...
name|bits
parameter_list|)
block|{
specifier|final
name|BitSet
name|bitSet
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|bit
range|:
name|bits
control|)
block|{
name|bitSet
operator|.
name|set
argument_list|(
name|bit
argument_list|)
expr_stmt|;
block|}
return|return
name|bitSet
return|;
block|}
comment|/**      * Creates a bitset with given bits set.      *      *<p>For example, {@code bitSetOf(new Integer[] {0, 3})} returns a bit set      * with bits {0, 3} set.      *      * @param bits Array of bits to set      * @return Bit set      */
specifier|public
specifier|static
name|BitSet
name|bitSetOf
parameter_list|(
name|Integer
index|[]
name|bits
parameter_list|)
block|{
specifier|final
name|BitSet
name|bitSet
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|bit
range|:
name|bits
control|)
block|{
name|bitSet
operator|.
name|set
argument_list|(
name|bit
argument_list|)
expr_stmt|;
block|}
return|return
name|bitSet
return|;
block|}
comment|/**      * Creates a bitset with given bits set.      *      *<p>For example, {@code bitSetOf(Arrays.asList(0, 3)) } returns a bit set      * with bits {0, 3} set.      *      * @param bits Collection of bits to set      * @return Bit set      */
specifier|public
specifier|static
name|BitSet
name|bitSetOf
parameter_list|(
name|Collection
argument_list|<
name|Integer
argument_list|>
name|bits
parameter_list|)
block|{
specifier|final
name|BitSet
name|bitSet
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|bit
range|:
name|bits
control|)
block|{
name|bitSet
operator|.
name|set
argument_list|(
name|bit
argument_list|)
expr_stmt|;
block|}
return|return
name|bitSet
return|;
block|}
comment|/**      * Creates a bitset with bits from {@code fromIndex} (inclusive) to      * specified {@code toIndex} (exclusive) set to {@code true}.      *      *<p>For example, {@code bitSetBetween(0, 3)} returns a bit set with bits      * {0, 1, 2} set.      *      * @param fromIndex Index of the first bit to be set.      * @param toIndex   Index after the last bit to be set.      * @return Bit set      */
specifier|public
specifier|static
name|BitSet
name|bitSetBetween
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
specifier|final
name|BitSet
name|bitSet
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
if|if
condition|(
name|toIndex
operator|>
name|fromIndex
condition|)
block|{
comment|// Avoid http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6222207
comment|// "BitSet internal invariants may be violated"
name|bitSet
operator|.
name|set
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
expr_stmt|;
block|}
return|return
name|bitSet
return|;
block|}
comment|/**      * Returns a string of N spaces.      */
specifier|public
specifier|static
name|String
name|spaces
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|SpaceList
operator|.
name|INSTANCE
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/** Creates a list that returns every {@code n}th element of a list,      * starting at element {@code k}.      *      *<p>It is OK if the list is empty or its size is not a multiple of      * {@code n}.</p>      *      *<p>For instance, {@code quotientList(list, 2, 0)} returns the even      * elements of a list, and {@code quotientList(list, 2, 1)} returns the odd      * elements. Those lists are the same length only if list has even size.</p>      */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|quotientList
parameter_list|(
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
specifier|final
name|int
name|n
parameter_list|,
specifier|final
name|int
name|k
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<=
literal|0
operator|||
name|k
operator|<
literal|0
operator|||
name|k
operator|>=
name|n
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"n must be positive; k must be between 0 and n - 1"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|size
init|=
operator|(
name|list
operator|.
name|size
argument_list|()
operator|+
name|n
operator|-
name|k
operator|-
literal|1
operator|)
operator|/
name|n
decl_stmt|;
return|return
operator|new
name|AbstractList
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|index
operator|*
name|n
operator|+
name|k
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
block|}
return|;
block|}
comment|/** Returns whether a bit set contains every bit of another bit set. */
specifier|public
specifier|static
name|boolean
name|isSupersetOf
parameter_list|(
name|BitSet
name|set0
parameter_list|,
name|BitSet
name|set1
parameter_list|)
block|{
if|if
condition|(
name|set1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|set0
operator|.
name|intersects
argument_list|(
name|set1
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Integer
name|integer
range|:
name|toIter
argument_list|(
name|set1
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|set0
operator|.
name|get
argument_list|(
name|integer
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|first
parameter_list|(
name|T
name|t0
parameter_list|,
name|T
name|t1
parameter_list|)
block|{
return|return
name|t0
operator|!=
literal|null
condition|?
name|t0
else|:
name|t1
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|range
parameter_list|(
specifier|final
name|int
name|start
parameter_list|,
specifier|final
name|int
name|end
parameter_list|)
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|end
operator|-
name|start
return|;
block|}
specifier|public
name|Integer
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|start
operator|+
name|index
return|;
block|}
block|}
return|;
block|}
comment|/** Converts an underscore-separated name into a camelCase name.      * For example, {@code uncamel("MY_JDBC_DRIVER")} returns "myJdbcDriver". */
specifier|public
specifier|static
name|String
name|toCamelCase
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|nextUpper
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|name
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
block|{
name|nextUpper
operator|=
name|i
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nextUpper
operator|==
name|i
condition|)
block|{
name|c
operator|=
name|Character
operator|.
name|toUpperCase
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|Character
operator|.
name|toLowerCase
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Returns whether the elements of {@code list} are distinct. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|isDistinct
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|E
argument_list|,
name|Object
argument_list|>
name|set
init|=
operator|new
name|HashMap
argument_list|<
name|E
argument_list|,
name|Object
argument_list|>
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|list
control|)
block|{
if|if
condition|(
name|set
operator|.
name|put
argument_list|(
name|e
argument_list|,
literal|""
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**      * Exception used to interrupt a tree walk of any kind.      */
specifier|public
specifier|static
class|class
name|FoundOne
extends|extends
name|RuntimeException
block|{
specifier|private
specifier|final
name|Object
name|node
decl_stmt|;
specifier|public
name|FoundOne
parameter_list|(
name|Object
name|node
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
block|}
specifier|public
name|Object
name|getNode
parameter_list|()
block|{
return|return
name|node
return|;
block|}
block|}
comment|// Experimental support for functional programming follows...
comment|/**      * Function of arity 0.      *      * @param<R> Result type.      */
interface|interface
name|Function0
parameter_list|<
name|R
parameter_list|>
block|{
comment|/**          * Applies the function.          *          * @return Result value.          */
name|R
name|apply
parameter_list|()
function_decl|;
block|}
comment|/**      * Function of arity 1.      *      * @param<R> Result type.      * @param<T0> Type of parameter 0.      */
specifier|public
interface|interface
name|Function1
parameter_list|<
name|R
parameter_list|,
name|T0
parameter_list|>
block|{
comment|/**          * Applies the function.          *          * @param p0 Parameter 0.          * @return Result value.          */
name|R
name|apply
parameter_list|(
name|T0
name|p0
parameter_list|)
function_decl|;
block|}
comment|/**      * Function of arity 2.      *      * @param<R> Result type.      * @param<T0> Type of parameter 0.      * @param<T1> Type of parameter 1.      */
specifier|public
interface|interface
name|Function2
parameter_list|<
name|R
parameter_list|,
name|T0
parameter_list|,
name|T1
parameter_list|>
block|{
comment|/**          * Applies the function.          *          * @param p0 Parameter 0.          * @param p1 Parameter 1.          * @return Result value.          */
name|R
name|apply
parameter_list|(
name|T0
name|p0
parameter_list|,
name|T1
name|p1
parameter_list|)
function_decl|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|}
argument_list|)
specifier|public
specifier|static
class|class
name|Functions
block|{
comment|/**          * Returns a function of arity 0 that does nothing.          *          * @param<R> Return type          * @return Function that does nothing.          */
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|>
name|Function0
argument_list|<
name|R
argument_list|>
name|ignore0
parameter_list|()
block|{
return|return
name|Ignore
operator|.
name|INSTANCE
return|;
block|}
comment|/**          * Returns a function of arity 1 that does nothing.          *          * @param<R> Return type          * @param<T0> Type of parameter 0          * @return Function that does nothing.          */
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|,
name|T0
parameter_list|>
name|Function1
argument_list|<
name|R
argument_list|,
name|T0
argument_list|>
name|ignore1
parameter_list|()
block|{
return|return
name|Ignore
operator|.
name|INSTANCE
return|;
block|}
comment|/**          * Returns a function of arity 2 that does nothing.          *          * @param<R> Return type          * @param<T0> Type of parameter 0          * @param<T1> Type of parameter 1          * @return Function that does nothing.          */
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|,
name|T0
parameter_list|,
name|T1
parameter_list|>
name|Function2
argument_list|<
name|R
argument_list|,
name|T0
argument_list|,
name|T1
argument_list|>
name|ignore2
parameter_list|()
block|{
return|return
name|Ignore
operator|.
name|INSTANCE
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|Ignore
parameter_list|<
name|R
parameter_list|,
name|T0
parameter_list|,
name|T1
parameter_list|>
implements|implements
name|Function0
argument_list|<
name|R
argument_list|>
implements|,
name|Function1
argument_list|<
name|R
argument_list|,
name|T0
argument_list|>
implements|,
name|Function2
argument_list|<
name|R
argument_list|,
name|T0
argument_list|,
name|T1
argument_list|>
block|{
specifier|public
name|R
name|apply
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|R
name|apply
parameter_list|(
name|T0
name|p0
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|R
name|apply
parameter_list|(
name|T0
name|p0
parameter_list|,
name|T1
name|p1
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
specifier|static
specifier|final
name|Ignore
name|INSTANCE
init|=
operator|new
name|Ignore
argument_list|()
decl_stmt|;
block|}
specifier|private
specifier|static
class|class
name|SpaceList
extends|extends
name|CopyOnWriteArrayList
argument_list|<
name|String
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|INSTANCE
init|=
operator|new
name|SpaceList
argument_list|()
decl_stmt|;
specifier|public
name|SpaceList
parameter_list|()
block|{
name|populate
argument_list|(
literal|"               "
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|super
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|String
name|s
init|=
name|get
argument_list|(
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|populate
argument_list|(
name|s
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Populates this list with all prefix strings of a given string. All          * of the prefix strings share the same backing array of chars. */
specifier|private
name|void
name|populate
parameter_list|(
specifier|final
name|String
name|s
parameter_list|)
block|{
comment|// If another thread sees list as momentarily empty, it will throw
comment|// and retry.
name|clear
argument_list|()
expr_stmt|;
name|addAll
argument_list|(
operator|new
name|AbstractList
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|s
operator|.
name|length
argument_list|()
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End Util.java
end_comment

end_unit

