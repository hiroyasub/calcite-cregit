begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Toolkit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheLoader
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LoadingCache
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_comment
comment|/**  * Miscellaneous utility functions.  */
end_comment

begin_class
specifier|public
class|class
name|Util
block|{
specifier|private
name|Util
parameter_list|()
block|{
block|}
comment|//~ Static fields/initializers ---------------------------------------------
comment|/**    * Name of the system property that controls whether the AWT work-around is    * enabled. This workaround allows Farrago to load its native libraries    * despite a conflict with AWT and allows applications that use AWT to    * function normally.    *    * @see #loadLibrary(String)    */
specifier|public
specifier|static
specifier|final
name|String
name|AWT_WORKAROUND_PROPERTY
init|=
literal|"org.eigenbase.util.AWT_WORKAROUND"
decl_stmt|;
comment|/**    * System-dependent newline character.    *    *<p>In general, you should not use this in expected results of tests.    * Expected results should be the expected result on Linux (or Mac OS) using    * '\n'. Apply {@link Util#toLinux(String)} to Windows actual results, if    * necessary, to make them look like Linux actual.</p>    */
specifier|public
specifier|static
specifier|final
name|String
name|LINE_SEPARATOR
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
comment|/**    * System-dependent file separator, for example, "/" or "\."    */
specifier|public
specifier|static
specifier|final
name|String
name|FILE_SEPARATOR
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
decl_stmt|;
comment|/**    * Datetime format string for generating a timestamp string to be used as    * part of a filename. Conforms to SimpleDateFormat conventions.    */
specifier|public
specifier|static
specifier|final
name|String
name|FILE_TIMESTAMP_FORMAT
init|=
literal|"yyyy-MM-dd_HH_mm_ss"
decl_stmt|;
specifier|private
specifier|static
name|boolean
name|driversLoaded
init|=
literal|false
decl_stmt|;
comment|/**    * Regular expression for a valid java identifier which contains no    * underscores and can therefore be returned intact by {@link #toJavaId}.    */
specifier|private
specifier|static
specifier|final
name|Pattern
name|JAVA_ID_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[a-zA-Z_$][a-zA-Z0-9$]*"
argument_list|)
decl_stmt|;
comment|/**    * @see #loadLibrary(String)    */
specifier|private
specifier|static
name|Toolkit
name|awtToolkit
decl_stmt|;
comment|/**    * Maps classes to the map of their enum values. Uses a weak map so that    * classes are not prevented from being unloaded.    */
specifier|private
specifier|static
specifier|final
name|LoadingCache
argument_list|<
name|Class
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Enum
argument_list|>
argument_list|>
name|ENUM_CONSTANTS
init|=
name|CacheBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|weakKeys
argument_list|()
operator|.
name|build
argument_list|(
operator|new
name|CacheLoader
argument_list|<
name|Class
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Enum
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Enum
argument_list|>
name|load
parameter_list|(
name|Class
name|clazz
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
name|enumConstants
argument_list|(
name|clazz
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Does nothing with its argument. Call this method when you have a value    * you are not interested in, but you don't want the compiler to warn that    * you are not using it.    */
specifier|public
specifier|static
name|void
name|discard
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
name|discard
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Does nothing with its argument. Call this method when you have a value    * you are not interested in, but you don't want the compiler to warn that    * you are not using it.    */
specifier|public
specifier|static
name|void
name|discard
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
name|discard
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Does nothing with its argument. Call this method when you have a value    * you are not interested in, but you don't want the compiler to warn that    * you are not using it.    */
specifier|public
specifier|static
name|boolean
name|discard
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
return|return
name|b
return|;
block|}
comment|/**    * Does nothing with its argument. Call this method when you have a value    * you are not interested in, but you don't want the compiler to warn that    * you are not using it.    */
specifier|public
specifier|static
name|void
name|discard
parameter_list|(
name|double
name|d
parameter_list|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
name|discard
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Records that an exception has been caught but will not be re-thrown. If    * the tracer is not null, logs the exception to the tracer.    *    * @param e      Exception    * @param logger If not null, logs exception to this logger    */
specifier|public
specifier|static
name|void
name|swallow
parameter_list|(
name|Throwable
name|e
parameter_list|,
name|Logger
name|logger
parameter_list|)
block|{
if|if
condition|(
name|logger
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINER
argument_list|,
literal|"Discarding exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns whether two objects are equal or are both null.    */
specifier|public
specifier|static
name|boolean
name|equal
parameter_list|(
name|Object
name|s0
parameter_list|,
name|Object
name|s1
parameter_list|)
block|{
if|if
condition|(
name|s0
operator|==
name|s1
condition|)
block|{
return|return
literal|true
return|;
block|}
if|else if
condition|(
name|s0
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|s0
operator|.
name|equals
argument_list|(
name|s1
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns whether two lists are equal to each other using shallow    * comparisons.    *    * @param list0 First list    * @param list1 Second list    * @return Whether lists are same length and all of their elements are    * equal using {@code ==} (may be null).    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|equalShallow
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|list0
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|list1
parameter_list|)
block|{
if|if
condition|(
name|list0
operator|.
name|size
argument_list|()
operator|!=
name|list1
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list0
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list0
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
name|list1
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Combines two integers into a hash code.    */
specifier|public
specifier|static
name|int
name|hash
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
return|return
operator|(
name|i
operator|<<
literal|4
operator|)
operator|^
name|j
return|;
block|}
comment|/**    * Computes a hash code from an existing hash code and an object (which may    * be null).    */
specifier|public
specifier|static
name|int
name|hash
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
name|int
name|k
init|=
operator|(
name|o
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|o
operator|.
name|hashCode
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|h
operator|<<
literal|4
operator|)
operator||
name|h
operator|)
operator|^
name|k
return|;
block|}
comment|/**    * Computes a hash code from an existing hash code and an array of objects    * (which may be null).    */
specifier|public
specifier|static
name|int
name|hashArray
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
index|[]
name|a
parameter_list|)
block|{
comment|// The hashcode for a null array and an empty array should be different
comment|// than h, so use magic numbers.
if|if
condition|(
name|a
operator|==
literal|null
condition|)
block|{
return|return
name|hash
argument_list|(
name|h
argument_list|,
literal|19690429
argument_list|)
return|;
block|}
if|if
condition|(
name|a
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|hash
argument_list|(
name|h
argument_list|,
literal|19690721
argument_list|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|a
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|h
operator|=
name|hash
argument_list|(
name|h
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
comment|/**    * Computes a hash code over var args.    */
specifier|public
specifier|static
name|int
name|hashV
parameter_list|(
name|Object
modifier|...
name|a
parameter_list|)
block|{
name|int
name|h
init|=
literal|19690721
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|a
control|)
block|{
name|h
operator|=
name|hash
argument_list|(
name|h
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
comment|/** Computes the hash code of a {@code double} value. Equivalent to    * {@link Double}{@code .hashCode(double)}, but that method was only    * introduced in JDK 1.8.    *    * @param v Value    * @return Hash code    */
specifier|public
specifier|static
name|int
name|hashCode
parameter_list|(
name|double
name|v
parameter_list|)
block|{
name|long
name|bits
init|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|v
argument_list|)
decl_stmt|;
return|return
operator|(
name|int
operator|)
operator|(
name|bits
operator|^
operator|(
name|bits
operator|>>>
literal|32
operator|)
operator|)
return|;
block|}
comment|/**    * Returns a set of the elements which are in<code>set1</code> but not in    *<code>set2</code>, without modifying either.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|T
argument_list|>
name|minus
parameter_list|(
name|Set
argument_list|<
name|T
argument_list|>
name|set1
parameter_list|,
name|Set
argument_list|<
name|T
argument_list|>
name|set2
parameter_list|)
block|{
if|if
condition|(
name|set1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|set1
return|;
block|}
if|else if
condition|(
name|set2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|set1
return|;
block|}
else|else
block|{
name|Set
argument_list|<
name|T
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|T
argument_list|>
argument_list|(
name|set1
argument_list|)
decl_stmt|;
name|set
operator|.
name|removeAll
argument_list|(
name|set2
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
block|}
comment|/**    * Computes<code>nlogn(n)</code> using the natural logarithm (or<code>    * n</code> if<code>n&lt; {@link Math#E}</code>, so the result is never    * negative.    */
specifier|public
specifier|static
name|double
name|nLogN
parameter_list|(
name|double
name|d
parameter_list|)
block|{
return|return
operator|(
name|d
operator|<
name|Math
operator|.
name|E
operator|)
condition|?
name|d
else|:
operator|(
name|d
operator|*
name|Math
operator|.
name|log
argument_list|(
name|d
argument_list|)
operator|)
return|;
block|}
comment|/**    * Prints an object using reflection. We can handle<code>null</code>;    * arrays of objects and primitive values; for regular objects, we print all    * public fields.    */
specifier|public
specifier|static
name|void
name|print
parameter_list|(
name|PrintWriter
name|pw
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
name|print
argument_list|(
name|pw
argument_list|,
name|o
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|print
parameter_list|(
name|PrintWriter
name|pw
parameter_list|,
name|Object
name|o
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Class
name|clazz
init|=
name|o
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|String
condition|)
block|{
name|printJavaString
argument_list|(
name|pw
argument_list|,
operator|(
name|String
operator|)
name|o
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|clazz
operator|==
name|Integer
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Boolean
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Character
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Byte
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Short
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Long
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Float
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Double
operator|.
name|class
operator|)
operator|||
operator|(
name|clazz
operator|==
name|Void
operator|.
name|class
operator|)
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|clazz
operator|.
name|isArray
argument_list|()
condition|)
block|{
comment|// o is an array, but we can't cast to Object[] because it may be
comment|// an array of primitives.
name|Object
index|[]
name|a
decl_stmt|;
comment|// for debug
if|if
condition|(
name|o
operator|instanceof
name|Object
index|[]
condition|)
block|{
name|a
operator|=
operator|(
name|Object
index|[]
operator|)
name|o
expr_stmt|;
name|discard
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|int
name|n
init|=
name|Array
operator|.
name|getLength
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|indent
condition|;
name|j
operator|++
control|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
name|print
argument_list|(
name|pw
argument_list|,
name|Array
operator|.
name|get
argument_list|(
name|o
argument_list|,
name|i
argument_list|)
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|o
operator|instanceof
name|Iterator
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
name|iter
init|=
operator|(
name|Iterator
operator|)
name|o
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" {"
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|print
argument_list|(
name|pw
argument_list|,
name|iter
operator|.
name|next
argument_list|()
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|o
operator|instanceof
name|Enumeration
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Enumeration
name|e
init|=
operator|(
name|Enumeration
operator|)
name|o
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" {"
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|print
argument_list|(
name|pw
argument_list|,
name|e
operator|.
name|nextElement
argument_list|()
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pw
operator|.
name|print
argument_list|(
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" {"
argument_list|)
expr_stmt|;
name|Field
index|[]
name|fields
init|=
name|clazz
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|int
name|printed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Field
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|isStatic
argument_list|(
name|field
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|printed
operator|++
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|indent
condition|;
name|j
operator|++
control|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
name|Object
name|val
decl_stmt|;
try|try
block|{
name|val
operator|=
name|field
operator|.
name|get
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
name|newInternal
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|print
argument_list|(
name|pw
argument_list|,
name|val
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Prints a string, enclosing in double quotes (") and escaping if    * necessary. For examples,<code>printDoubleQuoted(w,"x\"y",false)</code>    * prints<code>"x\"y"</code>.    */
specifier|public
specifier|static
name|void
name|printJavaString
parameter_list|(
name|PrintWriter
name|pw
parameter_list|,
name|String
name|s
parameter_list|,
name|boolean
name|nullMeansNull
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|nullMeansNull
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//pw.print("");
block|}
block|}
else|else
block|{
name|String
name|s1
init|=
name|replace
argument_list|(
name|s
argument_list|,
literal|"\\"
argument_list|,
literal|"\\\\"
argument_list|)
decl_stmt|;
name|String
name|s2
init|=
name|replace
argument_list|(
name|s1
argument_list|,
literal|"\""
argument_list|,
literal|"\\\""
argument_list|)
decl_stmt|;
name|String
name|s3
init|=
name|replace
argument_list|(
name|s2
argument_list|,
literal|"\n\r"
argument_list|,
literal|"\\n"
argument_list|)
decl_stmt|;
name|String
name|s4
init|=
name|replace
argument_list|(
name|s3
argument_list|,
literal|"\n"
argument_list|,
literal|"\\n"
argument_list|)
decl_stmt|;
name|String
name|s5
init|=
name|replace
argument_list|(
name|s4
argument_list|,
literal|"\r"
argument_list|,
literal|"\\r"
argument_list|)
decl_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|s5
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|void
name|println
parameter_list|(
name|PrintWriter
name|pw
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
name|print
argument_list|(
name|pw
argument_list|,
name|o
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pw
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|/**    * Formats a {@link BigDecimal} value to a string in scientific notation For    * example<br>    *    *<ul>    *<li>A value of 0.00001234 would be formated as<code>1.234E-5</code></li>    *<li>A value of 100000.00 would be formated as<code>1.00E5</code></li>    *<li>A value of 100 (scale zero) would be formated as    *<code>1E2</code></li>    *</ul>    *    *<p>If<code>bd</code> has a precision higher than 20, this method will    * truncate the output string to have a precision of 20 (no rounding will be    * done, just a truncate).    */
specifier|public
specifier|static
name|String
name|toScientificNotation
parameter_list|(
name|BigDecimal
name|bd
parameter_list|)
block|{
specifier|final
name|int
name|truncateAt
init|=
literal|20
decl_stmt|;
name|String
name|unscaled
init|=
name|bd
operator|.
name|unscaledValue
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|bd
operator|.
name|signum
argument_list|()
operator|<
literal|0
condition|)
block|{
name|unscaled
operator|=
name|unscaled
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|len
init|=
name|unscaled
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|scale
init|=
name|bd
operator|.
name|scale
argument_list|()
decl_stmt|;
name|int
name|e
init|=
name|len
operator|-
name|scale
operator|-
literal|1
decl_stmt|;
name|StringBuilder
name|ret
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|bd
operator|.
name|signum
argument_list|()
operator|<
literal|0
condition|)
block|{
name|ret
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
comment|// do truncation
name|unscaled
operator|=
name|unscaled
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|truncateAt
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|unscaled
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
comment|// trim trailing zeroes since they aren't significant
name|int
name|i
init|=
name|unscaled
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|unscaled
operator|.
name|charAt
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|!=
literal|'0'
condition|)
block|{
break|break;
block|}
operator|--
name|i
expr_stmt|;
block|}
name|unscaled
operator|=
name|unscaled
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unscaled
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ret
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|unscaled
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|.
name|append
argument_list|(
literal|"E"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|ret
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Replaces every occurrence of<code>find</code> in<code>s</code> with    *<code>replace</code>.    */
specifier|public
specifier|static
name|String
name|replace
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|find
parameter_list|,
name|String
name|replace
parameter_list|)
block|{
comment|// let's be optimistic
name|int
name|found
init|=
name|s
operator|.
name|indexOf
argument_list|(
name|find
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|s
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|s
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
name|start
operator|<
name|found
condition|;
name|start
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
name|replace
argument_list|)
expr_stmt|;
name|start
operator|+=
name|find
operator|.
name|length
argument_list|()
expr_stmt|;
name|found
operator|=
name|s
operator|.
name|indexOf
argument_list|(
name|find
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
operator|-
literal|1
condition|)
block|{
name|found
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Creates a file-protocol URL for the given file.    */
specifier|public
specifier|static
name|URL
name|toURL
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|MalformedURLException
block|{
name|String
name|path
init|=
name|file
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
comment|// This is a bunch of weird code that is required to
comment|// make a valid URL on the Windows platform, due
comment|// to inconsistencies in what getAbsolutePath returns.
name|String
name|fs
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|)
block|{
name|char
name|sep
init|=
name|fs
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sep
operator|!=
literal|'/'
condition|)
block|{
name|path
operator|=
name|path
operator|.
name|replace
argument_list|(
name|sep
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'/'
condition|)
block|{
name|path
operator|=
literal|'/'
operator|+
name|path
expr_stmt|;
block|}
block|}
name|path
operator|=
literal|"file://"
operator|+
name|path
expr_stmt|;
return|return
operator|new
name|URL
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/**    * Gets a timestamp string for use in file names. The generated timestamp    * string reflects the current time.    */
specifier|public
specifier|static
name|String
name|getFileTimestamp
parameter_list|()
block|{
name|SimpleDateFormat
name|sdf
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|FILE_TIMESTAMP_FORMAT
argument_list|)
decl_stmt|;
return|return
name|sdf
operator|.
name|format
argument_list|(
operator|new
name|java
operator|.
name|util
operator|.
name|Date
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Converts double-quoted Java strings to their contents. For example,    *<code>"foo\"bar"</code> becomes<code>foo"bar</code>.    */
specifier|public
specifier|static
name|String
name|stripDoubleQuotes
parameter_list|(
name|String
name|value
parameter_list|)
block|{
assert|assert
name|value
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'"'
assert|;
assert|assert
name|value
operator|.
name|charAt
argument_list|(
name|value
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'"'
assert|;
name|String
name|s5
init|=
name|value
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|value
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|String
name|s4
init|=
name|Util
operator|.
name|replace
argument_list|(
name|s5
argument_list|,
literal|"\\r"
argument_list|,
literal|"\r"
argument_list|)
decl_stmt|;
name|String
name|s3
init|=
name|Util
operator|.
name|replace
argument_list|(
name|s4
argument_list|,
literal|"\\n"
argument_list|,
literal|"\n"
argument_list|)
decl_stmt|;
name|String
name|s2
init|=
name|Util
operator|.
name|replace
argument_list|(
name|s3
argument_list|,
literal|"\\\""
argument_list|,
literal|"\""
argument_list|)
decl_stmt|;
name|String
name|s1
init|=
name|Util
operator|.
name|replace
argument_list|(
name|s2
argument_list|,
literal|"\\\\"
argument_list|,
literal|"\\"
argument_list|)
decl_stmt|;
return|return
name|s1
return|;
block|}
comment|/**    * Converts an arbitrary string into a string suitable for use as a Java    * identifier.    *    *<p>The mapping is one-to-one (that is, distinct strings will produce    * distinct java identifiers). The mapping is also reversible, but the    * inverse mapping is not implemented.</p>    *    *<p>A valid Java identifier must start with a Unicode letter, underscore,    * or dollar sign ($). The other characters, if any, can be a Unicode    * letter, underscore, dollar sign, or digit.</p>    *    *<p>This method uses an algorithm similar to URL encoding. Valid    * characters are unchanged; invalid characters are converted to an    * underscore followed by the hex code of the character; and underscores are    * doubled.</p>    *    * Examples:    *    *<ul>    *<li><code>toJavaId("foo")</code> returns<code>"foo"</code>    *<li><code>toJavaId("foo bar")</code> returns<code>"foo_20_bar"</code>    *<li><code>toJavaId("foo_bar")</code> returns<code>"foo__bar"</code>    *<li><code>toJavaId("0bar")</code> returns<code>"_40_bar"</code> (digits    * are illegal as a prefix)    *<li><code>toJavaId("foo0bar")</code> returns<code>"foo0bar"</code>    *</ul>    */
specifier|public
specifier|static
name|String
name|toJavaId
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
comment|// If it's already a valid Java id (and doesn't contain any
comment|// underscores), return it unchanged.
if|if
condition|(
name|JAVA_ID_PATTERN
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
comment|// prepend "ID$" to string so it doesn't clash with java keywords
return|return
literal|"ID$"
operator|+
name|ordinal
operator|+
literal|"$"
operator|+
name|s
return|;
block|}
comment|// Escape underscores and other undesirables.
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|s
operator|.
name|length
argument_list|()
operator|+
literal|10
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"ID$"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|ordinal
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"__"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|c
operator|<
literal|0x7F
operator|)
comment|/* Normal ascii character */
operator|&&
operator|!
name|Character
operator|.
name|isISOControl
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|Character
operator|.
name|isJavaIdentifierStart
argument_list|(
name|c
argument_list|)
else|:
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|c
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|String
name|toLinux
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|s
operator|.
name|replaceAll
argument_list|(
literal|"\r\n"
argument_list|,
literal|"\n"
argument_list|)
return|;
block|}
comment|/**    * Materializes the results of a {@link java.util.Iterator} as a {@link    * java.util.List}.    *    * @param iter iterator to materialize    * @return materialized list    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|toList
parameter_list|(
name|Iterator
argument_list|<
name|T
argument_list|>
name|iter
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
specifier|static
name|boolean
name|isStatic
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Member
name|member
parameter_list|)
block|{
name|int
name|modifiers
init|=
name|member
operator|.
name|getModifiers
argument_list|()
decl_stmt|;
return|return
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isStatic
argument_list|(
name|modifiers
argument_list|)
return|;
block|}
comment|/**    * @return true if s==null or if s.length()==0    */
specifier|public
specifier|static
name|boolean
name|isNullOrEmpty
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
operator|(
literal|null
operator|==
name|s
operator|)
operator|||
operator|(
name|s
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
return|;
block|}
comment|/**    * Converts a list of a string, with commas between elements.    *    * For example,    *<code>commaList(Arrays.asList({"a", "b"}))</code>    * returns "a, b".    *    * @param list List    * @return String representation of string    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|String
name|commaList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|sepList
argument_list|(
name|list
argument_list|,
literal|", "
argument_list|)
return|;
block|}
comment|/** Converts a list of a string, with a given separator between elements. */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|String
name|sepList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|,
name|String
name|sep
parameter_list|)
block|{
specifier|final
name|int
name|max
init|=
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|max
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
literal|""
return|;
case|case
literal|0
case|:
return|return
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|max
condition|)
block|{
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|sep
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns the {@link Charset} object representing the value of {@link    * SaffronProperties#defaultCharset}    *    * @throws java.nio.charset.IllegalCharsetNameException If the given charset    *                                                      name is illegal    * @throws java.nio.charset.UnsupportedCharsetException If no support for    *                                                      the named charset is    *                                                      available in this    *                                                      instance of the Java    *                                                      virtual machine    */
specifier|public
specifier|static
name|Charset
name|getDefaultCharset
parameter_list|()
block|{
return|return
name|Charset
operator|.
name|forName
argument_list|(
name|SaffronProperties
operator|.
name|instance
argument_list|()
operator|.
name|defaultCharset
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|()
block|{
return|return
name|newInternal
argument_list|(
literal|"(unknown cause)"
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
operator|new
name|AssertionError
argument_list|(
literal|"Internal error: "
operator|+
name|s
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
return|return
name|newInternal
argument_list|(
name|e
argument_list|,
literal|"(unknown cause)"
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Error
name|newInternal
parameter_list|(
name|Throwable
name|e
parameter_list|,
name|String
name|s
parameter_list|)
block|{
name|String
name|message
init|=
literal|"Internal error: "
operator|+
name|s
decl_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
comment|// TODO re-enable this code when we're no longer throwing spurious
comment|//   internal errors (which should be parse errors, for example)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
name|AssertionError
name|ae
init|=
operator|new
name|AssertionError
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|ae
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|ae
return|;
block|}
comment|/**    * Retrieves messages in a exception and writes them to a string. In the    * string returned, each message will appear on a different line.    *    * @return a non-null string containing all messages of the exception    */
specifier|public
specifier|static
name|String
name|getMessages
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Throwable
name|curr
init|=
name|t
init|;
name|curr
operator|!=
literal|null
condition|;
name|curr
operator|=
name|curr
operator|.
name|getCause
argument_list|()
control|)
block|{
name|String
name|msg
init|=
operator|(
operator|(
name|curr
operator|instanceof
name|EigenbaseException
operator|)
operator|||
operator|(
name|curr
operator|instanceof
name|SQLException
operator|)
operator|)
condition|?
name|curr
operator|.
name|getMessage
argument_list|()
else|:
name|curr
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns the stack trace of a throwable. Called from native code.    *    * @param t Throwable    * @return Stack trace    */
specifier|public
specifier|static
name|String
name|getStackTrace
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
specifier|final
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|t
operator|.
name|printStackTrace
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Checks a pre-condition.    *    *<p>For example,    *    *<pre>    * /**    *   * @ pre x != 0    *   * /    * void foo(int x) {    *     Util.pre(x != 0, "x != 0");    * }</pre>    *    * @param b           Result of evaluating the pre-condition.    * @param description Description of the pre-condition.    */
specifier|public
specifier|static
name|void
name|pre
parameter_list|(
name|boolean
name|b
parameter_list|,
name|String
name|description
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
block|{
throw|throw
name|newInternal
argument_list|(
literal|"pre-condition failed: "
operator|+
name|description
argument_list|)
throw|;
block|}
block|}
comment|/**    * Checks a post-condition.    *    *<p>For example,    *    *<pre>    * /**    *   * @ post return != 0    *   * /    * void foo(int x) {    *     int res = bar(x);    *     Util.post(res != 0, "return != 0");    * }</pre>    *    * @param b           Result of evaluating the pre-condition.    * @param description Description of the pre-condition.    */
specifier|public
specifier|static
name|void
name|post
parameter_list|(
name|boolean
name|b
parameter_list|,
name|String
name|description
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
block|{
throw|throw
name|newInternal
argument_list|(
literal|"post-condition failed: "
operator|+
name|description
argument_list|)
throw|;
block|}
block|}
comment|/**    * Checks an invariant.    *    *<p>This is similar to<code>assert</code> keyword, except that the    * condition is always evaluated even if asserts are disabled.    */
specifier|public
specifier|static
name|void
name|permAssert
parameter_list|(
name|boolean
name|b
parameter_list|,
name|String
name|description
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
block|{
throw|throw
name|newInternal
argument_list|(
literal|"invariant violated: "
operator|+
name|description
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns a {@link java.lang.RuntimeException} indicating that a particular    * feature has not been implemented, but should be.    *    *<p>If every 'hole' in our functionality uses this method, it will be    * easier for us to identity the holes. Throwing a    * {@link java.lang.UnsupportedOperationException} isn't as good, because    * sometimes we actually want to partially implement an API.    *    *<p>Example usage:    *    *<blockquote>    *<pre><code>class MyVisitor extends BaseVisitor {    *     void accept(Foo foo) {    *         // Exception will identify which subclass forgot to override    *         // this method    *         throw Util.needToImplement(this);    *     }    * }</code></pre>    *</blockquote>    *    * @param o The object which was the target of the call, or null. Passing    *          the object gives crucial information if a method needs to be    *          overridden and a subclass forgot to do so.    * @return an {@link UnsupportedOperationException}.    */
specifier|public
specifier|static
name|RuntimeException
name|needToImplement
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|String
name|description
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|description
operator|=
name|o
operator|.
name|getClass
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|o
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|description
argument_list|)
throw|;
block|}
comment|/**    * Flags a piece of code as needing to be cleaned up before you check in.    *    *<p>Introduce a call to this method to indicate that a piece of code, or a    * javadoc comment, needs work before you check in. If you have an IDE which    * can easily trace references, this is an easy way to maintain a to-do    * list.    *    *<p><strong>Checked-in code must never call this method</strong>: you must    * remove all calls/references to this method before you check in.    *    *<p>The<code>argument</code> has generic type and determines the type of    * the result. This allows you to use the method inside an expression, for    * example    *    *<blockquote>    *<pre><code>int x = Util.deprecated(0, false);</code></pre>    *</blockquote>    *    * but the usual usage is to pass in a descriptive string.    *    *<h3>Examples</h3>    *    *<h4>Example #1: Using<code>deprecated</code> to fail if a piece of    * supposedly dead code is reached</h4>    *    *<blockquote>    *<pre><code>void foo(int x) {    *     if (x&lt; 0) {    *         // If this code is executed, an error will be thrown.    *         Util.deprecated(    *             "no longer need to handle negative numbers", true);    *         bar(x);    *     } else {    *         baz(x);    *     }    * }</code></pre>    *</blockquote>    *    *<h4>Example #2: Using<code>deprecated</code> to comment out dead    * code</h4>    *    *<blockquote>    *<pre>if (Util.deprecated(false, false)) {    *     // This code will not be executed, but an error will not be thrown.    *     baz();    * }</pre>    *</blockquote>    *    * @param argument Arbitrary argument to the method.    * @param fail     Whether to throw an exception if this method is called    * @return The value of the<code>argument</code>.    * @deprecated If a piece of code calls this method, it indicates that the    * code needs to be cleaned up.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|deprecated
parameter_list|(
name|T
name|argument
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
if|if
condition|(
name|fail
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
return|return
name|argument
return|;
block|}
comment|/**    * Uses {@link System#loadLibrary(String)} to load a native library    * correctly under mingw (Windows/Cygwin) and Linux environments.    *    *<p>This method also implements a work-around for applications that wish    * to load AWT. AWT conflicts with some native libraries in a way that    * requires AWT to be loaded first. This method checks the system property    * named {@link #AWT_WORKAROUND_PROPERTY} and if it is set to "on" (default;    * case-insensitive) it pre-loads AWT to avoid the conflict.    *    * @param libName the name of the library to load, as in {@link    *                System#loadLibrary(String)}.    */
specifier|public
specifier|static
name|void
name|loadLibrary
parameter_list|(
name|String
name|libName
parameter_list|)
block|{
name|String
name|awtSetting
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|AWT_WORKAROUND_PROPERTY
argument_list|,
literal|"on"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|awtToolkit
operator|==
literal|null
operator|)
operator|&&
name|awtSetting
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"on"
argument_list|)
condition|)
block|{
comment|// REVIEW jvs 8-Sept-2006:  workaround upon workaround.  This
comment|// is required because in native code, we sometimes (see Farrago)
comment|// have to use dlopen("libfoo.so", RTLD_GLOBAL) in order for native
comment|// plugins to load correctly.  But the RTLD_GLOBAL causes trouble
comment|// later if someone tries to use AWT from within the same JVM.
comment|// So... preload AWT here unless someone configured explicitly
comment|// not to do so.
try|try
block|{
name|awtToolkit
operator|=
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|// Suppress problems so that a headless server doesn't fail on
comment|// startup.  If AWT is actually needed, the same exception will
comment|// show up later, which is fine.
comment|// NOTE jvs 27-Mar-2007: If this exception occurs, we'll
comment|// retry the AWT load on each loadLibrary call.  That's okay,
comment|// since there are only a few libraries and they're loaded
comment|// via static initializers.
block|}
block|}
name|System
operator|.
name|loadLibrary
argument_list|(
name|libName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns whether an array of strings contains a given string among the    * first<code>length</code> entries.    *    * @param a      Array of strings    * @param length Number of entries to search    * @param s      String to seek    * @return Whether array contains the name    */
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|String
index|[]
name|a
parameter_list|,
name|int
name|length
parameter_list|,
name|String
name|s
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Reads all remaining contents from a {@link java.io.Reader} and returns    * them as a string.    *    * @param reader reader to read from    * @return reader contents as string    */
specifier|public
specifier|static
name|String
name|readAllAsString
parameter_list|(
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|char
index|[]
name|buf
init|=
operator|new
name|char
index|[
literal|4096
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|n
init|=
name|reader
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|sb
operator|.
name|append
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Closes a Jar, ignoring any I/O exception. This should only be    * used in finally blocks when it's necessary to avoid throwing an exception    * which might mask a real exception.    *    * @param jar jar to close    */
specifier|public
specifier|static
name|void
name|squelchJar
parameter_list|(
name|JarFile
name|jar
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|jar
operator|!=
literal|null
condition|)
block|{
name|jar
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Closes an InputStream, ignoring any I/O exception. This should only be    * used in finally blocks when it's necessary to avoid throwing an exception    * which might mask a real exception.    *    * @param stream stream to close    */
specifier|public
specifier|static
name|void
name|squelchStream
parameter_list|(
name|InputStream
name|stream
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|stream
operator|!=
literal|null
condition|)
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Closes an OutputStream, ignoring any I/O exception. This should only be    * used in finally blocks when it's necessary to avoid throwing an exception    * which might mask a real exception. If you want to make sure that data has    * been successfully flushed, do NOT use this anywhere else; use    * stream.close() instead.    *    * @param stream stream to close    */
specifier|public
specifier|static
name|void
name|squelchStream
parameter_list|(
name|OutputStream
name|stream
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|stream
operator|!=
literal|null
condition|)
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Closes a Reader, ignoring any I/O exception. This should only be used in    * finally blocks when it's necessary to avoid throwing an exception which    * might mask a real exception.    *    * @param reader reader to close    */
specifier|public
specifier|static
name|void
name|squelchReader
parameter_list|(
name|Reader
name|reader
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Closes a Writer, ignoring any I/O exception. This should only be used in    * finally blocks when it's necessary to avoid throwing an exception which    * might mask a real exception. If you want to make sure that data has been    * successfully flushed, do NOT use this anywhere else; use writer.close()    * instead.    *    * @param writer writer to close    */
specifier|public
specifier|static
name|void
name|squelchWriter
parameter_list|(
name|Writer
name|writer
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Closes a Statement, ignoring any SQL exception. This should only be used    * in finally blocks when it's necessary to avoid throwing an exception    * which might mask a real exception.    *    * @param stmt stmt to close    */
specifier|public
specifier|static
name|void
name|squelchStmt
parameter_list|(
name|Statement
name|stmt
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|stmt
operator|!=
literal|null
condition|)
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Closes a Connection, ignoring any SQL exception. This should only be used    * in finally blocks when it's necessary to avoid throwing an exception    * which might mask a real exception.    *    * @param connection connection to close    */
specifier|public
specifier|static
name|void
name|squelchConnection
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
comment|// intentionally suppressed
block|}
block|}
comment|/**    * Trims trailing spaces from a string.    *    * @param s string to be trimmed    * @return trimmed string    */
specifier|public
specifier|static
name|String
name|rtrim
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|int
name|n
init|=
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
operator|!=
literal|' '
condition|)
block|{
return|return
name|s
return|;
block|}
while|while
condition|(
operator|(
operator|--
name|n
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
operator|!=
literal|' '
condition|)
block|{
return|return
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|n
operator|+
literal|1
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|""
return|;
block|}
comment|/**    * Pads a string with spaces up to a given length.    *    * @param s   string to be padded    * @param len desired length    * @return padded string    */
specifier|public
specifier|static
name|String
name|rpad
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>=
name|len
condition|)
block|{
return|return
name|s
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|<
name|len
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Converts an iterable to a string.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|String
name|toString
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|String
name|start
parameter_list|,
name|String
name|sep
parameter_list|,
name|String
name|end
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|T
argument_list|>
name|ord
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|iterable
argument_list|)
control|)
block|{
if|if
condition|(
name|ord
operator|.
name|i
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|sep
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|ord
operator|.
name|e
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|end
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Converts a Java timezone to POSIX format, so that the boost C++ library    * can instantiate timezone objects.    *    *<p><a    * href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap08.html">POSIX    * IEEE 1003.1</a> defines a format for timezone specifications.    *    *<p>The boost C++ library can read these specifications and instantiate<a    * href="http://www.boost.org/doc/html/date_time/local_time.html#date_time.local_time.posix_time_zone">    * posix_time_zone</a> objects from them. The purpose of this method,    * therefore, is to allow the C++ code such as the fennel calculator to use    * the same notion of timezone as Java code.    *    *<p>The format is as follows:    *    *<blockquote>"std offset dst [offset],start[/time],end[/time]"    *</blockquote>    *    * where:    *    *<ul>    *<li>'std' specifies the abbrev of the time zone.    *<li>'offset' is the offset from UTC, and takes the form    *<code>[+|-]hh[:mm[:ss]] {h=0-23, m/s=0-59}</code></li>    *<li>'dst' specifies the abbrev of the time zone during daylight savings    * time    *<li>The second offset is how many hours changed during DST. Default=1    *<li>'start' and 'end' are the dates when DST goes into (and out of)    *     effect.<br>    *<br>    *     They can each be one of three forms:    *    *<ol>    *<li>Mm.w.d {month=1-12, week=1-5 (5 is always last), day=0-6}    *<li>Jn {n=1-365 Feb29 is never counted}    *<li>n {n=0-365 Feb29 is counted in leap years}    *</ol>    *</li>    *    *<li>'time' has the same format as 'offset', and defaults to 02:00:00.</li>    *</ul>    *    *<p>For example:</p>    *    *<ul>    *<li>"PST-8PDT01:00:00,M4.1.0/02:00:00,M10.1.0/02:00:00"; or more tersely    *<li>"PST-8PDT,M4.1.0,M10.1.0"    *</ul>    *    *<p>(Real format strings do not contain spaces; they are in the above    * template only for readability.)    *    *<p>Boost apparently diverges from the POSIX standard in how it treats the    * sign of timezone offsets. The POSIX standard states '<i>If preceded by a    * '-', the timezone shall be east of the Prime Meridian; otherwise, it    * shall be west</i>', yet boost requires the opposite. For instance, PST    * has offset '-8' above. This method generates timezone strings consistent    * with boost's expectations.    *    * @param tz      Timezone    * @param verbose Whether to include fields which can be omitted because    *                they have their default values    * @return Timezone in POSIX format (offset sign reversed, per boost's    * idiosyncracies)    */
specifier|public
specifier|static
name|String
name|toPosix
parameter_list|(
name|TimeZone
name|tz
parameter_list|,
name|boolean
name|verbose
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|tz
operator|.
name|getDisplayName
argument_list|(
literal|false
argument_list|,
name|TimeZone
operator|.
name|SHORT
argument_list|)
argument_list|)
expr_stmt|;
name|appendPosixTime
argument_list|(
name|buf
argument_list|,
name|tz
operator|.
name|getRawOffset
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|dstSavings
init|=
name|tz
operator|.
name|getDSTSavings
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstSavings
operator|==
literal|0
condition|)
block|{
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|tz
operator|.
name|getDisplayName
argument_list|(
literal|true
argument_list|,
name|TimeZone
operator|.
name|SHORT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
operator|(
name|dstSavings
operator|!=
literal|3600000
operator|)
condition|)
block|{
comment|// POSIX allows us to omit DST offset if it is 1:00:00
name|appendPosixTime
argument_list|(
name|buf
argument_list|,
name|dstSavings
argument_list|)
expr_stmt|;
block|}
name|String
name|patternString
init|=
literal|".*,"
operator|+
literal|"startMode=([0-9]*),"
operator|+
literal|"startMonth=([0-9]*),"
operator|+
literal|"startDay=([-0-9]*),"
operator|+
literal|"startDayOfWeek=([0-9]*),"
operator|+
literal|"startTime=([0-9]*),"
operator|+
literal|"startTimeMode=([0-9]*),"
operator|+
literal|"endMode=([0-9]*),"
operator|+
literal|"endMonth=([0-9]*),"
operator|+
literal|"endDay=([-0-9]*),"
operator|+
literal|"endDayOfWeek=([0-9]*),"
operator|+
literal|"endTime=([0-9]*),"
operator|+
literal|"endTimeMode=([0-9]*).*"
decl_stmt|;
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|patternString
argument_list|)
decl_stmt|;
name|String
name|tzString
init|=
name|tz
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Matcher
name|matcher
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|tzString
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matcher
operator|.
name|matches
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"tz.toString not of expected format: "
operator|+
name|tzString
argument_list|)
throw|;
block|}
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|startMode
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|startMonth
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|startDay
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|startDayOfWeek
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|startTime
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|startTimeMode
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endMode
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endMonth
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endDay
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endDayOfWeek
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endTime
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endTimeMode
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
operator|++
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|appendPosixDaylightTransition
argument_list|(
name|tz
argument_list|,
name|buf
argument_list|,
name|startMode
argument_list|,
name|startDay
argument_list|,
name|startMonth
argument_list|,
name|startDayOfWeek
argument_list|,
name|startTime
argument_list|,
name|startTimeMode
argument_list|,
name|verbose
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|appendPosixDaylightTransition
argument_list|(
name|tz
argument_list|,
name|buf
argument_list|,
name|endMode
argument_list|,
name|endDay
argument_list|,
name|endMonth
argument_list|,
name|endDayOfWeek
argument_list|,
name|endTime
argument_list|,
name|endTimeMode
argument_list|,
name|verbose
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Writes a daylight savings time transition to a POSIX timezone    * description.    *    * @param tz        Timezone    * @param buf       Buffer to append to    * @param mode      Transition mode    * @param day       Day of transition    * @param month     Month of transition    * @param dayOfWeek Day of week of transition    * @param time      Time of transition in millis    * @param timeMode  Mode of time transition    * @param verbose   Verbose    * @param isEnd     Whether this transition is leaving DST    */
specifier|private
specifier|static
name|void
name|appendPosixDaylightTransition
parameter_list|(
name|TimeZone
name|tz
parameter_list|,
name|StringBuilder
name|buf
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|day
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|dayOfWeek
parameter_list|,
name|int
name|time
parameter_list|,
name|int
name|timeMode
parameter_list|,
name|boolean
name|verbose
parameter_list|,
name|boolean
name|isEnd
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|int
name|week
init|=
name|day
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|1
case|:
comment|// SimpleTimeZone.DOM_MODE
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|0
argument_list|)
throw|;
case|case
literal|3
case|:
comment|// SimpleTimeZone.DOW_GE_DOM_MODE
comment|// If the day is 1, 8, 15, 22, we can translate this to case 2.
switch|switch
condition|(
name|day
condition|)
block|{
case|case
literal|1
case|:
name|week
operator|=
literal|1
expr_stmt|;
comment|// 1st week of month
break|break;
case|case
literal|8
case|:
name|week
operator|=
literal|2
expr_stmt|;
comment|// 2nd week of month
break|break;
case|case
literal|15
case|:
name|week
operator|=
literal|3
expr_stmt|;
comment|// 3rd week of month
break|break;
case|case
literal|22
case|:
name|week
operator|=
literal|4
expr_stmt|;
comment|// 4th week of month
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"POSIX timezone format cannot represent "
operator|+
name|tz
argument_list|)
throw|;
block|}
comment|// fall through
case|case
literal|2
case|:
comment|// SimpleTimeZone.DOW_IN_MONTH_MODE
name|buf
operator|.
name|append
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|month
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// 1<= m<= 12
name|buf
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|week
operator|==
operator|-
literal|1
condition|)
block|{
comment|// java represents 'last week' differently from POSIX
name|week
operator|=
literal|5
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|week
argument_list|)
expr_stmt|;
comment|// 1<= n<= 5, 5 means 'last'
name|buf
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|dayOfWeek
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// 0<= d<= 6, 0=Sunday
break|break;
case|case
literal|4
case|:
comment|// SimpleTimeZone.DOW_LE_DOM_MODE
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|0
argument_list|)
throw|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected value: "
operator|+
name|mode
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|timeMode
condition|)
block|{
case|case
literal|0
case|:
comment|// SimpleTimeZone.WALL_TIME
break|break;
case|case
literal|1
case|:
comment|// SimpleTimeZone.STANDARD_TIME, e.g. Australia/Sydney
if|if
condition|(
name|isEnd
condition|)
block|{
name|time
operator|+=
name|tz
operator|.
name|getDSTSavings
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|// SimpleTimeZone.UTC_TIME, e.g. Europe/Paris
name|time
operator|+=
name|tz
operator|.
name|getRawOffset
argument_list|()
expr_stmt|;
if|if
condition|(
name|isEnd
condition|)
block|{
name|time
operator|+=
name|tz
operator|.
name|getDSTSavings
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|verbose
operator|||
operator|(
name|time
operator|!=
literal|7200000
operator|)
condition|)
block|{
comment|// POSIX allows us to omit the time if it is 2am (the default)
name|buf
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|appendPosixTime
argument_list|(
name|buf
argument_list|,
name|time
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Given a time expressed in milliseconds, append the time formatted as    * "hh[:mm[:ss]]".    *    * @param buf    Buffer to append to    * @param millis Milliseconds    */
specifier|private
specifier|static
name|void
name|appendPosixTime
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|int
name|millis
parameter_list|)
block|{
if|if
condition|(
name|millis
operator|<
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|millis
operator|=
operator|-
name|millis
expr_stmt|;
block|}
name|int
name|hours
init|=
name|millis
operator|/
literal|3600000
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|hours
argument_list|)
expr_stmt|;
name|millis
operator|-=
name|hours
operator|*
literal|3600000
expr_stmt|;
if|if
condition|(
name|millis
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|int
name|minutes
init|=
name|millis
operator|/
literal|60000
decl_stmt|;
if|if
condition|(
name|minutes
operator|<
literal|10
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|minutes
argument_list|)
expr_stmt|;
name|millis
operator|-=
name|minutes
operator|*
literal|60000
expr_stmt|;
if|if
condition|(
name|millis
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|int
name|seconds
init|=
name|millis
operator|/
literal|1000
decl_stmt|;
if|if
condition|(
name|seconds
operator|<
literal|10
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|seconds
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parses a locale string.    *    *<p>The inverse operation of {@link java.util.Locale#toString()}.    *    * @param localeString Locale string, e.g. "en" or "en_US"    * @return Java locale object    */
specifier|public
specifier|static
name|Locale
name|parseLocale
parameter_list|(
name|String
name|localeString
parameter_list|)
block|{
name|String
index|[]
name|strings
init|=
name|localeString
operator|.
name|split
argument_list|(
literal|"_"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|strings
operator|.
name|length
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|new
name|Locale
argument_list|(
name|strings
index|[
literal|0
index|]
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|new
name|Locale
argument_list|(
name|strings
index|[
literal|0
index|]
argument_list|,
name|strings
index|[
literal|1
index|]
argument_list|)
return|;
case|case
literal|3
case|:
return|return
operator|new
name|Locale
argument_list|(
name|strings
index|[
literal|0
index|]
argument_list|,
name|strings
index|[
literal|1
index|]
argument_list|,
name|strings
index|[
literal|2
index|]
argument_list|)
return|;
default|default:
throw|throw
name|newInternal
argument_list|(
literal|"bad locale string '"
operator|+
name|localeString
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Runs an external application.    *    * @param cmdarray  command and arguments, see {@link ProcessBuilder}    * @param logger    if not null, command and exit status will be logged    * @param appInput  if not null, data will be copied to application's stdin    * @param appOutput if not null, data will be captured from application's    *                  stdout and stderr    * @return application process exit value    * @throws IOException    * @throws InterruptedException    */
specifier|public
specifier|static
name|int
name|runApplication
parameter_list|(
name|String
index|[]
name|cmdarray
parameter_list|,
name|Logger
name|logger
parameter_list|,
name|Reader
name|appInput
parameter_list|,
name|Writer
name|appOutput
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|runAppProcess
argument_list|(
name|newAppProcess
argument_list|(
name|cmdarray
argument_list|)
argument_list|,
name|logger
argument_list|,
name|appInput
argument_list|,
name|appOutput
argument_list|)
return|;
block|}
comment|/**    * Constructs a {@link ProcessBuilder} to run an external application.    *    * @param cmdarray command and arguments.    * @return a ProcessBuilder.    */
specifier|public
specifier|static
name|ProcessBuilder
name|newAppProcess
parameter_list|(
name|String
index|[]
name|cmdarray
parameter_list|)
block|{
comment|// Concatenate quoted words from cmdarray.
comment|// REVIEW mb 2/24/09 Why is this needed?
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cmdarray
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|cmdarray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
name|String
name|fullcmd
init|=
name|buf
operator|.
name|toString
argument_list|()
decl_stmt|;
name|buf
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|new
name|ProcessBuilder
argument_list|(
name|cmdarray
argument_list|)
return|;
block|}
comment|/**    * Runs an external application process.    *    * @param pb        {@link ProcessBuilder} for the application; might be returned by {@link #newAppProcess}.    * @param logger    if not null, command and exit status will be logged here    * @param appInput  if not null, data will be copied to application's stdin    * @param appOutput if not null, data will be captured from application's    *                  stdout and stderr    * @return application process exit value    * @throws IOException    * @throws InterruptedException    */
specifier|public
specifier|static
name|int
name|runAppProcess
parameter_list|(
name|ProcessBuilder
name|pb
parameter_list|,
name|Logger
name|logger
parameter_list|,
name|Reader
name|appInput
parameter_list|,
name|Writer
name|appOutput
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|pb
operator|.
name|redirectErrorStream
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"start process: "
operator|+
name|pb
operator|.
name|command
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Process
name|p
init|=
name|pb
operator|.
name|start
argument_list|()
decl_stmt|;
comment|// Setup the input/output streams to the subprocess.
comment|// The buffering here is arbitrary. Javadocs strongly encourage
comment|// buffering, but the size needed is very dependent on the
comment|// specific application being run, the size of the input
comment|// provided by the caller, and the amount of output expected.
comment|// Since this method is currently used only by unit tests,
comment|// large-ish fixed buffer sizes have been chosen. If this
comment|// method becomes used for something in production, it might
comment|// be better to have the caller provide them as arguments.
if|if
condition|(
name|appInput
operator|!=
literal|null
condition|)
block|{
name|OutputStream
name|out
init|=
operator|new
name|BufferedOutputStream
argument_list|(
name|p
operator|.
name|getOutputStream
argument_list|()
argument_list|,
literal|100
operator|*
literal|1024
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|appInput
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|appOutput
operator|!=
literal|null
condition|)
block|{
name|InputStream
name|in
init|=
operator|new
name|BufferedInputStream
argument_list|(
name|p
operator|.
name|getInputStream
argument_list|()
argument_list|,
literal|100
operator|*
literal|1024
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|in
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|appOutput
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|appOutput
operator|.
name|flush
argument_list|()
expr_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|p
operator|.
name|waitFor
argument_list|()
expr_stmt|;
name|int
name|status
init|=
name|p
operator|.
name|exitValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"exit status="
operator|+
name|status
operator|+
literal|" from "
operator|+
name|pb
operator|.
name|command
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
comment|/**    * Converts a list whose members are automatically down-cast to a given    * type.    *    *<p>If a member of the backing list is not an instanceof<code>E</code>,    * the accessing method (such as {@link List#get}) will throw a {@link    * ClassCastException}.    *    *<p>All modifications are automatically written to the backing list. Not    * synchronized.    *    * @param list  Backing list.    * @param clazz Class to cast to.    * @return A list whose members are of the desired type.    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|cast
parameter_list|(
name|List
argument_list|<
name|?
super|super
name|E
argument_list|>
name|list
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
operator|new
name|CastingList
argument_list|<
name|E
argument_list|>
argument_list|(
name|list
argument_list|,
name|clazz
argument_list|)
return|;
block|}
comment|/**    * Converts a iterator whose members are automatically down-cast to a given    * type.    *    *<p>If a member of the backing iterator is not an instanceof<code>    * E</code>, {@link Iterator#next()}) will throw a {@link    * ClassCastException}.    *    *<p>All modifications are automatically written to the backing iterator.    * Not synchronized.    *    * @param iter  Backing iterator.    * @param clazz Class to cast to.    * @return An iterator whose members are of the desired type.    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Iterator
argument_list|<
name|E
argument_list|>
name|cast
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iter
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|E
name|next
parameter_list|()
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**    * Converts an {@link Iterable} whose members are automatically down-cast to    * a given type.    *    *<p>All modifications are automatically written to the backing iterator.    * Not synchronized.    *    * @param iterable Backing iterable    * @param clazz    Class to cast to    * @return An iterable whose members are of the desired type.    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Iterable
argument_list|<
name|E
argument_list|>
name|cast
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
super|super
name|E
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|cast
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|clazz
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Makes a collection of untyped elements appear as a list of strictly typed    * elements, by filtering out those which are not of the correct type.    *    *<p>The returned object is an {@link Iterable},    * which makes it ideal for use with the 'foreach' construct. For example,    *    *<blockquote><code>List&lt;Number&gt; numbers = Arrays.asList(1, 2, 3.14,    * 4, null, 6E23);<br>    * for (int myInt : filter(numbers, Integer.class)) {<br>    *&nbsp;&nbsp;&nbsp;&nbsp;print(i);<br>    * }</code></blockquote>    *    * will print 1, 2, 4.    *    * @param iterable      Iterable    * @param includeFilter Class whose instances to include    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Iterable
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|iterable
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|includeFilter
parameter_list|)
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Filterator
argument_list|<
name|E
argument_list|>
argument_list|(
name|iterable
operator|.
name|iterator
argument_list|()
argument_list|,
name|includeFilter
argument_list|)
return|;
block|}
block|}
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Collection
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|includeFilter
parameter_list|)
block|{
return|return
operator|new
name|AbstractCollection
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Filterator
argument_list|<
name|E
argument_list|>
argument_list|(
name|collection
operator|.
name|iterator
argument_list|()
argument_list|,
name|includeFilter
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Compute size.  This is expensive, but the value
comment|// collection.size() is not correct since we're
comment|// filtering values.  (Some java.util algorithms
comment|// call next() on the result of iterator() size() times.)
name|int
name|s
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|E
argument_list|>
name|iter
init|=
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|size
operator|=
name|s
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns a subset of a list containing only elements of a given type.    *    *<p>Modifications to the list are NOT written back to the source list.    *    * @param list          List of objects    * @param includeFilter Class to filter for    * @return List of objects of given class (or a subtype)    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|filter
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
argument_list|>
name|list
parameter_list|,
specifier|final
name|Class
argument_list|<
name|E
argument_list|>
name|includeFilter
parameter_list|)
block|{
name|List
argument_list|<
name|E
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|list
control|)
block|{
if|if
condition|(
name|includeFilter
operator|.
name|isInstance
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|includeFilter
operator|.
name|cast
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Converts a {@link Properties} object to a<code>{@link Map}&lt;String,    * String&gt;</code>.    *    *<p>This is necessary because {@link Properties} is a dinosaur class. It    * ought to extend<code>Map&lt;String,String&gt;</code>, but instead    * extends<code>{@link Hashtable}&lt;Object,Object&gt;</code>.    *    *<p>Typical usage, to iterate over a {@link Properties}:    *    *<blockquote>    *<code>    * Properties properties;<br>    * for (Map.Entry&lt;String, String&gt; entry =    * Util.toMap(properties).entrySet()) {<br>    * println("key=" + entry.getKey() + ", value=" + entry.getValue());<br>    * }    *</code>    *</blockquote>    */
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|toMap
parameter_list|(
specifier|final
name|Properties
name|properties
parameter_list|)
block|{
return|return
operator|(
name|Map
operator|)
name|properties
return|;
block|}
comment|/**    * Returns a hashmap with given contents.    *    *<p>Use this method in initializers. Type parameters are inferred from    * context, and the contents are initialized declaratively. For example,    *    *<blockquote><code>Map&lt;String, Integer&gt; population =<br>    *&nbsp;&nbsp;Olap4jUtil.mapOf(<br>    *&nbsp;&nbsp;&nbsp;&nbsp;"UK", 65000000,<br>    *&nbsp;&nbsp;&nbsp;&nbsp;"USA", 300000000);</code></blockquote>    *    * @param key       First key    * @param value     First value    * @param keyValues Second and sequent key/value pairs    * @param<K>       Key type    * @param<V>       Value type    * @return Map with given contents    */
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|mapOf
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|Object
modifier|...
name|keyValues
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|1
operator|+
name|keyValues
operator|.
name|length
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyValues
operator|.
name|length
condition|;
control|)
block|{
comment|//noinspection unchecked
name|map
operator|.
name|put
argument_list|(
operator|(
name|K
operator|)
name|keyValues
index|[
name|i
operator|++
index|]
argument_list|,
operator|(
name|V
operator|)
name|keyValues
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
comment|/**    * Returns an exception indicating that we didn't expect to find this    * enumeration here.    *    * @param value Enumeration value which was not expected    * @return an error, to be thrown    */
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Enum
argument_list|<
name|E
argument_list|>
parameter_list|>
name|Error
name|unexpected
parameter_list|(
name|E
name|value
parameter_list|)
block|{
return|return
operator|new
name|AssertionError
argument_list|(
literal|"Was not expecting value '"
operator|+
name|value
operator|+
literal|"' for enumeration '"
operator|+
name|value
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' in this context"
argument_list|)
return|;
block|}
comment|/**    * Creates a map of the values of an enumeration by name.    *    * @param clazz Enumeration class    * @return map of values    */
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|Enum
argument_list|<
name|T
argument_list|>
parameter_list|>
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|enumConstants
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
block|{
specifier|final
name|T
index|[]
name|ts
init|=
name|clazz
operator|.
name|getEnumConstants
argument_list|()
decl_stmt|;
if|if
condition|(
name|ts
operator|==
literal|null
condition|)
block|{
comment|// not an enum type
return|return
literal|null
return|;
block|}
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|ts
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|t
operator|.
name|name
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Returns the value of an enumeration with a particular name.    *    *<p>Similar to {@link Enum#valueOf(Class, String)}, but returns {@code    * null} rather than throwing {@link IllegalArgumentException}.    *    * @param clazz Enum class    * @param name  Name of enum constant    * @param<T>   Enum class type    * @return Enum constant or null    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|}
argument_list|)
specifier|public
specifier|static
specifier|synchronized
parameter_list|<
name|T
extends|extends
name|Enum
argument_list|<
name|T
argument_list|>
parameter_list|>
name|T
name|enumVal
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
operator|(
name|T
operator|)
name|ENUM_CONSTANTS
operator|.
name|getUnchecked
argument_list|(
name|clazz
argument_list|)
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**    * Creates a list that returns every {@code n}th element of a list,    * starting at element {@code k}.    *    *<p>It is OK if the list is empty or its size is not a multiple of    * {@code n}.</p>    *    *<p>For instance, {@code quotientList(list, 2, 0)} returns the even    * elements of a list, and {@code quotientList(list, 2, 1)} returns the odd    * elements. Those lists are the same length only if list has even size.</p>    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|quotientList
parameter_list|(
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
specifier|final
name|int
name|n
parameter_list|,
specifier|final
name|int
name|k
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<=
literal|0
operator|||
name|k
operator|<
literal|0
operator|||
name|k
operator|>=
name|n
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"n must be positive; k must be between 0 and n - 1"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|size
init|=
operator|(
name|list
operator|.
name|size
argument_list|()
operator|+
name|n
operator|-
name|k
operator|-
literal|1
operator|)
operator|/
name|n
decl_stmt|;
return|return
operator|new
name|AbstractList
argument_list|<
name|E
argument_list|>
argument_list|()
block|{
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|index
operator|*
name|n
operator|+
name|k
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
block|}
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|first
parameter_list|(
name|T
name|t0
parameter_list|,
name|T
name|t1
parameter_list|)
block|{
return|return
name|t0
operator|!=
literal|null
condition|?
name|t0
else|:
name|t1
return|;
block|}
comment|/** Returns the last element of a list.    *    * @throws java.lang.IndexOutOfBoundsException if the list is empty    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|E
name|last
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/** Returns every element of a list but its last element. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|skipLast
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|skipLast
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/** Returns every element of a list but its last {@code n} elements. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|skipLast
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|list
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|list
operator|.
name|size
argument_list|()
operator|-
name|n
argument_list|)
return|;
block|}
comment|/** Returns the last {@code n} elements of a list. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|last
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|list
operator|.
name|subList
argument_list|(
name|list
operator|.
name|size
argument_list|()
operator|-
name|n
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/** Returns all but the first element of a list. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|skip
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|skip
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/** Returns all but the first {@code n} elements of a list. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|skip
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|fromIndex
parameter_list|)
block|{
return|return
name|list
operator|.
name|subList
argument_list|(
name|fromIndex
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|range
parameter_list|(
specifier|final
name|int
name|start
parameter_list|,
specifier|final
name|int
name|end
parameter_list|)
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|end
operator|-
name|start
return|;
block|}
specifier|public
name|Integer
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|start
operator|+
name|index
return|;
block|}
block|}
return|;
block|}
comment|/**    * Converts an underscore-separated name into a camelCase name.    * For example, {@code uncamel("MY_JDBC_DRIVER")} returns "myJdbcDriver".    */
specifier|public
specifier|static
name|String
name|toCamelCase
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|nextUpper
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|name
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
block|{
name|nextUpper
operator|=
name|i
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nextUpper
operator|==
name|i
condition|)
block|{
name|c
operator|=
name|Character
operator|.
name|toUpperCase
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|Character
operator|.
name|toLowerCase
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Converts a camelCase name into an upper-case underscore-separated name.    * For example, {@code camelToUpper("myJdbcDriver")} returns    * "MY_JDBC_DRIVER".    */
specifier|public
specifier|static
name|String
name|camelToUpper
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|name
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isUpperCase
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|Character
operator|.
name|toUpperCase
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns whether the elements of {@code list} are distinct.    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|isDistinct
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|firstDuplicate
argument_list|(
name|list
argument_list|)
operator|<
literal|0
return|;
block|}
comment|/**    * Returns the ordinal of the first element in the list which is equal to a    * previous element in the list.    *    *<p>For example,<code>firstDuplicate(Arrays.asList("a", "b", "c", "b",    * "a"))</code> returns 3, the ordinal of the 2nd "b".    *    * @param list List    * @return Ordinal of first duplicate, or -1 if not found    */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|int
name|firstDuplicate
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|2
condition|)
block|{
comment|// Lists of size 0 and 1 are always distinct.
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|size
operator|<
literal|15
condition|)
block|{
comment|// For smaller lists, avoid the overhead of creating a set. Threshold
comment|// determined empirically using UtilTest.testIsDistinctBenchmark.
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|E
name|e
init|=
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|E
name|e1
init|=
name|list
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|equal
argument_list|(
name|e
argument_list|,
name|e1
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
specifier|final
name|Map
argument_list|<
name|E
argument_list|,
name|Object
argument_list|>
name|set
init|=
operator|new
name|HashMap
argument_list|<
name|E
argument_list|,
name|Object
argument_list|>
argument_list|(
name|size
argument_list|)
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|list
control|)
block|{
if|if
condition|(
name|set
operator|.
name|put
argument_list|(
name|e
argument_list|,
literal|""
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
name|set
operator|.
name|size
argument_list|()
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
specifier|public
specifier|static
name|int
name|match2
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|strings
parameter_list|,
name|String
name|name
parameter_list|,
name|boolean
name|caseSensitive1
parameter_list|)
block|{
if|if
condition|(
name|caseSensitive1
condition|)
block|{
return|return
name|strings
operator|.
name|indexOf
argument_list|(
name|name
argument_list|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strings
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|s
init|=
name|strings
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
specifier|public
specifier|static
name|boolean
name|match
parameter_list|(
name|boolean
name|caseSensitive
parameter_list|,
name|String
name|name1
parameter_list|,
name|String
name|name0
parameter_list|)
block|{
return|return
name|caseSensitive
condition|?
name|name0
operator|.
name|equals
argument_list|(
name|name1
argument_list|)
else|:
name|name0
operator|.
name|equalsIgnoreCase
argument_list|(
name|name1
argument_list|)
return|;
block|}
comment|/** Returns whether one list is a prefix of another. */
specifier|public
specifier|static
parameter_list|<
name|E
parameter_list|>
name|boolean
name|startsWith
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list0
parameter_list|,
name|List
argument_list|<
name|E
argument_list|>
name|list1
parameter_list|)
block|{
return|return
name|list0
operator|.
name|equals
argument_list|(
name|list1
argument_list|)
operator|||
name|list0
operator|.
name|size
argument_list|()
operator|>
name|list1
operator|.
name|size
argument_list|()
operator|&&
name|list0
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|list1
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|list1
argument_list|)
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Exception used to interrupt a tree walk of any kind.    */
specifier|public
specifier|static
class|class
name|FoundOne
extends|extends
name|ControlFlowException
block|{
specifier|private
specifier|final
name|Object
name|node
decl_stmt|;
comment|/** Singleton instance. Can be used if you don't care about node. */
specifier|public
specifier|static
specifier|final
name|FoundOne
name|NULL
init|=
operator|new
name|FoundOne
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|public
name|FoundOne
parameter_list|(
name|Object
name|node
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
block|}
specifier|public
name|Object
name|getNode
parameter_list|()
block|{
return|return
name|node
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End Util.java
end_comment

end_unit

