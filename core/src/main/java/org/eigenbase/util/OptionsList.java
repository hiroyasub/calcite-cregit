begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Command-line option parser.  *  *<p>For example, given the options</p>  *  *<table>  *<tr>  *<th>Short name</td>  *<th>Long name</td>  *<th>Type</td>  *<th>Default</td>  *<th>Anonymous</td>  *</tr>  *<tr>  *<td>v</td>  *<td>verbose</td>  *<td>Boolean</td>  *<td>true</td>  *<td>false</td>  *</tr>  *<tr>  *<td>f</td>  *<td>&nbsp;</td>  *<td>String</td>  *<td>&nbsp;</td>  *<td>true</td>  *</tr>  *<tr>  *<td>c</td>  *<td>count</td>  *<td>Number</td>  *<td>&nbsp;</td>  *<td>false</td>  *</tr>  *</table>  *  *<p>and the command line  *  *<pre>-v count=5 Foo.txt</pre>  *  * the parser will set<tt>verbose = true</tt>,<tt>count = 5</tt>, and<tt>file  * = Foo.txt</tt>.</p>  *  *<p>Options can generally be specified using<dfn>flag syntax</dfn> (for  * example<tt>-v</tt> or<tt>-count 5</tt>) or<dfn>property synax</dfn> (for  * example<tt>verbose=true</tt> or<tt>count=5</tt>).</p>  *  *<p>Boolean options do not have a value following the flag.<tt>-v</tt> means  * the same as<tt>verbose=true</tt>, and<tt>+v</tt> means the same as<tt>  * verbose=false</tt>.</p>  *  *<p>One of the options in a list can be<em>anonymous</em>. Arguments which  * are not flagged with an option name are assumed to be for this option.<br>  *<em>Defining options</em><br>  *</p>  *  *<p>You first define what options are available. Options all implement  * interface {@link Option}. You can use one of the built-in option types (  * {@link StringOption}, {@link NumberOption}, {@link BooleanOption}, {@link  * EnumeratedOption}) or write one of your own.<br>  *<em>Parsing options</em><br>  *</p>  *  *<p>Once you have defined the options, you can parse an argument list by  * calling {@link #parse}.</p>  *  *<p>There are two ways of handling options. By default, when you parse an  * array of command-line parameters, the values of those parameters are stored  * in the options themselves. Alternatively, you can specify a {@link  * OptionsList.OptionHandler handler}.</p>  */
end_comment

begin_class
specifier|public
class|class
name|OptionsList
block|{
comment|//~ Instance fields --------------------------------------------------------
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|Group
argument_list|>
name|optionGroups
init|=
operator|new
name|ArrayList
argument_list|<
name|Group
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|Option
argument_list|>
name|options
init|=
operator|new
name|ArrayList
argument_list|<
name|Option
argument_list|>
argument_list|()
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**      * Creates an options list with no options.      */
specifier|public
name|OptionsList
parameter_list|()
block|{
block|}
comment|/**      * Creates an options list with an array of options.      */
specifier|public
name|OptionsList
parameter_list|(
name|Option
index|[]
name|options
parameter_list|)
block|{
for|for
control|(
name|Option
name|option
range|:
name|options
control|)
block|{
name|this
operator|.
name|options
operator|.
name|add
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|public
name|void
name|add
parameter_list|(
name|Option
name|option
parameter_list|)
block|{
name|options
operator|.
name|add
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tells the options list that the given options are mutually exclusive.      * This means that at most one of the given options can be specified.      *      *<p>To create a set mutually exclusive options, specify minCount = 0 or 1,      * maxCount = 1. To create a set of mutually inclusive options, specify      * minCount = 1, maxCount = -1.</p>      *      * @param options List of mutually exclusive options      * @param minCount Minimum number of these options which must be specified.      * @param maxCount Maximum number of these options which must be specified.      *      * @pre None of the options must be mandatory.      */
specifier|public
name|void
name|constrain
parameter_list|(
name|Option
index|[]
name|options
parameter_list|,
name|int
name|minCount
parameter_list|,
name|int
name|maxCount
parameter_list|)
block|{
for|for
control|(
name|Option
name|option
range|:
name|options
control|)
block|{
if|if
condition|(
name|option
operator|.
name|required
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"!options[i].required"
argument_list|)
throw|;
block|}
block|}
name|optionGroups
operator|.
name|add
argument_list|(
operator|new
name|Group
argument_list|(
name|minCount
argument_list|,
name|maxCount
argument_list|,
name|options
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|parse
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
specifier|final
name|Option
index|[]
name|options
init|=
name|toArray
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Option
argument_list|>
name|usedOptions
init|=
operator|new
name|HashSet
argument_list|<
name|Option
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Option
name|option
range|:
name|options
control|)
block|{
name|option
operator|.
name|setHandler
argument_list|(
operator|new
name|OptionHandler
argument_list|()
block|{
specifier|public
name|void
name|invalidValue
parameter_list|(
name|Option
name|option
parameter_list|,
name|String
name|value
parameter_list|)
block|{
block|}
specifier|public
name|void
name|set
parameter_list|(
name|Option
name|option
parameter_list|,
name|Object
name|value
parameter_list|,
name|boolean
name|explicit
parameter_list|)
block|{
name|usedOptions
operator|.
name|add
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|Option
name|option
range|:
name|options
control|)
block|{
if|if
condition|(
name|usedOptions
operator|.
name|contains
argument_list|(
name|option
argument_list|)
condition|)
block|{
comment|// Each option can only be used once.
continue|continue;
block|}
name|int
name|k
init|=
name|option
operator|.
name|match
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|>
name|i
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|// Check mandatory options.
for|for
control|(
name|Option
name|option
range|:
name|options
control|)
block|{
if|if
condition|(
operator|!
name|option
operator|.
name|required
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|usedOptions
operator|.
name|contains
argument_list|(
name|option
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Mandatory option '"
operator|+
name|option
operator|.
name|getName
argument_list|()
operator|+
literal|"' was not specified"
argument_list|)
throw|;
block|}
block|}
comment|// Check inclusivity/exclusivity.
for|for
control|(
name|Group
name|group
range|:
name|optionGroups
control|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|options
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|Option
name|option
init|=
name|group
operator|.
name|options
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|usedOptions
operator|.
name|contains
argument_list|(
name|option
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|>
name|group
operator|.
name|maxCount
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"More than "
operator|+
name|group
operator|.
name|maxCount
operator|+
literal|" of the following options were specified: "
operator|+
name|group
operator|.
name|description
argument_list|)
throw|;
block|}
if|if
condition|(
name|count
operator|<
name|group
operator|.
name|minCount
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Fewer than "
operator|+
name|group
operator|.
name|minCount
operator|+
literal|" of the following options were specified: "
operator|+
name|group
operator|.
name|description
argument_list|)
throw|;
block|}
block|}
comment|// Set options to their default value if they have a default value and
comment|// have not been seen while parsing.
for|for
control|(
name|Option
name|option
range|:
name|options
control|)
block|{
if|if
condition|(
operator|!
name|usedOptions
operator|.
name|contains
argument_list|(
name|option
argument_list|)
operator|&&
operator|(
name|option
operator|.
name|defaultValue
operator|!=
literal|null
operator|)
condition|)
block|{
name|option
operator|.
name|set
argument_list|(
name|option
operator|.
name|defaultValue
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|Option
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|options
operator|.
name|toArray
argument_list|(
operator|new
name|Option
index|[
name|options
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|//~ Inner Interfaces -------------------------------------------------------
comment|/**      * Handles the event of setting options. One implementation stores options      * in a property list; another implementation uses reflection.      */
interface|interface
name|OptionHandler
block|{
name|void
name|invalidValue
parameter_list|(
name|Option
name|option
parameter_list|,
name|String
name|value
parameter_list|)
function_decl|;
name|void
name|set
parameter_list|(
name|Option
name|option
parameter_list|,
name|Object
name|value
parameter_list|,
name|boolean
name|isExplicit
parameter_list|)
function_decl|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
specifier|public
class|class
name|BasicOptionHandler
implements|implements
name|OptionHandler
block|{
specifier|public
name|void
name|invalidValue
parameter_list|(
name|Option
name|option
parameter_list|,
name|String
name|value
parameter_list|)
block|{
block|}
specifier|public
name|void
name|set
parameter_list|(
name|Option
name|option
parameter_list|,
name|Object
name|value
parameter_list|,
name|boolean
name|isExplicit
parameter_list|)
block|{
block|}
block|}
comment|/**      * Definition of a command-line option, including its short and long names,      * description, default value, and whether it is mandatory.      *      *<p>You can optionally provide a {@link OptionsList.OptionHandler handler}      * to handle events such as the option receiving a value, or a value being      * of the wrong format. If you do not provide a handler, the value is stored      * inside the option, and can be retrieved via</p>      */
specifier|public
specifier|static
specifier|abstract
class|class
name|Option
block|{
comment|/**          * Holds the runtime value of this option. Set by the default          * implementation {@link #set}. If the user has supplied an {@link          * OptionHandler}, or overridden the<code>set</code> method, this field          * is not assigned.          *          *<p>Several derived classes have typesafe methods to access this          * field: see {@link OptionsList.BooleanOption#booleanValue}, {@link          * OptionsList.StringOption#stringValue}, {@link          * OptionsList.NumberOption#intValue}, {@link          * OptionsList.NumberOption#doubleValue}.</p>          */
specifier|protected
name|Object
name|value
decl_stmt|;
comment|/**          * Default value of option, or null if there is no default value.          */
specifier|private
specifier|final
name|Object
name|defaultValue
decl_stmt|;
specifier|private
specifier|final
name|String
name|description
decl_stmt|;
comment|/**          * Short name of option, used as a flag, e.g. "c".          */
specifier|private
specifier|final
name|String
name|flag
decl_stmt|;
comment|/**          * Long name of option, e.g. "color".          */
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|required
decl_stmt|;
specifier|private
name|List
argument_list|<
name|OptionHandler
argument_list|>
name|handlers
init|=
operator|new
name|ArrayList
argument_list|<
name|OptionHandler
argument_list|>
argument_list|()
decl_stmt|;
name|Option
parameter_list|(
name|String
name|flag
parameter_list|,
name|String
name|option
parameter_list|,
name|String
name|description
parameter_list|,
name|boolean
name|required
parameter_list|,
name|boolean
name|anonymous
parameter_list|,
name|Object
name|defaultValue
parameter_list|)
block|{
name|this
operator|.
name|flag
operator|=
name|flag
expr_stmt|;
name|name
operator|=
name|option
expr_stmt|;
name|this
operator|.
name|required
operator|=
name|required
expr_stmt|;
name|this
operator|.
name|defaultValue
operator|=
name|defaultValue
expr_stmt|;
name|this
operator|.
name|description
operator|=
name|description
expr_stmt|;
block|}
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
return|return
name|description
return|;
block|}
specifier|public
name|void
name|setHandler
parameter_list|(
name|OptionHandler
name|handler
parameter_list|)
block|{
name|this
operator|.
name|handlers
operator|.
name|add
argument_list|(
name|handler
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
operator|!=
literal|null
condition|?
name|name
else|:
name|flag
return|;
block|}
comment|/**          * Returns the value of this option for the most recent call to {@link          * #parse}.          *          *<p>If you specified an {@link OptionsList.OptionHandler}, this value          * will not be set. Also note that this method is unsafe if the same          * options are shared between multiple threads.</p>          *          *<p>Some derived classes have methods which return the same          * information in a typesafe manner. For example: {@link          * OptionsList.BooleanOption#booleanValue}, {@link          * OptionsList.NumberOption#intValue}.</p>          */
specifier|public
name|Object
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
comment|/**          * Tries to apply this option to the<tt>i</tt>th member of          *<tt>args</tt>.          *          * @param args Argument list          * @param i Offset of argument in argument list          *          * @return If matched, the offset of the argument after the last one          * matched, otherwise<tt>i</tt>.          */
specifier|public
name|int
name|match
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|int
name|i
parameter_list|)
block|{
specifier|final
name|String
name|arg
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|startsWith
argument_list|(
literal|"-"
argument_list|)
operator|&&
operator|(
name|flag
operator|!=
literal|null
operator|)
operator|&&
name|arg
operator|.
name|equals
argument_list|(
literal|"-"
operator|+
name|flag
argument_list|)
condition|)
block|{
if|if
condition|(
name|this
operator|instanceof
name|BooleanOption
condition|)
block|{
comment|// e.g. "-nolog"
name|set
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|i
operator|+
literal|1
return|;
block|}
if|if
condition|(
name|i
operator|<
name|args
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// e.g. "-threads 5"
name|readArg
argument_list|(
name|args
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|i
operator|+
literal|2
return|;
block|}
block|}
if|if
condition|(
operator|(
name|name
operator|!=
literal|null
operator|)
operator|&&
name|arg
operator|.
name|startsWith
argument_list|(
name|name
operator|+
literal|"="
argument_list|)
condition|)
block|{
comment|// e.g. "threads=5"
name|readArg
argument_list|(
name|arg
operator|.
name|substring
argument_list|(
operator|(
name|name
operator|+
literal|"="
operator|)
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
operator|+
literal|1
return|;
block|}
return|return
name|i
return|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|Object
name|value
parameter_list|,
name|boolean
name|isExplicit
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
for|for
control|(
name|OptionHandler
name|handler
range|:
name|handlers
control|)
block|{
name|handler
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|value
argument_list|,
name|isExplicit
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Converts an argument to the correct value type, and acts on the          * value.          *          *<p>What action is taken depends upon whether the value is valid for          * this argument type, and whether there is a handler. If there is a          * handler, this method calls either {@link          * OptionsList.OptionHandler#set} or {@link          * OptionsList.OptionHandler#invalidValue}. If there is no handler, the          * method should execute a reasonable default action like assigning to a          * field via reflection.</p>          *          * @param arg Argument          */
specifier|protected
specifier|abstract
name|void
name|readArg
parameter_list|(
name|String
name|arg
parameter_list|)
function_decl|;
comment|/**          * Called by the parser when an argument is not a valid value for this          * type of argument.          *          *<p>For example, if "flag" is a boolean argument and they specify          * "flag=oui" on the command-line, the parser will call<code>          * valueError("oui")</code>.</p>          *          *<p>The default implementation calls {@link          * OptionsList.OptionHandler#invalidValue} if there is a handler, or          * prints a message to {@link System#out} if there is not. Derived          * option classes can override this method.</p>          *          * @param arg String value which is supposed to match the parameter, but          * doesn't.          */
specifier|protected
name|void
name|valueError
parameter_list|(
name|String
name|arg
parameter_list|)
block|{
for|for
control|(
name|OptionHandler
name|handler
range|:
name|handlers
control|)
block|{
name|handler
operator|.
name|invalidValue
argument_list|(
name|this
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|BooleanOption
extends|extends
name|Option
block|{
specifier|public
name|BooleanOption
parameter_list|(
name|String
name|flag
parameter_list|,
name|String
name|option
parameter_list|,
name|String
name|description
parameter_list|,
name|boolean
name|required
parameter_list|,
name|boolean
name|anonymous
parameter_list|,
name|boolean
name|defaultValue
parameter_list|)
block|{
name|super
argument_list|(
name|flag
argument_list|,
name|option
argument_list|,
name|description
argument_list|,
name|required
argument_list|,
name|anonymous
argument_list|,
name|Boolean
operator|.
name|valueOf
argument_list|(
name|defaultValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|booleanValue
parameter_list|()
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
operator|.
name|booleanValue
argument_list|()
return|;
block|}
specifier|protected
name|void
name|readArg
parameter_list|(
name|String
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|set
argument_list|(
name|Boolean
operator|.
name|TRUE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|arg
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|set
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|valueError
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|EnumeratedOption
extends|extends
name|Option
block|{
specifier|private
specifier|final
name|EnumeratedValues
name|enumeration
decl_stmt|;
specifier|public
name|EnumeratedOption
parameter_list|(
name|String
name|flag
parameter_list|,
name|String
name|option
parameter_list|,
name|String
name|description
parameter_list|,
name|boolean
name|required
parameter_list|,
name|boolean
name|anonymous
parameter_list|,
name|EnumeratedValues
operator|.
name|Value
name|defaultValue
parameter_list|,
name|EnumeratedValues
name|enumeration
parameter_list|)
block|{
name|super
argument_list|(
name|flag
argument_list|,
name|option
argument_list|,
name|description
argument_list|,
name|required
argument_list|,
name|anonymous
argument_list|,
name|defaultValue
argument_list|)
expr_stmt|;
name|this
operator|.
name|enumeration
operator|=
name|enumeration
expr_stmt|;
block|}
specifier|protected
name|void
name|readArg
parameter_list|(
name|String
name|arg
parameter_list|)
block|{
specifier|final
name|EnumeratedValues
operator|.
name|Value
name|value
init|=
name|enumeration
operator|.
name|getValue
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|valueError
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set
argument_list|(
name|value
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|NumberOption
extends|extends
name|Option
block|{
specifier|public
name|NumberOption
parameter_list|(
name|String
name|flag
parameter_list|,
name|String
name|option
parameter_list|,
name|String
name|description
parameter_list|,
name|boolean
name|required
parameter_list|,
name|boolean
name|anonymous
parameter_list|,
name|Number
name|defaultValue
parameter_list|)
block|{
name|super
argument_list|(
name|flag
argument_list|,
name|option
argument_list|,
name|description
argument_list|,
name|required
argument_list|,
name|anonymous
argument_list|,
name|defaultValue
argument_list|)
expr_stmt|;
block|}
specifier|public
name|double
name|doubleValue
parameter_list|()
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
specifier|public
name|int
name|intValue
parameter_list|()
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
specifier|protected
name|void
name|readArg
parameter_list|(
name|String
name|arg
parameter_list|)
block|{
try|try
block|{
specifier|final
name|long
name|value
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|set
argument_list|(
operator|new
name|Long
argument_list|(
name|value
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
try|try
block|{
specifier|final
name|double
name|doubleValue
init|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|set
argument_list|(
operator|new
name|Double
argument_list|(
name|doubleValue
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e1
parameter_list|)
block|{
name|valueError
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|StringOption
extends|extends
name|Option
block|{
specifier|public
name|StringOption
parameter_list|(
name|String
name|flag
parameter_list|,
name|String
name|option
parameter_list|,
name|String
name|description
parameter_list|,
name|boolean
name|required
parameter_list|,
name|boolean
name|anonymous
parameter_list|,
name|String
name|defaultValue
parameter_list|)
block|{
name|super
argument_list|(
name|flag
argument_list|,
name|option
argument_list|,
name|description
argument_list|,
name|required
argument_list|,
name|anonymous
argument_list|,
name|defaultValue
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|stringValue
parameter_list|()
block|{
return|return
operator|(
name|String
operator|)
name|value
return|;
block|}
specifier|protected
name|void
name|readArg
parameter_list|(
name|String
name|arg
parameter_list|)
block|{
name|set
argument_list|(
name|arg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|Group
block|{
specifier|private
specifier|final
name|String
name|description
decl_stmt|;
specifier|private
specifier|final
name|Option
index|[]
name|options
decl_stmt|;
specifier|private
specifier|final
name|int
name|maxCount
decl_stmt|;
specifier|private
specifier|final
name|int
name|minCount
decl_stmt|;
name|Group
parameter_list|(
name|int
name|maxCount
parameter_list|,
name|int
name|minCount
parameter_list|,
name|Option
index|[]
name|options
parameter_list|)
block|{
name|this
operator|.
name|maxCount
operator|=
name|maxCount
expr_stmt|;
name|this
operator|.
name|minCount
operator|=
name|minCount
expr_stmt|;
name|this
operator|.
name|options
operator|=
name|options
expr_stmt|;
comment|// derive description
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"{"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|this
operator|.
name|options
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|Option
name|option
init|=
name|this
operator|.
name|options
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|option
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|description
operator|=
name|buf
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End OptionsList.java
end_comment

end_unit

