begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|materialize
package|;
end_package

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|Schemas
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|MaterializedViewTable
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|StarTable
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|jdbc
operator|.
name|OptiqPrepare
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|jdbc
operator|.
name|OptiqSchema
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|util
operator|.
name|graph
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlSelect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|mapping
operator|.
name|IntPair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Structure that allows materialized views based upon a star schema to be  * recognized and recommended.  */
end_comment

begin_class
specifier|public
class|class
name|Lattice
block|{
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Node
argument_list|>
name|nodes
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|columns
decl_stmt|;
specifier|private
name|Lattice
parameter_list|(
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
parameter_list|)
block|{
name|this
operator|.
name|nodes
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
comment|// Validate that nodes form a tree; each node except the first references
comment|// a predecessor.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
assert|assert
name|node
operator|.
name|parent
operator|==
literal|null
assert|;
block|}
else|else
block|{
assert|assert
name|nodes
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
operator|.
name|contains
argument_list|(
name|node
operator|.
name|parent
argument_list|)
assert|;
block|}
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|node
operator|.
name|scan
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|name
range|:
name|node
operator|.
name|scan
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|node
operator|.
name|alias
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|columns
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|/** Creates a Lattice. */
specifier|public
specifier|static
name|Lattice
name|create
parameter_list|(
name|OptiqSchema
name|schema
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
name|OptiqPrepare
operator|.
name|ConvertResult
name|parsed
init|=
name|Schemas
operator|.
name|convert
argument_list|(
name|MaterializedViewTable
operator|.
name|MATERIALIZATION_CONNECTION
argument_list|,
name|schema
argument_list|,
name|schema
operator|.
name|path
argument_list|(
literal|null
argument_list|)
argument_list|,
name|sql
argument_list|)
decl_stmt|;
comment|// Walk the join tree.
name|List
argument_list|<
name|RelNode
argument_list|>
name|relNodes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|int
index|[]
index|[]
argument_list|>
name|tempLinks
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|populate
argument_list|(
name|relNodes
argument_list|,
name|tempLinks
argument_list|,
name|parsed
operator|.
name|relNode
argument_list|)
expr_stmt|;
comment|// Get aliases.
name|List
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|populateAliases
argument_list|(
operator|(
operator|(
name|SqlSelect
operator|)
name|parsed
operator|.
name|sqlNode
operator|)
operator|.
name|getFrom
argument_list|()
argument_list|,
name|aliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Build a graph.
specifier|final
name|DirectedGraph
argument_list|<
name|RelNode
argument_list|,
name|Edge
argument_list|>
name|graph
init|=
name|DefaultDirectedGraph
operator|.
name|create
argument_list|(
name|Edge
operator|.
name|FACTORY
argument_list|)
decl_stmt|;
for|for
control|(
name|RelNode
name|node
range|:
name|relNodes
control|)
block|{
name|graph
operator|.
name|addVertex
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
index|[]
index|[]
name|tempLink
range|:
name|tempLinks
control|)
block|{
specifier|final
name|RelNode
name|source
init|=
name|relNodes
operator|.
name|get
argument_list|(
name|tempLink
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|target
init|=
name|relNodes
operator|.
name|get
argument_list|(
name|tempLink
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|Edge
name|edge
init|=
name|graph
operator|.
name|getEdge
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|edge
operator|==
literal|null
condition|)
block|{
name|edge
operator|=
name|graph
operator|.
name|addEdge
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|edge
operator|.
name|pairs
operator|.
name|add
argument_list|(
name|IntPair
operator|.
name|of
argument_list|(
name|tempLink
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|tempLink
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Convert the graph into a tree of nodes, each connected to a parent and
comment|// with a join condition to that parent.
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|Node
name|previous
init|=
literal|null
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Node
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newIdentityHashMap
argument_list|()
decl_stmt|;
name|int
name|previousColumn
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelNode
name|relNode
range|:
name|TopologicalOrderIterator
operator|.
name|of
argument_list|(
name|graph
argument_list|)
control|)
block|{
specifier|final
name|List
argument_list|<
name|Edge
argument_list|>
name|edges
init|=
name|graph
operator|.
name|getInwardEdges
argument_list|(
name|relNode
argument_list|)
decl_stmt|;
name|Node
name|node
decl_stmt|;
specifier|final
name|int
name|column
init|=
name|previousColumn
operator|+
name|relNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|previous
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|edges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"root node must not have relationships: "
operator|+
name|relNode
argument_list|)
throw|;
block|}
name|node
operator|=
operator|new
name|Node
argument_list|(
operator|(
name|TableAccessRelBase
operator|)
name|relNode
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|previousColumn
argument_list|,
name|column
argument_list|,
name|aliases
operator|.
name|get
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|edges
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"child node must have precisely one parent: "
operator|+
name|relNode
argument_list|)
throw|;
block|}
specifier|final
name|Edge
name|edge
init|=
name|edges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|node
operator|=
operator|new
name|Node
argument_list|(
operator|(
name|TableAccessRelBase
operator|)
name|relNode
argument_list|,
name|map
operator|.
name|get
argument_list|(
name|edge
operator|.
name|getSource
argument_list|()
argument_list|)
argument_list|,
name|edge
operator|.
name|pairs
argument_list|,
name|previousColumn
argument_list|,
name|column
argument_list|,
name|aliases
operator|.
name|get
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|relNode
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|previous
operator|=
name|node
expr_stmt|;
name|previousColumn
operator|=
name|column
expr_stmt|;
block|}
return|return
operator|new
name|Lattice
argument_list|(
name|nodes
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|populateAliases
parameter_list|(
name|SqlNode
name|from
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|,
name|String
name|current
parameter_list|)
block|{
if|if
condition|(
name|from
operator|instanceof
name|SqlJoin
condition|)
block|{
name|SqlJoin
name|join
init|=
operator|(
name|SqlJoin
operator|)
name|from
decl_stmt|;
name|populateAliases
argument_list|(
name|join
operator|.
name|getLeft
argument_list|()
argument_list|,
name|aliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|populateAliases
argument_list|(
name|join
operator|.
name|getRight
argument_list|()
argument_list|,
name|aliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|from
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AS
condition|)
block|{
name|populateAliases
argument_list|(
name|SqlUtil
operator|.
name|stripAs
argument_list|(
name|from
argument_list|)
argument_list|,
name|aliases
argument_list|,
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|from
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|current
operator|=
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|from
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|aliases
operator|.
name|add
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|populate
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|nodes
parameter_list|,
name|List
argument_list|<
name|int
index|[]
index|[]
argument_list|>
name|tempLinks
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|rel
operator|instanceof
name|ProjectRel
condition|)
block|{
return|return
name|populate
argument_list|(
name|nodes
argument_list|,
name|tempLinks
argument_list|,
operator|(
operator|(
name|ProjectRel
operator|)
name|rel
operator|)
operator|.
name|getChild
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|TableAccessRelBase
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|JoinRel
condition|)
block|{
name|JoinRel
name|join
init|=
operator|(
name|JoinRel
operator|)
name|rel
decl_stmt|;
if|if
condition|(
name|join
operator|.
name|getJoinType
argument_list|()
operator|!=
name|JoinRelType
operator|.
name|INNER
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"only inner join allowed, but got "
operator|+
name|join
operator|.
name|getJoinType
argument_list|()
argument_list|)
throw|;
block|}
name|populate
argument_list|(
name|nodes
argument_list|,
name|tempLinks
argument_list|,
name|join
operator|.
name|getLeft
argument_list|()
argument_list|)
expr_stmt|;
name|populate
argument_list|(
name|nodes
argument_list|,
name|tempLinks
argument_list|,
name|join
operator|.
name|getRight
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|RexNode
name|rex
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|join
operator|.
name|getCondition
argument_list|()
argument_list|)
control|)
block|{
name|tempLinks
operator|.
name|add
argument_list|(
name|grab
argument_list|(
name|nodes
argument_list|,
name|rex
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid node type "
operator|+
name|rel
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" in lattice query"
argument_list|)
throw|;
block|}
comment|/** Converts an "t1.c1 = t2.c2" expression into two (input, field) pairs. */
specifier|private
specifier|static
name|int
index|[]
index|[]
name|grab
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|leaves
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
switch|switch
condition|(
name|rex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"only equi-join allowed"
argument_list|)
throw|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
return|return
operator|new
name|int
index|[]
index|[]
block|{
name|inputField
argument_list|(
name|leaves
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
name|inputField
argument_list|(
name|leaves
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
block|}
return|;
block|}
comment|/** Converts an expression into an (input, field) pair. */
specifier|private
specifier|static
name|int
index|[]
name|inputField
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|leaves
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|rex
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"only equi-join of columns allowed: "
operator|+
name|rex
argument_list|)
throw|;
block|}
name|RexInputRef
name|ref
init|=
operator|(
name|RexInputRef
operator|)
name|rex
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leaves
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelNode
name|leaf
init|=
name|leaves
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|start
operator|+
name|leaf
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|ref
operator|.
name|getIndex
argument_list|()
operator|<
name|end
condition|)
block|{
return|return
operator|new
name|int
index|[]
block|{
name|i
block|,
name|ref
operator|.
name|getIndex
argument_list|()
operator|-
name|start
block|}
return|;
block|}
name|start
operator|=
name|end
expr_stmt|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"input not found"
argument_list|)
throw|;
block|}
specifier|public
name|StarTable
name|createStarTable
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|Table
argument_list|>
name|tables
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
name|node
range|:
name|nodes
control|)
block|{
name|tables
operator|.
name|add
argument_list|(
name|node
operator|.
name|scan
operator|.
name|getTable
argument_list|()
operator|.
name|unwrap
argument_list|(
name|Table
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|StarTable
operator|.
name|of
argument_list|(
name|this
argument_list|,
name|tables
argument_list|)
return|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getColumn
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/** Source relation of a lattice.    *    *<p>Relations form a tree; all relations except the root relation    * (the fact table) have precisely one parent and an equi-join    * condition on one or more pairs of columns linking to it. */
specifier|public
specifier|static
class|class
name|Node
block|{
specifier|public
specifier|final
name|TableAccessRelBase
name|scan
decl_stmt|;
specifier|public
specifier|final
name|Node
name|parent
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|IntPair
argument_list|>
name|link
decl_stmt|;
specifier|public
specifier|final
name|int
name|startCol
decl_stmt|;
specifier|public
specifier|final
name|int
name|endCol
decl_stmt|;
specifier|public
specifier|final
name|String
name|alias
decl_stmt|;
specifier|public
name|Node
parameter_list|(
name|TableAccessRelBase
name|scan
parameter_list|,
name|Node
name|parent
parameter_list|,
name|List
argument_list|<
name|IntPair
argument_list|>
name|link
parameter_list|,
name|int
name|startCol
parameter_list|,
name|int
name|endCol
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
name|this
operator|.
name|scan
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|link
operator|=
name|link
operator|==
literal|null
condition|?
literal|null
else|:
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|link
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|parent
operator|==
literal|null
operator|)
operator|==
operator|(
name|link
operator|==
literal|null
operator|)
assert|;
assert|assert
name|startCol
operator|>=
literal|0
assert|;
assert|assert
name|endCol
operator|>
name|startCol
assert|;
name|this
operator|.
name|startCol
operator|=
name|startCol
expr_stmt|;
name|this
operator|.
name|endCol
operator|=
name|endCol
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
block|}
block|}
comment|/** Edge in the temporary graph. */
specifier|private
specifier|static
class|class
name|Edge
extends|extends
name|DefaultEdge
block|{
specifier|public
specifier|static
specifier|final
name|DirectedGraph
operator|.
name|EdgeFactory
argument_list|<
name|RelNode
argument_list|,
name|Edge
argument_list|>
name|FACTORY
init|=
operator|new
name|DirectedGraph
operator|.
name|EdgeFactory
argument_list|<
name|RelNode
argument_list|,
name|Edge
argument_list|>
argument_list|()
block|{
specifier|public
name|Edge
name|createEdge
parameter_list|(
name|RelNode
name|source
parameter_list|,
name|RelNode
name|target
parameter_list|)
block|{
return|return
operator|new
name|Edge
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|final
name|List
argument_list|<
name|IntPair
argument_list|>
name|pairs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|public
name|Edge
parameter_list|(
name|RelNode
name|source
parameter_list|,
name|RelNode
name|target
parameter_list|)
block|{
name|super
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RelNode
name|getTarget
parameter_list|()
block|{
return|return
operator|(
name|RelNode
operator|)
name|target
return|;
block|}
specifier|public
name|RelNode
name|getSource
parameter_list|()
block|{
return|return
operator|(
name|RelNode
operator|)
name|source
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End Lattice.java
end_comment

end_unit

